%%+%%scripts/brains/ballphinbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"

local STOP_RUN_DIST = 12
local SEE_PLAYER_DIST = 7

local AVOID_PLAYER_DIST = 5
local AVOID_PLAYER_STOP = 8

local MAX_CHASE_TIME = 10
local MAX_CHASE_DIST = 30

local SEE_BAIT_DIST = 20
local MAX_IDLE_WANDER_DIST = TUNING.SOLOFISH_WANDER_DIST

local WANDER_DIST_DAY = 8
local WANDER_DIST_NIGHT = 4

local START_FACE_DIST = 4
local KEEP_FACE_DIST = 6

local START_FOLLOW_DIST = 13

local MIN_FOLLOW_DIST = 0
local MAX_FOLLOW_DIST = 8
local TARGET_FOLLOW_DIST = 2

local SEE_LIGHT_DIST = 30

local SEE_FOOD_DIST = 10
local SEE_CORAL_DIST = 15
local KEEP_MINING_DIST = 10

local BallphinBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
	self.afraid = false
end)


function BallphinBrain:OnInitializationComplete()
	  self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
 end

local wandertimes =
{
	minwalktime = 2,
	randwalktime =  2,
	minwaittime = 0.1,
	randwaittime = 0.1,
}

local function EatFoodAction(inst)
	local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
	local target = FindEntity(inst, SEE_BAIT_DIST, function(item) return inst.components.eater:CanEat(item) and item.components.bait and not item:HasTag("planted") and not (item.components.inventoryitem and item.components.inventoryitem:IsHeld()) end, nil, notags)
	if target then
		local act = BufferedAction(inst, target, ACTIONS.EAT)
		act.validfn = function() return not (target.components.inventoryitem and target.components.inventoryitem:IsHeld()) end
		return act
	end
end

local function GetWanderDistFn(inst)
	if TheWorld.state.isday then
        return WANDER_DIST_DAY
	else
        return WANDER_DIST_NIGHT
	end
end

local function GetFaceTargetFn(inst)
	local target = GetClosestInstWithTag("character", inst, START_FACE_DIST)
	if target and not target:HasTag("notarget") and target:GetIsOnWater(target:GetPosition():Get()) then
		return target
	end
end

local function KeepFaceTargetFn(inst, target)
	return inst:GetDistanceSqToInst(target) <= KEEP_FACE_DIST*KEEP_FACE_DIST and not target:HasTag("notarget") and target:GetIsOnWater(target:GetPosition():Get())
end

local function GetFollowTargetFn(inst)
	local target = GetClosestInstWithTag("character", inst, START_FOLLOW_DIST)
	if target and not target:HasTag("notarget") and target:GetIsOnWater(target:GetPosition():Get()) then
		return target
	end
end

local function HasValidHome(inst)
	return inst.components.homeseeker
	and inst.components.homeseeker.home
	and inst.components.homeseeker.home:IsValid()
end

local function GoHomeAction(inst)
	if not inst.components.follower.leader
	and HasValidHome(inst)
	and not inst.components.combat.target then
		return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
	end
end

local function GetTraderFn(inst)
	return FindEntity(inst, TRADE_DIST, function(target) return inst.components.trader:IsTryingToTradeWithMe(target) end, {"player"})
end

local function KeepTraderFn(inst, target)
	return inst.components.trader:IsTryingToTradeWithMe(target)
end

local function GetLeader(inst)
	return inst.components.follower.leader
end

local function GetHomePos(inst)
	return HasValidHome(inst) and inst.components.homeseeker:GetHomePos()
end

local function GetNoLeaderHomePos(inst)
	if GetLeader(inst) then
		return nil
	end
	return GetHomePos(inst)
end

-- I don't bother checking this function -M
local function FindFoodAction(inst)
	local target = nil

	if inst.sg:HasStateTag("busy") then
		return
	end

	if inst.components.inventory and inst.components.eater then
		target = inst.components.inventory:FindItem(function(item) return inst.components.eater:CanEat(item) end)
	end

	local time_since_eat = inst.components.eater:TimeSinceLastEating()
	local noveggie = time_since_eat and time_since_eat < TUNING.PIG_MIN_POOP_PERIOD*4

	if not target and (not time_since_eat or time_since_eat > TUNING.PIG_MIN_POOP_PERIOD*2) then

		target = FindEntity(inst, SEE_FOOD_DIST, function(item)
				if item:GetTimeAlive() < 8 then return false end
				if item.prefab == "mandrake" then return false end
				if noveggie and item.components.edible and item.components.edible.foodtype ~= "MEAT" then
					return false
				end
				if not item:IsOnValidGround() then
					return false
				end

				return inst.components.eater:CanEat(item)
			end)

	end

	if target then
		return BufferedAction(inst, target, ACTIONS.EAT)
	end

	if not target and (not time_since_eat or time_since_eat > TUNING.PIG_MIN_POOP_PERIOD*2) then
		target = FindEntity(inst, SEE_FOOD_DIST, function(item)
				if not item.components.shelf then return false end
				if not item.components.shelf.itemonshelf or not item.components.shelf.cantakeitem then return false end
				if noveggie and item.components.shelf.itemonshelf.components.edible and item.components.shelf.itemonshelf.components.edible.foodtype ~= "MEAT" then

					return false
				end
				if not item:IsOnValidGround() then
					return false
				end

				return inst.components.eater:CanEat(item.components.shelf.itemonshelf)
			end)
	end

	if target then
		return BufferedAction(inst, target, ACTIONS.TAKEITEM)
	end

end

local function KeepMiningAction(inst)
	return inst.components.follower.leader and inst.components.follower.leader:GetDistanceSqToInst(inst) <= KEEP_MINING_DIST*KEEP_MINING_DIST
	or FindEntity(inst, SEE_CORAL_DIST/3, function(item)
			return item.components.workable and item.components.workable.action == ACTIONS.MINE 
		end)
end

local function StartMiningCondition(inst)
	return inst.components.follower.leader and inst.components.follower.leader.sg
	and (inst.components.follower.leader.sg:HasStateTag("mining") or inst.components.follower.leader.sg:HasStateTag("premine"))
end

local function FindCoralToMineAction(inst)
	local target = FindEntity(inst, SEE_CORAL_DIST, function(item) return item.components.workable and item.components.workable.action == ACTIONS.MINE end)
	if target then
		return BufferedAction(inst, target, ACTIONS.MINE)
	end
end

local function SafeLightDist(inst, target)
    return (target:HasTag("player") or target:HasTag("playerlight")
            or (target.inventoryitem and target.inventoryitem:GetGrandOwner() and target.inventoryitem:GetGrandOwner():HasTag("player")))
        and 4
        or target.Light:GetCalculatedRadius() / 3
end

function BallphinBrain:OnStart()
	
	local root = PriorityNode(
	{
        WhileNode(function() return not self.inst.entity:IsVisible() end, "Hiding", StandStill(self.inst)),
		WhileNode(function() return not self.inst:HasTag("ballphinfriend") end, "Not a ballphinfriend", ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST)),
		WhileNode(function() return self.inst:HasTag("ballphinfriend") end, "a ballphinfriend", ChaseAndAttack(self.inst, 100)),
		ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_FIND_MEAT, DoAction(self.inst, FindFoodAction)),
		WhileNode(function() return self.afraid end, "IsAfraid",
			PriorityNode{
				ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_FIND_LIGHT,
					FindLight(self.inst, SEE_LIGHT_DIST)),
				ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_PANIC,
					Panic(self.inst)),
			},1),
		WhileNode(function() return not TheWorld.state.isday end, "IsNight",
			PriorityNode{
				ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_HOME,
					DoAction(self.inst, GoHomeAction, "go home", true)),
			},1),
		ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_FOLLOWWILSON, Follow(self.inst, GetLeader, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST)),
		Leash(self.inst, function() return self.inst.components.knownlocations:GetLocation("herd") end, 30, 20),
		WhileNode(function() return TheWorld.state.isday end, "IsDay",
			PriorityNode{
				IfNode(function() return StartMiningCondition(self.inst) end, "mine", 
					WhileNode(function() return KeepMiningAction(self.inst) end, "keep mining",
						LoopNode{ 
							ChattyNode(self.inst, STRINGS.BALLPHIN_TALK_HELP_MINE_CORAL,
							DoAction(self.inst, FindCoralToMineAction))}))
			},1),
		Follow(self.inst, function() return GetFollowTargetFn(self.inst) end, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST),
		FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
		Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("herd") end, GetWanderDistFn),
	}, .25)
	self.bt = BT(self.inst, root)
end

return BallphinBrain
%%+%%scripts/brains/bluewhalebrain.lua%%-%%require "behaviours/wander"
require "behaviours/faceentity"
require "behaviours/chaseandattack"
require "behaviours/panic"
require "behaviours/runaway"
require "behaviours/leash"

local RUN_AWAY_DIST = 10
local STOP_RUN_AWAY_DIST = 14
local START_FACE_DIST = 15
local KEEP_FACE_DIST = 20

local LEASH_RETURN_DIST = 5
local LEASH_MAX_DIST = 10

local wander_times =
{
	minwalktime = 4,
	randwalktime = 4,
	minwaittime = 4,
	randwaittime = 3,
}

local function GetFaceTargetFn(inst)
	local target = GetClosestInstWithTag("player", inst, START_FACE_DIST)
	if target and not target:HasTag("notarget") then
		return target
	end
end

local function KeepFaceTargetFn(inst, target)
	return inst:IsNear(target, KEEP_FACE_DIST) and not target:HasTag("notarget")
end

local BlueWhaleBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)

function BlueWhaleBrain:OnInitializationComplete()
    self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
end

function BlueWhaleBrain:OnStart()
	
	local root = PriorityNode(
	{
		SequenceNode{
            ConditionNode(function() 
	            local tile = self.inst.components.tiletracker.tile
	            if tile == GROUND.OCEAN_SHALLOW then
	            	self.inst.hitshallow = true
	            end
	            return tile == GROUND.OCEAN_SHALLOW or self.inst.hitshallow
	        end, "HitShallow"),

            ParallelNodeAny {
                WaitNode(15+math.random()*2),
                Leash(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, LEASH_MAX_DIST, LEASH_RETURN_DIST),
            },
            DoAction(self.inst, function() self.inst.hitshallow = nil end ),
        },

		ChaseAndAttack(self.inst, TUNING.WHALE_BLUE_FOLLOW_TIME, TUNING.WHALE_BLUE_CHASE_DIST),
		SequenceNode{
			FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn, 0.5),
			RunAway(self.inst, "character", RUN_AWAY_DIST, STOP_RUN_AWAY_DIST)
		},
		FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
		Wander(self.inst, nil, nil, wander_times)
	}, .25)
	
	self.bt = BT(self.inst, root)
end

return BlueWhaleBrain
%%+%%scripts/brains/crabbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/panic"

local STOP_RUN_DIST = 10
local SEE_PLAYER_DIST = 5

local AVOID_PLAYER_DIST = 3
local AVOID_PLAYER_STOP = 6

local SEE_BAIT_DIST = 20
local MAX_WANDER_DIST = 20


local CrabBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local function GoHomeAction(inst)
    if inst.components.homeseeker and 
       inst.components.homeseeker.home and 
       inst.components.homeseeker.home:IsValid() and
	   inst.sg:HasStateTag("trapped") == false then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

local function EatFoodAction(inst)
    local notags = {"FX", "NOCLICK", "DECOR","INLIMBO", "planted", "floating", "aquatic"}
    local target = FindEntity(inst, SEE_BAIT_DIST, function(item) return inst.components.eater:CanEat(item) and item.components.bait and not (item.components.inventoryitem and item.components.inventoryitem:IsHeld()) end, nil, notags)

    if target and target.prefab ~= "ice" then
        local act = BufferedAction(inst, target, ACTIONS.EAT)
        act.validfn = function() return not (target.components.inventoryitem and target.components.inventoryitem:IsHeld()) end
        return act
    end
end

local function IsDangerClose(inst)
    return FindEntity(inst, 5, nil, {"scarytoprey"}, {'notarget'}) ~= nil
end

local function TryHide(inst)
    if not inst.sg:HasStateTag("busy") then
        return BufferedAction(inst, inst, ACTIONS.CRAB_HIDE)
    end
end

function CrabBrain:OnStart()
    local root = PriorityNode(
    {
        WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
        --RunAway(self.inst, "scarytopr1ey", AVOID_PLAYER_DIST, AVOID_PLAYER_STOP),
        ParallelNode
        {
            RunAway(self.inst, "scarytoprey", SEE_PLAYER_DIST, STOP_RUN_DIST),
            SequenceNode
            {
                WaitNode(5),
                IfNode(function() return IsDangerClose(self.inst) end, "DangerClose", DoAction(self.inst, TryHide, "Hide")),
            },
        },
        EventNode(self.inst, "gohome",
            DoAction(self.inst, GoHomeAction, "go home", true )),
        WhileNode(function() return not TheWorld.state.isday end, "IsNight",
            DoAction(self.inst, GoHomeAction, "go home", true )),
        DoAction(self.inst, EatFoodAction),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST)
    }, .25)
    self.bt = BT(self.inst, root)
end

return CrabBrain
%%+%%scripts/brains/crocodogbrain.lua%%-%%require "behaviours/wander"
require "behaviours/chaseandattack"
require "behaviours/panic"
require "behaviours/attackwall"
require "behaviours/minperiod"
require "behaviours/leash"
require "behaviours/faceentity"
require "behaviours/doaction"
require "behaviours/standstill"

local CrocodogBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
  end)

local SEE_DIST = 30

local MIN_FOLLOW_LEADER = 2
local MAX_FOLLOW_LEADER = 6
local TARGET_FOLLOW_LEADER = (MAX_FOLLOW_LEADER+MIN_FOLLOW_LEADER)/2

local LEASH_RETURN_DIST = 10
local LEASH_MAX_DIST = 40

local HOUSE_MAX_DIST = 40
local HOUSE_RETURN_DIST = 50 

local SIT_BOY_DIST = 10

local function HarvestAction(inst)
  local target = FindEntity(inst, SEE_DIST, function(item) return item.components.breeder and item.components.breeder.volume > 0 end)
  if target then
    print("target",target.prefab)
    return BufferedAction(inst, target, ACTIONS.HARVEST)
  end
end

local function EatFoodAction(inst)
  local target = FindEntity(inst, SEE_DIST, function(item) return inst.components.eater:CanEat(item) and item:IsOnValidGround() end)
  if target then
    return BufferedAction(inst, target, ACTIONS.EAT)
  end
end

local function GetLeader(inst)
  return inst.components.follower and inst.components.follower.leader
end

local function GetHome(inst)
  return inst.components.homeseeker and inst.components.homeseeker.home
end

local function GetHomePos(inst)
  local home = GetHome(inst)
  return home and home:GetPosition()
end

local function GetNoLeaderLeashPos(inst)
  if GetLeader(inst) then
    return nil
  end
  return GetHomePos(inst)
end

local function GetWanderPoint(inst)
  local target = GetLeader(inst)

  if target == nil then
    local x, y, z = inst.Transform:GetWorldPosition()
    local players = FindPlayersInRange(x, y, z, 25)
    local randomtarget = #players > 0 and math.random(#players) or nil
    target = randomtarget and players[randomtarget]
  end

  if target then
    return target:GetPosition()
  end 
end

local function ShouldStandStill(inst)
  return inst:HasTag("pet_hound") and not TheWorld.state.isday and not GetLeader(inst) and not inst.components.combat.target and inst:IsNear(GetHome(inst), SIT_BOY_DIST)
end

function CrocodogBrain:OnStart()

  local root = PriorityNode(
    {
      WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst) ),
      WhileNode(function() return not GetLeader(self.inst) end, "NoLeader", AttackWall(self.inst) ),

      WhileNode(function() return self.inst:HasTag("pet_hound") end, "Is Pet", ChaseAndAttack(self.inst, 10)),
      WhileNode(function() return not self.inst:HasTag("pet_hound") and GetHome(self.inst) end, "No Pet Has Home", ChaseAndAttack(self.inst, 10, 20)),
      WhileNode(function() return not self.inst:HasTag("pet_hound") and not GetHome(self.inst) end, "Not Pet", ChaseAndAttack(self.inst, 100)),

      Leash(self.inst, GetNoLeaderLeashPos, HOUSE_MAX_DIST, HOUSE_RETURN_DIST),

      DoAction(self.inst, EatFoodAction, "eat food", true ),
      DoAction(self.inst, HarvestAction, "harvest", true ),
      Follow(self.inst, GetLeader, MIN_FOLLOW_LEADER, TARGET_FOLLOW_LEADER, MAX_FOLLOW_LEADER),
      FaceEntity(self.inst, GetLeader, GetLeader),

      StandStill(self.inst, ShouldStandStill),

      WhileNode(function() return GetHome(self.inst) end, "HasHome", Wander(self.inst, GetHomePos, 8) ),
      Wander(self.inst, GetWanderPoint, 20),
      }, .25)

  self.bt = BT(self.inst, root)

end

return CrocodogBrain
%%+%%scripts/brains/doydoybrain.lua%%-%%require "behaviours/runaway"
require "behaviours/wander"
require "behaviours/doaction"
require "behaviours/panic"
require "behaviours/minperiod"

local SEE_FOOD_DIST = 15
local SEE_STRUCTURE_DIST = 30

local NO_TAGS = {"FX", "NOCLICK", "DECOR", "INLIMBO", "AQUATIC"}
local PICKABLE_FOODS =
{
	"berries",
	"cave_banana",
	"carrot",
	"limpets",
	"blue_cap",
	"green_cap",
}

local function EatFoodAction(inst)  --Look for food to eat
	-- print("doydoybrain EatFoodAction")

	local target = nil
	local action = nil

	if inst.sg:HasStateTag("busy") and not
	inst.sg:HasStateTag("wantstoeat") then
		return
	end

	if inst.components.inventory and inst.components.eater then
		target = inst.components.inventory:FindItem(function(item) return inst.components.eater:CanEat(item) end)
		if target then return BufferedAction(inst,target,ACTIONS.EAT) end
	end

	local pt = inst:GetPosition()
	local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, SEE_FOOD_DIST, nil, NO_TAGS, inst.components.eater:GetEdibleTags())

	if not target then
		for k,v in pairs(ents) do
			if v and v:IsOnValidGround() and 
			inst.components.eater:CanEat(v) and
			v:GetTimeAlive() > 5 and 
			v.components.inventoryitem and not 
			v.components.inventoryitem:IsHeld() then
				target = v
				break
			end
		end
	end    

	if target then
		local action = BufferedAction(inst,target,ACTIONS.PICKUP)
		return action 
	end
end

local function StealFoodAction(inst) --Look for things to take food from (EatFoodAction handles picking up/ eating)
	-- print("doydoybrain StealFoodAction")

	-- Food On Ground > Pots = Farms = Drying Racks > Plants

	local target = nil

	if inst.sg:HasStateTag("busy") or 
	(inst.components.inventory and inst.components.inventory:IsFull()) then
		return
	end

	local pt = inst:GetPosition()
	local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, SEE_STRUCTURE_DIST, nil, NO_TAGS) 
	--Look for crop/ cookpots/ drying rack, harvest them.
	if not target then
		for k,item in pairs(ents) do
			if (item.components.stewer and item.components.stewer:IsDone()) or
			(item.components.dryer and item.components.dryer:IsDone()) or
			(item.components.crop and item.components.crop:IsReadyForHarvest()) then
				target = item
				break
			end
		end
	end

	if target then
		return BufferedAction(inst, target, ACTIONS.HARVEST)
	end

	--Berrybushes, carrots etc.
	if not target then
		for k,item in pairs(ents) do
			if item.components.pickable and 
			item.components.pickable.caninteractwith and 
			item.components.pickable:CanBePicked() and
			table.contains(PICKABLE_FOODS, item.components.pickable.product) then
				target = item
				break
			end
		end
	end

	if target then
		return BufferedAction(inst, target, ACTIONS.PICK)
	end
end

local function MateAction(inst)
	if inst:HasTag("mating") and inst.components.mateable and inst.components.mateable:PartnerValid() then
		return BufferedAction(inst, inst.components.mateable:GetPartner(), ACTIONS.MATE, nil, nil, nil, TUNING.DOYDOY_MATING_DANCE_DIST)
	end
end

local DoydoyBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)

function DoydoyBrain:OnStart()

	local eatnode =
	PriorityNode(
	{
		DoAction(self.inst, StealFoodAction),
	}, 2)

	local root =
	PriorityNode(
	{
		--These birds are so crazy for mating, they don't even care if they're on fire during the act. No wonder they went extinct.
		DoAction(self.inst, function() return MateAction(self.inst) end, "Mate", true),

		WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
		
		DoAction(self.inst, EatFoodAction), 
		MinPeriod(self.inst, math.random(4,6), false, eatnode),
		Wander(self.inst, nil, 15),
	},1)
	
	self.bt = BT(self.inst, root) 
		
end

return DoydoyBrain
%%+%%scripts/brains/elephantcactusbrain.lua%%-%%require("behaviours/standandattack")

local START_FACE_DIST = 10
local KEEP_FACE_DIST = 15

local ElephantCactusBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function ElephantCactusBrain:OnStart()
    local root = PriorityNode({
        WhileNode(function() return self.inst.has_spike end, "Has Spike", StandAndAttack(self.inst)),
    }, .25)
    
    self.bt = BT(self.inst, root)
end

return ElephantCactusBrain
%%+%%scripts/brains/flupbrain.lua%%-%%require "behaviours/wander"
require "behaviours/doaction"
require "behaviours/chaseandattack"
require "behaviours/standstill"

local AVOID_PLAYER_DIST = 1.5
local AVOID_PLAYER_STOP = 3

local MAX_WANDER_DIST = 20
local SEE_TARGET_DIST = 6

local MAX_CHASE_TIME = 8

local HOME_LEASH_DIST = 5
local HOME_RETURN_DIST = 3

local function SetUpAmbush(inst)
  if inst.components.combat.target or inst.sg:HasStateTag("ambusher") then
    return
  end

  return BufferedAction(inst, inst, ACTIONS.FLUP_HIDE)
end

local function ShouldRun(inst)
  return function(hunter)
    return not inst.sg:HasStateTag("jumping") and not inst.sg:HasStateTag("ambusher")
  end
end

local FlupBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
  end)

function FlupBrain:OnStart()

  local root = PriorityNode(
    {
      WhileNode(function() return not self.inst.components.combat.target end, "No Target",
        Leash(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, HOME_LEASH_DIST, HOME_RETURN_DIST, true)),
      DoAction(self.inst, SetUpAmbush, "Try Ambush"),
      WhileNode(function() return self.inst.sg:HasStateTag("ambusher") end, "Lay In Wait",
        StandStill(self.inst, function() return self.inst.sg:HasStateTag("ambusher") end, nil)),
      RunAway(self.inst, "scarytoprey", AVOID_PLAYER_DIST, AVOID_PLAYER_STOP, ShouldRun(self.inst)),
      ChaseAndAttack(self.inst, MAX_CHASE_TIME),
      Wander(self.inst, function() return self.inst:GetPosition() end, MAX_WANDER_DIST),
      }, .25)

  self.bt = BT(self.inst, root)

end

return FlupBrain
%%+%%scripts/brains/jellyfishbrain.lua%%-%%require "behaviours/wander"

local MAX_WANDER_DIST = 40

local jellyfishBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function jellyfishBrain:OnInitializationComplete()
    self.inst.components.knownlocations:RememberLocation("home", self.inst:GetPosition(), true)
end

function jellyfishBrain:OnStart()
    local root = PriorityNode(
    {
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST)
    }, .25)
    self.bt = BT(self.inst, root)
end

return jellyfishBrain
%%+%%scripts/brains/knightboatbrain.lua%%-%%require "behaviours/standstill"
require "behaviours/runaway"
require "behaviours/panic"
require "behaviours/chaseandattack"

local START_FACE_DIST = 15
local KEEP_FACE_DIST = 25
local GO_HOME_DIST = 1
local MAX_CHASE_TIME = 10
local MAX_CHASE_DIST = 20
local RUN_AWAY_DIST = 10
local STOP_RUN_AWAY_DIST = 20

local KnightBoatBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local function GoHomeAction(inst)
    local homePos = inst.components.knownlocations:GetLocation("home")
    if homePos and 
       not inst.components.combat.target then
        return BufferedAction(inst, nil, ACTIONS.WALKTO, nil, homePos, nil, 0.2)
    end
end

local function GetFaceTargetFn(inst)
    local target = GetClosestInstWithTag("player", inst, START_FACE_DIST)
    if target and not target:HasTag("notarget") then
        return target
    end
end

local function KeepFaceTargetFn(inst, target)
    return inst:GetDistanceSqToInst(target) <= KEEP_FACE_DIST*KEEP_FACE_DIST and not target:HasTag("notarget")
end

local function ShouldGoHome(inst)
    if (inst.components.follower and inst.components.follower.leader) then
        return false
    end

    local homePos = inst.components.knownlocations:GetLocation("home")
    local myPos = Vector3(inst.Transform:GetWorldPosition() )
    return (homePos and distsq(homePos, myPos) > GO_HOME_DIST*GO_HOME_DIST)
end

function KnightBoatBrain:OnStart()
    local root = PriorityNode(
    {
        WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)), 
        WhileNode(function() return self.inst.components.combat.target == nil or not self.inst.components.combat:InCooldown() end,
            "AttackMomentarily", ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST)),
        WhileNode(function() return self.inst.components.combat.target and self.inst.components.combat:InCooldown() end, 
            "Dodge", RunAway(self.inst, function(inst) return self.inst.components.combat.target end, RUN_AWAY_DIST, STOP_RUN_AWAY_DIST)),
        -- WhileNode(function() return ShouldGoHome(self.inst) end, "ShouldGoHome", DoAction(self.inst, GoHomeAction, "Go Home", true)),
        FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
        StandStill(self.inst),
    }, .25)

    self.bt = BT(self.inst, root)
end

return KnightBoatBrain
%%+%%scripts/brains/lobsterbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/panic"

local STOP_RUN_DIST = 10
local SEE_PLAYER_DIST = 5

local AVOID_PLAYER_DIST = 3
local AVOID_PLAYER_STOP = 6

local SEE_BAIT_DIST = 20
local MAX_WANDER_DIST = 20

local LobsterBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local function GoHomeAction(inst)
    if inst.components.homeseeker and 
       inst.components.homeseeker.home and 
       inst.components.homeseeker.home:IsValid() and
	   inst.sg:HasStateTag("trapped") == false then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

local function EatFoodAction(inst)
    local notags = {"FX", "NOCLICK", "DECOR","INLIMBO", "planted"}
    local target = FindEntity(inst, SEE_BAIT_DIST, function(item) return inst.components.eater:CanEat(item) and item.components.bait and not (item.components.inventoryitem and item.components.inventoryitem:IsHeld()) end, nil, notags )
    if target then
        local act = BufferedAction(inst, target, ACTIONS.EAT)
        act.validfn = function() return not (target.components.inventoryitem and target.components.inventoryitem:IsHeld()) end
        return act
    end
end


function LobsterBrain:OnStart()    
    local root = PriorityNode(
    {
        WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
        RunAway(self.inst, "scarytoprey", AVOID_PLAYER_DIST, AVOID_PLAYER_STOP),
        RunAway(self.inst, "scarytoprey", SEE_PLAYER_DIST, STOP_RUN_DIST, nil, true),
        EventNode(self.inst, "gohome", 
            DoAction(self.inst, GoHomeAction, "go home", true )),
        WhileNode(function() return TheWorld.state.isday end, "IsDay",
            DoAction(self.inst, GoHomeAction, "go home", true )),
        WhileNode(function() return TheWorld.state.isspring end, "IsSpring",
            DoAction(self.inst, GoHomeAction, "go home", true )),
        DoAction(self.inst, EatFoodAction),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST)
    }, .25)
    self.bt = BT(self.inst, root)
end

return LobsterBrain
%%+%%scripts/brains/mermfisherbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/panic"
require "behaviours/chattynode"

local SEE_HOME_DIST = 18
local MAX_WANDER_DIST = 15
local RUN_AWAY_DIST = 5
local STOP_RUN_AWAY_DIST = 8

local MermFisherBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local function GoHomeAction(inst)
	if not inst.components.combat.target
		and inst.components.homeseeker 
		and inst.components.homeseeker.home 
		and inst.components.homeseeker.home:IsValid()
		and not (inst.components.homeseeker.home.components.burnable ~= nil
			and inst.components.homeseeker.home.components.burnable:IsBurning())
		and not inst.components.homeseeker.home:HasTag("burnt") then
		return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
	end
end

local function ShouldGoHome(inst)
	--one merm should stay outside
	local home = inst.components.homeseeker ~= nil and inst.components.homeseeker.home or nil
	return TheWorld.state.isday
		and home ~= nil
		and (home.components.childspawner == nil
			or home.components.childspawner:CountChildrenOutside() > 1)
end

local function Fish(inst)
    local pond = FindEntity(inst, 20, nil, {"fishable"})

    if pond and not inst.sg:HasStateTag("fishing") and inst.CanFish then
        return BufferedAction(inst, pond, ACTIONS.FISH)
    end
end

local function IsHomeOnFire(inst)
    return inst.components.homeseeker
        and inst.components.homeseeker.home
        and inst.components.homeseeker.home.components.burnable
        and inst.components.homeseeker.home.components.burnable:IsBurning()
        and inst.components.homeseeker.home:IsNear(inst, SEE_HOME_DIST)
end

function MermFisherBrain:OnStart()

    local root = PriorityNode(
    {
        WhileNode(function() return self.inst.components.hauntable ~= nil and self.inst.components.hauntable.panic end, "PanicHaunted", 
            ChattyNode(self.inst, STRINGS.MERM_TALK_PANIC,
                Panic(self.inst))),

        WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", 
            ChattyNode(self.inst, STRINGS.MERM_TALK_PANIC,
                Panic(self.inst))),

        WhileNode(function() return self.inst.components.combat.target ~= nil and not self.inst.sg:HasStateTag("fishing") end, "Is Threatened",
			ChattyNode(self.inst, STRINGS.MERM_TALK_RUNAWAY,
				RunAway(self.inst, function() return self.inst.components.combat.target end, RUN_AWAY_DIST, STOP_RUN_AWAY_DIST))),
        
        WhileNode( function() return IsHomeOnFire(self.inst) end, "HomeOnFire", 
            ChattyNode(self.inst, STRINGS.MERM_TALK_PANIC,
                Panic(self.inst))),

        ChattyNode(self.inst, STRINGS.MERM_TALK_GO_HOME,
            WhileNode(function() return ShouldGoHome(self.inst) end, "ShouldGoHome", DoAction(self.inst, GoHomeAction, "Go Home", true))),

        ChattyNode(self.inst, STRINGS.MERM_TALK_FISH,
            DoAction(self.inst, Fish, "Fish Action")),

        WhileNode(function() return not self.inst.sg:HasStateTag("fishing") end, "Is Idle",
			Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST)),
    }, 0.25)
    
    self.bt = BT(self.inst, root)
end

return MermFisherBrain%%+%%scripts/brains/nightmareprimeapebrain.lua%%-%%require "behaviours/wander"
require "behaviours/panic"
require "behaviours/chaseandattack"

local MAX_WANDER_DIST = 10

local MAX_CHASE_TIME = 60
local MAX_CHASE_DIST = 40


local NightmarePrimeapeBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function NightmarePrimeapeBrain:OnStart()
    
    local root = PriorityNode(
    {

        WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
        ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST), 
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST),

    }, .25)
    self.bt = BT(self.inst, root)
end

return NightmarePrimeapeBrain
%%+%%scripts/brains/oxbrain.lua%%-%%require "behaviours/wander"
require "behaviours/faceentity"
require "behaviours/chaseandattack"
require "behaviours/panic"
require "behaviours/follow"
require "behaviours/attackwall"

local STOP_RUN_DIST = 10
local SEE_PLAYER_DIST = 5
local WANDER_DIST_DAY = 20
local WANDER_DIST_NIGHT = 5
local START_FACE_DIST = 4
local KEEP_FACE_DIST = 6

local MAX_CHASE_TIME = 6

local MIN_FOLLOW_DIST = 1
local TARGET_FOLLOW_DIST = 5
local MAX_FOLLOW_DIST = 5

local function GetFaceTargetFn(inst)
    local target = GetClosestInstWithTag("player", inst, START_FACE_DIST)
    if target and not target:HasTag("notarget") then
        return target
    end
end

local function KeepFaceTargetFn(inst, target)
    return inst:GetDistanceSqToInst(target) <=   KEEP_FACE_DIST*KEEP_FACE_DIST and not target:HasTag("notarget")
end

local function GetWanderDistFn(inst)
    if TheWorld.state.isday then
        return WANDER_DIST_NIGHT
    else
        return WANDER_DIST_DAY
    end
end

local function GoHomeAction(inst)
    if inst.components.homeseeker and 
       inst.components.homeseeker.home and 
       inst.components.homeseeker.home:IsValid() then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

local OxBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function OxBrain:OnInitializationComplete()
	--TODO only if valid ground? (i.e. land or mangrove)
    self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
end

function OxBrain:OnStart()
    local root = PriorityNode(
    {
        WhileNode( function() 
                local tile = self.inst.components.tiletracker.tile
                return IsWater(tile) and tile ~= GROUND.MANGROVE
            end, "intheocean",  
            Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, WANDER_DIST_NIGHT)),

        WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
		IfNode( function() return self.inst.components.combat.target ~= nil end, "hastarget", AttackWall(self.inst)),
        ChaseAndAttack(self.inst, MAX_CHASE_TIME),
        Follow(self.inst, function() return self.inst.components.follower and self.inst.components.follower.leader end, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST, false),
        FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("herd") end, GetWanderDistFn)
    }, .25)
    
    self.bt = BT(self.inst, root)
    
end

return OxBrain
%%+%%scripts/brains/packimbrain.lua%%-%%require "behaviours/follow"
require "behaviours/wander"
require "behaviours/faceentity"
require "behaviours/panic"


local MIN_FOLLOW_DIST = 0
local MAX_FOLLOW_DIST = 12
local TARGET_FOLLOW_DIST = 6

local MAX_WANDER_DIST = 3

local MAX_CHASE_TIME = 60
local MAX_CHASE_DIST = 40

local function GetFaceTargetFn(inst)
	return inst.components.follower.leader
end

local function KeepFaceTargetFn(inst, target)
	return inst.components.follower.leader == target
end


local PackimBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)


function PackimBrain:OnStart()
	local root =
	PriorityNode({
		WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),
		WhileNode(function() return self.inst.PackimState == "FIRE" and self.inst.components.combat.target ~= nil and self.inst.components.combat.target:HasTag("player") end, "Attack",
            ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST)),
		WhileNode( function() return self.inst.PackimState == "FIRE" and (self.inst.components.combat.target == nil or not self.inst.components.combat:InCooldown()) end, "AttackMomentarily",
			ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST)),
		Follow(self.inst, function() return self.inst.components.follower.leader end, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST),
		FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
		Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST),

	}, .25)
	self.bt = BT(self.inst, root)
end

return PackimBrain
%%+%%scripts/brains/primeapebrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/panic"
require "behaviours/chaseandattack"
require "behaviours/leash"
local BrainCommon = require "brains/braincommon"

local MIN_FOLLOW_DIST = 0
local TARGET_FOLLOW_DIST = 7
local MAX_FOLLOW_DIST = 10

local MIN_FRIEND_FOLLOW_DIST = 0
local TARGET_FRIEND_FOLLOW_DIST = 5
local MAX_FRIEND_FOLLOW_DIST = 10

local RUN_AWAY_DIST = 7
local STOP_RUN_AWAY_DIST = 15

local SEE_FOOD_DIST = 10

local MAX_WANDER_DIST = 20

local MAX_CHASE_TIME = 60
local MAX_CHASE_DIST = 40

local TIME_BETWEEN_EATING = 30

local LEASH_RETURN_DIST = 15
local LEASH_MAX_DIST = 20

local NO_LOOTING_TAGS = { "INLIMBO", "catchable", "fire", "irreplaceable", "heavy", "outofreach", "floating", "aquatic", "nosteal" }
local NO_PICKUP_TAGS = deepcopy(NO_LOOTING_TAGS)
table.insert(NO_PICKUP_TAGS, "_container")

local PrimeapeBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
  end)

local function GetLeader(inst)
  return inst.components.follower.leader
end

local function FriendsWithPlayer(inst, player)
  return player ~= nil and (GetLeader(inst) == player or player:HasTag("monkey"))
end

local function HasMonkeyBait(inst)
  local ball = inst.components.inventory:FindItem(function(item) return item:HasTag("monkeybait") end)
  if ball then
    -- print("I have the ball!")
    return true
  end
end

local function ShouldRunFn(inst, hunter)
	if inst.components.combat:TargetIs(hunter)
	or hunter.components.combat and hunter.components.combat:TargetIs(inst) then
		return hunter:HasTag("player")
	end
end

local function GetPoop(inst)
	if inst.sg:HasStateTag("busy") then
		return
	end
	local target = FindEntity(inst, SEE_FOOD_DIST, function(item)
		return item.prefab == "poop"
			and not item:IsNear(inst.components.combat.target, RUN_AWAY_DIST)
			and item:IsOnValidGround()
	end, nil, NO_PICKUP_TAGS)

    return target ~= nil and BufferedAction(inst, target, ACTIONS.PICKUP) or nil
end

local ValidFoodsToPick = 
{
  "berries",
  "cave_banana",
  "carrot",
  "sweet_potato",
  "red_cap",
  "blue_cap",
  "green_cap", 
}

local function ItemIsInList(item, list)
  for _, v in ipairs(list) do
    if v == item then
      return true
    end
  end
end

local function SetCurious(inst)
  inst._curioustask = nil
  inst.curious = true
end

local function CanPickup(item)
  local ret = item:IsValid() and
  item.components.inventoryitem and 
  not item.components.inventoryitem:IsHeld() and
  item.components.inventoryitem.canbepickedup and
  not item.components.inventoryitem.owner and

  not item.components.container and
  not item.components.inventory and
  not item:HasTag("fire") and
  not item:HasTag("irreplaceable") and
  not item:HasTag("nosteal") and
  not item:HasTag("heavy") and
  not item:HasTag("outofreach") and
  not item:HasTag("trap")

  and item:IsOnValidGround()

  return ret
end


local function EatFoodAction(inst)
  if inst.sg:HasStateTag("busy") or
  (inst.components.eater:TimeSinceLastEating() ~= nil and inst.components.eater:TimeSinceLastEating() < TIME_BETWEEN_EATING) or
  (inst.components.inventory ~= nil and inst.components.inventory:IsFull()) or
  math.random() < .75 then
    return
  elseif inst.components.inventory ~= nil and inst.components.eater ~= nil then
    local target = inst.components.inventory:FindItem(function(item) return inst.components.eater:CanEat(item) end)
    if target ~= nil then
      return BufferedAction(inst, target, ACTIONS.EAT)
    end
  end

  --Get the stuff around you and store it in ents
  local x, y, z = inst.Transform:GetWorldPosition()
  local ents = TheSim:FindEntities(x, y, z, SEE_FOOD_DIST,
    nil,
    NO_PICKUP_TAGS,
    { "_inventoryitem", "pickable", "readyforharvest" })

  --If you're not wearing a hat, look for a hat to wear!
  if inst.components.inventory ~= nil and inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HEAD) == nil then
    for i, item in ipairs(ents) do
      if item.components.equippable ~= nil and
      item.components.equippable.equipslot == EQUIPSLOTS.HEAD and
      item.components.inventoryitem ~= nil and
      item.components.inventoryitem.canbepickedup and
      item:IsOnValidGround() then
        return BufferedAction(inst, item, ACTIONS.PICKUP)
      end
    end
  end

  --Look for food on the ground, pick it up
  for i, item in ipairs(ents) do
    if item:GetTimeAlive() > 8 and
    item.components.inventoryitem ~= nil and
    item.components.inventoryitem.canbepickedup and
    inst.components.eater:CanEat(item) and
    item:IsOnValidGround() then
      return BufferedAction(inst, item, ACTIONS.PICKUP)
    end
  end

  --Look for harvestable items, pick them.
  for i, item in ipairs(ents) do
    if item.components.pickable ~= nil and
    item.components.pickable.caninteractwith and
    item.components.pickable:CanBePicked() and
    (item.prefab == "worm" or ItemIsInList(item.components.pickable.product, ValidFoodsToPick)) then
      return BufferedAction(inst, item, ACTIONS.PICK)
    end
  end

  --Look for crops items, harvest them.
  for i, item in ipairs(ents) do
    if item.components.crop ~= nil and
    item.components.crop:IsReadyForHarvest() then
      return BufferedAction(inst, item, ACTIONS.HARVEST)
    end
  end

  if not inst.curious or inst.components.combat:HasTarget() then
    return
  end

  ---At the very end, look for a random item to pick up and do that.
  for i, item in ipairs(ents) do
    if item.components.inventoryitem ~= nil and
    item.components.inventoryitem.canbepickedup and
    item:IsOnValidGround() then
      inst.curious = false
      if inst._curioustask ~= nil then
        inst._curioustask:Cancel()
      end
      inst._curioustask = inst:DoTaskInTime(10, SetCurious)
      return BufferedAction(inst, item, ACTIONS.PICKUP)
    end
  end
end


local function AnnoyPlayer(inst)
  if inst.sg:HasStateTag("busy") then
    return
  end
  local player = inst.harassplayer -- You will only ever harass the player.
  if FriendsWithPlayer(inst, player) then
    -- we are friends with the player, don't annoy him
    return
  end

  local p_pt = player:GetPosition()
  local m_pt = inst:GetPosition()
  local ents = TheSim:FindEntities(m_pt.x, m_pt.y, m_pt.z, 30, {"_inventoryitem"}, NO_PICKUP_TAGS)

  --Can we hassle the player by taking items from stuff he has killed or worked?
  for _, item in pairs(ents) do
    if CanPickup(item) and item:GetTimeAlive() < 5 then
      -- print("pickup 4", item.prefab)
      return BufferedAction(inst, item, ACTIONS.PICKUP)
    end
  end

  --Can we hassle our player by taking the items he wants?
  local ba = player:GetBufferedAction()
  if ba and ba.action.id == "PICKUP" then
    --The player wants to pick something up. Am I closer than the player?
    local tar = ba.target

    local t_pt = tar:GetPosition()

    if CanPickup(tar) and distsq(p_pt, t_pt) > distsq(m_pt, t_pt) then
      --I'm closer to the item than the player! Lets go get it!
      -- print("pickup 5", item.prefab)
      return BufferedAction(inst, tar, ACTIONS.PICKUP)
    end
  end
end

local function GetFaceTargetFn(inst)
  return inst.components.combat.target
end

local function KeepFaceTargetFn(inst, target)
  return target == inst.components.combat.target
end

local function HarassPlayer(inst)

  if FriendsWithPlayer(inst, inst.harassplayer) then
    -- we are friends with the player, don't annoy him
    return
  end

  local player = inst.harassplayer -- You will only ever harass the player.
  return not (player and player.components.sailor and player.components.sailor:IsSailing()) and player or nil
end

local function GoHome(inst)
    local homeseeker = inst.components.homeseeker
    if homeseeker and homeseeker.home and homeseeker.home:IsValid()
    and (not homeseeker.home.components.burnable or not homeseeker.home.components.burnable:IsBurning()) then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

local function AssistPlayer(inst)
  --Do some sort of cooldown on this action. 30-60 seconds?
  if inst.CanThrowItems then
    --If I have stuff in my inventory, throw it towards the player.
    if inst.components.inventory then
      local throwable = inst.components.inventory:FindItem(function(item) return not inst.components.eater:CanEat(item) and not item.components.fertilizer and item:IsValid() and item.Physics end)
      print("Inside primeapebrain AssistPlayer function with throwable = " .. tostring(throwable))
      if throwable then
        --Add throwable component, remove when it is picked up again.
        if not throwable.components.throwable then
          throwable:AddComponent("throwable") --TODO ideally do not rely on this component
          throwable.throwable_onputininventory = function()
            throwable:RemoveComponent("throwable")
            throwable:RemoveEventCallback("onputininventory", throwable.throwable_onputininventory)
            throwable.throwable_onputininventory = nil
          end
          throwable:ListenForEvent("onputininventory", throwable.throwable_onputininventory)
        end

        inst.components.timer:StartTimer("CanThrow", TUNING.PRIMEAPE_THROW_COOLDOWN)
        inst.CanThrowItems = false

        return BufferedAction(inst, inst.harassplayer, ACTIONS.THROW, throwable)
      end
    end

    --If there is anything nearby (but still farish from the player) that I can pick, pick it.
    local pt = inst:GetPosition()
    local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, SEE_FOOD_DIST*2, nil, NO_PICKUP_TAGS, { "pickable", "readyforharvest" })

    --Look for harvestable items, pick them.
    for _, item in pairs(ents) do
      if item.components.pickable and item.components.pickable.caninteractwith and item.components.pickable:CanBePicked() and not (item.GetIsOnWater ~= nil and item:GetIsOnWater()) then
        inst.components.timer:StartTimer("CanThrow", TUNING.PRIMEAPE_THROW_COOLDOWN)
        inst.CanThrowItems = false
        return BufferedAction(inst, item, ACTIONS.PICK)
      end
    end

    --Look for crops items, harvest them.
    for _, item in pairs(ents) do
      if item.components.crop and item.components.crop:IsReadyForHarvest() and not IsOnWater(item) then
        inst.components.timer:StartTimer("CanThrow", TUNING.PRIMEAPE_THROW_COOLDOWN)
        inst.CanThrowItems = false
        return BufferedAction(inst, item, ACTIONS.HARVEST)
      end
    end
  end
end

local function GetRidOfTheBall(inst)
  local ball = inst.components.inventory:FindItem(function(item) return item:HasTag("monkeybait") and item.Physics end)
  local action

  if math.random() < TUNING.MONKEYBALL_PASS_TO_PLAYER_CHANCE then
    action = BufferedAction(inst, inst.harassplayer, ACTIONS.THROW, ball)
  else
    local pos = inst:GetPosition()
    local offset, _, _ = FindWalkableOffset(inst:GetPosition(), math.random()*2*PI, math.random()*5 + 5, 8, true, false) -- try to avoid walls

    if offset then
      action = BufferedAction(inst, nil, ACTIONS.THROW, ball, pos + offset)
    else
      action = BufferedAction(inst, inst.harassplayer, ACTIONS.THROW, ball)
    end
    -- doer, target, action, invobject, pos, recipe, distance, rotation
  end

  return action
end

local function HomeOffset(inst)
  local home = inst.components.homeseeker and inst.components.homeseeker.home

  if home then
    local rad = home.Physics:GetRadius() + inst.Physics:GetRadius() + 0.2
    local vec = (inst:GetPosition() - home:GetPosition()):Normalize()
    local offset = Vector3(vec.x * rad, 0, vec.z * rad)

    return home:GetPosition() + offset
  else
    return inst:GetPosition()
  end
end

local function EquipWeapon(inst, weapon)
    if not weapon.components.equippable:IsEquipped() then
        inst.components.inventory:Equip(weapon)
    end
end


function PrimeapeBrain:OnStart()

	local root = PriorityNode(
	{
		BrainCommon.PanicWhenScared(self.inst, .3),
		WhileNode( function() return self.inst.components.hauntable and self.inst.components.hauntable.panic end, "PanicHaunted", Panic(self.inst)),
		WhileNode( function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst)),

		--Primeapes go home when quakes start.
		EventNode(self.inst, "gohome", 
			DoAction(self.inst, GoHome)),

      SequenceNode{
        ConditionNode(function() return HasMonkeyBait(self.inst) end, "HasBall"),
        ParallelNodeAny {
          WaitNode(4+math.random()*2),
          Panic(self.inst),
        },
        DoAction(self.inst, GetRidOfTheBall),
      },

      Follow(self.inst, function() return FindEntity(self.inst, 20, HasMonkeyBait, {"primeape"}) end, 1, 1.5, 2),


      --In combat (with the player)... Should only ever use poop throwing.
      RunAway(self.inst, "character", RUN_AWAY_DIST, STOP_RUN_AWAY_DIST, function(hunter) return ShouldRunFn(self.inst, hunter) end),

      WhileNode(function() return self.inst.components.combat.target and self.inst.components.combat.target:HasTag("player") and self.inst.HasAmmo(self.inst) end, "Attack Player", 
		SequenceNode({
            ActionNode(function() EquipWeapon(self.inst, self.inst.weaponitems.thrower) end, "Equip thrower"),
            ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST),
        })),
		--Pick up poop to throw
      WhileNode(function() return self.inst.components.combat.target and self.inst.components.combat.target:HasTag("player") and not self.inst.HasAmmo(self.inst) end, "Pick Up Poop", 
        DoAction(self.inst, GetPoop)),
      --Eat/ pick/ harvest foods.
      WhileNode(function() return self.inst.components.combat.target == nil or self.inst.components.combat.target:HasTag("player") end, "Should Eat",
        DoAction(self.inst, EatFoodAction)),
      --Priority must be lower than poop pick up or it will never happen.
      WhileNode(function() return self.inst.components.combat.target and self.inst.components.combat.target:HasTag("player") and not self.inst.HasAmmo(self.inst) end, "Leash to Player",
        PriorityNode{
          Leash(self.inst, function() if self.inst.components.combat.target then return self.inst.components.combat.target:GetPosition() end end, LEASH_MAX_DIST, LEASH_RETURN_DIST),
          FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn)
        }),


      --In combat with everything else
      WhileNode(function() return self.inst.components.combat.target ~= nil and not self.inst.components.combat.target:HasTag("player") end, "Attack NPC", --For everything else
		SequenceNode({
            ActionNode(function() EquipWeapon(self.inst, self.inst.weaponitems.hitter) end, "Equip hitter"),
            ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST),
        })),

      --Following
      WhileNode(function() return HarassPlayer(self.inst) ~= nil end, "Annoy Player", 
        DoAction(self.inst, AnnoyPlayer)),
      Follow(self.inst, function() return HarassPlayer(self.inst) end, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST),

      --Prime apes like the player.        
      WhileNode(function() return FriendsWithPlayer(self.inst, self.inst.harassplayer) and self.inst.harassplayer or nil end, "Assist Player", 
        DoAction(self.inst, AssistPlayer)),

      -- Following as a friend
      Follow(self.inst, function() return FriendsWithPlayer(self.inst, self.inst.harassplayer) and self.inst.harassplayer or nil end, MIN_FRIEND_FOLLOW_DIST, TARGET_FRIEND_FOLLOW_DIST, MAX_FRIEND_FOLLOW_DIST),

      -- occasionally just go home
      WhileNode(function() return not self.inst.components.timer:TimerExists("go_home_delay") end, "Occasionally go home",
        DoAction(self.inst, GoHome)),

      --Doing nothing
      WhileNode(function() return HarassPlayer(self.inst) ~= nil end, "Wander Around Player", 
        Wander(self.inst, function() if HarassPlayer(self.inst) ~= nil then return self.inst.harassplayer:GetPosition() end end, MAX_FOLLOW_DIST)),
      WhileNode(function() return HarassPlayer(self.inst) == nil and not self.inst.components.combat.target end,
        "Wander Around Home", Wander(self.inst, function() return HomeOffset(self.inst) end, MAX_WANDER_DIST))
      }, .25)
  self.bt = BT(self.inst, root)
end

return PrimeapeBrain
%%+%%scripts/brains/rainbowjellyfishbrain.lua%%-%%require "behaviours/wander"
require "behaviours/migrate"

local MAX_WANDER_DIST = 40


local RainbowJellyfishBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)


function RainbowJellyfishBrain:OnInitializationComplete()
      --self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
 end

function RainbowJellyfishBrain:OnStart()
    local migrationMgr = TheWorld.components.rainbowjellymigration

    local root = PriorityNode(
    {
        WhileNode(function() return migrationMgr ~= nil and migrationMgr:IsMigrationActive() end, "Migrating",
                PriorityNode({
                    Migrate(self.inst, function() return self.inst.components.knownlocations:GetLocation("migration") end),
                    Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("migration") end, MAX_WANDER_DIST * 0.25)
                }, 1)
            ),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_WANDER_DIST)
    }, 1)
    self.bt = BT(self.inst, root)
end

return RainbowJellyfishBrain
%%+%%scripts/brains/sharkittenbrain.lua%%-%%require "behaviours/follow"
require "behaviours/wander"
require "behaviours/faceentity"
require "behaviours/panic"
require "behaviours/runaway"

local MIN_FOLLOW_DIST = 0
local MAX_FOLLOW_DIST = 12
local TARGET_FOLLOW_DIST = 6
local MAX_WANDER_DIST = 4

local SEE_FOOD_DIST = 15

local STOP_RUN_DIST = 10
local SEE_PLAYER_DIST = 5

local FOOD_TAGS = {"kittenchow"}
local NO_TAGS = {"FX", "NOCLICK", "DECOR","INLIMBO"}

local function EatFoodAction(inst)  --Look for food to eat.
    local target = nil
    local action = nil

    if inst.sg:HasStateTag("busy") and not
    inst.sg:HasStateTag("wantstoeat") then
        return
    end

    local pt = inst:GetPosition()
    local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, SEE_FOOD_DIST, FOOD_TAGS, NO_TAGS)

    if not target then
        for k,v in pairs(ents) do
            if v and v:IsOnValidGround() and
            inst.components.eater:CanEat(v) and
            v:GetTimeAlive() > 5 and
            v.components.inventoryitem and not
            v.components.inventoryitem:IsHeld() then
                target = v
                break
            end
        end
    end

    if target then
        local action = BufferedAction(inst,target,ACTIONS.EAT)
        return action
    end
end

local function GetFaceTargetFn(inst)
    return FindEntity(inst, 5, nil, {"tigershark"})
end

local function KeepFaceTargetFn(inst, target)
    return inst:GetPosition():Dist(target:GetPosition()) < 10
end

local function GoHomeAction(inst)
    if inst.components.homeseeker and 
       inst.components.homeseeker.home and 
       inst.components.homeseeker.home:IsValid() then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

local function HomeOffset(inst)
    local home = inst.components.homeseeker and inst.components.homeseeker.home

    if home then
        local rad = home.Physics:GetRadius() + inst.Physics:GetRadius() + 0.2
        local vec = (inst:GetPosition() - home:GetPosition()):Normalize()
        local offset = Vector3(vec.x * rad, 0, vec.z * rad)

        return home:GetPosition() + offset
    else
        return inst:GetPosition()
    end
end

local SharkittenBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function SharkittenBrain:OnStart()
    local root =
    PriorityNode({
        EventNode(self.inst, "gohome", 
            DoAction(self.inst, GoHomeAction, "go home", true )),
        DoAction(self.inst, EatFoodAction),
        FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn),
        Wander(self.inst, function() return HomeOffset(self.inst) end, MAX_WANDER_DIST),
    }, .25)
    self.bt = BT(self.inst, root)
end

return SharkittenBrain%%+%%scripts/brains/sharxbrain.lua%%-%%require "behaviours/wander"
require "behaviours/chaseandattack"
require "behaviours/panic"
require "behaviours/attackwall"
require "behaviours/minperiod"
require "behaviours/leash"
require "behaviours/faceentity"
require "behaviours/doaction"
require "behaviours/standstill"

local SharxBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
  end)

local SEE_DIST = 30

local MIN_FOLLOW_LEADER = 2
local MAX_FOLLOW_LEADER = 6
local TARGET_FOLLOW_LEADER = (MAX_FOLLOW_LEADER+MIN_FOLLOW_LEADER)/2

local LEASH_RETURN_DIST = 10
local LEASH_MAX_DIST = 40

local HOUSE_MAX_DIST = 40
local HOUSE_RETURN_DIST = 50 

local SIT_BOY_DIST = 10

local function EatFoodAction(inst)
  local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
  local mustonetags = {"floating", "aquatic"}
  local target = FindEntity(inst, SEE_DIST, function(item) return inst.components.eater:CanEat(item) and item:IsOnValidGround() end, nil, notags, mustonetags)
  if target then
    return BufferedAction(inst, target, ACTIONS.EAT)
  end
end

local function GetLeader(inst)
  return inst.components.follower and inst.components.follower.leader
end


local function GetWanderPoint(inst)
  local target = GetLeader(inst)

  if target == nil then
    local x, y, z = inst.Transform:GetWorldPosition()
    local players = FindPlayersInRange(x, y, z, 25)
    local randomtarget = (players and #players > 0 and math.random(#players)) or nil
    target = randomtarget and players[randomtarget]
  end

  if target and target:HasTag("aquatic") then
    return target:GetPosition()
  else 
    return inst:GetPosition()
  end 
end


function SharxBrain:OnStart()

  local root = PriorityNode(
    {
      --WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst) ),
      --WhileNode(function() return not GetLeader(self.inst) end, "NoLeader", AttackWall(self.inst) ),

      ChaseAndAttack(self.inst, 100),


      DoAction(self.inst, EatFoodAction, "eat food", true ),
      Follow(self.inst, GetLeader, MIN_FOLLOW_LEADER, TARGET_FOLLOW_LEADER, MAX_FOLLOW_LEADER),
      FaceEntity(self.inst, GetLeader, GetLeader),

      Wander(self.inst, GetWanderPoint, 20),

      }, .25)

  self.bt = BT(self.inst, root)

end

return SharxBrain
%%+%%scripts/brains/snakebrain.lua%%-%%require "behaviours/wander"
require "behaviours/chaseandattack"
require "behaviours/panic"
require "behaviours/attackwall"
require "behaviours/minperiod"
require "behaviours/faceentity"
require "behaviours/doaction"
require "behaviours/standstill"

local SnakeBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)

local SEE_DIST = 30

local function EatFoodAction(inst)
	local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
	local target = FindEntity(inst, SEE_DIST, function(item) return inst.components.eater:CanEat(item) and item:IsOnValidGround() end, nil, notags)
	if target then
		return BufferedAction(inst, target, ACTIONS.EAT)
	end
end

local function GetHome(inst)
	return inst.components.homeseeker and inst.components.homeseeker.home
end

local function GetHomePos(inst)
	local home = GetHome(inst)
	return home and home:GetPosition()
end

local function GetWanderPoint(inst)
	local target = GetHome(inst) or inst:GetNearestPlayer(true)

	if target then
		return target:GetPosition()
	end 
end

local function ShouldSpitFn(inst)
	if inst:HasTag("lavaspitter") then
		if inst.sg:HasStateTag("sleeping") or inst.num_targets_vomited >= TUNING.DRAGONFLY_VOMIT_TARGETS_FOR_SATISFIED or inst.hassleepdestination then return false end
		if not inst.recently_frozen and not inst.flame_on then
			if not inst.last_spit_time then 
				if inst:GetTimeAlive() > 5 then
					return true
				end
			else
				return (GetTime() - inst.last_spit_time) >= inst.spit_interval
			end
		end
	end
	return false
end

local function LavaSpitAction(inst)
	--print("LavaSpitAction", inst.target, inst.target ~= inst, not inst.target:HasTag("fire"))
	if not inst.target or (inst.target ~= inst and not inst.target:HasTag("fire")) then
		inst.last_spit_time = GetTime()
		inst.spit_interval = math.random(20,30)
		if not inst.target then
			inst.target = inst
		end
		-- print("LavaSpitAction", inst, inst.target)
		return BufferedAction(inst, inst.target, ACTIONS.LAVASPIT)
	end
end

local function FindLavaSpitTargetAction(inst) 
	if inst.sg:HasStateTag("sleeping") or inst.num_targets_vomited >= TUNING.DRAGONFLY_VOMIT_TARGETS_FOR_SATISFIED or inst.hassleepdestination then return false end
	if inst.last_spit_time and ((GetTime() - inst.last_spit_time) < 5) then return false end

	local target = nil
	local action = nil

	if inst.sg:HasStateTag("busy") or inst.recently_frozen or inst.flame_on then
		return
	end

	local tagpriority = {"dragonflybait_highprio", "dragonflybait_medprio", "dragonflybait_lowprio"}
	local prio = 1
	local currtag = nil
	
	local pt = inst:GetPosition()
	local ents = nil

	while not target and prio <= #tagpriority do
		currtag = {tagpriority[prio]}
		ents = TheSim:FindEntities(pt.x, pt.y, pt.z, SEE_BAIT_DIST, currtag, {"fire"})
	
		for k,v in pairs(ents) do
			if v and v.components.burnable and (not v.components.inventoryitem or not v.components.inventoryitem:IsHeld()) then
				if not target or (distsq(pt, Vector3(v.Transform:GetWorldPosition())) < distsq(pt, Vector3(target.Transform:GetWorldPosition()))) then
					if inst.last_target ~= v then
						target = v
					end
				end
			end
		end

		prio = prio + 1
	end

	if target and not target:HasTag("fire") then
		inst.target = target
		return BufferedAction(inst, inst.target, ACTIONS.LAVASPIT)
	end
end

local function GoHomeAction(inst)
    if inst.components.homeseeker and 
       inst.components.homeseeker.home and 
       inst.components.homeseeker.home:IsValid() then
        return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
    end
end

function SnakeBrain:OnStart()
	
	local root = PriorityNode(
	{
		WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire", Panic(self.inst) ),
		
		ChaseAndAttack(self.inst, 8),

		EventNode(self.inst, "gohome", 
            DoAction(self.inst, GoHomeAction, "go home", true )),
        WhileNode(function() return TheWorld.state.isday end, "IsDay",
            DoAction(self.inst, GoHomeAction, "go home", true )),

		DoAction(self.inst, EatFoodAction, "eat food", true ),
		WhileNode(function() return ShouldSpitFn(self.inst) end, "Spit",
            DoAction(self.inst, LavaSpitAction)),

		WhileNode(function() return GetHome(self.inst) end, "HasHome", Wander(self.inst, GetHomePos, 8) ),
		Wander(self.inst, GetWanderPoint, 20),

	}, .25)
	
	self.bt = BT(self.inst, root)
	
end

return SnakeBrain
%%+%%scripts/brains/solofishbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"


local STOP_RUN_DIST = 12
local SEE_PLAYER_DIST = 7

local AVOID_PLAYER_DIST = 5
local AVOID_PLAYER_STOP = 8

local SEE_BAIT_DIST = 20
local MAX_IDLE_WANDER_DIST = TUNING.SOLOFISH_WANDER_DIST


local SolofishBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)


function SolofishBrain:OnInitializationComplete()
      self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
 end

local wandertimes =
{
    minwalktime = 2,
    randwalktime =  2,
    minwaittime = 0.1,
    randwaittime = 0.1,
}


local function EatFoodAction(inst)
    local notags = {"FX", "NOCLICK", "DECOR","INLIMBO", "planted"}
    local target = FindEntity(inst, SEE_BAIT_DIST, function(item) return inst.components.eater:CanEat(item) and item.components.bait and not (item.components.inventoryitem and item.components.inventoryitem:IsHeld()) end, nil, notags)
    if target then
        local act = BufferedAction(inst, target, ACTIONS.EAT)
        act.validfn = function() return not (target.components.inventoryitem and target.components.inventoryitem:IsHeld()) end
        return act
    end
end


function SolofishBrain:OnStart()
    local root = PriorityNode(
    {
        -- DoAction(self.inst, EatFoodAction),
        RunAway(self.inst, "scarytoprey", AVOID_PLAYER_DIST, AVOID_PLAYER_STOP),
        -- RunAway(self.inst, "scarytoprey", SEE_PLAYER_DIST, STOP_RUN_DIST, nil),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_IDLE_WANDER_DIST, wandertimes),
    }, .25)
    self.bt = BT(self.inst, root)
end

return SolofishBrain
%%+%%scripts/brains/stungraybrain.lua%%-%%require "behaviours/standstill"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/panic"
require "behaviours/wander"
require "behaviours/chaseandattack"

local StungrayBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)

function StungrayBrain:OnStart()
    local root = PriorityNode({
        WhileNode(function() return self.inst.components.health.takingfiredamage and not self.inst.components.teamattacker.inteam end, "OnFire", Panic(self.inst)),
        AttackWall(self.inst),
        ChaseAndAttack(self.inst, TUNING.STINKRAY_CHASE_TIME, TUNING.STINKRAY_CHASE_DIST),
        WhileNode(function() return self.inst.components.teamattacker.teamleader == nil end, "No Leader Wander Action",
            Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, 40)),
    }, .25)
    self.bt = BT(self.inst, root)
end

return StungrayBrain
%%+%%scripts/brains/swordfishbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"
require "behaviours/chaseandattack"

local CHASE_TIME = 30
local CHASE_DIST = 40
local MAX_IDLE_WANDER_DIST = TUNING.SOLOFISH_WANDER_DIST


local SwordfishBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)


function SwordfishBrain:OnInitializationComplete()
      self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
 end

local wandertimes =
{
    minwalktime = 2,
    randwalktime =  2,
    minwaittime = 0.1,
    randwaittime = 0.1,
}

function SwordfishBrain:OnStart()
    
    local root = PriorityNode(
    {
        ChaseAndAttack(self.inst, CHASE_TIME, CHASE_DIST),
        Wander(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, MAX_IDLE_WANDER_DIST, wandertimes)

    }, .25)
    self.bt = BT(self.inst, root)
end

return SwordfishBrain
%%+%%scripts/brains/tigersharkbrain.lua%%-%%require "behaviours/wander"
require "behaviours/runaway"
require "behaviours/doaction"

local MAX_IDLE_WANDER_DIST = 30

local MAX_CHASE_TIME = 10
local GIVE_UP_DIST = 20
local MAX_CHARGE_DIST = 60

local DO_ACTIONS_DISTANCE = 30

local NO_TAGS = {"FX", "NOCLICK", "DECOR", "INLIMBO", "kittenchow"}

local TigersharkBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local wandertimes =
{
    minwalktime = 6,
    randwalktime =  6,
    minwaittime = 5,
    randwaittime = 5,
}

--[[
    intended behaviour cases:

    -defend children from baddies
        -aggressive if player is near home
    -feed children
        -drop food near them
    -hunt prey near player
        -after doing something near the player, return home
--]]

local function FeedChildrenAction(inst)
    --If you are holding some food and your children are nearby
    --Go over to them and drop the food.

    if GetTime() < inst.NextFeedTime or inst.components.combat.target ~= nil then
        return
    end

    local kittenHerd = inst:FindSharkHome()

    if kittenHerd and inst:GetPosition():Dist(kittenHerd:GetPosition()) < 40 then --children are nearby
        inst.NextFeedTime = GetTime() + 30
        return BufferedAction(inst, kittenHerd, ACTIONS.TIGERSHARK_FEED)
    end
end

local function EatFoodAction(inst)
    local target = nil

    local pt = inst:GetPosition()
    local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, DO_ACTIONS_DISTANCE, nil, NO_TAGS, inst.components.eater:GetEdibleTags())

    for _, ent in pairs(ents) do
        if inst.components.eater:CanEat(ent) then
            target = ent
            break
        end
    end

    if target then
        return BufferedAction(inst, target, ACTIONS.EAT)--(PICK UP ACTION)
    end
end

local function GetWanderPoint(inst)
    if inst.components.knownlocations and inst.components.knownlocations:GetLocation("point_of_interest") then
        return inst.components.knownlocations:GetLocation("point_of_interest")
    end

    if inst:FindSharkHome() and inst:GetPosition():Dist(inst:FindSharkHome():GetPosition()) < 40 then
        return inst:FindSharkHome():GetPosition()
    end

    return inst:GetPosition()
end

local function FindWaterAction(inst)
    if inst:HasTag("aquatic") then
        --Don't do anything.
        return nil
    end
    local wateroffset = FindWaterOffset(inst:GetPosition(), math.random() * 2 * math.pi, 30, 36)
    if wateroffset then
        return BufferedAction(inst, nil, ACTIONS.WALKTO, nil, inst:GetPosition() + wateroffset)
    end
end

function TigersharkBrain:OnStart()
    local root = PriorityNode(
    {
        ---- Combat Actions ----
        WhileNode(function() return self.inst.CanRun and self.inst.components.combat.target and
            (distsq(self.inst:GetPosition(), self.inst.components.combat.target:GetPosition()) > 10*10 or self.inst.sg:HasStateTag("running")) end,
                "Charge Behaviours", ChaseAndRam(self.inst, MAX_CHASE_TIME, GIVE_UP_DIST, MAX_CHARGE_DIST)),
        ChaseAndAttack(self.inst),
        ----

        --Run home
        WhileNode(function() return self.inst.components.health:GetPercent() <= 0.1 end, "Low Health",
            PriorityNode({
                DoAction(self.inst, FindWaterAction, "Go To Water"), --Get into water
                Leash(self.inst, function() return self.inst:FindSharkHome() and self.inst:FindSharkHome():GetPosition() end, 81, 80, true),
            }, 0.25)),

        DoAction(self.inst, FeedChildrenAction, "Feed Action"),

        DoAction(self.inst, EatFoodAction, "Eat Action"),

        WhileNode(function() return not self.inst.CanFly end, "Wander Behaviours", --Wander around
            Wander(self.inst, function() return GetWanderPoint(self.inst) end, MAX_IDLE_WANDER_DIST, wandertimes)),

    }, .25)
    self.bt = BT(self.inst, root)
end

return TigersharkBrain%%+%%scripts/brains/treeguardbrain.lua%%-%%require "behaviours/chaseandattack"
require "behaviours/runaway"
require "behaviours/wander"
require "behaviours/doaction"
require "behaviours/attackwall"
--require "behaviours/spreadout"


local TreeGuardBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function TreeGuardBrain:OnStart()
    local root =
        PriorityNode(
        {
            RunAway(self.inst, "treeguard", 5, 10),
            --SpreadOut(self.inst, 10, {"treeguard"}),
            AttackWall(self.inst),
            ChaseAndAttack(self.inst),
            Wander(self.inst),
        },1)
    
    self.bt = BT(self.inst, root)
end

return TreeGuardBrain
%%+%%scripts/brains/twisterbrain.lua%%-%%require "behaviours/wander"
require "behaviours/doaction"
require "behaviours/chaseandram"
require "behaviours/chaseandattack"
require "behaviours/standandattack"
require "behaviours/leash"

local MAX_CHASE_TIME = 10
local GIVE_UP_DIST = 20
local MAX_CHARGE_DIST = 60

local wandertimes =
{
    minwalktime = 5,
    randwalktime =  3,
    minwaittime = 0,
    randwaittime = 0,
}

local function GetWanderPos(inst)
    if inst:IsNearPlayer(60, true) then
        return inst:GetNearestPlayer(true):GetPosition()
    elseif inst.components.knownlocations:GetLocation("home") then
        return inst.components.knownlocations:GetLocation("home")
    elseif inst.components.knownlocations:GetLocation("spawnpoint") then
        return inst.components.knownlocations:GetLocation("spawnpoint")
    end
end

local function GetNewHome(inst)
    if inst.forgethometask then
        inst.forgethometask:Cancel()
        inst.forgethometask = nil
    end
    -- Pick a point to go to that is some distance away from here.
    local targetPos = Vector3(inst.Transform:GetWorldPosition())
    local wanderAwayPoint = GetWanderAwayPoint(targetPos)
    if wanderAwayPoint then
        inst.components.knownlocations:RememberLocation("home", wanderAwayPoint)
    end

    inst.forgethometask = inst:DoTaskInTime(30, function() inst.components.knownlocations:ForgetLocation("home") end)
end

local function GetHomePos(inst)
    if not inst.components.knownlocations:GetLocation("home") then
        GetNewHome(inst)
    end
    return inst.components.knownlocations:GetLocation("home")
end

local TwisterBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

function TwisterBrain:OnStart()
    local root =
        PriorityNode(
        {
            WhileNode(function() return self.inst.sg:HasStateTag("running") or 
                (self.inst.CanCharge and self.inst.components.combat.target and self.inst.components.combat.target:GetPosition():Dist(self.inst:GetPosition()) >= TUNING.TWISTER_ATTACK_RANGE) end, 
                "Charge Behaviours", ChaseAndRam(self.inst, MAX_CHASE_TIME, GIVE_UP_DIST, MAX_CHARGE_DIST)),
            WhileNode(function() return not self.inst.CanCharge end, "Attack Behaviours", ChaseAndAttack(self.inst, nil, nil, nil, nil, true)),
            WhileNode(function() return self.inst.shouldGoAway end, "Should Leave", Wander(self.inst, GetHomePos, 20)),
            Wander(self.inst, GetWanderPos, 20, wandertimes),
        }, .25)
    
    self.bt = BT(self.inst, root)
end

function TwisterBrain:OnInitializationComplete()
    self.inst.components.knownlocations:RememberLocation("spawnpoint", Point(self.inst.Transform:GetWorldPosition()))
end

return TwisterBrain%%+%%scripts/brains/twistersealbrain.lua%%-%%require "behaviours/faceentity"

local TwisterSealBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
end)

local START_FACE_DIST = 14
local KEEP_FACE_DIST = 20

local function GetFaceTargetFn(inst)
    local target = GetClosestInstWithTag("player", inst, START_FACE_DIST)
    if target and not target:HasTag("notarget") then
        return target
    end
end

local function KeepFaceTargetFn(inst, target)
    return inst:GetDistanceSqToInst(target) <= KEEP_FACE_DIST * KEEP_FACE_DIST and not target:HasTag("notarget")
end

function TwisterSealBrain:OnStart()
    local root =
        PriorityNode({FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn)}, .25)
    self.bt = BT(self.inst, root)
end

return TwisterSealBrain%%+%%scripts/brains/whitewhalebrain.lua%%-%%require "behaviours/wander"
require "behaviours/chaseandattack"


local LEASH_RETURN_DIST = 5
local LEASH_MAX_DIST = 10

local wander_times =
{
	minwalktime = 4,
	randwalktime = 4,
	minwaittime = 4,
	randwaittime = 3,
}

local WhiteWhaleBrain = Class(Brain, function(self, inst)
	Brain._ctor(self, inst)
end)

function WhiteWhaleBrain:OnInitializationComplete()
    self.inst.components.knownlocations:RememberLocation("home", Point(self.inst.Transform:GetWorldPosition()), true)
end

function WhiteWhaleBrain:OnStart()
	
	local root = PriorityNode(
	{
		SequenceNode{
            ConditionNode(function() 
	            local tile = self.inst.components.tiletracker.tile
	            if tile == GROUND.OCEAN_SHALLOW then
	            	self.inst.hitshallow = true
	            end
	            return tile == GROUND.OCEAN_SHALLOW or self.inst.hitshallow
	        end, "HitShallow"),

            ParallelNodeAny {
                WaitNode(15+math.random()*2),
                Leash(self.inst, function() return self.inst.components.knownlocations:GetLocation("home") end, LEASH_MAX_DIST, LEASH_RETURN_DIST),
            },
            DoAction(self.inst, function() self.inst.hitshallow = nil end ),
        },

		ChaseAndAttack(self.inst, TUNING.WHALE_WHITE_FOLLOW_TIME, TUNING.WHALE_WHITE_CHASE_DIST),
		Wander(self.inst, nil, nil, wander_times)
	}, .25)
	
	self.bt = BT(self.inst, root)
end

return WhiteWhaleBrain
%%+%%scripts/brains/wildborebrain.lua%%-%%require "behaviours/wander"
require "behaviours/follow"
require "behaviours/faceentity"
require "behaviours/chaseandattack"
require "behaviours/runaway"
require "behaviours/doaction"
--require "behaviours/choptree"
require "behaviours/findlight"
require "behaviours/panic"
require "behaviours/chattynode"
require "behaviours/leash"
require "behaviours/chaseandram"
local BrainCommon = require "brains/braincommon"



local MIN_FOLLOW_DIST = 2
local TARGET_FOLLOW_DIST = 5
local MAX_FOLLOW_DIST = 9
local MAX_WANDER_DIST = 20

local LEASH_RETURN_DIST = 10
local LEASH_MAX_DIST = 30

local START_FACE_DIST = 6
local KEEP_FACE_DIST = 8
local START_RUN_DIST = 3
local STOP_RUN_DIST = 5
local MAX_CHASE_TIME = 10
local MAX_CHASE_DIST = 30
local SEE_LIGHT_DIST = 20
local TRADE_DIST = 20
local SEE_TREE_DIST = 15
local SEE_TARGET_DIST = 20
local SEE_FOOD_DIST = 10

local KEEP_CHOPPING_DIST = 10

local RUN_AWAY_DIST = 5
local STOP_RUN_AWAY_DIST = 8

local MAX_CHARGE_TIME = 5
local MAX_CHARGE_DIST = 15
local CHASE_GIVEUP_DIST = 10

local ANNOYANCE_THRESHOLD = TUNING.WILDBOAR_ANNOYANCE_THRESHOLD

local function ShouldRunAway(inst, target)
  return not inst.components.trader:IsTryingToTradeWithMe(target)
end

local function GetTraderFn(inst)
  return FindEntity(inst, TRADE_DIST, function(target) return inst.components.trader:IsTryingToTradeWithMe(target) end, {"player"})
end

local function KeepTraderFn(inst, target)
  return inst.components.trader:IsTryingToTradeWithMe(target)
end

local function FindFoodAction(inst)
  local target = nil

  if inst.sg:HasStateTag("busy") then
    return
  end

  if inst.components.inventory and inst.components.eater then
    target = inst.components.inventory:FindItem(function(item) return inst.components.eater:CanEat(item) end)
  end

  local time_since_eat = inst.components.eater:TimeSinceLastEating()
  local noveggie = time_since_eat and time_since_eat < TUNING.PIG_MIN_POOP_PERIOD*4

  local notags = {"FX","NOCLICK","DECOR","INLIMBO","floating"}
  if not target and (not time_since_eat or time_since_eat > TUNING.PIG_MIN_POOP_PERIOD*2) then
    target = FindEntity(inst, SEE_FOOD_DIST, function(item) 
        if item:GetTimeAlive() < 8 then return false end
        if item.prefab == "mandrake" then return false end
        if noveggie and item.components.edible and item.components.edible.foodtype ~= "MEAT" then
          return false
        end
        if not item:IsOnValidGround() then
          return false
        end
        return inst.components.eater:CanEat(item) 
      end, nil, notags)
  end
  if target then
    return BufferedAction(inst, target, ACTIONS.EAT)
  end

  if not target and (not time_since_eat or time_since_eat > TUNING.PIG_MIN_POOP_PERIOD*2) then
    target = FindEntity(inst, SEE_FOOD_DIST, function(item) 
        if not item.components.shelf then return false end
        if not item.components.shelf.itemonshelf or not item.components.shelf.cantakeitem then return false end
        if noveggie and item.components.shelf.itemonshelf.components.edible and item.components.shelf.itemonshelf.components.edible.foodtype ~= "MEAT" then
          return false
        end
        if not item:IsOnValidGround() then
          return false
        end
        return inst.components.eater:CanEat(item.components.shelf.itemonshelf) 
      end, nil, notags)
  end

  if target then
    return BufferedAction(inst, target, ACTIONS.TAKEITEM)
  end

end


local function KeepChoppingAction(inst)
  local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
  local keep_chop = inst.components.follower.leader and inst.components.follower.leader:GetDistanceSqToInst(inst) <= KEEP_CHOPPING_DIST*KEEP_CHOPPING_DIST
  local target = FindEntity(inst, SEE_TREE_DIST/3, function(item)
      return item.prefab == "deciduoustree" and item.monster and item.components.workable and item.components.workable.action == ACTIONS.CHOP 
    end, nil, notags)    
  if inst.tree_target ~= nil then target = inst.tree_target end

  return (keep_chop or target ~= nil)
end

local function StartChoppingCondition(inst)
  local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
  local start_chop = inst.components.follower.leader and inst.components.follower.leader.sg and inst.components.follower.leader.sg:HasStateTag("chopping")
  local target = FindEntity(inst, SEE_TREE_DIST/3, function(item) 
      return item.prefab == "deciduoustree" and item.monster and item.components.workable and item.components.workable.action == ACTIONS.CHOP 
    end, nil, notags)
  if inst.tree_target ~= nil then target = inst.tree_target end

  return (start_chop or target ~= nil)
end


local function FindTreeToChopAction(inst)
  local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
  local target = FindEntity(inst, SEE_TREE_DIST, function(item) return item.components.workable and item.components.workable.action == ACTIONS.CHOP end)
  if target then
    local decid_monst_target = FindEntity(inst, SEE_TREE_DIST/3, function(item)
        return item.prefab == "deciduoustree" and item.monster and item.components.workable and item.components.workable.action == ACTIONS.CHOP 
      end, nil, notags)
    if decid_monst_target ~= nil then 
      target = decid_monst_target 
    end
    if inst.tree_target then 
      target = inst.tree_target
      inst.tree_target = nil 
    end
    return BufferedAction(inst, target, ACTIONS.CHOP)
  end
end

local function KeepHackingAction(inst)
  local keep_hack = inst.components.follower.leader and inst.components.follower.leader:GetDistanceSqToInst(inst) <= KEEP_CHOPPING_DIST*KEEP_CHOPPING_DIST
  return keep_hack
end

local function StartHackingCondition(inst)
  local start_chop = inst.components.follower.leader and inst.components.follower.leader.sg and inst.components.follower.leader.sg:HasStateTag("hacking")
  return start_chop
end

local function FindBushToHackAction(inst)
  local notags = {"FX", "NOCLICK", "DECOR","INLIMBO"}
  local target = FindEntity(inst, SEE_TREE_DIST, function(item) return item.components.hackable and item.components.hackable.canbehacked and item.components.hackable.caninteractwith end, nil, notags)
  if target then
    return BufferedAction(inst, target, ACTIONS.HACK)
  end
end

local function HasValidHome(inst)
  return inst.components.homeseeker and 
  inst.components.homeseeker.home and 
  not inst.components.homeseeker.home:HasTag("fire") and
  not inst.components.homeseeker.home:HasTag("burnt") and
  inst.components.homeseeker.home:IsValid()
end

local function GoHomeAction(inst)
  if not inst.components.follower.leader and
  HasValidHome(inst) and
  not inst.components.combat.target then
    return BufferedAction(inst, inst.components.homeseeker.home, ACTIONS.GOHOME)
  end
end

local function GetLeader(inst)
  return inst.components.follower.leader 
end

local function GetHomePos(inst)
  return HasValidHome(inst) and inst.components.homeseeker:GetHomePos()
end

local function GetNoLeaderHomePos(inst)
  if GetLeader(inst) then
    return nil
  end
  return GetHomePos(inst)
end

local function GetFaceTargetFn(inst)
  return inst.components.follower.leader
end

local function KeepFaceTargetFn(inst, target)
  return inst.components.follower.leader == target
end

local function GetAnnoyedFn(inst, target)
  inst.annoyance = 0
  if inst.reset_annoyance_task then
    inst.reset_annoyance_task:Cancel()
  end

  if inst.components.combat then
    inst.components.combat:SuggestTarget(target)
  end
end

local function ShouldRunFromPlayerFn(inst)
  return function(hunter)
    inst.annoyance = inst.annoyance + 1

    local resetfn = function()
      inst.annoyance = 0
    end

    if inst.reset_annoyance_task then
      inst.reset_annoyance_task:Cancel()
    end

    inst.reset_annoyance_task = inst:DoTaskInTime(10, resetfn)

    --print(string.format("%2.0f/%2.0f", inst.annoyance, ANNOYANCE_THRESHOLD))

    if inst.annoyance >= ANNOYANCE_THRESHOLD then
      GetAnnoyedFn(inst, hunter)
      return false
    end

    return true
  end
end

local function SafeLightDist(inst, target)
  return (target:HasTag("player") or target:HasTag("playerlight")
    or (target.inventoryitem and target.inventoryitem:GetGrandOwner() and target.inventoryitem:GetGrandOwner():HasTag("player")))
  and 4
  or target.Light:GetCalculatedRadius() / 3
end

local PigBrain = Class(Brain, function(self, inst)
    Brain._ctor(self, inst)
  end)

function PigBrain:OnStart()   
  local day = WhileNode( function() return TheWorld.state.isday end, "IsDay",
    PriorityNode{
      ChattyNode(self.inst, "BORE_TALK_FIND_MEAT",
        DoAction(self.inst, FindFoodAction )),
      IfNode(function() return StartChoppingCondition(self.inst) end, "chop", 
        WhileNode(function() return KeepChoppingAction(self.inst) end, "keep chopping",
          LoopNode{ 
            ChattyNode(self.inst, "BORE_TALK_HELP_CHOP_WOOD",
              DoAction(self.inst, FindTreeToChopAction ))})),
      IfNode(function() return StartHackingCondition(self.inst) end, "hack", 
        WhileNode(function() return KeepHackingAction(self.inst) end, "keep hacking",
          LoopNode{ 
            ChattyNode(self.inst, "BORE_TALK_HELP_HACK",
              DoAction(self.inst, FindBushToHackAction ))})),
      ChattyNode(self.inst, "BORE_TALK_FOLLOWWILSON", 
        Follow(self.inst, GetLeader, MIN_FOLLOW_DIST, TARGET_FOLLOW_DIST, MAX_FOLLOW_DIST)),
      IfNode(function() return GetLeader(self.inst) end, "has leader",
        ChattyNode(self.inst, "BORE_TALK_FOLLOWWILSON",
          FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn ))),

      Leash(self.inst, GetNoLeaderHomePos, LEASH_MAX_DIST, LEASH_RETURN_DIST),

      ChattyNode(self.inst, "BORE_TALK_RUNAWAY_WILSON",
        RunAway(self.inst, "player", START_RUN_DIST, STOP_RUN_DIST, ShouldRunFromPlayerFn(self.inst))),
      --DoAction(self.inst, GetAnnoyedFn),
      ChattyNode(self.inst, "BORE_TALK_LOOKATWILSON",
        FaceEntity(self.inst, GetFaceTargetFn, KeepFaceTargetFn)),
      Wander(self.inst, GetNoLeaderHomePos, MAX_WANDER_DIST)
      },.5)


  local night = WhileNode( function() return not TheWorld.state.isday end, "IsNight",
    PriorityNode{
      ChattyNode(self.inst, "BORE_TALK_RUN_FROM_SPIDER",
        RunAway(self.inst, "spider", 4, 8)),
      ChattyNode(self.inst, "BORE_TALK_FIND_MEAT",
        DoAction(self.inst, FindFoodAction )),
      RunAway(self.inst, "player", START_RUN_DIST, STOP_RUN_DIST, function(target) return ShouldRunAway(self.inst, target) end ),
      ChattyNode(self.inst, "BORE_TALK_GO_HOME",
        DoAction(self.inst, GoHomeAction, "go home", true )),
      ChattyNode(self.inst, "BORE_TALK_FIND_LIGHT",
        FindLight(self.inst, SEE_LIGHT_DIST, SafeLightDist)),
    ChattyNode(self.inst, "BORE_TALK_PANIC",
      Panic(self.inst)),
    },1)


local root = 
PriorityNode(
  {

	BrainCommon.PanicWhenScared(self.inst, .25, "BORE_TALK_PANICBOSS"),
	WhileNode( function() return self.inst.components.hauntable and self.inst.components.hauntable.panic end, "PanicHaunted",
		ChattyNode(self.inst, "BORE_TALK_PANICHAUNT",
			Panic(self.inst))),
    WhileNode(function() return self.inst.components.health.takingfiredamage end, "OnFire",
      ChattyNode(self.inst, "BORE_TALK_PANICFIRE",
        Panic(self.inst))),
    ChattyNode(self.inst, "BORE_TALK_FIGHT",
      WhileNode( function() return self.inst.components.combat.target and not self.inst.components.combat:InCooldown() end, "AttackMomentarily",
        PriorityNode({ --Is a second priority node really necessary? And is it wise? Would a Parallel node suffice? -M
            WhileNode( function() return self.inst.components.combat.target and (not self.inst.components.combat.target:IsNear(self.inst, 6) or self.inst.sg:HasStateTag("charging")) end,
              --If you're far away or already doing a charge, charge.
              "RamAttack", ChaseAndRam(self.inst, MAX_CHARGE_TIME, CHASE_GIVEUP_DIST, MAX_CHARGE_DIST)),
            -- WhileNode( function() return self.inst.components.combat.target and self.inst.components.combat.target:IsNear(self.inst, 6) and not self.inst.sg:HasStateTag("charging") end,
              --If you're close and not already charging just do a regular attack.
            ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST),
              -- "NormalAttack", ChaseAndAttack(self.inst, MAX_CHASE_TIME, MAX_CHASE_DIST)),
            }, 0.1)
      )),
    ChattyNode(self.inst, "BORE_TALK_FIGHT",
      WhileNode( function() return self.inst.components.combat.target and self.inst.components.combat:InCooldown() end, "Dodge",
        RunAway(self.inst, function() return self.inst.components.combat.target end, RUN_AWAY_DIST, STOP_RUN_AWAY_DIST, 
          function(hunter) return self.inst.components.combat:InCooldown() end))),
    RunAway(self.inst, function(guy) return guy:HasTag("pig") and guy.components.combat and guy.components.combat.target == self.inst end, RUN_AWAY_DIST, STOP_RUN_AWAY_DIST ),
    ChattyNode(self.inst, "BORE_TALK_ATTEMPT_TRADE",
      FaceEntity(self.inst, GetTraderFn, KeepTraderFn)),
    day,
    night
    }, .5)

self.bt = BT(self.inst, root)

end

return PigBrain
%%+%%scripts/components/appeasement.lua%%-%%--This is a barebones component for the componentaction

local Appeasement = Class(function(self, inst)
    self.inst = inst
    self.appeasementvalue = 0 
end)

return Appeasement%%+%%scripts/components/areapoisoner.lua%%-%%local function DefaultPoisonAttackFn(inst, target)
	if target.components.poisonable then
		target.components.poisonable:Poison(true)
	end
end

local AreaPoisoner = Class(function(self, inst)
	self.inst = inst
	
	self.poisonrange = 0
	self.duration = 0
	self.onpoisonattackfn = DefaultPoisonAttackFn

	self.spreading = false
end)

--function AreaPoisoner:GetDebugString()
	--return string.format("%s", self.spreading and "SPREADING" or "NOT SPREADING")
--end

function AreaPoisoner:StartSpreading(duration)
	self.duration = duration or 0
	self.spreading = true
	if self.duration > 0 then
		self.start_time = GetTime()
	end
	
	self:DoPoison()
	if not self.task then
		self.task = self.inst:DoPeriodicTask(TUNING.AREA_POISONER_CHECK_INTERVAL, function() self:DoPoison() end)
	end
end

function AreaPoisoner:StopSpreading()
	self.spreading = false
	self.start_time = nil
	
	if self.task then
		self.task:Cancel()
		self.task = nil
	end
end

function AreaPoisoner:SetOnPoisonAttackFn(onpoisonattackfn)
	self.onpoisonattackfn = onpoisonattackfn
end

function AreaPoisoner:DoPoison(oneoff)
	if self.duration > 0 and GetTime() - self.start_time > self.duration then
		self:StopSpreading()
		return
	end

	if (self.spreading or oneoff) and self.poisonrange > 0 then
		-- in here we are targeting other entities and damaging them
		local pos = Vector3(self.inst.Transform:GetWorldPosition())
		local prop_range = self.poisonrange
		local ents = TheSim:FindEntities(pos.x, pos.y, pos.z, prop_range, {"poisonable"})
		
		for k,v in pairs(ents) do
			if not v:IsInLimbo() then
				if v ~= self.inst and v.components.poisonable then
					if self.onpoisonattackfn then
						self.onpoisonattackfn(self.inst, v)
					end
				end
			end
		end
	end
end

function AreaPoisoner:OnSave()    
	return 
	{
		timeleft = self.start_time and self.duration - (GetTime() - self.start_time) or nil,
	}
end

function AreaPoisoner:OnLoad(data)
	if data.timeleft then
		self:StartSpreading(data.timeleft)
	end
end

return AreaPoisoner
%%+%%scripts/components/areaspawner.lua%%-%%
local function DoSpawn(inst)
    local spawner = inst.components.areaspawner
    if spawner then
		spawner.target_time = nil    
		spawner:TrySpawn()
        spawner:Start()
    end
end

local AreaSpawner = Class(function(self, inst)
    self.inst = inst
    self.basetime = 40
    self.randtime = 60
    self.prefabfn = nil
    self.prefab = nil
    
    self.range = nil
    self.density = nil
    self.spacing = nil
    
    self.onspawn = nil
    self.spawntest = nil
    
    self.spawnoffscreen = false
    self.spawnphase = nil
    self.spawntiles = nil
end)

function AreaSpawner:SetPrefab(prefab)
    self.prefab = prefab
end

function AreaSpawner:SetPrefabFn(fn)
    self.prefabfn = fn
end

function AreaSpawner:SetValidTileType(tiles)
    if type(tiles) == "table" then
        self.spawntiles = tiles
    else
        self.spawntiles = {tiles}
    end
end

function AreaSpawner:SetRandomTimes(basetime, variance, no_reset)
    self.basetime = basetime
    self.randtime = variance
    if self.task and not no_reset then
        self:Stop()
        self:Start()
    end
end

function AreaSpawner:SetDensityInRange(range, density)
    self.range = range
    self.density = density
end

function AreaSpawner:SetMinimumSpacing(spacing)
    self.spacing = spacing
end

function AreaSpawner:SetOnlySpawnOffscreen(offscreen)
    self.spawnoffscreen = offscreen
end

function AreaSpawner:IsSpawnOffscreen()
    return self.spawnoffscreen
end

function AreaSpawner:SetSpawnPhase(phase)
    self.spawnphase = phase
end

function AreaSpawner:SetOnSpawnFn(fn)
    self.onspawn = fn
end

function AreaSpawner:SetSpawnTestFn(fn)
    self.spawntest = fn
end

function AreaSpawner:TrySpawn(prefab)
    prefab = prefab or (self.prefabfn and self.prefabfn()) or self.prefab
    if not self.inst:IsValid() or not prefab then
        return
    end

    local pos = Vector3(self.inst.Transform:GetWorldPosition())
    local canspawn = true

    if self.spawnoffscreen and not self.inst:IsAsleep() then
        return false
    end

    if self.spawnphase and TheWorld.state.phase ~= self.spawnphase then
        return false
    end

    if canspawn and (self.range or self.spacing) then
        local ents = TheSim:FindEntities(pos.x,pos.y,pos.z, self.range or self.spacing)
        local count = 0
        for k,v in pairs(ents) do
            if v.prefab == prefab then
                if self.spacing and v:GetDistanceSqToInst(self.inst) < self.spacing*self.spacing then
                    canspawn = false
                    break
                end
                count = count + 1
            end
        end
        if self.density and count >= self.density then
            return false
        end
    end

    local map = TheWorld.Map
    local x, y, z = pos.x + self.range * (2.0 * math.random() - 1.0), pos.y, pos.z + self.range * (2.0 * math.random() - 1.0)
    local ground = self.inst:GetCurrentTileType(x, y, z)--map:GetTile(map:GetTileCoordsAtPoint(x, y, z))

    if self.spawntiles then
        local is_validtile = function(ground)
            for i = 1, #self.spawntiles, 1 do
                if self.spawntiles[i] == ground then
                    return true
                end
            end
            return false
        end
        canspawn = canspawn and is_validtile(ground)
    end
    
    if self.spawntest then
        canspawn = canspawn and self.spawntest(self.inst, ground, x, y, z)
    end

    if canspawn then
        local inst = SpawnPrefab(prefab)
        -- transform first incase the callback wants to change it
        inst.Transform:SetPosition(x, y, z)
        if self.onspawn then
            self.onspawn(self.inst, inst, ground)
        end
    end
    return canspawn
end

function AreaSpawner:Start()
    local t = self.basetime + math.random()*self.randtime
    self.target_time = GetTime() + t
    self.task = self.inst:DoTaskInTime(t, DoSpawn)
    --self.inst:StartUpdatingComponent(self)
end


function AreaSpawner:Stop()
    self.target_time = nil
    if self.task then
        self.task:Cancel()
        self.task = nil
    end
    --self.inst:StopUpdatingComponent(self)
end

--[[
function AreaSpawner:OnEntitySleep()
	self:Stop()
end

function AreaSpawner:OnEntityWake()
	self:Start()
end
--]]

function AreaSpawner:OnUpdate(dt)
    self:DebugRender()
end

function AreaSpawner:LongUpdate(dt)
	if self.target_time then
		if self.task then
			self.task:Cancel()
			self.task = nil
		end
		local time_to_wait = self.target_time - GetTime() - dt
		
		if time_to_wait <= 0 then
			DoSpawn(self.inst)		
		else
			self.target_time = GetTime() + time_to_wait
			self.task = self.inst:DoTaskInTime(time_to_wait, DoSpawn)
		end
	end
end

function AreaSpawner:OnSave()
    return
    {
        basetime = self.basetime,
        randtime = self.randtime,
        range = self.range,
        density = self.density,
        spacing = self.spacing,
        spawnphase = self.spawnphase
    }
end

function AreaSpawner:OnLoad(data)
    if data then
        self.basetime = data.basetime or self.basetime
        self.randtime = data.randtime or self.randtime
        self.range = data.range or self.range
        self.density = data.density or self.density
        self.spacing = data.spacing or self.spacing
        self.spawnphase = data.spawnphase or self.spawnphase
    end
end

function AreaSpawner:DebugRender()
    if TheSim:GetDebugRenderEnabled() then
        if self.inst.draw then
            self.inst.draw:Flush()
            self.inst.draw:SetRenderLoop(true)
            self.inst.draw:SetZ(0.15)

            local dim = 2.0 * self.range
            local x, y, z = self.inst.Transform:GetWorldPosition()
            self.inst.draw:Box(x - self.range, z - self.range, dim, dim, 0, 1, 0, 1)
        else
            --TheSim:SetDebugRenderEnabled(true)
            self.inst.draw = self.inst.entity:AddDebugRender()
        end
    end
end

return AreaSpawner%%+%%scripts/components/autofixer.lua%%-%%local AutoFixer = Class(function(self, inst)
    self.inst = inst

    --V2C: Recommended to explicitly add tag to prefab pristine state
    inst:AddTag("autofixer")

    self.users = {}
    self.locked = false

    self.onremoveuser = function(user) self:TurnOff(user) end
end)

function AutoFixer:OnRemoveFromEntity()
    self.inst:RemoveTag("autofixer")
    for i, user in ipairs(self.users) do
        self.inst:RemoveEventCallback("onremove", self.onremoveuser, user)
        if self.stopfixing then
            self.stopfixing(self.inst, user)
        end        
    end
    self.users = nil
end

AutoFixer.OnRemoveEntity = AutoFixer.OnRemoveFromEntity

function AutoFixer:OnSave()
    return {locked = self.locked}
end

function AutoFixer:OnLoad(data)
    if data then
        self.locked = data.locked
    end
end

function AutoFixer:SetAutoFixUserTestFn(fn)
    self.autofixusertest = fn
end

function AutoFixer:SetCanTurnOnFn(fn)
    self.canturnon = fn
end

function AutoFixer:SetOnTurnOnFn(fn)
    self.onturnon = fn
end

function AutoFixer:SetOnTurnOffFn(fn)
    self.onturnoff = fn
end

function AutoFixer:SetStartFixingFn(fn)
    self.startfixing = fn
end

function AutoFixer:SetStopFixingFn(fn)
    self.stopfixing = fn
end

function AutoFixer:CanAutoFixUser(user)
    return not self.locked and (self.autofixusertest == nil or self.autofixusertest(self.inst, user))
end

function AutoFixer:TurnOn(user) 
    if not self.locked and (self.canturnon == nil or self.canturnon(self.inst)) then
        local _usercount = #self.users
        if not table.contains(self.users, user) then
            table.insert(self.users, user)
            self.inst:ListenForEvent("onremove", self.onremoveuser, user)
            if self.startfixing then
                self.startfixing(self.inst, user)
            end
        end
        if self.onturnon and _usercount == 0 and #self.users >= 1 then
            self.onturnon(self.inst)
        end
    end
end

function AutoFixer:TurnOff(user)
    if user == nil then
        local users = {}
        for i, v in ipairs(self.users) do
            users[i] = v
        end
        for i, v in ipairs(users) do
            self:TurnOff(v)
        end
        return
    end
    local _usercount = #self.users
    if table.contains(self.users, user) then
        table.removearrayvalue(self.users, user)
        self.inst:RemoveEventCallback("onremove", self.onremoveuser, user)
        if self.stopfixing then
            self.stopfixing(self.inst, user)
        end
    end
    if self.onturnoff and _usercount > 0 and #self.users <= 0 then
        self.onturnoff(self.inst)
    end
end

function AutoFixer:IsOn()
    return #self.users > 0
end

return AutoFixer%%+%%scripts/components/ballphinfriend.lua%%-%%
local function OnAttacked(inst, data)
	--print("BallphinFriend OnAttacked", data.attacker and data.attacker.prefab)
	if (math.random() < TUNING.BALLPHIN_FRIEND_CHANCE) and data.attacker and data.attacker.prefab == "crocodog" then
		local ballphinfriend = inst.components.ballphinfriend
		if ballphinfriend then
			ballphinfriend:HelpAgainst(data.attacker)
		end
	end
end

local BallphinFriend = Class(function(self, inst)
	self.inst = inst

	self.minDist = 30
	self.maxDist = 32

	self.timetospawn_variation = TUNING.FLOWER_SPAWN_TIME_VARIATION
	self.timetospawn = TUNING.FLOWER_SPAWN_TIME
	self.active = true
	
	self.spawntimer = self:GetSpawnTime()

	self.inst:ListenForEvent("boatattacked", OnAttacked)
end)

function BallphinFriend:GetSpawnTime()
	return self.timetospawn + (math.random() * self.timetospawn_variation)
end

function BallphinFriend:GetSpawnPoint(player)
	local pt = player:GetPosition()
	local theta = math.random() * 2 * PI
	local radius = math.random(self.minDist, self.maxDist)
	local steps = 8
	local validpos = {}
	for i = 1, steps do
		local offset = Vector3(radius * math.cos( theta ), 0, -radius * math.sin( theta ))
		local try_pos = pt + offset
		if player:GetIsOnWater(try_pos:Get()) and #TheSim:FindEntities(try_pos.x, try_pos.y, try_pos.z, 1, nil, {"falling", "FX", "NOCLICK", "DECOR", "INLIMBO"}) <= 0 then
			table.insert(validpos, try_pos)
		end
		theta = theta - (2 * PI / steps)
	end
	if #validpos > 0 then
		local num = math.random(#validpos)
		return validpos[num]
	else
		return nil
	end
end

function BallphinFriend:SpawnBallphin(pt)
	local ballphin = SpawnPrefab("ballphin")
	ballphin.Transform:SetPosition(pt:Get())
	return ballphin
end

function BallphinFriend:HelpAgainst(attacker)
	--print("BallphinFriend:HelpAgainst", attacker)
    local player = self.inst
	local pt

	for i = 1, math.random(1, 4) do
		pt = self:GetSpawnPoint(player)
		
		if pt then
			local ballphin = self:SpawnBallphin(pt)
			if ballphin then
				ballphin:AddTag("ballphinfriend")
				ballphin.components.combat:SuggestTarget(attacker)
			end
		end
	end
end

function BallphinFriend:GetDebugString()
	return "Next spawn: "..tostring(self.spawntimer)
end

function BallphinFriend:OnSave()
	local data = {}
		data.spawntimer = self.spawntimer
		data.timetospawn = self.timetospawn
		data.timetospawn_variation = self.timetospawn_variation
		data.active = self.active
	return data
end

function BallphinFriend:OnLoad(data)
	if data then
		self.spawntimer = data.spawntimer
		self.timetospawn = data.timetospawn or TUNING.FLOWER_SPAWN_TIME
		self.timetospawn_variation = data.timetospawn_variation or TUNING.FLOWER_SPAWN_TIME_VARIATION
		self.active = data.active or true
		if not self.active then
			self.inst:StopUpdatingComponent(self)
		end
	end
end


return BallphinFriend
%%+%%scripts/components/blowinwindgust.lua%%-%%return Class(function(self, inst)

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst

--Private
local _ismastersim = TheWorld.ismastersim
local _activeplayers = {}
local task = nil
local blowing = false
local enabled = false

local startfn = nil
local endfn = nil
local destroyfn = nil
local windspeedthreshold = 0
local destroychance = 0.01

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function UpdateTask()
	task = nil
	if not self.inst then
		return
	end

	local windspeed = TheWorld.state.gustspeed
	if not blowing then
		if windspeed > windspeedthreshold then
			if _ismastersim and math.random() < destroychance then
				for i, player in ipairs(_activeplayers) do
					if self.inst:IsNear(player, TUNING.WINDBLOWN_DESTROY_DIST) then
						if destroyfn then
							destroyfn(self.inst)
						end
						return
					end
				end
			end
			if startfn then
				startfn(self.inst, windspeed)
			end
			blowing = true
		end
	else
		if windspeed < windspeedthreshold then
			if endfn then
				endfn(self.inst, windspeed)
			end
			blowing = false
		end
	end
end

--------------------------------------------------------------------------
--[[ Player handlers ]]
--------------------------------------------------------------------------

if _ismastersim then

local function OnPlayerJoined(src, player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            return
        end
    end
    table.insert(_activeplayers, player)
end

local function OnPlayerLeft(src, player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            table.remove(_activeplayers, i)
            return
        end
    end
end

--Initialize variables
for i, v in ipairs(AllPlayers) do
    table.insert(_activeplayers, v)
end

--Register events
inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)

end

--------------------------------------------------------------------------
--[[ Private Event Handlers ]]
--------------------------------------------------------------------------

local function OnGustSpeedChanged(src, windspeed)
	if enabled and not task and blowing ~= (windspeed > windspeedthreshold) then
		task = self.inst:DoTaskInTime(math.random() * 0.5 + 1.0, UpdateTask)
	end
end

--Register events
-- inst:WatchWorldState("gustspeed", OnGustSpeedChanged)

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

-- --Debug function
-- function self:Destroy()
	-- if destroyfn then
		-- destroyfn(self.inst)
	-- end
	-- blowing = false
-- end

function self:Start(soft)
	if not soft then
		enabled = true
	end
	if IsInIAClimate(self.inst) then
		self.inst:WatchWorldState("gustspeed", OnGustSpeedChanged)
	end
end

function self:Stop(soft)
	if not soft then
		enabled = false
	end
	self.inst:StopWatchingWorldState("gustspeed", OnGustSpeedChanged)
	if blowing and endfn then
		endfn(self.inst, windspeed)
	end
	blowing = false
	if task then
		task:Cancel()
	end
	task = nil
end

function self:SetWindSpeedThreshold(windspeed)
	windspeedthreshold = windspeed
end

function self:SetDestroyChance(chance)
	destroychance = chance
end

function self:SetGustStartFn(fn)
	startfn = fn
end

function self:SetGustEndFn(fn)
	endfn = fn
end

function self:SetDestroyFn(fn)
	destroyfn = fn
end

function self:OnEntitySleep()
	self:Stop(true)
end

function self:OnEntityWake()
	if enabled then
		self:Start(true)
	end
end

function self:OnRemoveEntity()
	self:Stop()
end

function self:OnRemoveFromEntity()
	self:Stop()
end

function self:IsGusting()
	return blowing
end

end)
%%+%%scripts/components/blowinwindgustitem.lua%%-%%local easing = require("easing")

local SPEED_VAR_PERIOD = 5
local SPEED_VAR_PERIOD_VARIANCE = 2

local function startfromevent(inst)
	inst.components.blowinwindgustitem:Start()
end
local function stopfromevent(inst)
	inst.components.blowinwindgustitem:Stop()
end

local BlowInWind = Class(function(self, inst)

    self.inst = inst

	self.maxSpeedMult = 1.5
	self.minSpeedMult = .5
	self.averageSpeed = (TUNING.WILSON_RUN_SPEED + TUNING.WILSON_WALK_SPEED)/2
	self.speed = 0

	self.velocity = Vector3(0,0,0)

	self.speedVarTime = 0
	self.speedVarPeriod = GetRandomWithVariance(SPEED_VAR_PERIOD, SPEED_VAR_PERIOD_VARIANCE)

	self.spawnPeriod = 1.0
	self.timeSinceSpawn = self.spawnPeriod
	
	self.inst:ListenForEvent("hitland", startfromevent)--R08_ROT_TURNOFTIDES
	self.inst:ListenForEvent("on_landed", startfromevent)--R08_ROT_TURNOFTIDES
	self.inst:ListenForEvent("ondropped", startfromevent)
	self.inst:ListenForEvent("onpickup", stopfromevent)
end)

function BlowInWind:OnRemoveEntity()
	self:Stop()
	self.inst:RemoveEventCallback("hitland", startfromevent)
	self.inst:RemoveEventCallback("on_landed", startfromevent)--R08_ROT_TURNOFTIDES
	self.inst:RemoveEventCallback("ondropped", startfromevent)
	self.inst:RemoveEventCallback("onpickup", stopfromevent)
end

function BlowInWind:OnEntitySleep()
	self:Stop()
end

function BlowInWind:OnEntityWake()
	self:Start()
end

function BlowInWind:Start()
	if (self.inst.components.inventoryitem and self.inst.components.inventoryitem:IsHeld())
	or not IsInIAClimate(self.inst) then
		return
	end
	self.onwater = IsOnWater(self.inst)
	self.inst:StartUpdatingComponent(self)
end

function BlowInWind:Stop()
	self.velocity = Vector3(0,0,0)
	self.speed = 0.0
	if self.inst:IsValid() then
		self.inst.Physics:Stop()
	end
	self.inst:StopUpdatingComponent(self)
end

function BlowInWind:SetMaxSpeedMult(spd)
	if spd then self.maxSpeedMult = spd end
end

function BlowInWind:SetMinSpeedMult(spd)
	if spd then self.minSpeedMult = spd end
end

function BlowInWind:SetAverageSpeed(spd)
	if spd then self.averageSpeed = spd end
end

function BlowInWind:GetSpeed()
	return self.speed
end

function  BlowInWind:GetVelocity()
	return self.velocity
end

function BlowInWind:GetDebugString()
	return string.format("Vel: %2.2f/%2.2f, Speed: %3.3f/%3.3f", self.velocity.x, self.velocity.z, self.speed, self.maxSpeedMult)
end

--disabled cause that FX is invisible (even in SW) -M
-- function BlowInWind:SpawnWindTrail(dt)
    -- self.timeSinceSpawn = self.timeSinceSpawn + dt
    -- if self.timeSinceSpawn > self.spawnPeriod and math.random() < 0.8 then 
        -- local wake = SpawnPrefab( "windtrail")
        -- local x, y, z = self.inst.Transform:GetWorldPosition()
        -- wake.Transform:SetPosition( x, y, z )
        -- wake.Transform:SetRotation(self.inst.Transform:GetRotation())
        -- self.timeSinceSpawn = 0
    -- end
-- end

function BlowInWind:OnUpdate(dt)
	
	if not self.inst then 
		self:Stop()
		return
	end
	
	if self.inst:HasTag("falling")
	or (self.inst.components.inventoryitem and self.inst.components.inventoryitem.is_landed == false) --R08_ROT_TURNOFTIDES
	-- or self.inst:GetPosition().y > 3 --assume this is a falling item that didn't get its tag set
	or (self.inst.components.inventoryitem and self.inst.components.inventoryitem:IsHeld()) then
		return
	end
	
	if TheWorld.state.hurricane and TheWorld.state.gustspeed > 0 then
		local windspeed = TheWorld.state.gustspeed
		local windangle = TheWorld.state.gustangle * DEGREES
		self.velocity = Vector3(windspeed * math.cos(windangle), 0.0, windspeed * math.sin(windangle))
	elseif self.velocity:Length() > 0 then
		--dumb hack to make sure this item stops
		self.velocity = Vector3(0,0,0)
	else
		return
	end
	
	-- unbait from traps
	if self.inst.components.bait and self.inst.components.bait.trap then
		self.inst.components.bait.trap:RemoveBait()
	end

	if self.velocity:Length() > 1 then self.velocity = self.velocity:GetNormalized() end

	-- Map velocity magnitudes to a useful range of walkspeeds
	local curr_speed = self.averageSpeed
	--[[local player = ThePlayer
	if player and player.components.locomotor then
		curr_speed = (player.components.locomotor:GetRunSpeed() + TUNING.WILSON_WALK_SPEED) / 2
	end]]
	self.speed = Remap(self.velocity:Length(), 0, 1, 0, curr_speed) --maybe only if changing dir??

	-- Do some variation on the speed if velocity is a reasonable amount
	if self.velocity:Length() >= .5 then
		self.speedVarTime = self.speedVarTime + dt
		if self.speedVarTime > SPEED_VAR_PERIOD then 
			self.speedVarTime = 0
			self.speedVarPeriod = GetRandomWithVariance(SPEED_VAR_PERIOD, SPEED_VAR_PERIOD_VARIANCE)
		end
		local speedvar = math.sin(2*PI*(self.speedVarTime / self.speedVarPeriod))
		local mult = Remap(speedvar, -1, 1, self.minSpeedMult, self.maxSpeedMult)
		self.speed = self.speed * mult
	end

	-- Walk!	
	self.inst.Transform:SetRotation( math.atan2(self.velocity.z, self.velocity.x)/DEGREES )

	self.inst.Physics:SetMotorVel(self.speed,0,0)

	-- if self.speed > 3.0 then
		-- self:SpawnWindTrail(dt)
	-- end

	if not self.onwater and IsOnWater(self.inst) then
		self.onwater = true
		if self.inst.components.burnable and self.inst.components.burnable:IsBurning() then
  			self.inst.components.burnable:Extinguish() --Do this before anything that required the inventory item component, it gets removed when something is lit on fire and re-added when it's extinguished 
  		end

		if self.inst.components.inventoryitem then
			--set landed to false then true to force refresh this thing
			--setting poll_for_landing would delay it by a tick
			self.inst.components.inventoryitem:SetLanded(false)
			self.inst.components.inventoryitem:SetLanded(true)
		end

		if self.inst.components.floater ~= nil then
			local vx, vy, vz = self.inst.Physics:GetMotorVel()
			self.inst.Physics:SetMotorVel(0.5 * vx, 0, 0)
			self.inst:DoTaskInTime(1.0, function(inst)
				self.inst.Physics:SetMotorVel(0, 0, 0)
				-- if self.inst.components.inventoryitem then 
					-- self.inst.components.inventoryitem:OnHitWater()
				-- end
			end)
			self.inst:StopUpdatingComponent(self)
		end

	-- elseif not IsOnLand(self.inst) then
	else 
		local tile = TheWorld.Map:GetTileAtPoint(self.inst.Transform:GetWorldPosition())
		if tile == GROUND.VOLCANO_LAVA or tile == GROUND.IMPASSABLE or tile == GROUND.INVALID then
			self.inst:DoTaskInTime(0.5, function(inst)
				self.inst.Physics:SetMotorVel(0, 0, 0)
				if self.inst.components.inventoryitem then
					self.inst.components.inventoryitem:SetLanded(false)
					self.inst.components.inventoryitem:SetLanded(true)
				else
					self.inst:Remove()
				end
			end)
			self.inst:StopUpdatingComponent(self)
		end
	end
end

return BlowInWind
%%+%%scripts/components/boatcontainer.lua%%-%%local containers = require("containers")
local EquipSlot = require("equipslotutil")

local function onenableboatequipslots(self, enableboatequipslots)
    self.inst.replica.container._enableboatequipslots:set(enableboatequipslots)
end

local function oncanbeopened(self, canbeopened)
    self.inst.replica.container:SetCanBeOpened(canbeopened)
end

local function onopener(self, opener)
    self.inst.replica.container:SetOpener(opener)
end

local BoatContainer = Class(function(self, inst)
    self.inst = inst
    self.slots = {}
    self.boatequipslots = {}
    self.hasboatequipslots = false
    self.enableboatequipslots = true
    self.numslots = 0
    self.canbeopened = true
    self.acceptsstacks = true
    self.issidewidget = false
    self.type = nil
    self.widget = nil
    self.itemtestfn = nil
    self.opener = nil

    --Hacky flags for altering behaviour when moving items between containers
    self.ignoresound = false

    inst:AddTag("boatcontainer")
end,
nil,
{
    canbeopened = oncanbeopened,
    opener = onopener,
    enableboatequipslots = onenableboatequipslots
})

local widgetprops =
{
    "numslots",
    "acceptsstacks",
    "issidewidget",
    "type",
    "widget",
    "itemtestfn",
}

function BoatContainer:WidgetSetup(prefab, data)
    for i, v in ipairs(widgetprops) do
        removesetter(self, v)
    end

    containers.widgetsetup(self, prefab, data)
    self.inst.replica.container:WidgetSetup(prefab, data)

    for i, v in ipairs(widgetprops) do
        makereadonly(self, v)
    end
end

function BoatContainer:GetWidget()
    --UNUSED
    return self.widget
end

function BoatContainer:NumItems()
    local num = 0
    for k,v in pairs(self.slots) do
        num = num + 1
    end

    return num
end

function BoatContainer:IsFull()
    local items = 0
    for k, v in pairs(self.slots) do
        items = items + 1
    end

    return items >= self.numslots
end

function BoatContainer:IsEmpty()
    return next(self.slots) == nil
end

function BoatContainer:SetNumSlots(numslots)
    assert(numslots >= self.numslots)
    self.numslots = numslots
end

function BoatContainer:DropItemBySlot(slot)
    local item = self:RemoveItemBySlot(slot)
    if item ~= nil then
        item.Transform:SetPosition(self.inst.Transform:GetWorldPosition())
        if item.components.inventoryitem ~= nil then
            item.components.inventoryitem:OnDropped(true)
        end
        item.prevcontainer = nil
        item.prevslot = nil
        self.inst:PushEvent("dropitem", { item = item })
    end
end

function BoatContainer:DropBoatEquipBySlot(slot)
    local item = self:Unequip(slot)
    if item ~= nil then
        item.Transform:SetPosition(self.inst.Transform:GetWorldPosition())
        if item.components.inventoryitem ~= nil then
            item.components.inventoryitem:OnDropped(true)
        end
        item.prevcontainer = nil
        item.prevslot = nil
        self.inst:PushEvent("dropitem", { item = item })
    end
end

function BoatContainer:DropEverythingWithTag(tag)
    local containers = {}

    for i = 1, self.numslots do
        local item = self.slots[i]
        if item ~= nil then
            if item:HasTag(tag) then
                self:DropItemBySlot(i)
            elseif item.components.container ~= nil then
                table.insert(containers, item)
            end
        end
    end
    if self.hasboatequipslots then 
         for k,v in pairs(self.boatequipslots) do
            local item = v
            if item:HasTag(tag) then
                self:DropBoatEquipBySlot(k)
            elseif item.components.container ~= nil then
                table.insert(containers, item)
            end
        end    
    end 

    for i, v in ipairs(containers) do
        v.components.container:DropEverythingWithTag(tag)
    end
end

function BoatContainer:DropEverything()
    for i = 1, self.numslots do
        self:DropItemBySlot(i)
    end
    if self.hasboatequipslots then 
         for k,v in pairs(self.boatequipslots) do
            self:DropBoatEquipBySlot(k)
        end    
    end 
end

function BoatContainer:DropItem(itemtodrop)
    local item = self:RemoveItem(itemtodrop)
    if item then 
        local pos = Vector3(self.inst.Transform:GetWorldPosition())
        item.Transform:SetPosition(pos:Get())
        if item.components.inventoryitem then
            item.components.inventoryitem:OnDropped(true)
        end
        item.prevcontainer = nil
        item.prevslot = nil
        self.inst:PushEvent("dropitem", {item = item})
    end
end

function BoatContainer:CanTakeItemInSlot(item, slot)
    return item ~= nil
        and item.components.inventoryitem ~= nil
        and item.components.inventoryitem.cangoincontainer
        and not item.components.inventoryitem.canonlygoinpocket
        and (slot == nil or (slot >= 1 and slot <= self.numslots))
        and not (GetGameModeProperty("non_item_equips") and item.components.equippable ~= nil)
        and (self.itemtestfn == nil or self:itemtestfn(item, slot))
end

function BoatContainer:AcceptsStacks()
    return self.acceptsstacks
end

function BoatContainer:IsSideWidget()
    return self.issidewidget
end

function BoatContainer:DestroyContents()
    for k = 1, self.numslots do
        local item = self:RemoveItemBySlot(k)
        if item ~= nil then
            item:Remove()
        end
    end
end

function BoatContainer:GiveItem(item, slot, src_pos, drop_on_fail)

    local eslot = self:IsItemBoatEquipped(item)

    if eslot then
       self:Unequip(eslot)
    end

    if item == nil then
        return false
    elseif item.components.inventoryitem ~= nil and self:CanTakeItemInSlot(item, slot) then
        --try to burn off stacks if we're just dumping it in there
        if item.components.stackable ~= nil and self.acceptsstacks then
            --Added this for when we want to dump a stack back into a
            --specific spot (e.g. moving half a stack failed, so we
            --need to dump the leftovers back into the original stack)
            if slot ~= nil and slot <= self.numslots then
                local other_item = self.slots[slot]
                if other_item ~= nil and (other_item.prefab == item.prefab and other_item.skinname == item.skinname) and not other_item.components.stackable:IsFull() then
                    if self.inst.components.inventoryitem ~= nil and self.inst.components.inventoryitem.owner ~= nil then
                        self.inst.components.inventoryitem.owner:PushEvent("gotnewitem", { item = item, slot = slot })
                    end

                    item = other_item.components.stackable:Put(item, src_pos)
                    if item == nil then
                        return true
                    end

                    slot = nil
                end
            end

            if slot == nil then
                for k = 1, self.numslots do
                    local other_item = self.slots[k]
                    if other_item and (other_item.prefab == item.prefab and other_item.skinname == item.skinname) and not other_item.components.stackable:IsFull() then
                        if self.inst.components.inventoryitem ~= nil and self.inst.components.inventoryitem.owner ~= nil then
                            self.inst.components.inventoryitem.owner:PushEvent("gotnewitem", { item = item, slot = k })
                        end

                        item = other_item.components.stackable:Put(item, src_pos)
                        if item == nil then
                            return true
                        end
                    end
                end
            end
        end

        local use_slot = slot and slot <= self.numslots and not self.slots[slot]
        local in_slot = nil
        if use_slot then
            in_slot = slot
        elseif self.numslots > 0 then
            for k = 1,self.numslots do
                if not self.slots[k] then
                    in_slot = k
                    break
                end
            end
        end

        if in_slot then
            --weird case where we are trying to force a stack into a non-stacking container. this should probably have been handled earlier, but this is a failsafe        
            if not self.acceptsstacks and item.components.stackable and item.components.stackable:StackSize() > 1 then
                item = item.components.stackable:Get()
                self.slots[in_slot] = item
                item.components.inventoryitem:OnPutInInventory(self.inst)
                self.inst:PushEvent("itemget", { slot = in_slot, item = item, src_pos = src_pos })
                return false
            end

            self.slots[in_slot] = item
            item.components.inventoryitem:OnPutInInventory(self.inst)
            self.inst:PushEvent("itemget", { slot = in_slot, item = item, src_pos = src_pos })

            if not self.ignoresound and self.inst.components.inventoryitem ~= nil and self.inst.components.inventoryitem.owner ~= nil then
                self.inst.components.inventoryitem.owner:PushEvent("gotnewitem", { item = item, slot = in_slot })
            end

            return true
        end
    end

    --default to true if nil
    if drop_on_fail ~= false then
        item.Transform:SetPosition(self.inst.Transform:GetWorldPosition())
        if item.components.inventoryitem ~= nil then
            item.components.inventoryitem:OnDropped(true)
        end
    end
    return false
end

function BoatContainer:RemoveItemBySlot(slot)
    if slot and self.slots[slot] then
        local item = self.slots[slot]
        if item then
            self.slots[slot] = nil
            if item.components.inventoryitem then
                item.components.inventoryitem:OnRemoved()
            end

            self.inst:PushEvent("itemlose", {slot = slot})
        end
        item.prevcontainer = self
        item.prevslot = slot
        return item
    end
end

function BoatContainer:GetNumSlots()
    return self.numslots
end

function BoatContainer:GetItemInSlot(slot)
    if slot and self.slots[slot] then
        return self.slots[slot]
    end
end

function BoatContainer:GetItemInBoatSlot(slot)
    if slot and self.boatequipslots[slot] then 
        return self.boatequipslots[slot]
    end 
end 

function BoatContainer:GetItemSlot(item)
    for k,v in pairs(self.slots) do
        if item == v then
            return k
        end
    end
end

function BoatContainer:Open(doer)
    if self.opener == nil and doer ~= nil then
        self.inst:StartUpdatingComponent(self)

        local inventory = doer.components.inventory
        if inventory ~= nil then
            for k, v in pairs(inventory.opencontainers) do
                if k.prefab == self.inst.prefab or k.components.container.type == self.type then
                    k.components.container:Close()
                end
            end

            inventory.opencontainers[self.inst] = true
        end

        self.opener = doer

        if doer.HUD ~= nil then
            if self.type == "boat" then
                doer.HUD:OpenBoat(self.inst, self.inst.entity:GetParent() == doer)
            else
                doer.HUD:OpenContainer(self.inst, self:IsSideWidget())
            end
            if self:IsSideWidget() then
                TheFocalPoint.SoundEmitter:PlaySound("dontstarve/wilson/backpack_open")
            end
        elseif self.widget ~= nil
            and self.widget.buttoninfo ~= nil
            and doer.components.playeractionpicker ~= nil then
            doer.components.playeractionpicker:RegisterContainer(self.inst)
        end

        self.inst:PushEvent("onopen", {doer = doer})

        if self.onopenfn ~= nil then
            self.onopenfn(self.inst, {doer = doer})
        end
    end
end

function BoatContainer:Close(forceclose)
    if self.opener ~= nil and not (self.inst.components.sailable and self.inst.components.sailable.sailor == self.opener and not forceclose) then
        self.inst:StopUpdatingComponent(self)

        local doer = self.opener
        self.opener = nil

        if doer.HUD ~= nil then
            doer.HUD:CloseContainer(self.inst, self:IsSideWidget())
            if self:IsSideWidget() then
                TheFocalPoint.SoundEmitter:PlaySound("dontstarve/wilson/backpack_close")
            end
        elseif doer.components.playeractionpicker ~= nil then
            doer.components.playeractionpicker:UnregisterContainer(self.inst)
        end

        if doer.components.inventory ~= nil then
            doer.components.inventory.opencontainers[self.inst] = nil
        end

        if self.onclosefn ~= nil then
            self.onclosefn(self.inst, doer)
        end

        self.inst:PushEvent("onclose", { doer = doer })
    end
end

function BoatContainer:IsOpen()
    return self.opener ~= nil
end

function BoatContainer:IsOpenedBy(guy)
    return self.opener == guy
end

local function CheckItem(item, target, checkcontainer)
    return target ~= nil
        and (item == target
            or (checkcontainer and
                target.replica.container ~= nil and
                target.replica.container:IsHolding(item, checkcontainer)))
end

function BoatContainer:IsHolding(item, checkcontainer)
    for k, v in pairs(self.slots) do
        if CheckItem(item, v, checkcontainer) then
            return true
        end
    end
end

function BoatContainer:FindItem(fn)
    for k,v in pairs(self.slots) do
        if fn(v) then
            return v
        end
    end
end

function BoatContainer:FindItems(fn)
    local items = {}

    for k,v in pairs(self.slots) do
        if fn(v) then
            table.insert(items, v)
        end
    end

    return items
end

function BoatContainer:Has(item, amount)
    local num_found = 0
    for k,v in pairs(self.slots) do
        if v and v.prefab == item then
            if v.components.stackable ~= nil then
                num_found = num_found + v.components.stackable:StackSize()
            else
                num_found = num_found + 1
            end
        end
    end

    return num_found >= amount, num_found
end

function BoatContainer:GetItemByName(item, amount)
    local total_num_found = 0
    local items = {}

    local function tryfind(v)
        local num_found = 0
        if v and v.prefab == item then
            local num_left_to_find = amount - total_num_found
            if v.components.stackable then
                if v.components.stackable.stacksize > num_left_to_find then
                    items[v] = num_left_to_find
                    num_found = amount
                else
                    items[v] = v.components.stackable.stacksize
                    num_found = num_found + v.components.stackable.stacksize
                end
            else
                items[v] = 1
                num_found = num_found + 1
            end
        end
        return num_found
    end

    for k,v in pairs(self.slots) do
        total_num_found = total_num_found + tryfind(v)
        
        if total_num_found >= amount then
            break
        end
    end

    return items
end

local function tryconsume(self, v, amount)
    if v.components.stackable == nil then
        self:RemoveItem(v):Remove()
        return 1
    elseif v.components.stackable.stacksize > amount then
        v.components.stackable:SetStackSize(v.components.stackable.stacksize - amount)
        return amount
    else
        amount = v.components.stackable.stacksize
        self:RemoveItem(v, true):Remove()
        return amount
    end
    --shouldn't be possible?
    return 0
end

function BoatContainer:ConsumeByName(item, amount)
    if amount <= 0 then
        return
    end

    for k, v in pairs(self.slots) do
        if v.prefab == item then
            amount = amount - tryconsume(self, v, amount)
            if amount <= 0 then
                return
            end
        end
    end
end

function BoatContainer:OnSave()
    local data = {items= {}, boatequipitems = {}}
    local references = {}
    local refs = {}
    for k,v in pairs(self.slots) do
        if v:IsValid() and v.persists then --only save the valid items
            data.items[k], refs = v:GetSaveRecord()
            if refs then
                for k,v in pairs(refs) do
                    table.insert(references, v)
                end
            end
        end
    end
    for k,v in pairs(self.boatequipslots) do
        if v:IsValid() and v.persists then --only save the valid items
            data.boatequipitems[k], refs = v:GetSaveRecord()
            if refs then
                for k,v in pairs(refs) do
                    table.insert(references, v)
                end
            end
        end
    end
    return data, references
end

function BoatContainer:OnLoad(data, newents)
    if data.items then
        for k,v in pairs(data.items) do
            local inst = SpawnSaveRecord(v, newents)
            if inst then
                self:GiveItem(inst, k)
            end
        end
    end
    if data.boatequipitems then
        for k,v in pairs(data.boatequipitems) do
            local inst = SpawnSaveRecord(v, newents)
            if inst then
                self:Equip(inst, false)
            end
        end
    end
end

function BoatContainer:Equip(item, old_to_active)
    if not item or not item.components.equippable or not item:IsValid() then
        return
    end

    local inventory = self.opener ~= nil and self.opener.components.inventory or nil

    item.prevslot = inventory and inventory:GetItemSlot(item) or nil

    if item.prevslot == nil and
        item.components.inventoryitem.owner ~= nil and
        item.components.inventoryitem.owner.components.container ~= nil and
        item.components.inventoryitem.owner.components.inventoryitem ~= nil then
        item.prevcontainer = item.components.inventoryitem.owner.components.container
        item.prevslot = item.components.inventoryitem.owner.components.container:GetItemSlot(item)
    else
        item.prevcontainer = nil
    end

    local leftovers = nil
    if item.components.inventoryitem == nil then
        item = self:RemoveItem(item, item.components.equippable.equipstack) or item
    elseif item.components.inventoryitem:IsHeld() then
        item = item.components.inventoryitem:RemoveFromOwner(item.components.equippable.equipstack) or item
    elseif item.components.stackable ~= nil and item.components.stackable:IsStack() and not item.components.equippable.equipstack then
        leftovers = item
        item = item.components.stackable:Get()
    end

    if inventory and item == inventory.activeitem then
        leftovers = inventory.activeitem
        inventory:SetActiveItem(nil)
    end

    local eslot = item.components.equippable.boatequipslot
    if self.boatequipslots[eslot] ~= item then
        local olditem = self.boatequipslots[eslot]
        if leftovers ~= nil then
            if old_to_active then
                inventory:GiveActiveItem(leftovers)
            else
                inventory.silentfull = true
                inventory:GiveItem(leftovers)
                inventory.silentfull = false
            end
        end
        if olditem then
            self:Unequip(eslot)
            olditem.components.equippable:ToPocket()
            if olditem.components.inventoryitem and not olditem.components.inventoryitem.cangoincontainer and not inventory.ignorescangoincontainer then
                olditem.components.inventoryitem:OnRemoved()
                self:DropItem(olditem)
            elseif old_to_active then
                inventory:GiveActiveItem(olditem)
            else
                inventory.silentfull = true
                inventory:GiveItem(olditem)
                inventory.silentfull = false
            end  
        end
        
        item.components.inventoryitem:OnPutInInventory(self.inst)
        item.components.equippable:Equip(self.inst)
        self.boatequipslots[eslot] = item
        self.inst:PushEvent("equip", {item=item, eslot=eslot})
        return true
    end
end

function BoatContainer:Unequip(equipslot)
    local item = self.boatequipslots[equipslot]
     if item and item.components.equippable then
        item.components.equippable:Unequip(self.inst)
    end
    self.boatequipslots[equipslot] = nil
    self.inst:PushEvent("unequip", {item=item, eslot=equipslot})
    return item
end 


function BoatContainer:RemoveItem(item, wholestack)
    if item == nil then
        return
    end

    local prevslot = self:GetItemSlot(item)

    if not wholestack and item.components.stackable ~= nil and item.components.stackable:IsStack() then
        local dec = item.components.stackable:Get()
        dec.prevslot = prevslot
        dec.prevcontainer = self
        return dec
    end

    for k, v in pairs(self.slots) do
        if v == item then
            self.slots[k] = nil
            self.inst:PushEvent("itemlose", { slot = k })
            item.components.inventoryitem:OnRemoved()
            item.prevslot = prevslot
            item.prevcontainer = self
            return item
        end
    end

    local inventory = self.opener ~= nil and self.opener.components.inventory or nil

    if inventory and item == inventory.activeitem then
        inventory:SetActiveItem()
        inventory.inst:PushEvent("itemlose", { activeitem = true })
        item.components.inventoryitem:OnRemoved()
        item.prevslot = prevslot
        item.prevcontainer = self
        return item
    end

    for k, v in pairs(self.boatequipslots) do
        if v == item then
            self:Unequip(k)
            item.components.inventoryitem:OnRemoved()
            item.prevslot = prevslot
            item.prevcontainer = nil
            return item
        end
    end

    return item
end

--------------------------------------------------------------------------
--Check for auto-closing conditions
--------------------------------------------------------------------------

function BoatContainer:OnUpdate(dt)
    if self.opener == nil then
        self.inst:StopUpdatingComponent(self)
    elseif not (self.inst.components.inventoryitem ~= nil and
                self.inst.components.inventoryitem:IsHeldBy(self.opener))
        and ((self.opener.components.rider ~= nil and self.opener.components.rider:IsRiding())
            or not (self.opener:IsNear(self.inst, 3) and
                    CanEntitySeeTarget(self.opener, self.inst))) then
        self:Close()
    end
end

BoatContainer.OnRemoveEntity = BoatContainer.Close
BoatContainer.OnRemoveFromEntity = BoatContainer.Close


--------------------------------------------------------------------------
--InvSlot click action handlers
--------------------------------------------------------------------------

local function QueryActiveItem(self)
    local inventory = self.opener ~= nil and self.opener.components.inventory or nil
    return inventory, inventory ~= nil and inventory:GetActiveItem() or nil
end

function BoatContainer:PutOneOfActiveItemInSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    if active_item ~= nil and
        self:GetItemInSlot(slot) == nil and
        self:CanTakeItemInSlot(active_item, slot) and
        active_item.components.stackable ~= nil and
        active_item.components.stackable:IsStack() then

        self.ignoresound = true
        self:GiveItem(active_item.components.stackable:Get(1), slot)
        self.ignoresound = false
    end
end

function BoatContainer:PutAllOfActiveItemInSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    if active_item ~= nil and
        self:GetItemInSlot(slot) == nil and
        self:CanTakeItemInSlot(active_item, slot) and
        (self:AcceptsStacks() or
        active_item.components.stackable == nil or
        not active_item.components.stackable:IsStack()) then

        inventory:RemoveItem(active_item, true)
        self.ignoresound = true
        self:GiveItem(active_item, slot)
        self.ignoresound = false
    end
end

function BoatContainer:TakeActiveItemFromHalfOfSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    local item = self:GetItemInSlot(slot)
    if item ~= nil and
        active_item == nil and
        inventory ~= nil and
        item.components.stackable ~= nil and
        item.components.stackable:IsStack() then

        local halfstack = item.components.stackable:Get(math.floor(item.components.stackable:StackSize() / 2))
        halfstack.prevslot = slot
        halfstack.prevcontainer = self
        inventory:GiveActiveItem(halfstack)
    end
end

function BoatContainer:TakeActiveItemFromAllOfSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    local item = self:GetItemInSlot(slot)
    if item ~= nil and
        active_item == nil and
        inventory ~= nil then

        self:RemoveItemBySlot(slot)
        inventory:GiveActiveItem(item)
    end
end

function BoatContainer:AddOneOfActiveItemToSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    local item = self:GetItemInSlot(slot)
    if active_item ~= nil and
        item ~= nil and
        self:CanTakeItemInSlot(active_item, slot) and
        (item.prefab == active_item.prefab and item.skinname == active_item.skinname) and
        item.components.stackable ~= nil and
        self:AcceptsStacks() and
        active_item.components.stackable ~= nil and
        active_item.components.stackable:IsStack() and
        not item.components.stackable:IsFull() then

        item.components.stackable:Put(active_item.components.stackable:Get(1))
    end
end

function BoatContainer:AddAllOfActiveItemToSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    local item = self:GetItemInSlot(slot)
    if active_item ~= nil and
        item ~= nil and
        self:CanTakeItemInSlot(active_item, slot) and
        (item.prefab == active_item.prefab and item.skinname == active_item.skinname) and
        item.components.stackable ~= nil and
        self:AcceptsStacks() then

        local leftovers = item.components.stackable:Put(active_item)
        inventory:SetActiveItem(leftovers)
    end
end

function BoatContainer:SwapActiveItemWithSlot(slot)
    local inventory, active_item = QueryActiveItem(self)
    local item = self:GetItemInSlot(slot)
    if active_item ~= nil and
        item ~= nil and
        self:CanTakeItemInSlot(active_item, slot) and
        not ((item.prefab == active_item.prefab and item.skinname == active_item.skinname) and
            item.components.stackable ~= nil and
            self:AcceptsStacks()) and
        not (active_item.components.stackable ~= nil and
            active_item.components.stackable:IsStack() and
            not self:AcceptsStacks()) then

        inventory:RemoveItem(active_item, true)
        self:RemoveItemBySlot(slot)
        inventory:GiveActiveItem(item)
        self:GiveItem(active_item, slot)
    end
end

function BoatContainer:BoatEquipActiveItem()
    local inventory, active_item = QueryActiveItem(self)
    if active_item ~= nil and
        active_item.components.equippable ~= nil and
        self:GetItemInBoatSlot(active_item.components.equippable.boatequipslot) == nil then

        self:Equip(active_item, true)
    end
end

function BoatContainer:SwapBoatEquipWithActiveItem()
    local inventory, active_item = QueryActiveItem(self)
    if active_item ~= nil and
        active_item.components.equippable ~= nil and
        self:GetItemInBoatSlot(active_item.components.equippable.boatequipslot) ~= nil then

        self:Equip(active_item, true)
    end
end

function BoatContainer:IsItemBoatEquipped(item)
    for k, v in pairs(self.boatequipslots) do
        if v == item then
            return k
        end
    end
end

function BoatContainer:TakeActiveItemFromBoatEquipSlot(eslot)
    local item = self:GetItemInBoatSlot(eslot)
    local inventory, active_item = QueryActiveItem(self)
    if item ~= nil and active_item == nil then
        if inventory.maxslots > 0 then
            if self.boatequipslots[eslot] then
                local olditem = active_item
                local newitem = self:Unequip(eslot)
                inventory:SetActiveItem(newitem)

                if olditem and not self:IsItemBoatEquipped(olditem) then
                    inventory:GiveItem(olditem)
                end
            end
        else
            self:DropItem(self:Unequip(eslot), true, true)
        end
    end
end

function BoatContainer:TakeActiveItemFromBoatEquipSlotID(eslotid)
    self:TakeActiveItemFromBoatEquipSlot(EquipSlot.BoatFromID(eslotid))
end

function BoatContainer:MoveItemFromAllOfSlot(slot, container)
    local item = self:GetItemInSlot(slot)
    if item ~= nil and container ~= nil then
        container = container.components.container or container.components.inventory
        if container ~= nil and container:IsOpenedBy(self.opener) then
            local targetslot =
                self.opener.components.constructionbuilderuidata ~= nil and
                self.opener.components.constructionbuilderuidata:GetContainer() == container.inst and
                self.opener.components.constructionbuilderuidata:GetSlotForIngredient(item.prefab) or
                nil

            if container:CanTakeItemInSlot(item, targetslot) then
                item = self:RemoveItemBySlot(slot)
                item.prevcontainer = nil
                item.prevslot = nil

                --Hacks for altering normal inventory:GiveItem() behaviour
                if container.ignoreoverflow ~= nil and container:GetOverflowContainer() == self then
                    container.ignoreoverflow = true
                end
                if container.ignorefull ~= nil then
                    container.ignorefull = true
                end

                if not container:GiveItem(item, targetslot) then
                    self:GiveItem(item, slot, nil, true)
                end

                --Hacks for altering normal inventory:GiveItem() behaviour
                if container.ignoreoverflow then
                    container.ignoreoverflow = false
                end
                if container.ignorefull then
                    container.ignorefull = false
                end
            end
        end
    end
end

function BoatContainer:MoveItemFromHalfOfSlot(slot, container)
    local item = self:GetItemInSlot(slot)
    if item ~= nil and container ~= nil then
        container = container.components.container or container.components.inventory
        if container ~= nil and
            container:IsOpenedBy(self.opener) and
            item.components.stackable ~= nil and
            item.components.stackable:IsStack() then

            local targetslot =
                self.opener.components.constructionbuilderuidata ~= nil and
                self.opener.components.constructionbuilderuidata:GetContainer() == container.inst and
                self.opener.components.constructionbuilderuidata:GetSlotForIngredient(item.prefab) or
                nil

            if container:CanTakeItemInSlot(item, targetslot) then
                local halfstack = item.components.stackable:Get(math.floor(item.components.stackable:StackSize() / 2))
                halfstack.prevcontainer = nil
                halfstack.prevslot = nil

                --Hacks for altering normal inventory:GiveItem() behaviour
                if container.ignoreoverflow ~= nil and container:GetOverflowContainer() == self then
                    container.ignoreoverflow = true
                end
                if container.ignorefull ~= nil then
                    container.ignorefull = true
                end

                if not container:GiveItem(halfstack, targetslot) then
                    self.ignoresound = true
                    self:GiveItem(halfstack, slot, nil, true)
                    self.ignoresound = false
                end

                --Hacks for altering normal inventory:GiveItem() behaviour
                if container.ignoreoverflow then
                    container.ignoreoverflow = false
                end
                if container.ignorefull then
                    container.ignorefull = false
                end
            end
        end
    end
end

function BoatContainer:ReferenceAllItems()
    local items = {}
    for i=1,self.numslots do
        if self.slots[i] ~= nil then
            table.insert(items, self.slots[i])
        end
    end
    return items
end

return BoatContainer
%%+%%scripts/components/boatcontainer_replica.lua%%-%%local containers = require("containers")

local BoatContainer = Class(function(self, inst)
    self.inst = inst

    self._cannotbeopened = net_bool(inst.GUID, "boatcontainer._cannotbeopened")
    self._enableboatequipslots = net_bool(inst.GUID, "boatcontainer._enableboatequipslots")
    self._isopen = false
    self._numslots = 0
    self.hasboatequipslots = false
    self.acceptsstacks = true
    self.issidewidget = false
    self.type = nil
    self.widget = nil
    self.itemtestfn = nil
    self.opentask = nil

    if TheWorld.ismastersim then
        self.classified = SpawnPrefab("boatcontainer_classified")
        self.classified.entity:SetParent(inst.entity)

        --Server intercepts messages and forwards to clients via classified net vars
        self._onitemget = function(inst, data)
            self.classified:SetSlotItem(data.slot, data.item, data.src_pos)
            if self.issidewidget and
                inst.components.inventoryitem.owner ~= nil and
                inst.components.inventoryitem.owner.HUD ~= nil then
                inst.components.inventoryitem.owner:PushEvent("refreshcrafting")
            end
        end
        self._onitemlose = function(inst, data)
            self.classified:SetSlotItem(data.slot)
            if self.issidewidget and
                inst.components.inventoryitem.owner ~= nil and
                inst.components.inventoryitem.owner.HUD ~= nil then
                inst.components.inventoryitem.owner:PushEvent("refreshcrafting")
            end
        end
        inst:ListenForEvent("itemget", self._onitemget)
        inst:ListenForEvent("itemlose", self._onitemlose)
        inst:ListenForEvent("equip", function(inst, data) self.classified:SetSlotBoatEquip(data.eslot, data.item) end)
        inst:ListenForEvent("unequip", function(inst, data) self.classified:SetSlotBoatEquip(data.eslot) end)
    else
        containers.widgetsetup(self)

        if self.classified == nil and inst.boatcontainer_classified ~= nil then
            self.classified = inst.boatcontainer_classified
            inst.boatcontainer_classified.OnRemoveEntity = nil
            inst.boatcontainer_classified = nil
            self:AttachClassified(self.classified)
        end
    end
end)

--------------------------------------------------------------------------

function BoatContainer:OnRemoveFromEntity()
    if self.classified ~= nil then
        if TheWorld.ismastersim then
            self.classified:Remove()
            self.classified = nil
            self.inst:RemoveEventCallback("itemget", self._onitemget)
            self.inst:RemoveEventCallback("itemlose", self._onitemlose)
            if self._onputininventory ~= nil then
                self.inst:RemoveEventCallback("onputininventory", self._onputininventory)
                self.inst:RemoveEventCallback("ondropped", self._ondropped)
                self._onputininventory = nil
                self._ondropped = nil
                self._owner = nil
            end
        else
            self.classified._parent = nil
            self.inst:RemoveEventCallback("onremove", self.ondetachclassified, self.classified)
            self:DetachClassified()
        end
    end
end

BoatContainer.OnRemoveEntity = BoatContainer.OnRemoveFromEntity

--------------------------------------------------------------------------
--Client triggers open/close based on receiving access to classified data
--------------------------------------------------------------------------

local function OnRefreshCrafting(inst)
    if TheLocalPlayer ~= nil and TheLocalPlayer.HUD ~= nil then
        TheLocalPlayer:PushEvent("refreshcrafting")
    end
end

local function OpenContainer(inst, self, snap)
    self.opentask = nil

    --V2C: don't animate to and from the backpack position 
    --     when re-opening inventory as Werebeaver->Woodie
    local inv = snap and TheLocalPlayer ~= nil and TheLocalPlayer.HUD ~= nil and TheLocalPlayer.HUD.controls.inv or nil
    snap = inv ~= nil and not inv.rebuild_pending

    self:Open(TheLocalPlayer)
    OnRefreshCrafting(inst)

    if snap and inv.rebuild_pending then
        inv.rebuild_snapping = true
    end
end

function BoatContainer:AttachClassified(classified)
    self.classified = classified

    self.ondetachclassified = function() self:DetachClassified() end
    self.inst:ListenForEvent("onremove", self.ondetachclassified, classified)

    classified:InitializeSlots(self:GetNumSlots())

    local inv = self.issidewidget and TheLocalPlayer ~= nil and TheLocalPlayer.HUD ~= nil and TheLocalPlayer.HUD.controls.inv or nil
    self.opentask = self.inst:DoTaskInTime(0, OpenContainer, self, inv ~= nil and (not inv.shown or inv.rebuild_snapping))

    if self.issidewidget then
        self.inst:ListenForEvent("itemget", OnRefreshCrafting)
        self.inst:ListenForEvent("itemlose", OnRefreshCrafting)
    end
end

function BoatContainer:DetachClassified()
    self.classified = nil
    self.ondetachclassified = nil
    if self.issidewidget then
        self.inst:RemoveEventCallback("itemget", OnRefreshCrafting)
        self.inst:RemoveEventCallback("itemlose", OnRefreshCrafting)
        OnRefreshCrafting(self.inst)
    end
    self:Close()
end

--------------------------------------------------------------------------
--Server initialization requires param since prefab property is not set yet
--------------------------------------------------------------------------

function BoatContainer:WidgetSetup(prefab, data)
    containers.widgetsetup(self, prefab, data)
    if self.classified ~= nil then
        self.classified:InitializeSlots(self:GetNumSlots())
    end
    if self.issidewidget then
        if self._onputininventory == nil then
            self._owner = nil
            self._ondropped = function(inst)
                if self._owner ~= nil then
                    local owner = self._owner
                    self._owner = nil
                    if owner.HUD ~= nil then
                        owner:PushEvent("refreshcrafting")
                    end
                end
            end
            self._onputininventory = function(inst, owner)
                self._ondropped(inst)
                self._owner = owner
                if owner ~= nil and owner.HUD ~= nil then
                    owner:PushEvent("refreshcrafting")
                end
            end
            self.inst:ListenForEvent("onputininventory", self._onputininventory)
            self.inst:ListenForEvent("ondropped", self._ondropped)
        end
    end
end

--------------------------------------------------------------------------
--Common interface
--------------------------------------------------------------------------

function BoatContainer:GetWidget(boatwidget)
    if not boatwidget then
        return self.widget
    else
        return self.inspectwidget
    end
end

function BoatContainer:SetNumSlots(numslots)
    self._numslots = numslots
end

function BoatContainer:GetNumSlots()
    return self._numslots
end

function BoatContainer:SetCanBeOpened(canbeopened)
    self._cannotbeopened:set(not canbeopened)
end

function BoatContainer:CanBeOpened()
    return not self._cannotbeopened:value()
end

function BoatContainer:CanTakeItemInSlot(item, slot)
    return item ~= nil
        and item.replica.inventoryitem ~= nil
        and item.replica.inventoryitem:CanGoInContainer()
        and not item.replica.inventoryitem:CanOnlyGoInPocket()
        and not (GetGameModeProperty("non_item_equips") and item.replica.equippable ~= nil)
        and (self.itemtestfn == nil or self:itemtestfn(item, slot))
end

function BoatContainer:AcceptsStacks()
    return self.acceptsstacks
end

function BoatContainer:IsSideWidget()
    return self.issidewidget
end

function BoatContainer:SetOpener(opener)
    self.classified.Network:SetClassifiedTarget(opener or self.inst)
    if self.inst.components.container ~= nil then
        for k, v in pairs(self.inst.components.container.slots) do
            v.replica.inventoryitem:SetOwner(self.inst)
        end
        for k, v in pairs(self.inst.components.container.boatequipslots) do
            v.replica.inventoryitem:SetOwner(self.inst)
        end
    else
        --Should only reach here during container construction
        assert(opener == nil)
    end
end

function BoatContainer:IsOpenedBy(guy)
    if self.inst.components.container ~= nil then
        return self.inst.components.container:IsOpenedBy(guy)
    else
        return self._isopen and self.classified ~= nil and guy ~= nil and guy == TheLocalPlayer
    end
end

function BoatContainer:IsHolding(item, checkcontainer)
    if self.inst.components.container ~= nil then
        return self.inst.components.container:IsHolding(item, checkcontainer)
    else
        return self.classified ~= nil and self.classified:IsHolding(item, checkcontainer)
    end
end

function BoatContainer:GetItemInSlot(slot)
    if self.inst.components.container ~= nil then
        return self.inst.components.container:GetItemInSlot(slot)
    else
        return self.classified ~= nil and self.classified:GetItemInSlot(slot) or nil
    end
end

function BoatContainer:GetItemInBoatSlot(slot)
    if self.inst.components.container ~= nil then
        return self.inst.components.container:GetItemInBoatSlot(slot)
    else
        return self.classified ~= nil and self.classified:GetItemInBoatSlot(slot) or nil
    end
end

function BoatContainer:GetItems()
    if self.inst.components.container ~= nil then
        return self.inst.components.container.slots
    else
        return self.classified ~= nil and self.classified:GetItems() or {}
    end
end

function BoatContainer:GetBoatEquips()
    if self.inst.components.container ~= nil then
        return self.inst.components.container.boatequipslots
    else
        return self.classified ~= nil and self.classified:GetBoatEquips() or {}
    end
end

function BoatContainer:IsEmpty()
    if self.inst.components.container ~= nil then
        return self.inst.components.container:IsEmpty()
    else
        return self.classified ~= nil and self.classified:IsEmpty()
    end
end

function BoatContainer:IsFull()
    if self.inst.components.container ~= nil then
        return self.inst.components.container:IsFull()
    else
        return self.classified ~= nil and self.classified:IsFull()
    end
end

function BoatContainer:Has(prefab, amount)
    if self.inst.components.container ~= nil then
        return self.inst.components.container:Has(prefab, amount)
    elseif self.classified ~= nil then
        return self.classified:Has(prefab, amount)
    else
        return amount <= 0, 0
    end
end

function BoatContainer:Open(doer)
    if self.inst.components.container ~= nil then
        if self.opentask ~= nil then
            self.opentask:Cancel()
            self.opentask = nil
        end
        self.inst.components.container:Open(doer)
    elseif self.classified ~= nil and
        self.opentask == nil and
        doer ~= nil and
        doer == TheLocalPlayer then
        if doer.HUD == nil then
            self._isopen = false
        elseif not self._isopen then
            if self.type == "boat" then
                doer.HUD:OpenBoat(self.inst, self.inst.entity:GetParent() == doer)
            else
                doer.HUD:OpenContainer(self.inst, self:IsSideWidget())
            end
            if self:IsSideWidget() then
                TheFocalPoint.SoundEmitter:PlaySound("dontstarve/wilson/backpack_open")
            end
            self._isopen = true
        end
    end
end

function BoatContainer:Close()
    if self.opentask ~= nil then
        self.opentask:Cancel()
        self.opentask = nil
    end
    if self.inst.components.container ~= nil then
        self.inst.components.container:Close()
    elseif self._isopen then
        if TheLocalPlayer ~= nil and TheLocalPlayer.HUD ~= nil then
            TheLocalPlayer.HUD:CloseContainer(self.inst, self:IsSideWidget())
            if self:IsSideWidget() then
                TheFocalPoint.SoundEmitter:PlaySound("dontstarve/wilson/backpack_close")
            end
        end
        self._isopen = false
    end
end

function BoatContainer:IsBusy()
    return self.inst.components.container == nil and (self.classified == nil or self.classified:IsBusy())
end

--------------------------------------------------------------------------
--InvSlot click action handlers
--------------------------------------------------------------------------

function BoatContainer:PutOneOfActiveItemInSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:PutOneOfActiveItemInSlot(slot)
    elseif self.classified ~= nil then
        self.classified:PutOneOfActiveItemInSlot(slot)
    end
end

function BoatContainer:PutAllOfActiveItemInSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:PutAllOfActiveItemInSlot(slot)
    elseif self.classified ~= nil then
        self.classified:PutAllOfActiveItemInSlot(slot)
    end
end

function BoatContainer:TakeActiveItemFromHalfOfSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:TakeActiveItemFromHalfOfSlot(slot)
    elseif self.classified ~= nil then
        self.classified:TakeActiveItemFromHalfOfSlot(slot)
    end
end

function BoatContainer:TakeActiveItemFromAllOfSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:TakeActiveItemFromAllOfSlot(slot)
    elseif self.classified ~= nil then
        self.classified:TakeActiveItemFromAllOfSlot(slot)
    end
end

function BoatContainer:AddOneOfActiveItemToSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:AddOneOfActiveItemToSlot(slot)
    elseif self.classified ~= nil then
        self.classified:AddOneOfActiveItemToSlot(slot)
    end
end

function BoatContainer:AddAllOfActiveItemToSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:AddAllOfActiveItemToSlot(slot)
    elseif self.classified ~= nil then
        self.classified:AddAllOfActiveItemToSlot(slot)
    end
end

function BoatContainer:SwapActiveItemWithSlot(slot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:SwapActiveItemWithSlot(slot)
    elseif self.classified ~= nil then
        self.classified:SwapActiveItemWithSlot(slot)
    end
end

function BoatContainer:BoatEquipActiveItem()
    if self.inst.components.container ~= nil then
        self.inst.components.container:BoatEquipActiveItem()
    elseif self.classified ~= nil then
        self.classified:BoatEquipActiveItem()
    end
end

function BoatContainer:SwapBoatEquipWithActiveItem()
    if self.inst.components.container ~= nil then
        self.inst.components.container:SwapBoatEquipWithActiveItem()
    elseif self.classified ~= nil then
        self.classified:SwapBoatEquipWithActiveItem()
    end
end

function BoatContainer:TakeActiveItemFromBoatEquipSlot(eslot)
    if self.inst.components.container ~= nil then
        self.inst.components.container:TakeActiveItemFromBoatEquipSlot(eslot)
    elseif self.classified ~= nil then
        self.classified:TakeActiveItemFromBoatEquipSlot(eslot)
    end
end

function BoatContainer:MoveItemFromAllOfSlot(slot, container)
    if self.inst.components.container ~= nil then
        self.inst.components.container:MoveItemFromAllOfSlot(slot, container)
    elseif self.classified ~= nil then
        self.classified:MoveItemFromAllOfSlot(slot, container)
    end
end

function BoatContainer:MoveItemFromHalfOfSlot(slot, container)
    if self.inst.components.container ~= nil then
        self.inst.components.container:MoveItemFromHalfOfSlot(slot, container)
    elseif self.classified ~= nil then
        self.classified:MoveItemFromHalfOfSlot(slot, container)
    end
end

--------------------------------------------------------------------------

return BoatContainer%%+%%scripts/components/boathealth.lua%%-%%local function onmaxhealth(self, maxhealth)
    self.inst.replica.boathealth._maxhealth:set(maxhealth)
end

local function oncurrenthealth(self, currenthealth)
    self.inst.replica.boathealth._currenthealth:set(currenthealth)
end

local function oninvincible(self, invincible)
    self.inst.replica.boathealth._invincible:set(invincible)
end

local BoatHealth = Class(function(self, inst)
    self.inst = inst
    self.consuming = false

    self.maxhealth = 100
    self.currenthealth = 0
    self.rate = 1

    self.period = 1
    self.bonusmult = 1
    self.depleted = nil
    self.depletionmultiplier = 1

    self.base_damage_scale = 1
    self.wave_damage_scale = 1
    self.attack_damage_scale = 1

    self.leakinghealth = 0

    self.damagesound = nil

    self.moving = false
    self.invincible = false

    self.inst:ListenForEvent("boatstartmoving", function() 
        self.moving = true
    end, self.inst)

    self.inst:ListenForEvent("boatstopmoving", function() 
        self.moving = false 
    end, self.inst)
end, nil, {
    maxhealth = onmaxhealth,
    currenthealth = oncurrenthealth,
    invincible = oninvincible,
})


function BoatHealth:MakeEmpty()
    if self.currenthealth > 0 then
        self:DoDelta(-self.currenthealth)
    end
end

function BoatHealth:OnSave()
    return {health = self.currenthealth, rate = self.rate}
end

function BoatHealth:OnLoad(data)
    self.rate = data.rate
    if data.health then
        self:SetHealth(data.health)
    end
end

function BoatHealth:SetDepletedFn(fn)
    self.depleted = fn
end

function BoatHealth:IsEmpty()
    return self.currenthealth <= 0
end

function BoatHealth:IsFull()
    return self.currenthealth >= self.maxhealth
end

function BoatHealth:SetUpdateFn(fn)
    self.updatefn = fn
end

function BoatHealth:GetDebugString()
    return string.format("%s %2.2f/%2.2f (-%2.2f)", self.consuming and "ON" or "OFF", self.currenthealth, self.maxhealth, self.rate)
end

function BoatHealth:GetPercent()
    if self.maxhealth > 0 then 
        return math.min(1, self.currenthealth / self.maxhealth)
    else
        return 0
    end
end

function BoatHealth:IsInvincible()
    return self.invincible
end

function BoatHealth:SetInvincible(val)
    self.invincible = val
    self.inst:PushEvent("boatinvincibletoggle", {invincible = val})
end

function BoatHealth:SetIsMoving(move)
    self.moving = move
end

function BoatHealth:SetPercent(amount)
    local target = (self.maxhealth * amount)
    self:DoDelta(target - self.currenthealth)
end

function BoatHealth:StartConsuming()
    self.consuming = true
    if self.task == nil then
        self.task = self.inst:DoPeriodicTask(self.period, function() self:DoUpdate(self.period) end)
    end
end

function BoatHealth:IsDead()
    return self.currenthealth <= 0
end

function BoatHealth:SetHealth(hp, perishtime)
    local oldpercent = self:GetPercent()
    if self.maxhealth < hp then
        self.maxhealth = hp
    end
    if perishtime then
        self.rate = hp / perishtime
    end
    self.currenthealth = hp
    self.inst:PushEvent("boathealthchange", {percent = self:GetPercent(), oldpercent = oldpercent, damage = false, currenthealth = hp, maxhealth = self.maxhealth})
end

function BoatHealth:DoDelta(amount, damageType, source, ignore_invincible)
    if self.invincible and not ignore_invincible then
        return
    end

    local sailor = self.inst.components.sailable and self.inst.components.sailable.sailor or nil

    if damageType == "combat" or damageType == "wave" then
        if self.damagesound and sailor then
            self.inst.SoundEmitter:PlaySound(self.damagesound)
        end
    end

    if self.moving and damageType == nil and amount < 0 then
        amount = amount * self.depletionmultiplier
    end

    local oldpercent = self:GetPercent()

    self.currenthealth = math.max(0, math.min(self.maxhealth, self.currenthealth + amount) )

    if self.currenthealth <= 0 and self.depleted then
        --This isn't great but deferring the function call is needed to fix a potential crash when dying from hitting a wave
        --When getting depleted by hitting a wave this function will be called from the waves onCollision callback 
        --The depleted function for boats causes the player to switch collision shapes which will cause a crash when done in the midst of the physics engine processing collisions 
        self.inst:DoTaskInTime(0, self.depleted) 
    end

    local percent = self:GetPercent()

    local isDamage = damageType == "wave" or damageType == "combat" or damageType == "fire"

    if self.hitfx and oldpercent-percent > TUNING.BOAT_HITFX_THRESHOLD
    and isDamage and damageType ~= "fire" then
        SpawnAt(self.hitfx, self.inst)
    end

    self.inst:PushEvent("boathealthchange", {percent = percent, oldpercent = oldpercent, damage = isDamage, currenthealth = self.currenthealth, maxhealth = self.maxhealth})
end

function BoatHealth:DoUpdate(dt)
    if self.consuming and self.moving then
        self:DoDelta(-dt*self.rate)
    end

    if self:IsEmpty() then
        self:StopConsuming()
    end

    if self.updatefn then
        self.updatefn(self.inst)
    end
end

function BoatHealth:StopConsuming()
    self.consuming = false
    if self.task then
        self.task:Cancel()
        self.task = nil
    end
end

function BoatHealth:LongUpdate(dt)
    self:DoUpdate(dt)
end

function BoatHealth:IsLeaking()
    return self.currenthealth <= self.leakinghealth
end

return BoatHealth
%%+%%scripts/components/boathealth_replica.lua%%-%%local function OnBoatHealthDelta(inst, data)
    --we are doing a sneaky, and sending the boolean data.damge, since we cant "know" on the client.
    inst.replica.boathealth._boathealthchange:set_local(data.damage)
    inst.replica.boathealth._boathealthchange:set(data.damage)
end

local function OnBoatHealthDirty(inst)
    local oldpercent = inst.replica.boathealth._oldhealthpercent or 1
    local percent = inst.replica.boathealth:GetPercent()
    local data = {
        oldpercent = oldpercent,
        percent = percent,
        damage = inst.replica.boathealth._boathealthchange:value(),
        currenthealth = inst.replica.boathealth:GetCurrentHealth(),
        maxhealth = inst.replica.boathealth:GetMaxHealth(),
    }

    inst.replica.boathealth._oldhealthpercent = percent
    inst:PushEvent("boathealthchange", data)
end

local BoatHealth = Class(function(self, inst)
    self.inst = inst

    self._maxhealth = net_ushortint(inst.GUID, "_maxhealth")
    self._currenthealth = net_ushortint(inst.GUID, "_currentboathealth")
    self._invincible = net_bool(inst.GUID, "_invincible")
        
    self._boathealthchange = net_bool(inst.GUID, "_boathealthchange", "boathealthdirty")

    inst:DoTaskInTime(0, function(inst)
        if TheWorld.ismastersim then
            inst:ListenForEvent("boathealthchange", OnBoatHealthDelta)
        else
            inst:ListenForEvent("boathealthdirty", OnBoatHealthDirty)
            self._oldhealthpercent = self._maxhealth:value() > 0 and self._currenthealth:value() / self._maxhealth:value() or 0
        end
    end)
end)

function BoatHealth:GetMaxHealth()
    if self.inst.components.boathealth then
        return self.inst.components.boathealth.maxhealth
    else
        return self._maxhealth:value()
    end
end

function BoatHealth:GetCurrentHealth()  
    if self.inst.components.boathealth then
        return self.inst.components.boathealth.currenthealth
    else
        return self._currenthealth:value()
    end
end

function BoatHealth:IsInvincible()
    if self.inst.components.boathealth then
        return self.inst.components.boathealth:IsInvincible()
    else
        return self._invincible:value()
    end
end

function BoatHealth:IsEmpty()
    if self.inst.components.boathealth then
        return self.inst.components.boathealth:IsEmpty()
    else
        return self:GetCurrentHealth() <= 0
    end
end

function BoatHealth:IsFull()
    if self.inst.components.boathealth then
        return self.inst.components.boathealth:IsFull()
    else
        return self:GetCurrentHealth() >= self:GetMaxHealth()
    end
end

function BoatHealth:GetPercent()
    if self.inst.components.boathealth then
        return self.inst.components.boathealth:GetPercent()
    else
        if self:GetMaxHealth() > 0 then 
            return math.min(1, self:GetCurrentHealth() / self:GetMaxHealth())
        else
            return 0
        end
    end
end

BoatHealth.IsDead = BoatHealth.IsEmpty

return BoatHealth%%+%%scripts/components/boatvisualanims.lua%%-%%local BoatVisualAnims = Class(function(self, inst)
    self.inst = inst

    self.prerowanimation = "row_pre"
    self.rowanimation = "row_loop"
    self.postrowanimation = "row_pst"

    self.presailanim = "sail_pre"
    self.sailanim = "sail_loop"
    self.postsailanim = "sail_pst"

    self.trawlover = "trawlover"

    self.idleanim = "idle_loop"
end)

function BoatVisualAnims:OnUpdate(dt)
    if self.update then
        self.update(self.inst, dt)
    end
end

function BoatVisualAnims:PlayPreRowAnims()
    self.inst.AnimState:PlayAnimation(self.prerowanimation)
    if self.prerow then
        self.prerow(self.inst)
    end
end

function BoatVisualAnims:PlayRowAnims()
    if not self.inst.AnimState:IsCurrentAnimation(self.rowanimation) then
        self.inst.AnimState:PlayAnimation(self.rowanimation, true)
    end
    if self.row then
        self.row(self.inst)
    end
end

function BoatVisualAnims:PlayPostRowAnims()
    self.inst.AnimState:PlayAnimation(self.postrowanimation)
    if self.postrow then
        self.postrow(self.inst)
    end
end

function BoatVisualAnims:PlayPreSailAnims()
    self.inst.AnimState:PlayAnimation(self.presailanim)
    if self.presail then
        self.presail(self.inst)
    end
end

function BoatVisualAnims:PlaySailAnims()
    if not self.inst.AnimState:IsCurrentAnimation(self.sailanim) then
        self.inst.AnimState:PlayAnimation(self.sailanim, true)
    end
    if self.sail then
        self.sail(self.inst)
    end
end

function BoatVisualAnims:PlayPostSailAnims()
    self.inst.AnimState:PlayAnimation(self.postsailanim)
    if self.postsail then
        self.postsail(self.inst)
    end
end

function BoatVisualAnims:PlayTrawlOverAnims()
    self.inst.AnimState:PlayAnimation(self.trawlover)
    if self.trawl then
        self.trawl(self.inst)
    end
end

function BoatVisualAnims:PlayIdleAnims(push)
    if push then
        self.inst.AnimState:PushAnimation(self.idleanim, true)
        if self.idle then
            self.idle(self.inst)
        end
        return
    end
    if not self.inst.AnimState:IsCurrentAnimation(self.idleanim) then
        self.inst.AnimState:PlayAnimation(self.idleanim, true)
    end
    if self.idle then
        self.idle(self.inst)
    end
end

return BoatVisualAnims%%+%%scripts/components/boatvisualmanager.lua%%-%%local BoatVisualManager = Class(function(self, inst)
    self.inst = inst
    self.visuals = {}
end)

function BoatVisualManager:SpawnBoatEquipVisuals(item, visualprefab)
    assert(visualprefab and type(visualprefab) == "string", "item.visualprefab must be a valid string!")

    local visual = SpawnPrefab("visual_"..visualprefab.."_boat")
    visual.entity:SetParent(self.inst.entity)
    self.visuals[item] = visual

    item.visual = visual

    visual.boat = self.inst

    visual.boat.boatvisuals[visual] = true
    visual:ListenForEvent("onremove", function(inst)
        inst.boat.boatvisuals[inst] = nil
    end)

    visual.Transform:SetRotation(visual.boat.Transform:GetRotation())
    visual:StartUpdatingComponent(visual.components.boatvisualanims)
end

function BoatVisualManager:RemoveBoatEquipVisuals(item)
    item.visual = nil
    if self.visuals[item] then
        self.visuals[item]:Remove()
        self.visuals[item] = nil
    end
end

return BoatVisualManager%%+%%scripts/components/breeder.lua%%-%%local function onvolume(self, volume)
    if volume > 0 then
        self.inst:AddTag("breederharvest")
    else
        self.inst:RemoveTag("breederharvest")
    end
end

local function onseeded(self, seeded)
    if not seeded then
        self.inst:AddTag("canbeseeded")
    else
        self.inst:RemoveTag("canbeseeded")
    end
end

local Breeder = Class(function(self, inst)
    self.inst = inst

    --V2C: Recommended to explicitly add tag to prefab pristine state
    self.inst:AddTag("breeder")

    self.crops = {}
    self.volume = 0
    self.max_volume = 4
    self.seeded = false
    self.harvestable = false
    self.level = 1
    self.croppoints = {}
    self.growrate = 1

    self.haspredators = true

    self.luretime = TUNING.SEG_TIME * 5
    self.cycle_min = TUNING.SEG_TIME * 6
    self.cycle_max = TUNING.SEG_TIME * 10
end,
nil,
{
    seeded = onseeded,
    volume = onvolume,
})

function Breeder:IsEmpty()
    return self.volume == 0
end

function Breeder:OnSave()
    local data = {
        harvestable = self.harvestable,
        volume = self.volume,
        seeded = self.seeded,
        product = self.product,
        harvested = self.harvested,
    }

    if self.BreedTask then     
        data.breedtasktime = GetTaskRemaining(self.BreedTask)     
    end

    if self.luretask then
        data.luretasktime = GetTaskRemaining(self.luretask) 
    end

    return data
end    

function Breeder:OnLoad(data, newents)    
	self.volume = data.volume
    self.seeded = data.seeded
    self.harvestable = data.harvestable
    self.product = data.product   
    self.harvested= data.harvested

    if data.breedtasktime then        
        self.BreedTask = self.inst:DoTaskInTime(data.breedtasktime, function() self:CheckVolume() end)
    end

    if data.luretasktime then
        self.LureTask = self.inst:DoTaskInTime(data.luretask, function() self:CheckLure() end)
    end

    self.inst:DoTaskInTime(0, function() self.inst:PushEvent("vischange") end )
end

function Breeder:CheckSeeded()
    if self.volume < 1 and not self.harvestable then        
        self:StopBreeding()
    end 
    self.inst:PushEvent("vischange")
end

function Breeder:UpdateVolume(delta)
    self.volume = math.min(math.max(self.volume + delta, 0), self.max_volume)
    self:CheckSeeded()
end

local function SpawnPredatorPrefab(inst)
    local prefab = "crocodog"

    local x, y, z = inst.Transform:GetWorldPosition()
    local tile, tileinfo = inst:GetCurrentTileType(x, y, z)

    --TODO more tile properties?
    if tile == GROUND.OCEAN_DEEP or tile == GROUND.OCEAN_MEDIUM then
        if math.random() < 0.7 then
            prefab = "swordfish"
        end
    end

    local pt = Vector3(inst.Transform:GetWorldPosition())
    local predators = TheSim:FindEntities(pt.x, pt.y, pt.z, 10, {"crocodog", "swordfish"})

    if #predators > 2 then
        return nil
    end
    return SpawnPrefab(prefab)
end

function Breeder:SummonPredator()
    if not self.haspredators then
        return
    end
    local spawn_pt = Vector3(self.inst.Transform:GetWorldPosition())

    if spawn_pt then
        local predator = self.spawnpredatorprefabfn == nil and SpawnPredatorPrefab(self.inst) or self.spawnpredatorprefabfn(self.inst)

        if predator then
            local radius = 30 
            local base = spawn_pt
            local theta = math.random() * 2 * PI
            local offset = Vector3(0,0,0)

            local player = self.inst:GetNearestPlayer(true)

            if player and self.inst:GetDistanceSqToInst(player) < radius * radius then
                offset = Vector3(radius * math.cos(theta), 0, -radius * math.sin(theta))            
                base = Vector3(player.Transform:GetWorldPosition())
                predator.Physics:Teleport((base + offset):Get())
                predator.components.combat:SuggestTarget(player)
            else
                predator.Physics:Teleport(base:Get())
            end
        end
    end
end

function Breeder:CheckLure()
    if self.volume > 0 then
        if math.random() * 120 / math.pow(self.volume, 1.5) <= 1 then
            self:SummonPredator()
        end
    end
    self.LureTask = self.inst:DoTaskInTime(self.luretime, function() self:CheckLure() end)
end

function Breeder:CheckVolume()
    if self.seeded then
        self:UpdateVolume(1)
        self.inst:PushEvent("vischange")

        local time = math.random(self.cycle_min, self.cycle_max)

        self.BreedTask = self.inst:DoTaskInTime(time, function() self:CheckVolume() end)
    end
end

function Breeder:Seed(item)
    if not item.components.seedable then
        return false
    end
    
    self:Reset()
    
    local prefab = nil
    if item.components.seedable.product and type(item.components.seedable.product) == "function" then
		prefab = item.components.seedable.product(item)
    else
		prefab = item.components.seedable.product or item.prefab
	end

    self.product = prefab

    self.seeded = true

    local time = math.random(self.cycle_min, self.cycle_max)

    self.BreedTask = self.inst:DoTaskInTime(time, function() self:CheckVolume() end)

    self.LureTask = self.inst:DoTaskInTime(self.luretime, function() self:CheckLure() end)

    if self.onseedfn then
		self.onseedfn(self.inst, item)
    end

    self.inst:PushEvent("vischange")

	item:Remove()    
	
    return true
end

function Breeder:Harvest(harvester)
    if self.onharvestfn then
        self.onharvestfn(self.inst, harvester)
    end

    self.harvestable = false
    self.harvested = true
    if harvester and harvester.components.inventory then
        local product = SpawnPrefab(self.product)
        harvester.components.inventory:GiveItem(product)
    elseif harvester and harvester.components.lootdropper then
        harvester.components.lootdropper:SpawnLootPrefab(self.product)
    end
    self:UpdateVolume(-1)   

    return true
end

function Breeder:GetDebugString()
    return "seeded: ".. tostring(self.seeded) .." harvestable: ".. tostring(self.harvestable) .." volume: ".. tostring(self.volume)
end

function Breeder:Reset()
    self.harvested = false
    self.seeded = false
    self.harvestable = false
    self.volume = 0   
    self.product = nil 
    self.inst:PushEvent("vischange")

    if self.LureTask then
        self.LureTask:Cancel()
        self.LureTask = nil
    end
end

function Breeder:StopBreeding()
    self:Reset()
    if self.BreedTask then
        self.BreedTask:Cancel()
        self.BreedTask = nil
    end
end

return Breeder
%%+%%scripts/components/chessnavy.lua%%-%%-- Spawns water chess creatures at the location of past (water based) crimes.

local function ondeath(inst, data)
	if data then
		local victim = data.inst
		local crime_pos = victim:GetPosition()
		local on_water = IsWater(TheWorld.Map:GetTileAtPoint(crime_pos:Get()))

		if on_water and data.afflicter and data.afflicter:HasTag("player") and victim and not victim:HasTag("chess") and victim.components.health then
			local navy = inst.components.chessnavy
			local spawn_point = navy:GetSpawnPointNear(crime_pos)
			if not spawn_point then
				navy:AddSpawnPoint(crime_pos)
			end
			navy:ReportCrime(victim)
		end
	end
end

local ChessNavy = Class(function(self, inst)
	self.inst = inst

	assert(inst == TheWorld, "Invalid world")

	self.possible_spawn_points = {}
	self.min_spawn_dist_sq = 1600 -- 40 * 40

	self.attack_difficulty = self.difficulty.intro
	self.attack_frequency_fn = self.frequency.occasional
	self.spawn_timer = nil
	self.ready_to_spawn = false

	self.inst:ListenForEvent("entity_death", ondeath)
	self:Start()
end)

local _crime_modifier = 0.1
local _spawn_point_prefab = "chess_navy_spawner"

ChessNavy.difficulty =
{
	intro 	= {["knightboat"] = 1},
	light 	= {["knightboat"] = 2},
	med 	= {["knightboat"] = 3},
	heavy 	= {["knightboat"] = 3},
	crazy 	= {["knightboat"] = 3},
}

ChessNavy.frequency =
{
	rare = function() return TUNING.TOTAL_DAY_TIME * 15 + math.random() * TUNING.TOTAL_DAY_TIME * 5 end,
	occasional = function() return TUNING.TOTAL_DAY_TIME * 10 + math.random() * TUNING.TOTAL_DAY_TIME * 2.5 end,
	frequent = function() return TUNING.TOTAL_DAY_TIME * 7.5 + math.random() * TUNING.TOTAL_DAY_TIME * 1 end,
}

function ChessNavy:Start()
	local update_dt = 1
	self.chessnavy_updatetask = self.inst:DoPeriodicTask(update_dt, function() self:OnUpdate(update_dt) end)
end

function ChessNavy:Stop()
	if self.chessnavy_updatetask then
		self.chessnavy_updatetask:Cancel()
		self.chessnavy_updatetask = nil
	end
end

function ChessNavy:CalcEscalationLevel()
	local day = TheWorld.state.cycles
	
	if day < 20 then
		self.attack_frequency_fn = self.frequency.rare
		self.attack_difficulty = self.difficulty.intro
	elseif day < 30 then
		self.attack_frequency_fn = self.frequency.rare
		self.attack_difficulty = self.difficulty.light
	elseif day < 50 then
		self.attack_frequency_fn = self.frequency.occasional
		self.attack_difficulty = self.difficulty.med
	elseif day < 70 then
		self.attack_frequency_fn = self.frequency.occasional
		self.attack_difficulty = self.difficulty.heavy
	else
		self.attack_frequency_fn = self.frequency.frequent
		self.attack_difficulty = self.difficulty.crazy
	end
end

function ChessNavy:IsActive()
	return self.chessnavy_updatetask ~= nil
end

function ChessNavy:StartNewInvestigation()
	self:RemoveAllSpawnPoints()
	self:CalcEscalationLevel()
	self.spawn_timer = self.attack_frequency_fn()
	self.ready_to_spawn = false
end

function ChessNavy:DeltaTimer(delta)
	if not self.spawn_timer then print("WARNING: No Spawn Timer in ChessNavy:DeltaTimer!") return end

	self.spawn_timer = self.spawn_timer + delta
	self.spawn_timer = math.max(self.spawn_timer, 0)

	if self.spawn_timer <= 0 and self:IsActive() then
		self:ActivateSpawnPoints()
	end
end

function ChessNavy:ReportCrime(victim)
	if victim and not victim:HasTag("chess") and victim.components.health then
		--Get max health of thing killed.
		local max_hp = victim.components.health.maxhealth
		self:DeltaTimer(-max_hp * _crime_modifier)
	end
end

function ChessNavy:GetSpawnPointNear(pt)
	for _,v in ipairs(self.possible_spawn_points) do
		if v:GetPosition():DistSq(pt) <= self.min_spawn_dist_sq then
			return v
		end
	end
end

function ChessNavy:AddSpawnPoint(pt)
	local spawn_point = SpawnPrefab(_spawn_point_prefab)
	spawn_point.Transform:SetPosition(pt:Get())

	self:TrackSpawnPoint(spawn_point)
end

function ChessNavy:TrackSpawnPoint(spawn_point)
	if spawn_point then
		table.insert(self.possible_spawn_points, spawn_point)
		self.inst:ListenForEvent("onentitywake", function() self:SpawnPointWake(spawn_point) end, spawn_point)
	end
end

function ChessNavy:DoSpawnAtPoint(spawn_point)	
	local to_spawn = self:GetSpawnPrefabs()
	local pos = spawn_point:GetPosition()

	for _, prefab in ipairs(to_spawn) do
		local boat = SpawnPrefab(prefab)
		boat:RestartBrain()
		local offset = FindWaterOffset(pos, math.random() * 2 * PI, math.random(4, 10), 12)
		local spawn_point = pos + (offset or Vector3(0,0,0))
		boat.Transform:SetPosition(spawn_point:Get())
	end

	self:StartNewInvestigation()
end

function ChessNavy:SpawnPointWake(spawn_point)
	print("returned to scene of crime!", spawn_point:GetPosition())
	if self.ready_to_spawn and GetTime() > 1 --[[don't spawn on game load...]] then
		self:DoSpawnAtPoint(spawn_point)
	end
end

function ChessNavy:ActivateSpawnPoints()
	if not self.ready_to_spawn then
		self.ready_to_spawn = true
	end
end

function ChessNavy:RemoveAllSpawnPoints()
	for _,v in ipairs(self.possible_spawn_points) do
		v:Remove()
	end
	self.possible_spawn_points = {}
end

function ChessNavy:GetSpawnPrefabs()
	self:CalcEscalationLevel()
	local to_spawn = {}
	local difficulty = self.attack_difficulty

	for k,v in pairs(difficulty) do
		for i = 1, v do
			table.insert(to_spawn, k)
		end
	end
	return to_spawn
end

function ChessNavy:OnUpdate(dt)
	if self.spawn_timer == nil then
		self:StartNewInvestigation()
	end

	self:DeltaTimer(-dt)
end

function ChessNavy:LongUpdate(dt)
	if self:IsActive() then
		self:OnUpdate(dt)
	end
end

function ChessNavy:OnSave()
	local data = {}
	local references = {}

	data.ready_to_spawn = self.ready_to_spawn
	data.spawn_timer = self.spawn_timer
	
	for _, spawn_point in ipairs(self.possible_spawn_points) do
		if not data.spawn_point_GUIDs then
			data.spawn_point_GUIDs = {spawn_point.GUID}
		else
			table.insert(data.spawn_point_GUIDs, spawn_point.GUID)
		end

		table.insert(references, spawn_point.GUID)
	end

	return data, references
end

function ChessNavy:OnLoad(data)
	if data then
		self.ready_to_spawn = data.ready_to_spawn
		self.spawn_timer = data.spawn_timer
	end
end

function ChessNavy:LoadPostPass(newents, data)
    if data.spawn_point_GUIDs then
        for _, GUID in pairs(data.spawn_point_GUIDs) do
            local spawn_point = newents[GUID]
            if spawn_point then
                spawn_point = spawn_point.entity
                self:TrackSpawnPoint(spawn_point)
            end
        end
    end
end

 function ChessNavy:GetDebugString()
	if self.spawn_timer and self.spawn_timer > 0 then
		return string.format("The navy arrives in %2.2f. %2.0f active investigations.", self.spawn_timer or 0, #self.possible_spawn_points)
	else
		return string.format("waiting for criminal to return to the scene of a crime...")
	end
end

return ChessNavy%%+%%scripts/components/climatetracker.lua%%-%%local function onclimate(self, climate, _climate)
    if self.inst.player_classified ~= nil then
        self.inst.player_classified._climate:set(climate or CLIMATE_IDS.forest)
    end
    if _climate then
        self.inst:RemoveTag("Climate_"..CLIMATES[_climate])
    end
    if climate then
        self.inst:AddTag("Climate_"..CLIMATES[climate])
    end
end

local function onperiod(self, period)
    if period ~= nil then
        self.inst:StartUpdatingComponent(self)
    else
        self.inst:StopUpdatingComponent(self)
    end
end

local ClimateTracker = Class(function(self, inst)
    self.inst = inst
    self.climate = nil
    self.period = nil
    self.timetonextperiod = 0
    self.climatepos = nil

    inst:DoTaskInTime(0,function() self:GetClimate() end)
end, 
nil, 
{
    climate = onclimate,
    period = onperiod,
})

function ClimateTracker:OnUpdate(dt)
    self.timetonextperiod = self.timetonextperiod - dt
    if self.timetonextperiod <= 0 then

        self:GetClimate()

        self.timetonextperiod = self.period
    end
end

function ClimateTracker:GetClimate(forceupdate)
    local pt = self.inst:GetPosition()
    if forceupdate or not self.climatepos or pt:Dist(self.climatepos) > 2 then
		local oldclimate = self.climate
        if type(self.climateoverride) == "function" or type(self.climateoverride) == "number" then
            self.climate = type(self.climateoverride) == "function" and self.climateoverride(self.inst, pt) or self.climateoverride
        else
			local climate = CalculateClimate(self.inst, nil, self.climate)
			if climate and climate ~= self.climate then
				self.climate = climate
			end
			-- if self.inst:HasTag("player") then print(self.inst, "CLIMATE", climate) end
        end
        self.climatepos = pt
		if self.climate ~= oldclimate then
			self.inst:PushEvent("climatechange", {climate = self.climate, oldclimate = oldclimate})
		end
    end
    return self.climate
end

--convenience function :)
function ClimateTracker:IsInClimate(climate)
    if not self.climate then
        self:GetClimate()
    end
    return CLIMATES[self.climate] == climate
end

--convert climate to string, and then back on save, incase the ordering changes.
function ClimateTracker:OnSave()
	local data = {}
	if self.climate then
		data.climate = CLIMATES[self.climate]
	end
	if self.climatepos then
		data.climatepos = {x = self.climatepos.x, y = self.climatepos.y, z = self.climatepos.z}
	end
	if next(data) then
		return data
	end
end

function ClimateTracker:OnLoad(data, refs)
	if data.climate then
		self.climate = CLIMATE_IDS[data.climate]
	end
	if data.climatepos then
		self.climatepos = Vector3(data.climatepos.x, data.climatepos.y, data.climatepos.z)
	end
    self.inst:PushEvent("climatechange", {climate = self.climate})
end

function ClimateTracker:GetDebugString()
	if self.climate or self.climatepos then
		return (CLIMATES[self.climate or 0] or "<nil>") .." climate, last test pos: ".. tostring(self.climatepos or "<nil>")
	end
end

return ClimateTracker%%+%%scripts/components/doydoyspawner.lua%%-%%local DoydoySpawner = Class(function(self, inst)
	self.inst = inst
	-- self.inst:StartUpdatingComponent(self)
	self.doydoys = {}
	self.numdoydoys = 0
	self.doydoycap = TUNING.DOYDOY_MAX_POPULATION
	
	self:ScheduleSpawn()
end)

function DoydoySpawner:ScheduleSpawn(dt)
	
	if self.spawntask then self.spawntask:Cancel() end
	
	dt = dt or TUNING.DOYDOY_SPAWN_TIMER + math.random()*TUNING.DOYDOY_SPAWN_VARIANCE
	self.spawntime = GetTime() + dt
	self.spawntask = self.inst:DoTaskInTime(dt, function()
		if TheWorld.state.isday and self:TryToSpawn() then
			self:ScheduleSpawn()
		else
			self:ScheduleSpawn(TUNING.SEG_TIME)
		end
	end)
	-- print("DoydoySpawner:ScheduleSpawn",dt)
end

-- This function is for on-load and does not affect our spawntime
function DoydoySpawner:RequestMate(mommy, daddy)
	-- both partners will trigger this function, but the second call will fail in CanMate
	if mommy and mommy.components.mateable:CanMate() and mommy.sg
	and daddy and daddy.components.mateable:CanMate() and daddy.sg
	and mommy:GetDistSqToInst(daddy) <= TUNING.DOYDOY_MATING_RANGE then
		daddy.components.mateable:SetPartner(mommy, true)
		mommy.components.mateable:SetPartner(daddy, false)
	end
end

local nomatingtags = {
	"baby", "teen", "mating", "doydoynest", "insprungtrap",
}

function DoydoySpawner:TryToSpawn()
	-- print("DoydoySpawner:TryToSpawn", self.numdoydoys, "/", self.doydoycap)

	if self.numdoydoys < 2 or self.numdoydoys >= self.doydoycap then
		return false
	end

	local mommy
	local daddy

	-- find a new mother
	for k, _ in pairs(self.doydoys) do
		if k.components.mateable and k.components.mateable:CanMate() then
			local pt = k:GetPosition()
			local daddys = TheSim:FindEntities(pt.x, pt.y, pt.z, TUNING.DOYDOY_MATING_RANGE, {"doydoy"}, nomatingtags) 
			if #daddys > 1 then

				for _, d in pairs(daddys) do
					if d ~= k and not d.components.inventoryitem:IsHeld() then
						daddy = d
						break
					end
				end

				if daddy then
					mommy = k
					break
				end
			end
		end
	end

	if not mommy then
		-- print("DoydoySpawner:TryToSpawn no mommy found")
		return false
	end

	if not mommy.sg then
		-- print("DoydoySpawner:TryToSpawn no mommy.sg")
		return false
	end
	
	-- print("DoydoySpawner:TryToSpawn parents found!")
	daddy.components.mateable:SetPartner(mommy, true)
	mommy.components.mateable:SetPartner(daddy, false)

	-- self:ScheduleSpawn(TUNING.DOYDOY_SPAWN_TIMER + math.random()*TUNING.DOYDOY_SPAWN_VARIANCE)
	
	return true
end


function DoydoySpawner:OnSave()
	return 
	{
		timetospawn = math.max(0, self.spawntime - GetTime()),
		doydoycap = self.doydoycap,
	}
end

function DoydoySpawner:OnLoad(data)
	self.doydoycap = data.doydoycap or TUNING.DOYDOY_MAX_POPULATION
	if self.doydoycap > 0 then
		self:ScheduleSpawn(data.timetospawn)
	end
end

-- function DoydoySpawner:LongUpdate(dt)
	-- if self.timetospawn > 0 then
		-- self.timetospawn = self.timetospawn - dt
	-- end
-- end

-- function DoydoySpawner:OnUpdate( dt )
	-- if self.timetospawn > 0 then
		-- self.timetospawn = self.timetospawn - dt
	-- end
	
	-- if TheWorld.state.isday then
		-- if self.timetospawn <= 0 then
			-- self:TryToSpawn()
		-- end
	-- end
-- end

function DoydoySpawner:StartTracking(inst)

	if self.doydoys[inst] ~= nil then return end
	
	self.doydoys[inst] = true
	self.numdoydoys = self.numdoydoys + 1
end

function DoydoySpawner:StopTracking(inst)

	if self.doydoys[inst] == nil then return end
	
	self.doydoys[inst] = nil
	self.numdoydoys = self.numdoydoys - 1
end

function DoydoySpawner:IsTracking(inst)
	return self.doydoys[inst] ~= nil
end

function DoydoySpawner:GetInnocenceValue()
	if self.numdoydoys <= 2 then
		return TUNING.DOYDOY_INNOCENCE_REALLY_BAD
	elseif self.numdoydoys <= 4 then
		return TUNING.DOYDOY_INNOCENCE_BAD
	elseif self.numdoydoys <= 10 then
		return TUNING.DOYDOY_INNOCENCE_LITTLE_BAD
	else
		return TUNING.DOYDOY_INNOCENCE_OK
	end
end

function DoydoySpawner:GetDebugString()
	return "numdoydoys: "..self.numdoydoys.."\tNext spawn: "..tostring(self.spawntime - GetTime())
end

function DoydoySpawner:SpawnModeNever()
	self.doydoycap = 0
	self.spawntime = nil
	if self.spawntask then self.spawntask:Cancel() end
end

function DoydoySpawner:SpawnModeHeavy()
	self.doydoycap = TUNING.DOYDOY_MAX_POPULATION * 2
	-- self.timetospawn = TUNING.DOYDOY_SPAWN_TIMER / 2
end

function DoydoySpawner:SpawnModeMed()
	self.doydoycap = TUNING.DOYDOY_MAX_POPULATION
	-- self.timetospawn = TUNING.DOYDOY_SPAWN_TIMER
end

function DoydoySpawner:SpawnModeLight()
	self.doydoycap = TUNING.DOYDOY_MAX_POPULATION / 2
	-- self.timetospawn = TUNING.DOYDOY_SPAWN_TIMER * 2
end

return DoydoySpawner
%%+%%scripts/components/floodable.lua%%-%%local Floodable = Class(function(self, inst)
	self.inst = inst

	self.flooded = false

	-- self.onStartFlooded = nil
	-- self.onStopFlooded = nil

	-- self.inst:AddTag("floodable")

	self:SetFX(nil,nil,10) --This starts the update task.
end)

local function Update(inst)
	local self = inst.components.floodable
	local pt = inst:GetPosition()
	local onFlood = IsOnFlood(pt.x,pt.y,pt.z)

	if onFlood and not self.flooded then
		self.flooded = true
		inst:AddTag("flooded")
		if self.onStartFlooded then
			self.onStartFlooded(inst)
		end

	elseif not onFlood and self.flooded then
		self.flooded = false
		inst:RemoveTag("flooded")
		if self.onStopFlooded then
			self.onStopFlooded(inst)
		end
	end

	if self.flooded then
		if self.floodEffect then
			local fx = SpawnPrefab(self.floodEffect)
			if fx then
				fx.Transform:SetPosition(pt.x, pt.y, pt.z)
			end
		end
	end
end

function Floodable:SetFX(floodEffect, fxPeriod)
	self.floodEffect = floodEffect
	if fxPeriod and fxPeriod ~= self.fxPeriod then
		self.fxPeriod = fxPeriod
		if self.updatetask then
			self.updatetask:Cancel()
		end
		self.updatetask = self.inst:DoPeriodicTask(fxPeriod, Update, fxPeriod * math.random())
	end
end

function Floodable:OnRemoveEntity()
	self.inst:RemoveTag("flooded")
	if self.updatetask then
		self.updatetask:Cancel()
		self.updatetask = nil
	end
end

Floodable.OnRemoveFromEntity = Floodable.OnRemoveEntity

return Floodable
%%+%%scripts/components/flooding.lua%%-%%--Flood tiles are fake water on land tiles, and they're only half as wide as real tiles.
--In SW, it is mostly handled engine-side.
--Flood exists as tides and as Green season puddles.
--The puddle sources are also known as "puddle eyes", but that name is too silly for me to write serious code with it. -M
--They spread flood tiles around themselves, but can be blocked by sandbags.
--There's an implicit bug that prevents the spread if the source tile is blocked directly.
--Sandbags can also be used to entirely remove the flood, but the details are weird and possibly inconsistent.
--Puddles dry up over the course of three days in summer.

--------------------------------------------------------------------------

return Class(function(self, inst)

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local _moontideheights =
{
	["new"] = 0,
    ["quarter"] = 5,
    ["half"] = 7,
    ["threequarter"] = 8,
    ["full"] = 10,
}

local _surrounding_offsets = {
	{ .5, 0},
	{ 0, .5},
	{-.5, 0},
	{ 0,-.5},
}


--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public

self.inst = inst

--Private

local _world = TheWorld
local _map = _world.Map
local _ismastersim = _world.ismastersim

local _activeplayers = {}
local _scheduledtasks = {}

local _israining = false
local _isfloodseason = false
local _seasonprogress = 0

local _maxTide = 0
local _maxTideMod = 1 --settings modifier

local _targetTide = 0
local _currentTide = 0

local _puddles = _ismastersim and {}
local _puddle_xy_lookup = _ismastersim and {}
local _blocker_xy_lookup = _ismastersim and {} --will probably be needed clientside when tides get added

local _nPuddlesLeft

local _targetPuddleHeight = _ismastersim and 0

-- for puddles
local _mapedge_padding = TUNING.MAPEDGE_PADDING
local _maxFloodLevel = _ismastersim and TUNING.MAX_FLOOD_LEVEL
local _timeBetweenFloodIncreases = _ismastersim and TUNING.FLOOD_GROW_TIME
local _timeBetweenFloodDecreases = _ismastersim and TUNING.FLOOD_DRY_TIME
local _spawnerFrequency = _ismastersim and TUNING.FLOOD_FREQUENCY --unused

local _flood_xy_lookup = not _ismastersim and {} --NETVAR
local _spawnFloodEvent
local _removeFloodEvent

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

--forward declare
local RefreshPuddle

local GetTilePt = function(x,y,z)
--gets the floodtile center point for any point (as in entity position)
	y = z or y

	local w, h = _map:GetSize()
	-- (x + w/2) / TILE_SCALE
	return
		(math.floor(x) + (math.floor(x+1)%2)) / TILE_SCALE + w/2,
		(math.floor(y) + (math.floor(y+1)%2)) / TILE_SCALE + h/2
end

local SetFloodTile = function(x,y,b)
	b = b==true or nil
	--[[ --NETVAR
	--When trying the netvar again, don't forget to disable AddNetworkProxy in prefabs/flood.lua!
	if _ismastersim then
		local w, h = _map:GetSize()
		local dx = (x - .25) * 2
		local dy = (y - .25) * 2 * (w*2)
		if b then
			print("SET EVENT",x,y,dx,dy)
			_spawnFloodEvent:set(dx + dy)
			_spawnFloodEvent:set_local(0)
		else
			_removeFloodEvent:set(dx + dy)
			_removeFloodEvent:set_local(0)
		end
	end
	]]
	SetTileState(x,y,"flood",b)
	if not _ismastersim then
		local tile = GetTileState(x,y,"flood")
		if tile then
			tile._ms_controlled = true
		end
	end
end

--change this to define _targetTide instead
--[[
function self:GetTideHeight()

	local nightLength = GetClock():GetNightTime()
	local duskLength = GetClock():GetDuskTime()

	--Floods start at the beginning of evening and end at daybreak, in that time they interpolate to max height and back to zero
	local timepassed = 0

	local time = GetClock():GetNormTime()
	local tidePerc = 0
	local startGrowTime = 1.0 - 3/16
	local startShrinkTime = 0
	local endShrinkTime = 3/16

	if time > startGrowTime then
		tidePerc = (time - startGrowTime)/(3/16)
	elseif time > startShrinkTime and time < endShrinkTime then
		tidePerc = 1.0 - (time/(endShrinkTime - startShrinkTime))
	end

	return _maxTide * _maxTideMod * tidePerc
end
]]

local RemovePuddle = _ismastersim and function(puddle)
	--for convenience, this function accepts indexes or data
	local i
	if type(puddle) == "number" then
		i = puddle
		puddle = _puddles[i]
	end
	if not puddle then return end
	if not i then
		for j, p in pairs(_puddles) do
			if p == puddle then
				i = j
				break
			end
		end
	end
	--do the actual RemovePuddle
	if puddle.radius > 0 then
		puddle.radius = 0
		RefreshPuddle(puddle)
	end
	table.remove(_puddles, i)
	_puddle_xy_lookup[puddle.x][puddle.y] = nil
	if not next(_puddle_xy_lookup[puddle.x]) then
		_puddle_xy_lookup[puddle.x] = nil
	end
end

--forward declared
RefreshPuddle = _ismastersim and function(puddle, skipwetcheck)
	-- print("Refresh puddle...",puddle)

	-- remove tiles, iterating backwards to allow removal
	for i = #puddle._children, 1, -1 do
		local pt = puddle._children[i]
		local tile = GetTileState(pt[1],pt[2],"flood")
		if not tile or tile.val == nil then
			table.remove(puddle._children, i)
			-- print("REMOVE BY INVALID")

		-- calculate taxicab distance
		elseif 2* math.abs(puddle.x - pt[1]) + 2* math.abs(puddle.y - pt[2]) >= puddle.radius then
			-- remove this source
			-- print("Remove a child",pt[1],pt[2])
			tile.sources = tile.sources or {}
			tile.sources[puddle] = nil
			if not next(tile.sources) then
				-- print("REMOVE BY DISTANCE",puddle.radius)
				SetFloodTile(pt[1],pt[2],false)
				table.remove(puddle._children, i)
			end
		end
	end

	-- do not expand if there's no radius
	if puddle.radius < 1 then return end
	-- do not expand if the source is blocked (implicit in reachable check)
	-- if _blocker_xy_lookup[puddle.x] and _blocker_xy_lookup[puddle.x][puddle.y] then return end
	-- do not expand if the source is dry
	if not skipwetcheck and not GetTileState(puddle.x,puddle.y,"flood") then return end
	-- confirm that we can reach this tile via taxicab distance before flooding it!
	local reachable = {}
	local q1 = {{puddle.x, puddle.y}}
	local q2 = {}
	for i = 1, puddle.radius do
		for _, pt in pairs(q1) do
			-- print("Try flood",pt[1],pt[2])
			local ground = _map:GetTile(math.ceil(pt[1] -.5), math.ceil(pt[2] -.5))
			if not (_blocker_xy_lookup[pt[1]] and _blocker_xy_lookup[pt[1]][pt[2]])
			and IsLand(ground) and ground ~= GROUND.IMPASSABLE then
				reachable[pt[1]] = reachable[pt[1]] or {}
				reachable[pt[1]][pt[2]] = true
				-- print("Valid")
				for _, offset in pairs(_surrounding_offsets) do
					local qx = pt[1] + offset[1]
					local qy = pt[2] + offset[2]
					if not (reachable[qx] and reachable[qx][qy]) then
						-- print("Queued:",qx,qy)
						table.insert(q2,{qx, qy})
					end
				end
			end
		end
		q1 = q2
		q2 = {}
	end

	-- do not expand if the source is dry and separated from all wet
	-- if not skipwetcheck then
		-- local sourcewet = false
		-- for tx, y in pairs(reachable) do
			-- for ty, _ in pairs(y) do
				-- local tile = GetTileState(tx,ty,"flood")
				-- if tile and tile.val then
					-- sourcewet = true
					-- break
				-- end
			-- end
			-- if sourcewet then break end
		-- end
		-- if not sourcewet then return end
	-- end

	-- add tiles, iterating the previously calculated points

	-- for rx = -puddle.radius, puddle.radius do
		-- for ry = -puddle.radius + math.abs(rx), puddle.radius - math.abs(rx) do
			-- local tx = rx * .5 + puddle.x
			-- local ty = ry * .5 + puddle.y
			-- print("Trying to add a child",rx,ry,tx,ty)
	for tx, y in pairs(reachable) do
		for ty, _ in pairs(y) do
			-- print("Trying to add a child",tx,ty)

			-- local ground = _map:GetTile(math.ceil(tx -.5), math.ceil(ty -.5))
			-- if IsLand(ground) and ground ~= GROUND.IMPASSABLE then

				-- print("Add it")
				-- add it
				local tile = GetTileState(tx,ty,"flood")
				if not tile or tile.val == nil then
					SetFloodTile(tx,ty,true)
					tile = GetTileState(tx, ty, "flood")
				end
				tile.sources = tile.sources or {}
				if not tile.sources[puddle] then
					tile.sources[puddle] = true
					table.insert(puddle._children, {tx,ty})
				end
			-- end
    	end
	end

	if #puddle._children == 0 then
		RemovePuddle(puddle)
	end

end

local InitialiseChildren = _ismastersim and function(puddle)
	-- print("Init puddle...",puddle)
	for i, pt in ipairs(puddle._children) do
		local ground = _map:GetTile(math.ceil(pt[1] -.5), math.ceil(pt[2] -.5))
		if IsLand(ground) and ground ~= GROUND.IMPASSABLE then
			-- print("Add it")
			-- add it
			local tile = GetTileState(pt[1],pt[2],"flood")
			if not tile or tile.val == nil then
				SetFloodTile(pt[1],pt[2],true)
				tile = GetTileState(pt[1], pt[2], "flood")
			end
			tile.sources = tile.sources or {}
			if not tile.sources[puddle] then
				tile.sources[puddle] = true
				-- table.insert(puddle._children, {pt[1],pt[2]})
			end
		end
	end
end

local SpawnPuddleFromData = _ismastersim and function(data)
	assert( data.x ~= nil and data.y ~= nil )
	data.radius = data.radius or 2
	data._children = data._children or {}

	if _puddle_xy_lookup[data.x] and _puddle_xy_lookup[data.x][data.y] then
		-- print("ALREADY HAS A PUDDLE")
		_puddle_xy_lookup[data.x][data.y].radius = math.max(_puddle_xy_lookup[data.x][data.y].radius, data.radius)
		return false
	else
		print("SPAWN PUDDLE",data.x,data.y)

		table.insert(_puddles, data)
		_puddle_xy_lookup[data.x] = _puddle_xy_lookup[data.x] or {}
		_puddle_xy_lookup[data.x][data.y] = data

		if #data._children > 0 then
			InitialiseChildren(data)
		else
			RefreshPuddle(data, true)
		end
		return true
	end
end

--This takes about 6 guesses to find a valid spot. That doesn't seem to impair performance too much.
--We could assemble a list of valid spots to reduce the time this takes, but that might cause a lagspike.
local TrySpawnRandomPuddle = _ismastersim and function()
	local w,h = _map:GetSize()
	local x = math.random(_mapedge_padding, w *2 - _mapedge_padding) / 2 + .25
	local y = math.random(_mapedge_padding, h *2 - _mapedge_padding) / 2 + .25
	local ground = _map:GetTile(math.ceil(x -.5), math.ceil(y -.5))

	if IsLand(ground) and ground ~= GROUND.IMPASSABLE and not GROUND_FLOORING[ground]
	and IsInIAClimate(Vector3((x - w/2)  * TILE_SCALE, 0, (y - h/2) * TILE_SCALE)) then
		if SpawnPuddleFromData({x=x,y=y}) then
			_nPuddlesLeft = _nPuddlesLeft - 1
			-- print("TrySpawnRandomPuddle success! Left:",_nPuddlesLeft)
		end
	else
		-- print("Failed to TrySpawnRandomPuddle")
	end
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

--For when a sandbag or other floodblocker is removed
local floodblockerremoved =  _ismastersim and function(src, data)
	local bx, by, bz = data.blocker.Transform:GetWorldPosition()
	local x, y = GetTilePt(bx,by,bz)
	-- print("floodblockerremoved",x,y)

	if _blocker_xy_lookup[x] then
		_blocker_xy_lookup[x][y] = nil
		if not next(_blocker_xy_lookup[x]) then
			_blocker_xy_lookup[x] = nil
		end
	end
	-- refresh any puddles touching the affected tile
	-- flood doesn't (usually) survive if it gets blocked, so skip the tile itself
	local puddles = {}
	for _, offset in pairs(_surrounding_offsets) do
		local tile = GetTileState(x + offset[1], y + offset[2], "flood")
		if tile and tile.sources then
			for puddle, _ in pairs(tile.sources) do
				puddles[puddle] = true
			end
		end
	end
	for puddle, _ in pairs(puddles) do
		RefreshPuddle(puddle)
	end
end

local floodblockercreated = _ismastersim and function(src, data)
	local bx, by, bz = data.blocker.Transform:GetWorldPosition()
	local x, y = GetTilePt(bx,by,bz)
	-- print("floodblockercreated",x,y)

	if not _blocker_xy_lookup[x] then
		_blocker_xy_lookup[x] = {}
	end
	_blocker_xy_lookup[x][y] = true
	-- check if flood gets removed
	local tile = GetTileState(x, y, "flood")
	if tile then
		if tile.sources then
			-- inform the puddles
			for puddle, _ in pairs(tile.sources) do
				for i, pt in pairs(puddle._children) do
					if pt[1] == x and pt[2] == y then
						-- print("REMOVE BY BLOCKER",puddle)
						table.remove(puddle._children, i)
						break
					end
				end
				if #puddle._children == 0 then
					RemovePuddle(puddle)
				end
			end
		end
		SetFloodTile(x, y, false)
	end
end

local seasontick = _ismastersim and function(src, data)
	_seasonprogress = data.progress or 0
	_isfloodseason =
		data.season == "spring" and data.progress >= 0.25
		-- or data.season == "summer" and data.progress < 0.25 --summer is not necessarily the next season!
end

local moonphasechanged = _ismastersim and function(src, phase)
	assert( phase ~= nil )
	_maxTide = _moontideheights[ phase ] or 0
end

local precipitation_islandchanged = _ismastersim and function(src, bool)
	_israining = bool
end

local spawnflooddirty = not _ismastersim and function(src, data)
	local w, h = _map:GetSize()
	local x = (data % (w*2)) * .5 + .25
	local y = math.floor(data / (w*2)) * .5 + .25
	print("spawnflooddirty",x,y)
	SetFloodTile(x,y,true)
end

local removeflooddirty = not _ismastersim and function(src, data)
	local w, h = _map:GetSize()
	local x = (data % (w*2)) * .5 + .25
	local y = math.floor(data / (w*2)) * .5 + .25
	print("removeflooddirty",x,y)
	SetFloodTile(x,y,false)
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

--[[ --NETVAR
do
	--try to conserve bandwith by taking the smallest possible netvar (probably net_uint)
	local w, h = _map:GetSize()
	local netvar = w * 2 * h * 2 < 65535 and net_ushortint or net_uint
	_spawnFloodEvent = netvar(inst.GUID, "flooding._spawnFloodEvent","spawnflooddirty")
	_spawnFloodEvent:set_local(0)
	_removeFloodEvent = netvar(inst.GUID, "flooding._removeFloodEvent","removeflooddirty")
	_removeFloodEvent:set_local(0)
end
]]

--Register events
if _ismastersim then
	inst:ListenForEvent("floodblockerremoved", floodblockerremoved, _world)
	inst:ListenForEvent("floodblockercreated", floodblockercreated, _world)
	inst:ListenForEvent("seasontick", seasontick, _world)
	inst:ListenForEvent("moonphasechanged", moonphasechanged, _world)
	inst:ListenForEvent("precipitation_islandchanged", precipitation_islandchanged, _world)
end
--[[ --NETVAR
if not _ismastersim then
	inst:ListenForEvent("spawnflooddirty", spawnflooddirty, _world)
	inst:ListenForEvent("removeflooddirty", removeflooddirty, _world)
end
]]

inst:StartUpdatingComponent(self)

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

--mostly there in case something still tries to use it
function self:GetIsFloodSeason()
	return _isfloodseason
end
function self:SetFloodSettings(maxLevel, frequency)
	_maxFloodLevel = math.min(maxLevel, TUNING.MAX_FLOOD_LEVEL)
	_spawnerFrequency = frequency
end
function self:SetMaxTideModifier(mod)
	_maxTideMod = mod
end


-- NETVAR
function self:AddFloodTile(tile)
	local px, py = GetTilePt(tile.Transform:GetWorldPosition())
	if not _flood_xy_lookup[px] then
		_flood_xy_lookup[px] = {}
	end
	_flood_xy_lookup[px][py] = tile
end
function self:RemoveFloodTile(tile)
	local px, py = GetTilePt(tile.Transform:GetWorldPosition())
	if _flood_xy_lookup[px] then
		_flood_xy_lookup[px][py] = nil
		if not next(_flood_xy_lookup[px]) then
			_flood_xy_lookup[px] = nil
		end
	end
end

function self:P(player)
	print(GetTilePt(player:GetPosition():Get()))
end
function self:IsPointOnFlood(x,y,z)
	local px, py = GetTilePt(x,z)
	local tile = GetTileState(px, py, "flood")
	return tile ~= nil and tile.val
		or _flood_xy_lookup and _flood_xy_lookup[px] and _flood_xy_lookup[px][py] ~= nil -- NETVAR
end
self.OnFlood = self.IsPointOnFlood
-- function self:OnFlood(x,y,z)
	-- return self:IsPointOnFlood(x,y,z)
-- end


if _ismastersim then

--must be entity-coords, not tile coords, radius is optional (2 is default)
function self:SpawnPuddle(x,y,z,radius)
	local px, py = GetTilePt(x,z)

	local ground = _map:GetTile(_map:GetTileCoordsAtPoint(px, 0, py))
	if IsLand(ground) and ground ~= GROUND.IMPASSABLE and not GROUND_FLOORING[ground] then
		-- print("INVALID GROUND FOR PUDDLE")
		return
	else
		SpawnPuddleFromData({
			x = px,
			y = py,
			radius = radius,
		})
	end
end

self.SetPositionPuddleSource = self.SpawnPuddle

end -- _ismastersim

--------------------------------------------------------------------------
--[[ Update ]]
--------------------------------------------------------------------------
local ntries = 0
function self:OnUpdate( dt )

	if _ismastersim then
	--puddle growth is calculated serverside only
		if _isfloodseason then
			local perc = math.max(0, (_seasonprogress - 0.25)/0.75) --Don't spawn floods in the first 1/4 of the season
			_targetPuddleHeight = math.ceil(_maxFloodLevel * perc)
			--There are no puddles in the world? Start spawning them!
			if _israining and _nPuddlesLeft == nil and next(_puddle_xy_lookup) == nil and _spawnerFrequency > 0 then
				local w,h = _map:GetSize()
				_nPuddlesLeft = math.floor(w * .4)
			end
		else
			_targetPuddleHeight = 0
		end

		--Try spawning a puddle
		--Doing this not all at the same tick is probably helpful against local and network lag. -M
		if _nPuddlesLeft then
			ntries = ntries + 1
			TrySpawnRandomPuddle()
			if _nPuddlesLeft <= 0 then
				_nPuddlesLeft = nil
			end
		end

		if #_puddles > 0 then
			for i = #_puddles, 1, -1 do
				local puddle = _puddles[i]

				if _isfloodseason then
					if _israining then --only increase if currently in rain
						puddle.timeSinceIncrease = (puddle.timeSinceIncrease or 0) + dt
						if puddle.timeSinceIncrease > _timeBetweenFloodIncreases then
							puddle.timeSinceIncrease = 0
							if puddle.radius < _targetPuddleHeight then
								puddle.radius = puddle.radius + 1
								RefreshPuddle(puddle)
							end
						end
					end
				else
					--Dry the puddles away!
					puddle.timeSinceDecrease = (puddle.timeSinceDecrease or 0) + dt
					if puddle.timeSinceDecrease > _timeBetweenFloodDecreases then
						-- print("DRY!",puddle)
						puddle.timeSinceDecrease = 0
						puddle.radius = math.max(puddle.radius - 1, 0)
						RefreshPuddle(puddle)
						if puddle.radius <= 0 then
							RemovePuddle(i)
						end
					end
				end
			end
		end
	end -- _ismastersim

	--Tides stuff
	-- local currentHeight = GetWorld().Flooding:GetTargetDepth()
	-- local newHeight = self:GetTideHeight()
	-- GetWorld().Flooding:SetTargetDepth(newHeight)

	-- if newHeight < currentHeight then
		-- --Flood receding
	-- end

	-- if newHeight == 0 and GetIsFloodSeason() then
		-- self:SwitchMode("flood")
	-- end

	-- self.inst:PushEvent("floodChange")
end

function self:LongUpdate(dt)
	self:OnUpdate(dt)
end

--------------------------------------------------------------------------
--[[ Save/Load ]]
--------------------------------------------------------------------------

if _ismastersim then

function self:OnSave()
	local data = {}

	data._targetPuddleHeight = _targetPuddleHeight
	data._nPuddlesLeft = _nPuddlesLeft

	-- if #_puddles > 0 then
		-- data._puddles = {}
		-- for i, puddle in pairs(_puddles) do
			-- table.insert(data._puddles,{x=puddle.x,y=puddle.y,radius=puddle.radius})
		-- end
	-- end
	data._puddles = _puddles

	return data
end

function self:OnLoad(data)
	if data ~= nil then

		_targetPuddleHeight = data._targetPuddleHeight or 0
		_nPuddlesLeft = data._nPuddlesLeft

		if data._puddles then
			-- local w, h = _map:GetSize()
			for i, puddle in pairs(data._puddles) do
				-- self:SpawnPuddle((puddle.x - w/2)  * TILE_SCALE, 0, (puddle.y - h/2) * TILE_SCALE, puddle.radius)
				SpawnPuddleFromData(puddle)
			end
		end

	end
end

end -- _ismastersim

--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
	return string.format("tides: %d/%d, max %d, mod %d", _currentTide, _targetTide, _maxTide, _maxTideMod)
end

function self:ShowPuddles()
	--shows all puddles on the map, as rawling
	for x, dy in pairs(_puddle_xy_lookup) do
		for y, puddle in pairs(dy) do
			if puddle._children and #puddle._children > 0 then
				local minimap = GetTileState(puddle._children[1][1],puddle._children[1][2],"flood").inst.entity:AddMiniMapEntity()
				minimap:SetIcon( "rawling.tex" )
			end
		end
	end
end

--------------------------------------------------------------------------

end)
%%+%%scripts/components/floodmosquitospawner.lua%%-%%--------------------------------------------------------------------------
--[[ FloodMosquitoSpawner class definition ]]
-- based on ButterflySpawner
--------------------------------------------------------------------------

return Class(function(self, inst)

assert(TheWorld.ismastersim, "FloodMosquitoSpawner should not exist on client")

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst

--Private
local _activeplayers = {}
local _scheduledtasks = {}
local _worldstate = TheWorld.state
local _updating = false
local _mosquitos = {}
local _maxmosquitos = 3

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function GetSpawnPoint(player)
	--Since flood tiles are prefabs in the current implementation, we can use the ButterflySpawner code instead.
	--[[
	for i = 5, 20, 2 do
		local rad = i
		local x,y,z = spawnerinst.Transform:GetWorldPosition()
		local mindistance = 10
		local pt = Vector3(x,y,z)

		local theta = 360 * math.random()
		local result_offset = FindValidPositionByFan(theta, rad, 10, function(offset)
			local spawn_point = pt + offset
			if offset:Length() < mindistance then 
				return false 
			end

			if not self.inst:IsPosSurroundedByLand(spawn_point.x, spawn_point.y, spawn_point.z, 3) then 
				return false
			end 

			if IsOnFlood(spawn_point.x, spawn_point.y, spawn_point.z) then
				return true 
			end 

			return false

		end)
		if result_offset then
			return pt + result_offset
		end
	end
	]]
	local rad = 20
	local mindistance = 10
	local x, y, z = player.Transform:GetWorldPosition()
	local floodtiles = TheSim:FindEntities(x, y, z, rad)

	for i, v in ipairs(floodtiles) do
		while v ~= nil and (v.prefab ~= "flood" or player:GetDistanceSqToInst(v) <= mindistance) do
			table.remove(floodtiles, i)
			v = floodtiles[i]
		end
	end

	return next(floodtiles) ~= nil and floodtiles[math.random(1, #floodtiles)] or nil
end

local function SpawnMosquitoForPlayer(player, reschedule)
	local pt = player:GetPosition()
	local ents = TheSim:FindEntities(pt.x, pt.y, pt.z, 64, { "mosquito" })
	if #ents < _maxmosquitos then
		local spawnflood = GetSpawnPoint(player)
		if spawnflood ~= nil then
			local mosquito = SpawnPrefab("mosquito_poison")
			-- mosquito.components.homeseeker:SetHome(spawnflood)
			mosquito.Physics:Teleport(spawnflood.Transform:GetWorldPosition())
			--friendly code to make tightly-knit groups feel less besieged -M
			local mpt = mosquito:GetPosition()
			local player_ents = TheSim:FindEntities(mpt.x, mpt.y, mpt.z, 64, { "player" })
			for i, other_player in pairs(player_ents) do
				if other_player ~= player and _scheduledtasks[other_player] then
					_scheduledtasks[other_player]:Cancel()
					_scheduledtasks[other_player] = nil
					reschedule(other_player)
				end
			end
		end
	end
	_scheduledtasks[player] = nil
	reschedule(player)
end

local function ScheduleSpawn(player, initialspawn)
	if _scheduledtasks[player] == nil then
		local basedelay = initialspawn and 20 or 50
		_scheduledtasks[player] = player:DoTaskInTime(basedelay + math.random() * 20, SpawnMosquitoForPlayer, ScheduleSpawn)
	end
end

local function CancelSpawn(player)
	if _scheduledtasks[player] ~= nil then
		_scheduledtasks[player]:Cancel()
		_scheduledtasks[player] = nil
	end
end

local function ToggleUpdate(force)
	--SW has seasonprogress > .5, but updates every tick, so effectively the same as >= .5
	if _worldstate.isspring and (_worldstate.seasonprogress or 0) >= .5 and _maxmosquitos > 0 then
		if not _updating then
			_updating = true
			for i, v in ipairs(_activeplayers) do
				ScheduleSpawn(v, true)
			end
		elseif force then
			for i, v in ipairs(_activeplayers) do
				CancelSpawn(v)
				ScheduleSpawn(v, true)
			end
		end
	elseif _updating then
		_updating = false
		for i, v in ipairs(_activeplayers) do
			CancelSpawn(v)
		end
	end
end

local function SetMaxMosquitos(max)
	_maxmosquitos = max
	ToggleUpdate(true)
end

local function AutoRemoveTarget(inst, target)
	if _mosquitos[target] ~= nil and target:IsAsleep() then
		target:Remove()
	end
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function OnTargetSleep(target)
	inst:DoTaskInTime(0, AutoRemoveTarget, target)
end

local function OnPlayerJoined(src, player)
	for i, v in ipairs(_activeplayers) do
		if v == player then
			return
		end
	end
	table.insert(_activeplayers, player)
	if _updating then
		ScheduleSpawn(player, true)
	end
end

local function OnPlayerLeft(src, player)
	for i, v in ipairs(_activeplayers) do
		if v == player then
			CancelSpawn(player)
			table.remove(_activeplayers, i)
			return
		end
	end
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

--Initialize variables
for i, v in ipairs(AllPlayers) do
	table.insert(_activeplayers, v)
end

--Register events
-- inst:WatchWorldState("isspring", ToggleUpdate)
inst:WatchWorldState("seasonprogress", ToggleUpdate)
inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)

--------------------------------------------------------------------------
--[[ Post initialization ]]
--------------------------------------------------------------------------

function self:OnPostInit()
	ToggleUpdate(true)
end

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

function self:SpawnModeNever()
	SetMaxMosquitos(0)
end

function self:SpawnModeHeavy()
	SetMaxMosquitos(6)
end

function self:SpawnModeMed()
	SetMaxMosquitos(4)
end

function self:SpawnModeLight()
	SetMaxMosquitos(2)
end

function self.StartTrackingFn(target)
	if _mosquitos[target] == nil then
		local restore = target.persists -- and 1 or 0
		target.persists = false
		-- if target.components.homeseeker == nil then
			-- target:AddComponent("homeseeker")
		-- else
			-- restore = restore + 2
		-- end
		_mosquitos[target] = restore
		inst:ListenForEvent("entitysleep", OnTargetSleep, target)
	end
end

function self:StartTracking(target)
	self.StartTrackingFn(target)
end

function self.StopTrackingFn(target)
	local restore = _mosquitos[target]
	if restore ~= nil then
		target.persists = restore -- == 1 or restore == 3
		-- if restore < 2 then
			-- target:RemoveComponent("homeseeker")
		-- end
		_mosquitos[target] = nil
		inst:RemoveEventCallback("entitysleep", OnTargetSleep, target)
	end
end

function self:StopTracking(target)
	self.StopTrackingFn(target)
end

--------------------------------------------------------------------------
--[[ Save/Load ]]
--------------------------------------------------------------------------

function self:OnSave()
	return 
	{
		maxmosquitos = _maxmosquitos,
	}
end

function self:OnLoad(data)
	_maxmosquitos = data.maxmosquitos or 3

	-- ToggleUpdate(true)
end

--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
	local nummosquitos = 0
	for k, v in pairs(_mosquitos) do
		nummosquitos = nummosquitos + 1
	end
	return string.format("updating:%s mosquitos:%d/%d", tostring(_updating), nummosquitos, _maxmosquitos)
end

--------------------------------------------------------------------------
--[[ End ]]
--------------------------------------------------------------------------

end)
%%+%%scripts/components/flotsamspawner.lua%%-%%--Spawns flotsam periodically based on the health of the boat.
--Requires entity to have "boat health" component to work!

local function onhealthchange(inst, data)
    local spawner = inst.components.flotsamspawner

    if data.oldpercent > spawner.start_threshold and
    data.percent <= spawner.start_threshold then
        spawner:StartUpdating()
    elseif data.oldpercent <= spawner.start_threshold and
    data.percent > spawner.start_threshold then
        spawner:StopUpdating()
    end
end

local function embarked(inst, data)
    local percent = inst.components.boathealth:GetPercent()

    if percent <= inst.components.flotsamspawner.start_threshold then
        inst.components.flotsamspawner:StartUpdating()
    end
end

local function disembarked(inst, data)
    inst.components.flotsamspawner:StopUpdating()   
end

local FlotsamSpawner = Class(function(self, inst)
    self.inst = inst

    self.updateperiod = 1
    self.start_threshold = 0.5

    --As health goes from start_threshold -> 0 the values used lerp from max -> min
    self.max_spawndist = 150
    self.min_spawndist = 20

    self.last_pos = nil
    self.distance_traveled = 0

    self.flotsamprefab = "flotsam_rowboat" --"flotsam", is alot more tricky to implement, when its basegame usage, wont be used for a long time, if ever.

    self.inst:ListenForEvent("embarked", embarked)
    self.inst:ListenForEvent("disembarked", disembarked)
    self.inst:ListenForEvent("boathealthchange", onhealthchange)
end)

function FlotsamSpawner:StartUpdating()

    if self.updatetask then
        print("Tried to start update task in FlotsamSpawner when it already has one!")
        return
    end

    self:Spawn()

    self.updatetask = self.inst:DoPeriodicTask(self.updateperiod, function() self:OnUpdate() end)

end

function FlotsamSpawner:StopUpdating()
    if not self.updatetask then return end

    self.updatetask:Cancel()
    self.updatetask = nil
end

function FlotsamSpawner:CanSpawnFlotsam()   

    if not self.inst:GetIsOnWater() then
        return false 
    end
    if self.inpocket then
        return false
    end
    return true
end

function FlotsamSpawner:Spawn()
    self.distance_traveled = 0

    if not self:CanSpawnFlotsam() then return end

    local debris = SpawnPrefab(self.flotsamprefab)
    debris.Transform:SetPosition(self.inst:GetPosition():Get())
    local angle = math.random(-180, 180)*DEGREES
    local sp = math.random()*4+2
    debris.Physics:SetVel(sp*math.cos(angle), 0, sp*math.sin(angle))
end

function FlotsamSpawner:OnUpdate()
    local new_pos = self.inst:GetPosition()

    local distance_delta = new_pos:Dist(self.last_pos or self.inst:GetPosition())

    self.distance_traveled = self.distance_traveled + distance_delta
    self.last_pos = new_pos

    local percent = self.inst.replica.boathealth:GetPercent()
    percent = math.clamp(percent, 0, self.start_threshold)

    local t = percent/self.start_threshold

    local distThresh = Lerp(self.min_spawndist, self.max_spawndist, t)

    if self.distance_traveled >= distThresh then
        self:Spawn()
    end
end

function FlotsamSpawner:OnSave()
    local data = {}
    if self.inpocket then
        data.inpocket = true
    end
    return data
end

function FlotsamSpawner:OnLoad(data)
    if data then
        if data.inpocket == true then
            self.inpocket = true
        end
    end
end


return FlotsamSpawner%%+%%scripts/components/geyserfx.lua%%-%%local STATE_IDLE = 0
local STATE_BURN = 1
local STATE_EXTINGUISH = 2
local STATE_IGNITE = 3

local function onlightradius(self, radius)
  self.inst.Light:SetRadius(radius)
  self.inst.replica.geyserfx:SetRadius(radius)
end

local function onlightintensity(self, intensity)
  self.inst.Light:SetIntensity(intensity)
  self.inst.replica.geyserfx:SetIntensity(intensity)
end

local function onlightfalloff(self, falloff)
  self.inst.Light:SetFalloff(falloff)
  self.inst.replica.geyserfx:SetFalloff(falloff)
end

local function onlightrgb(self, rgb)
  self.inst.Light:SetColour(rgb[1], rgb[2], rgb[3])
  self.inst.replica.geyserfx:SetColour(rgb)
end

local GeyserFX = Class(function(self, inst)
    self.inst = inst
    self.state = STATE_BURN
    self.level = nil
    self.playingsound = nil
    self.levels = {}
    self.pre = {}
    self.pst = {}
    self.usedayparamforsound = false
    self.current_radius = 1
    self.lightsound = nil
    self.extinguishsound = nil

    self.radius = 0
    self.intensity = 0
    self.falloff = 0
    self.rgb = { 0, 0, 0}

    inst:DoTaskInTime(0, function()
        if not self.inst:IsAsleep() then
          self.inst:StartUpdatingComponent(self) 
        end
      end)
  end,
  nil,
  {
    radius = onlightradius,
    intensity = onlightintensity,
    falloff = onlightfalloff,
    rgb = onlightrgb,
  })

function GeyserFX:OnEntitySleep()
  self.inst:StopUpdatingComponent(self)
end

function GeyserFX:OnEntityWake()
  self.inst:StartUpdatingComponent(self) 
end

local sin = math.sin
local gettime = GetTime

function GeyserFX:SetPercentInternal(levels, p, loop)
  local percent = math.clamp(p, 0.0, 1.0)

  local la = 1
  local lb = #levels
  for i = 1, #levels, 1 do
    if levels[i].percent >= percent and levels[i].percent < levels[la].percent then la = i end
    if levels[i].percent <= percent and levels[i].percent > levels[lb].percent then lb = i end
  end

  la = math.max(la, 1)
  lb = math.min(lb, #levels)
  local levela = levels[la]
  local levelb = levels[lb]

  if levela ~= self.level then
    self.level = levela
    if levela.anim then
      self.inst.AnimState:PlayAnimation(levela.anim, loop)
    end
  end

  local t = 0.0
  if levela ~= levelb then
    t = (levelb.percent - percent) / (levelb.percent - levela.percent)
  end
  self.current_radius = Lerp(levelb.radius, levela.radius, t)

  self.radius = self.current_radius
  self.intensity = Lerp(levelb.intensity, levela.intensity, t)
  self.falloff = Lerp(levelb.falloff, levela.falloff, t)
  self.rgb = { Lerp(levelb.colour[1], levela.colour[1], t), Lerp(levelb.colour[2], levela.colour[2], t), Lerp(levelb.colour[3], levela.colour[3], t) }
  --print("levela", levela.percent, levela.intensity, levela.radius, levela.falloff)
  --print("levelb", levelb.percent, levelb.intensity, levelb.radius, levelb.falloff)
  --print("geyser", percent, t, intensity, radius, falloff)

  self.inst.Light:Enable(true)

  if self.playingsound ~= levela.sound then
    if self.playingsound then
      self.inst.SoundEmitter:KillSound(self.playingsound)
      self.playingsound = nil
    end
    if levela.sound then
      self.playingsound = levela.sound
      self.inst.SoundEmitter:PlaySound(levela.sound, "fire")
    end
  end

  if levela.soundintensity or levelb.soundintensity then
    local soundintensity = Lerp(levela.soundintensity or 0, levelb.soundintensity or 0, t)
    self.inst.SoundEmitter:SetParameter("fire", "intensity", soundintensity)
  end
end

function GeyserFX:SetPrePercent(percent)
  self.state = STATE_IGNITE
  self.inst:StartUpdatingComponent(self)
  self:SetPercentInternal(self.pre, percent, false)
end

function GeyserFX:SetPercent(percent)
  self.state = STATE_BURN
  self:SetPercentInternal(self.levels, percent, true)
end

function GeyserFX:SetPstPercent(percent)
  self.state = STATE_EXTINGUISH
  self:SetPercentInternal(self.pst, percent, false)
end

function GeyserFX:OnUpdate(dt)
  if self.state == STATE_IGNITE then
    local percent = 1.0 - (self.inst.AnimState:GetCurrentAnimationTime()/self.inst.AnimState:GetCurrentAnimationLength())
    self:SetPrePercent(percent)
    if self.inst.AnimState:AnimDone() then
      if self.inst.OnBurn then
        self.inst:OnBurn()
      end
      self.state = STATE_BURN
    end
  elseif self.state == STATE_EXTINGUISH then
    local percent = 1.0 - (self.inst.AnimState:GetCurrentAnimationTime()/self.inst.AnimState:GetCurrentAnimationLength())
    self:SetPstPercent(percent)
    if self.inst.AnimState:AnimDone() then
      if self.inst.OnIdle then
        self.inst:OnIdle()
      end
      self.state = STATE_IDLE
    end
  end

  local time = gettime()*30
  local flicker = ( sin( time ) + sin( time + 2 ) + sin( time + 0.7777 ) ) / 2.0 -- range = [-1 , 1]
  flicker = ( 1.0 + flicker ) / 2.0 -- range = 0:1
  self.radius = self.current_radius + flicker*.05

  if self.usedayparamforsound then
    local isday = TheWorld.state.isday
    if isday ~= self.isday then
      self.isday = isday
      local val = isday and 1 or 2
      self.inst.SoundEmitter:SetParameter( "fire", "daytime", val )
    end
  end
end

function GeyserFX:Ignite()
  if self.lightsound then
    self.inst.SoundEmitter:PlaySound(self.lightsound)
  end
  self:SetPrePercent(1.0)
end

--- Kill the fx.
function GeyserFX:Extinguish()
  self.inst.SoundEmitter:KillSound("fire")
  if self.extinguishsound then
    self.inst.SoundEmitter:PlaySound(self.extinguishsound)
  end
  self:SetPstPercent(1.0)
end

return GeyserFX
%%+%%scripts/components/geyserfx_replica.lua%%-%%local function onradiusdirty(inst)
  inst.Light:SetRadius(inst._lightradius:value())
end

local function onintensitydirty(inst)
  inst.Light:SetIntensity(inst._lightintensity:value()/100)
end

local function onfalloffdirty(inst)
  inst.Light:SetFalloff(inst._lightfalloff:value()/100)
end

local function onlightcolordirty(inst)
  inst.Light:SetColour(inst._lightred:value()/255, inst._lightgreen:value()/255, inst._lightblue:value()/255)
end

local GeyserFX = Class(function(self, inst)
    self.inst = inst

    self.inst._lightradius = net_smallbyte(inst.GUID, "geyserfx._lightradius", "radiusdirty")
    self.inst._lightintensity = net_byte(inst.GUID, "geyserfx._lightintensity", "intensitydirty")
    self.inst._lightfalloff = net_byte(inst.GUID, "geyserfx._lightfalloff", "falloffdirty")
    self.inst._lightred = net_byte(inst.GUID, "geyserfx._lightred")
    self.inst._lightgreen = net_byte(inst.GUID, "geyserfx._lightgreen")
    self.inst._lightblue = net_byte(inst.GUID, "geyserfx._lightblue")
    self.inst._lightcolordirty = net_event(inst.GUID, "geyserfx._lightcolordirty")

    self.inst:ListenForEvent("radiusdirty", onradiusdirty)
    self.inst:ListenForEvent("intensitydirty", onintensitydirty)
    self.inst:ListenForEvent("falloffdirty", onfalloffdirty)
    self.inst:ListenForEvent("geyserfx._lightcolordirty", onlightcolordirty)
  end)

function GeyserFX:SetRadius(radius)
  self.inst._lightradius:set(radius)
end

function GeyserFX:SetIntensity(intensity)
  self.inst._lightintensity:set(intensity*100)
end

function GeyserFX:SetFalloff(falloff)
  self.inst._lightfalloff:set(falloff*100)
end

function GeyserFX:SetColour(rgb)
  self.inst._lightred:set(rgb[1]*255)
  self.inst._lightgreen:set(rgb[2]*255)
  self.inst._lightblue:set(rgb[3]*255)
  self.inst._lightcolordirty:push()
end

return GeyserFX%%+%%scripts/components/hackable.lua%%-%%local function onhackable(self)
    if self.canbehacked and self.caninteractwith then
        self.inst:AddTag("hack_workable")
    else
        self.inst:RemoveTag("hack_workable")
    end
end

local function oncyclesleft(self, cyclesleft)
    if cyclesleft == 0 then
        self.inst:AddTag("barren")
    else
        self.inst:RemoveTag("barren")
    end
end

local Hackable = Class(function(self, inst)
    self.inst = inst
    self.canbehacked = nil
    self.regentime = nil
    self.baseregentime = nil
    self.product = nil
    self.onregenfn = nil
    self.onhackedfn = nil
    self.onfinishfn = nil
    self.makeemptyfn = nil
    self.makefullfn = nil
    self.cycles_left = nil
    self.max_cycles = nil
    self.transplanted = false
    self.caninteractwith = true
    self.numtoharvest = 1
    self.wildfirestarter = false
	
    self.hacksleft = 1
    self.maxhacks = 1

    self.drophacked = IA_CONFIG.droplootground or nil
    self.dropheight = nil

    self.paused = false
    self.pause_time = 0
    self.targettime = nil

    self.protected_cycles = nil
    self.task = nil
end,
nil,
{
    canbehacked = onhackable,
    caninteractwith = onhackable,
    cycles_left = oncyclesleft,
})

function Hackable:OnRemoveFromEntity()
    if self.task ~= nil then
        self.task:Cancel()
        self.task = nil
    end

    self.inst:RemoveTag("hack_workable")
    self.inst:RemoveTag("barren")
end

local function OnRegen(inst)
    inst.components.hackable:Regen()
end

function Hackable:LongUpdate(dt)
    if not self.paused and self.targettime ~= nil and not self.inst:HasTag("withered") then
        if self.task ~= nil then 
            self.task:Cancel()
            self.task = nil
        end

        local time = GetTime()
        if self.targettime > time + dt then
            --resechedule
            local time_to_hackable = self.targettime - time - dt
            if TheWorld.state.isspring then
                time_to_hackable = time_to_hackable * TUNING.SPRING_GROWTH_MODIFIER
            end
            self.task = self.inst:DoTaskInTime(time_to_hackable, OnRegen)
            self.targettime = time + time_to_hackable
        else
            --become hackable right away
            self:Regen()
        end
    end
end

function Hackable:IsWildfireStarter()
    return self.wildfirestarter == true or self.inst:HasTag("withered")
end

function Hackable:FinishGrowing()
    if self.task ~= nil and not (self.canbehacked or self.inst:HasTag("withered")) then
        self.task:Cancel()
        self.task = nil
        self:Regen()
    end
end

function Hackable:Resume()
    if self.paused then
        self.paused = false
        if not (self.canbehacked or self:IsBarren()) then
            if self.pause_time ~= nil then
                if TheWorld.state.isspring then
                    self.pause_time = self.pause_time * TUNING.SPRING_GROWTH_MODIFIER
                end
                if self.task ~= nil then
                    self.task:Cancel()
                end
                self.task = self.inst:DoTaskInTime(self.pause_time, OnRegen)
                self.targettime = GetTime() + self.pause_time
            else
                self:MakeEmpty()
            end
        end
    end
end

function Hackable:Pause()
    if not self.paused then
        self.paused = true
        self.pause_time = self.targettime ~= nil and math.max(0, self.targettime - GetTime()) or nil

        if self.task ~= nil then
            self.task:Cancel()
            self.task = nil
        end
    end
end

function Hackable:GetDebugString()
    local time = GetTime()
    local str = ""
    if self.caninteractwith then
        str = str.."caninteractwith "
    end
    if self.paused then
        str = str.."paused "
        if self.pause_time ~= nil then
            str = str..string.format("%2.2f ", self.pause_time)
        end
    end
    if not self.transplanted then
        str = str.."Not transplanted "
    elseif self.max_cycles ~= nil and self.cycles_left ~= nil then
        str = str..string.format("transplated; cycles: %d/%d ", self.cycles_left, self.max_cycles)
    end
    if self.protected_cycles ~= nil and self.protected_cycles > 0 then
        str = str..string.format("protected cycles: %d ", self.protected_cycles)
    end
    if self.targettime ~= nil and self.targettime > time then
        str = str..string.format("Regen in: %.2f ", self.targettime - time)
    end
    return str
end

function Hackable:SetUp(product, regen, number)
    self.canbehacked = true
    self.product = product
    self.baseregentime = regen
    self.regentime = regen
    self.numtoharvest = number or 1
end

-------------------------------------------------------------------------------
--V2C: Sadly, these weren't being used most of the time
--     so for consitency, don't use them anymore -__ -"
--     Keeping them around in case MODs were using them
--Mobb: Y-Yeah! What he said!
function Hackable:SetOnHackedFn(fn)
    self.onhackedfn = fn
end

function Hackable:SetOnRegenFn(fn)
    self.onregenfn = fn
end

function Hackable:SetMakeBarrenFn(fn)
    self.makebarrenfn = fn
end

function Hackable:SetMakeEmptyFn(fn)
    self.makeemptyfn = fn
end
-------------------------------------------------------------------------------

function Hackable:CanBeFertilized()
    return self:IsBarren() or self.inst:HasTag("withered")
end

function Hackable:ChangeProduct(newProduct)
    self.product = newProduct
end

function Hackable:Fertilize(fertilizer, doer)
    if self.inst.components.burnable ~= nil then
        self.inst.components.burnable:StopSmoldering()
    end

    local fertilize_cycles = 0
    if fertilizer.components.fertilizer ~= nil then
        if doer ~= nil and
            doer.SoundEmitter ~= nil and
            fertilizer.components.fertilizer.fertilize_sound ~= nil then
            doer.SoundEmitter:PlaySound(fertilizer.components.fertilizer.fertilize_sound)
        end
        fertilize_cycles = fertilizer.components.fertilizer.withered_cycles
    end

    if fertilizer.components.finiteuses ~= nil then
        fertilizer.components.finiteuses:Use()
    else
        fertilizer.components.stackable:Get():Remove()
    end

    self.cycles_left = self.max_cycles

    if self.inst.components.witherable ~= nil then
        self.protected_cycles = (self.protected_cycles or 0) + fertilize_cycles
        if self.protected_cycles <= 0 then
            self.protected_cycles = nil
        end

        self.inst.components.witherable:Enable(self.protected_cycles == nil)
        if self.inst.components.witherable:IsWithered() then
            self.inst.components.witherable:ForceRejuvenate()
        else
            self:MakeEmpty()
        end
    else
        self:MakeEmpty()
    end
end

function Hackable:OnSave()
    local data =
    {
        protected_cycles = self.protected_cycles,
        hacked = not self.canbehacked and true or nil,
        transplanted = self.transplanted and true or nil,
        paused = self.paused and true or nil,
        caninteractwith = self.caninteractwith and true or nil,
		-- hacksleft = self.hacksleft,
    }

    if self.cycles_left ~= self.max_cycles then
        data.cycles_left = self.cycles_left
        data.max_cycles = self.max_cycles
    end

    if self.pause_time ~= nil and self.pause_time > 0 then
        data.pause_time = self.pause_time
    end

    if self.targettime ~= nil then
        local time = GetTime()
        if self.targettime > time then
            data.time = math.floor(self.targettime - time)
        end
    end

    return next(data) ~= nil and data or nil
end

function Hackable:OnLoad(data)
    self.transplanted = data.transplanted or false
    self.cycles_left = data.cycles_left or self.cycles_left
    self.max_cycles = data.max_cycles or self.max_cycles
	self.hacksleft = data.hacksleft or self.hacksleft

    if data.hacked or data.time ~= nil then
        if self:IsBarren() and self.makebarrenfn ~= nil then
            self.makebarrenfn(self.inst, true)
        elseif self.makeemptyfn ~= nil then
            self.makeemptyfn(self.inst)
        end
        self.canbehacked = false
    else
        if self.makefullfn ~= nil then
            self.makefullfn(self.inst)
        end
        self.canbehacked = true
    end

    if data.caninteractwith then
        self.caninteractwith = data.caninteractwith
    end

    if data.paused then
        self.paused = true
        self.pause_time = data.pause_time
        if self.task ~= nil then
            self.task:Cancel()
            self.task = nil
        end
    elseif data.time ~= nil then
        if self.task ~= nil then
            self.task:Cancel()
        end
        self.task = self.inst:DoTaskInTime(data.time, OnRegen)
        self.targettime = GetTime() + data.time
    end

    if data.makealwaysbarren == 1 and self.makebarrenfn ~= nil then
        self:MakeBarren()
    end

    self.protected_cycles = data.protected_cycles ~= nil and data.protected_cycles > 0 and data.protected_cycles or nil
    if self.inst.components.witherable ~= nil then
        self.inst.components.witherable:Enable(self.protected_cycles == nil)
    end
end

function Hackable:IsBarren()
    return self.cycles_left == 0
end

function Hackable:CanBeHacked()
    return self.canbehacked
end

function Hackable:Regen()
    self.canbehacked = true
    self.hacksleft = self.maxhacks
    if self.onregenfn ~= nil then
        self.onregenfn(self.inst)
    end
    if self.makefullfn ~= nil then
        self.makefullfn(self.inst)
    end
    self.targettime = nil
    self.task = nil
end

function Hackable:MakeBarren()
    self.cycles_left = 0

    local wasempty = not self.canbehacked
    self.canbehacked = false

    if self.task ~= nil then
        self.task:Cancel()
        self.task = nil
    end

    if self.makebarrenfn ~= nil then
        self.makebarrenfn(self.inst, wasempty)
    end
end

function Hackable:OnTransplant()
    self.transplanted = true

    if self.ontransplantfn ~= nil then
        self.ontransplantfn(self.inst)
    end
end

function Hackable:MakeEmpty()
    if self.task ~= nil then
        self.task:Cancel()
        self.task = nil
    end

    if self.makeemptyfn ~= nil then
        self.makeemptyfn(self.inst)
    end

    self.canbehacked = false

    if not self.paused and self.baseregentime ~= nil then
        local time = self.baseregentime
        if self.getregentimefn ~= nil then
            time = self.getregentimefn(self.inst)
        end
        if TheWorld.state.isspring then
            time = time * TUNING.SPRING_GROWTH_MODIFIER
        end

        self.task = self.inst:DoTaskInTime(time, OnRegen)
        self.targettime = GetTime() + time
    end
end

function Hackable:Hack(hacker, numworks)
    if self.canbehacked and self.caninteractwith then
		
    	self.hacksleft = self.hacksleft - numworks 
    	--Check work left here and fire callback and early out if there's still more work to do 
    	 if self.onhackedfn then
            self.onhackedfn(self.inst, hacker, self.hacksleft)
        end

        if(self.hacksleft <= 0) then
			if self.transplanted and self.cycles_left ~= nil then
				self.cycles_left = math.max(0, self.cycles_left - 1)
			end

			if self.protected_cycles ~= nil then
				self.protected_cycles = self.protected_cycles - 1
				if self.protected_cycles < 0 then
					self.protected_cycles = nil
					if self.inst.components.witherable ~= nil then
						self.inst.components.witherable:Enable(true)
					end
				end
			end

			local loot = nil
			if self.product ~= nil then
				if hacker ~= nil and hacker.components.inventory ~= nil and not self.drophacked then
					loot = SpawnPrefab(self.product)
					if loot ~= nil then
						if loot.components.inventoryitem ~= nil then
							loot.components.inventoryitem:InheritMoisture(TheWorld.state.wetness, TheWorld.state.iswet)
						end
						if self.numtoharvest > 1 and loot.components.stackable ~= nil then
							loot.components.stackable:SetStackSize(self.numtoharvest)
						end
						hacker:PushEvent("hacksomething", { object = self.inst, loot = loot })
						hacker.components.inventory:GiveItem(loot, nil, self.inst:GetPosition())
					end
				elseif self.inst.components.lootdropper ~= nil then
					local num = self.numtoharvest or 1
					local pt = self.inst:GetPosition()
					pt.y = pt.y + (self.dropheight or 0)
					for i = 1, num do
						self.inst.components.lootdropper:SpawnLootPrefab(self.product, pt)
					end
				end
			end

			if self.onfinishfn ~= nil then
				self.onfinishfn(self.inst, hacker, loot)
			end

			self.canbehacked = false

			if self.baseregentime ~= nil and not (self.paused or self:IsBarren() or self.inst:HasTag("withered")) then
				if TheWorld.state.isspring then
					self.regentime = self.baseregentime * TUNING.SPRING_GROWTH_MODIFIER
				end

				if self.task ~= nil then
					self.task:Cancel()
				end
				self.task = self.inst:DoTaskInTime(self.regentime, OnRegen)
				self.targettime = GetTime() + self.regentime
			end

			self.inst:PushEvent("hacked", { hacker = hacker, loot = loot, plant = self.inst })
		end
    end
end

return Hackable
%%+%%scripts/components/hailrain.lua%%-%%--Based on Frograin

return Class(function(self, inst)

assert(TheWorld.ismastersim, "HailRain should not exist on client")

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst

--Private
local _activeplayers = {}
local _scheduledtasks = {}
local _worldstate = TheWorld.state
local _map = TheWorld.Map
local _updating = false

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function GetSpawnPoint(pt)
    local function TestSpawnPoint(offset)
        local spawnpoint = pt + offset
        return _map:IsPassableAtPoint(spawnpoint:Get()) and IsInClimate(spawnpoint, "island")
    end

    local theta = math.random() * 2 * PI
    local radius = math.random() * 20 --range taken from SW prefabs/hail.lua
    local resultoffset = FindValidPositionByFan(theta, radius, 12, TestSpawnPoint)

    if resultoffset ~= nil then
        return pt + resultoffset
    end
end

local function SpawnHailForPlayer(player, reschedule)
    local pt = player:GetPosition()
	if IsInClimate(player, "island") then
		local spawn_point = GetSpawnPoint(pt)
		if spawn_point ~= nil then
			SpawnPrefab("hail_ice"):StartFalling(spawn_point.x, spawn_point.y, spawn_point.z)
			--mean code to make tightly-knit groups gain less ice -M
			local player_ents = TheSim:FindEntities(spawn_point.x, spawn_point.y, spawn_point.z, 64, { "player" })
			for i, other_player in pairs(player_ents) do
				if other_player ~= player and _scheduledtasks[other_player] then
					_scheduledtasks[other_player]:Cancel()
					_scheduledtasks[other_player] = nil
					reschedule(other_player)
				end
			end
		end
	end
    _scheduledtasks[player] = nil
    reschedule(player)
end

local function ScheduleSpawn(player)
    if _scheduledtasks[player] == nil then
		local _spawntime = 2 / (TheWorld.state.islandprecipitationrate * 3)
        _scheduledtasks[player] = player:DoTaskInTime(_spawntime, SpawnHailForPlayer, ScheduleSpawn)
    end
end

local function CancelSpawn(player)
    if _scheduledtasks[player] ~= nil then
        _scheduledtasks[player]:Cancel()
        _scheduledtasks[player] = nil
    end
end

local function ToggleUpdate(force)
    if _worldstate.hurricane and _worldstate.islandisraining then
        if not _updating then
            _updating = true
            for i, v in ipairs(_activeplayers) do
                ScheduleSpawn(v, true)
            end
        elseif force then
            for i, v in ipairs(_activeplayers) do
                CancelSpawn(v)
                ScheduleSpawn(v, true)
            end
        end
    elseif _updating then
        _updating = false
        for i, v in ipairs(_activeplayers) do
            CancelSpawn(v)
        end
    end
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function OnIsRaining(inst, israining)
    ToggleUpdate()
end

local function OnPlayerJoined(src, player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            return
        end
    end
    table.insert(_activeplayers, player)
    if _updating then
        ScheduleSpawn(player, true)
    end
end

local function OnPlayerLeft(src, player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            CancelSpawn(player)
            table.remove(_activeplayers, i)
            return
        end
    end
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

--Initialize variables
for i, v in ipairs(AllPlayers) do
    table.insert(_activeplayers, v)
end

--Register events
inst:WatchWorldState("islandisraining", OnIsRaining)
inst:WatchWorldState("hurricane", OnIsRaining)

inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)

-- ToggleUpdate(true) --conditions are never true at this point

--------------------------------------------------------------------------
--[[ Save/Load ]]
--------------------------------------------------------------------------

--need to return something so OnLoad gets used
-- function self:OnSave()
	-- return {
	-- }
-- end

-- function self:OnLoad(data)
    -- ToggleUpdate(true)
-- end

function self:OnPostInit()
    ToggleUpdate(true)
end

--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
    return string.format("HailRain: updating:%s", tostring(_updating))
end

--------------------------------------------------------------------------
--[[ End ]]
--------------------------------------------------------------------------

end)
%%+%%scripts/components/keeponland.lua%%-%%local function IsWaterAny(tile)
	return IsWater(tile) or (tile >= GROUND.OCEAN_START and tile <= GROUND.OCEAN_END)
end

local KeepOnLand = Class(function(self, inst)
    self.inst = inst
    self.inst:StartUpdatingComponent(self)
end)

function KeepOnLand:OnUpdateSw(dt)
    --Ignore if the player is any of this
    if self.inst.sg:HasStateTag("busy") or self.inst:IsAmphibious() or
        (self.inst.components.health and self.inst.components.health:IsDead()) then
        return
    end
    
    local pt = self.inst:GetPosition()

    if self.inst:CanOnLand() and not IsLand(GetVisualTileType(pt.x, pt.y, pt.z, 0.25 / 4)) then
        --Might have run onto water on accident
        local angle = self.inst.Transform:GetRotation()
        angle = angle * DEGREES
        local dist = -1
        local newpt = Vector3(pt.x + dist * math.cos(angle), pt.y, pt.z + dist * -math.sin(angle))
        if not IsLand(GetVisualTileType(newpt.x, newpt.y, newpt.z, 1.5 / 4)) then
            --Okay, try to find any point nearby
            local result_offset = FindGroundOffset(pt, 0, 5, 12)
            newpt = result_offset and pt + result_offset or nil
        end

        if newpt then
            self.inst.Transform:SetPosition(newpt.x, newpt.y, newpt.z)
            if self.inst.components.locomotor then
                self.inst.components.locomotor:Stop()
            end
        elseif self.inst.components.health then 
            self.inst.components.health:Drown()
        end
    elseif self.inst:CanOnWater() and not IsWaterAny(GetVisualTileType(pt.x, pt.y, pt.z, 1.25 / 4))
	and (not GROUND.OCEAN_START or TheWorld.Map:GetTileAtPoint(pt.x,pt.y,pt.z) < GROUND.OCEAN_START) then
        --Failsafe in case there's shore within the edge fog
        if self.inst.components.mapwrapper and self.inst.components.mapwrapper._state ~= 0 then return end

        --Might have run onto land on accident
        local angle = self.inst.Transform:GetRotation()
        angle = angle * DEGREES
        local dist = -1
        local newpt = Vector3(pt.x + dist * math.cos(angle), pt.y, pt.z + dist * -math.sin(angle))
        if not IsWater(GetVisualTileType(newpt.x, newpt.y, newpt.z, 0.001 / 4)) then
            --Okay, try to find any point nearby
            local result_offset = FindWaterOffset(pt, 0, 5, 12)
            newpt = result_offset and pt + result_offset or nil
        end

        if newpt then
            self.inst.Transform:SetPosition(newpt.x, newpt.y, newpt.z)
            if self.inst.components.locomotor then
                self.inst.components.locomotor:Stop()
            end
        elseif self.inst.components.health then
            if self.inst.components.sailor and self.inst.components.sailor.boat then
                local boat = self.inst.components.sailor.boat
                self.inst.components.sailor:Disembark(pt)
                if boat.components.boathealth then
                    boat.components.boathealth:MakeEmpty()
                elseif boat.components.workable then
                    boat.components.workable:Destroy(self.inst)
                end
            else
                --TODO, implement dry drowning properly. -Z
                self.inst.components.health:Kill()
            end
        end
    end
end

function KeepOnLand:OnUpdate(dt)
    --if TheWorld:IsVolcano() then
        --self:OnUpdateVolcano(dt)
    --else
        self:OnUpdateSw(dt)
    --end
end


return KeepOnLand
%%+%%scripts/components/mapwrapper.lua%%-%%-- Fog is handled client-side

return Class(function(self, inst)

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local STATE_WAIT = 0
local STATE_WARN = 1
local STATE_MOVEOFF = 2
local STATE_BLIND = 3
local STATE_MOVEBACK = 4
local STATE_RETURN = 5 -- For client-communication, basically same as STATE_WARN

local _map = TheWorld.Map

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

self.inst = inst
self._state = STATE_WAIT
local _warpdir = nil

--------------------------------------------------------------------------
--[[ Functions ]]
--------------------------------------------------------------------------

function self:GetDistanceFromEdge(x, y, z)
	-- Remember that (0/0) is in the middle
	local w, h = _map:GetSize()
	local halfw, halfh = 0.5 * w * TILE_SCALE, 0.5 * h * TILE_SCALE
	local distx = math.min(x + halfw, halfw - x)
	local distz = math.min(z + halfh, halfh - z)
	assert(distx >= 0)
	assert(distz >= 0)
	local dist = math.min(distx, distz)
	return dist
end

local function printcoords(msg, x, y, z)
	if z then
		local tx, ty = TheWorld.Map:GetTileCoordsAtPoint(x, y, z)
		print(string.format("%s (%f, %f) (%f, %f, %f)", msg, tx, ty, x, y, z))
	else
		local w, h = TheWorld.Map:GetSize()
		local cx = (x - w/2.0) * TILE_SCALE
		local cz = (y - h/2.0) * TILE_SCALE
		print(string.format("%s (%f, %f) (%f, %f, %f)", msg, x, y, cx, 0, cz))
	end
end

local function line_intersect(x1, y1, x2, y2, x3, y3, x4, y4)
	-- from http://paulbourke.net/geometry/pointlineplane/
	local denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
	if denom == 0 then
		return nil, nil --parallel
	end
	local ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom
	local ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom
	if not (0 <= ua and ua <= 1 and 0 <= ub and ub <= 1) then
		return nil, nil --outside segments
	end
	--printcoords("intersect", x1 + ua * (x2 - x1), 0, y1 + ua * (y2 - y1))
	return x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)
end

local function get_dest(inst, x1, y1, z1, rads, prints)
	local w, h = _map:GetSize()

	local dist = (TUNING.MAPWRAPPER_TELEPORT_RANGE + 2*TUNING.MAPWRAPPER_WARN_RANGE) * TILE_SCALE
	local x2, y2 = x1 + dist * math.cos(rads), z1 - dist * math.sin(rads)

	local width = (w - 2)*TILE_SCALE
	local height = (h - 2)*TILE_SCALE
	local right, top = width/2.0, height/2.0
	local left, bottom = -right, -top

	--printcoords("start", x1, y1, z1)
	--printcoords("proj", x2, 0, y2)

	local fx, fy
	local sx, sy
	fx, fy = line_intersect(x1, z1, x2, y2, left, top, right, top)
	if fx and fy then
		sx, sy = line_intersect(x1, z1, x2, y2, left, top, left, top + height)
		if sx and sy then
			--printcoords("dest tl", sx + width, 0, sy - height)
			return sx + width, 0, sy - height --top left
		end
		sx, sy = line_intersect(x1, z1, x2, y2, right, top, right, top + height)
		if sx and sy then
			--printcoords("dest tr", sx - width, 0, sy - height)
			return sx - width, 0, sy - height --top right
		end
		--printcoords("dest t", fx, 0, fy - height)
		return fx, 0, fy - height
	end

	fx, fy = line_intersect(x1, z1, x2, y2, left, bottom, right, bottom)
	if fx and fy then
		sx, sy = line_intersect(x1, z1, x2, y2, left, bottom, left, bottom - height)
		if sx and sy then
			--printcoords("dest bl", sx + left, 0, sy + height)
			return sx + left, 0, sy + height --bottom left
		end
		sx, sy = line_intersect(x1, z1, x2, y2, right, bottom, right, bottom - height)
		if sx and sy then
			--printcoords("dest br", sx - width, 0, sy + height)
			return sx - width, 0, sy + height --bottom right
		end
		--printcoords("dest b", fx, 0, fy + height)
		return fx, 0, fy + height
	end

	fx, fy = line_intersect(x1, z1, x2, y2, left, top, left, bottom)
	if fx and fy then
		sx, sy = line_intersect(x1, z1, x2, y2, left, top, left - width, top)
		if sx and sy then
			--printcoords("dest lt", sx + width, 0, sy - height)
			return sx + width, 0, sy - height --left top
		end
		sx, sy = line_intersect(x1, z1, x2, y2, left, bottom, left - width, bottom)
		if sx and sy then
			--printcoords("dest lb", sx + width, 0, sy + height)
			return sx, 0, sy + height --left bottom
		end
		--printcoords("dest l", fx + width, 0, fy)
		return fx + width, 0, fy
	end

	fx, fy = line_intersect(x1, z1, x2, y2, right, top, right, bottom)
	if fx and fy then
		sx, sy = line_intersect(x1, z1, x2, y2, right, top, right + width, top)
		if sx and sy then
			--printcoords("dest rt", sx - width, 0, sy - height)
			return sx - width, 0, sy - height --right top
		end
		sx, sy = line_intersect(x1, z1, x2, y2, right, bottom, right + width, bottom)
		if sx and sy then
			--printcoords("dest rb", sx - width, 0, sy + height)
			return sx - width, 0, sy + height --right bottom
		end
		--printcoords("dest r", fx - width, 0, fy)
		return fx - width, 0, fy
	end

	--print("no intersect?")
	return x1, y1, z1
end

local function get_angle(inst, x, y, z)
	local w, h = _map:GetSize()
	local halfw, halfh = 0.5 * w * TILE_SCALE, 0.5 * h * TILE_SCALE
	
	local dx, dz, dist = -halfw, z, x - -halfw
	if halfw - x < dist then
		dx, dz, dist = halfw, z, halfw - x
	end
	if z - -halfh < dist then
		dx, dz, dist = x, -halfh, z - -halfh
	end
	if halfh - z < dist then
		dx, dz, dist = x, halfh, halfh - z
	end

	local angle = -math.atan2(dz - z, dx - x)
	print("get_angle", dist, angle, angle / DEGREES, angle * DEGREES)
	return angle / DEGREES
end

local function get_angle2(x, y, z, rads)
	local w, h = _map:GetSize()
	local halfw, halfh = 0.5 * w * TILE_SCALE, 0.5 * h * TILE_SCALE
	
	--find closest edge
	--[[local dist = x - -halfw
	local x3, z3, x4, z4 = -halfw, halfh, -halfw, -halfh
	if halfw - x < dist then
		--dx, dz, dist = halfw, z, halfw - x
		x3, z3, x4, z4 = halfw, halfh, halfw, -halfh
	end
	if z - -halfh < dist then
		--dx, dz, dist = x, -halfh, z - -halfh
		x3, z3, x4, z4 = halfw, -halfh, -halfw, -halfh
	end
	if halfh - z < dist then
		--dx, dz, dist = x, halfh, halfh - z
		x3, z3, x4, z4 = halfw, halfh, -halfw, halfh
	end

	print("get_angle2 pos", x, z)
	print("get_angle2 edge", x3, z3, x4, z4)]]

	local function line_intersect_dist(x, y, x2, y2, x3, y3, x4, y4)
		local ix, iy = line_intersect(x, y, x2, y2, x3, y3, x4, y4)
		local d = 10000
		if ix and iy then
			ix, iy = ix - x, iy - y
			d = math.sqrt((ix*ix) + (iy*iy))
			--print("get_angle2 ray", d, x2, y2, ix + x, iy + y)
		end
		return d
	end

	local edges = {}
	table.insert(edges, {x3 = halfw, z3 = -halfh, x4 = halfw, z4 = halfh})
	table.insert(edges, {x3 = -halfw, z3 = -halfh, x4 = -halfw, z4 = halfh})
	table.insert(edges, {x3 = -halfw, z3 = halfh, x4 = halfw, z4 = halfh})
	table.insert(edges, {x3 = -halfw, z3 = -halfh, x4 = halfw, z4 = -halfh})

	--send a ray in 4 directions
	local dirs = {}
	local len = 2 * TUNING.MAPWRAPPER_WARN_RANGE * TILE_SCALE
	local dx, dz = len * math.cos(rads), len * math.sin(rads)
	--print("get_angle2 sincos", dx, dz, rads / DEGREES)
	table.insert(dirs, {x = dx, z = dz, rads = rads})
	table.insert(dirs, {x = - dz, z = dx, rads = rads + PI/2})
	table.insert(dirs, {x = - dx, z = - dz, rads = rads + PI})
	table.insert(dirs, {x = dz, z = - dx, rads = rads + 3*PI/2})
	--[[for i, v in ipairs(dirs) do
		print(string.format("get_angle2 dirs (%f,%f) deg=%f atan=%f", v.x, v.z, v.rads/DEGREES, math.atan2(v.z, v.x) / DEGREES))
	end]]

	local idx = 1
	local d = 10000
	for i = 1, #dirs, 1 do
		for j = 1, #edges, 1 do
			local newd = line_intersect_dist(x, z, x + dirs[i].x, z + dirs[i].z, edges[j].x3, edges[j].z3, edges[j].x4, edges[j].z4)
			--print("get_angle2", i, j, newd, dirs[i].rads / DEGREES, dirs[i].x, dirs[i].z)
			if newd < d and math.abs(newd - d) > 1.0 then
				d = newd
				idx = i
			end
		end
	end

	--print("get_angle2 return", dirs[idx].rads / DEGREES, math.atan2(dirs[idx].z, dirs[idx].x) / DEGREES)
	return dirs[idx].rads / DEGREES --math.atan2(dirs[idx].z, dirs[idx].x) / DEGREES
end

function self:OnUpdate( dt )
	local w, h = _map:GetSize()
	local x, y, z = self.inst.Transform:GetLocalPosition()
	local tx, ty = _map:GetTileCoordsAtPoint(x, y, z)

	local is_inrange = function(range)
		return (tx < range) or (w - tx < range) or (ty < range) or (h - ty < range)
	end

	--if self._state ~= STATE_WAIT then print(string.format("%d (%d, %d) - (%d, %d)\n\t(%4.2f, %4.2f, %4.2f)\n", self._state, tx, ty, w, h, x, y, z)) end
	--local angle = self.inst.Transform:GetRotation()
	--print("angle", angle, angle * DEGREES)

	if self._state == STATE_WAIT then
		if is_inrange(TUNING.MAPWRAPPER_WARN_RANGE) then
			self._state = STATE_WARN
		end

	elseif self._state == STATE_WARN or self._state == STATE_RETURN then
		if not is_inrange(TUNING.MAPWRAPPER_WARN_RANGE) then
			self._state = STATE_WAIT
		elseif is_inrange(TUNING.MAPWRAPPER_LOSECONTROL_RANGE)
		and self.inst:CanOnWater() then --is this is not true, assume the keeponland component or a character mod fixes it in a moment
			self.inst.components.health:SetInvincible(true)
			if TUNING.DO_SEA_DAMAGE_TO_BOAT and (self.inst.components.sailor and self.inst.components.sailor.boat and self.inst.components.sailor.boat.components.boathealth) then
				self.inst.components.sailor.boat.components.boathealth:SetInvincible(true)
			end


			--print("lose control get_angle2", -self.inst.Transform:GetRotation()*DEGREES, -self.inst.Transform:GetRotation())
			--local angle = get_angle2(x, y, z, -self.inst.Transform:GetRotation()*DEGREES)
			local angle = 0 
			local xDist = math.min(tx, math.abs(tx - w))
			local zDist = math.min(ty, math.abs(ty - h))
			
			if xDist < zDist then --horizontal (x)
				if x < 0 then 
					angle = 180
					_warpdir = "left"
				else 
					angle = 0 
					_warpdir = "right"
				end 
			else --vertical (z)
				if z < 0 then 
					angle = 90 
					_warpdir = "down"
				else 
					angle = -90
					_warpdir = "up"
				end 
			end 
			
			--self.inst.Transform:SetRotation(angle)
			--self.inst.components.locomotor:RunInDirection(angle)
			self.inst.components.locomotor:Stop()
			-- self.inst.components.locomotor:EnableGroundSpeedMultiplier(false)
			self.inst.components.playercontroller:Enable(false)
			self.inst.Transform:SetRotation(angle)
			self.inst.Physics:SetMotorVelOverride(TUNING.WILSON_RUN_SPEED, 0, 0)
			--self.inst.Physics:SetCollides(false)
			self._state = STATE_MOVEOFF
		end

	elseif self._state == STATE_MOVEOFF then
		--print("move to egde", x, y, z, self.inst.Transform:GetRotation())
		--self.inst.components.locomotor:WalkForward()
		self.inst.Physics:SetMotorVelOverride(TUNING.WILSON_RUN_SPEED, 0, 0)
		if is_inrange(TUNING.MAPWRAPPER_TELEPORT_RANGE) then
			--print(string.format("run_test(%f, %f, %f, %f)", x, y, z, self.inst.Transform:GetRotation()))
			--local dx, dy, dz = get_dest(self.inst, x, y, z, self.inst.Transform:GetRotation() * DEGREES, true)
			local width = (w - 2)*TILE_SCALE
			local height = (h - 2)*TILE_SCALE
			local right, top = width/2.0, height/2.0
			local left, bottom = -right, -top

			local dx, dy, dz = x, y, z  

			if _warpdir == "left" then 
				dx = right 
				dz = math.min(dz, top - (TUNING.MAPWRAPPER_GAINCONTROL_RANGE * 4 + 4))
				dz = math.max(dz, bottom + (TUNING.MAPWRAPPER_GAINCONTROL_RANGE * 4 + 4))
			elseif _warpdir == "right" then 
				dx = left 
				dz = math.min(dz, top - (TUNING.MAPWRAPPER_GAINCONTROL_RANGE * 4 + 4))
				dz = math.max(dz, bottom + (TUNING.MAPWRAPPER_GAINCONTROL_RANGE * 4+ 4))
			elseif _warpdir == "up" then 
				dz = bottom
				dx = math.min(dx, right - (TUNING.MAPWRAPPER_GAINCONTROL_RANGE*4 + 4))
				dx = math.max(dx, left + (TUNING.MAPWRAPPER_GAINCONTROL_RANGE*4 + 4))
			elseif _warpdir == "down" then 
				dz = top
				dx = math.min(dx, right - (TUNING.MAPWRAPPER_GAINCONTROL_RANGE*4 + 4))
				dx = math.max(dx, left + (TUNING.MAPWRAPPER_GAINCONTROL_RANGE*4 + 4))
			end 

			print("mapwrap", self.inst, _warpdir, dx, dy, dz, self.inst.Transform:GetRotation())
            if self.inst.Physics then
				self.inst.Physics:Teleport(dx, dy, dz)
			elseif self.inst.Transform then
				self.inst.Transform:SetPosition(dx, dy, dz)
			else
				print("Mapwrapping FAILED: entity has neither Physics nor Transform")
			end
			-- if self.inst.components.sailor and self.inst.components.sailor.boat then 
				-- self.inst.components.sailor.boat.Transform:SetPosition(dx, dy, dz)
			-- end 

			self._state = STATE_BLIND
			self.inst:DoTaskInTime(3, function()
				self._state = STATE_MOVEBACK
				self.inst:Show()
			end)
		end
	
	elseif self._state == STATE_BLIND then
		self.inst.components.locomotor:Stop()
		self.inst:Hide()
		
	elseif self._state == STATE_MOVEBACK then
		--self.inst.components.locomotor:WalkForward()
		self.inst.Physics:SetMotorVelOverride(TUNING.WILSON_RUN_SPEED, 0, 0)

		if not is_inrange(TUNING.MAPWRAPPER_GAINCONTROL_RANGE) then
			if self.inst.components.sanity then
				self.inst.components.sanity:DoDelta(-TUNING.SANITY_MED)
			end
			--self.inst.components.locomotor:Clear()
			--self.inst.components.locomotor:StopMoving()
			self.inst.Physics:Stop()
			self.inst.components.locomotor:Stop()
			-- self.inst.components.locomotor:EnableGroundSpeedMultiplier(true)
			self.inst.components.health:SetInvincible(false)
			if TUNING.DO_SEA_DAMAGE_TO_BOAT and (self.inst.components.sailor and self.inst.components.sailor.boat and self.inst.components.sailor.boat.components.boathealth) then
				self.inst.components.sailor.boat.components.boathealth:SetInvincible(false)
			end
			self.inst.components.playercontroller:Enable(true)
			--self.inst.Physics:SetCollides(true)
			self._state = STATE_RETURN
		end
	end
end

self.inst:StartUpdatingComponent(self)
	
end, nil, {
	_state = function(self, state)
		-- if not TheNet:IsDedicated() then
			self.inst.replica.mapwrapper._state:set(state)
		-- end
	end
})
%%+%%scripts/components/mapwrapper_replica.lua%%-%%return Class(function(self, inst)

local STATE_WAIT = 0
local STATE_WARN = 1
local STATE_MOVEOFF = 2
local STATE_BLIND = 3
local STATE_MOVEBACK = 4
local STATE_RETURN = 5

local _growlsounds = {
	-- 'ia/common/bermuda/sparks_active',
	-- 'ia/creatures/blue_whale/idle',
	'ia/creatures/blue_whale/breach_swim',
	'ia/creatures/cormorant/takeoff',
	'ia/creatures/crocodog/distant',
	'ia/creatures/crocodog/distant',
	-- 'ia/creatures/quacken/enter',
	'ia/creatures/seagull/takeoff',
	-- 'ia/creatures/sharx/distant',
	'ia/creatures/twister/distant',
	'ia/creatures/white_whale/breach_swim',
	'ia/creatures/white_whale/mouth_open',
	-- 'dontstarve/sanity/creature2/attack_grunt',
	-- 'dontstarve/sanity/creature1/taunt',
}
local _boatsounds = {
	'ia/creatures/seacreature_movement/splash_small',
	'ia/creatures/seacreature_movement/splash_medium',
	-- 'ia/creatures/seacreature_movement/splash_large',
	'ia/creatures/seacreature_movement/thrust',
	-- 'ia/common/brain_coral_harvest',
	-- 'ia/common/pickobject_water',
}

self.inst = inst
self._state = net_tinybyte(inst.GUID, "mapwrapper._state", "mapwrapperdirty")

-- This handles mist for us
if not TheNet:IsDedicated() then
	inst:AddChild( SpawnAt("edgefog", inst) )
end


local function PlayFunnyGrowl(inst)
	inst.SoundEmitter:PlaySound(_growlsounds[math.random(#_growlsounds)])
end
local function PlayFunnyBoat(inst)
	inst.SoundEmitter:PlaySound(_boatsounds[math.random(#_boatsounds)])
end

function self:GetState()
    return self._state:value()
end

function self:SetState()
    if TheNet:IsDedicated() then return end
	
	if self.inst ~= TheLocalPlayer then return end
	
	if self:GetState() == STATE_WARN then
		self.inst.components.talker:Say(GetString(self.inst, "ANNOUNCE_MAPWRAP_WARN"))
		
	elseif self:GetState() == STATE_MOVEOFF then
		self.inst.components.talker:Say(GetString(self.inst, "ANNOUNCE_MAPWRAP_LOSECONTROL"))
		if self.inst.HUD then
			TheFrontEnd:Fade(FADE_OUT, 3, nil, nil, nil, "white")
			self.inst.HUD:Hide()
		end

	elseif self:GetState() == STATE_BLIND then
		self.inst:DoTaskInTime(1.4, PlayFunnyGrowl)
		self.inst:DoTaskInTime(2.1, PlayFunnyGrowl)
		self.inst:DoTaskInTime(2.8, PlayFunnyBoat)
		
	elseif self:GetState() == STATE_MOVEBACK then
		if self.inst.HUD then
			TheFrontEnd:Fade(FADE_IN, 6, nil, nil, nil, "white")
		end

	elseif self:GetState() == STATE_RETURN then
		self.inst.components.talker:Say(GetString(self.inst, "ANNOUNCE_MAPWRAP_RETURN"))
		if self.inst.HUD then
			self.inst.HUD:Show()
		end
	end
	
end

self.inst:ListenForEvent("mapwrapperdirty", function() self:SetState() end)
	
end)
%%+%%scripts/components/mateable.lua%%-%%
local Mateable = Class(function(self, inst)
	self.inst = inst
	self.onmate = nil
	self.partnerGUID = nil
	self.doesdance = nil
end)

function Mateable:OnSave()
	if self.partnerGUID then
		local t = {
			partnerGUID = self.partnerGUID,
		}
		return t, t
	end
end

function Mateable:OnLoadPostPass(newents, data)
	self.partnerGUID = data.partnerGUID
	if self.partnerGUID then
		if TheWorld.components.doydoyspawner then
			TheWorld.components.doydoyspawner:RequestMate(self.inst, newents[self.partnerGUID])
		end
	end
end

local nomatingtags = {
	"baby", "teen", "mating", "doydoynest", "insprungtrap",
}

function Mateable:CanMate()

	if not TheWorld.state.isday then
		return false
	end

	-- Offscreen doys cannot mate, apparently
	-- Perhaps we could modify this so they skip the state and just spawn a baby if either is asleep -M
	if self.inst:IsAsleep() then
		return false
	end

	for _, tag in pairs(nomatingtags) do
		if self.inst:HasTag(tag) then
			return false
		end
	end

	if self.inst.components.inventoryitem:IsHeld() then
		return false
	end

	if self.inst.components.sleeper:IsAsleep() then
		return false
	end

	return true
end

function Mateable:SetOnMateCallback(onmate)
	self.onmate = onmate
end

function Mateable:SetPartner(partner, doesdance)
	self.partnerGUID = partner.GUID

	if doesdance then
		self.doesdance = true
	else
		self.doesdance = false
	end

	self.inst:AddTag("mating")
end

function Mateable:StopMating()

	-- if self.inst:HasTag("daddy") then
		-- self.inst:RemoveTag("daddy")

		-- local mommy = self:GetPartner()

		-- if mommy then
			-- mommy.components.mateable:RemovePartner()
		-- end

	-- else
		-- self.inst:RemoveTag("mommy")
	-- end
	
	self.inst:RemoveTag("mating")
	self.doesdance = nil
	self.partnerGUID = nil
end

function Mateable:GetPartner()
	return Ents[self.partnerGUID]
end
function Mateable:PartnerValid()
	return Ents[self.partnerGUID] and Ents[self.partnerGUID]:IsValid()
end

function Mateable:Mate()
	
	local partner = Ents[self.partnerGUID]
	
	if self.onmate then
		self.onmate(self.inst, partner)
	end
	
	if partner then
		partner:PushEvent("mateisdone", {mate = self.inst})
	end
	
	self:StopMating()
end

function Mateable:GetDebugString()
	return "Partner: "..tostring(self:GetPartner())..", "..tostring(self.partnerGUID)
end

return Mateable
%%+%%scripts/components/obsidiantool.lua%%-%%local ObsidianTool = Class(function(self, inst)
    self.inst = inst

    --V2C: Recommended to explicitly add tag to prefab pristine state
    inst:AddTag("obsidiantool")

    self.charge = 0
    self.maxcharge = TUNING.OBSIDIAN_TOOL_MAXCHARGES
    self.cooldowntime = TUNING.TOTAL_DAY_TIME / TUNING.OBSIDIAN_TOOL_MAXCHARGES
    self.cooltimer = 0

    self.red_threshold = 0.90
    self.orange_threshold = 0.66
    self.yellow_threshold = 0.33
    self.normal_threshold = 0.01
    self.tool_type = ""
end)

function ObsidianTool:Start()
	self.inst:StartUpdatingComponent(self)
end

function ObsidianTool:Stop()
	self.inst:StopUpdatingComponent(self)
end

function ObsidianTool:OnSave()
	return {charge = self.charge}
end

function ObsidianTool:OnLoad(data)
	self:SetCharge(data.charge or 0)
end

function ObsidianTool:GetCharge()
	return self.charge, self.maxcharge
end

function ObsidianTool:SetCharge(num)
	local old = self.charge
	self.charge = num

	if self.charge > 0 then
		self:Start()
	else
		self:Stop()
	end

	self.inst:PushEvent("obsidianchargechange", {percent = self.charge / self.maxcharge})

	self:OnChargeDelta(old, self.charge)
end

function ObsidianTool:Ignite(doer, target)
	if target.SoundEmitter then
		target.SoundEmitter:PlaySound("dontstarve/wilson/blowdart_impact_fire")
	end
	if target.components.burnable then
		target.components.burnable:Ignite()
	end
	if target.components.propagator then
		target.components.propagator:Flash()
	end
	if target.components.health then
		target.components.health:DoFireDamage(0)
	end
end

function ObsidianTool:Use(doer, target)
    --print("Executing ObsidianTool:Use")
	if TheWorld.state.iswinter or TheWorld.state.iswet then
		self:SetCharge(0)
		if self.inst.SoundEmitter then
			self.inst.SoundEmitter:PlaySound("ia/common/obsidian_wetsizzles")
		end
	else
		self:SetCharge(math.min(self.charge + 1, self.maxcharge))
		if self.charge >= self.maxcharge then
			self:Ignite(doer, target)
		end
		self.cooltimer = 0.0
	end
end

function ObsidianTool:OnUpdate(dt)
	self.cooltimer = self.cooltimer + dt
	if self.cooltimer >= self.cooldowntime then
		self:SetCharge(math.max(self.charge - 1, 0))
		self.cooltimer = 0.0
	end
end

local function getAnimSuffix(self, percentage)
	if percentage >= self.red_threshold then
		return "_red"
	elseif percentage >= self.orange_threshold then
		return "_orange"
	elseif percentage >= self.yellow_threshold then
		return "_yellow"
	else
		return ""
	end
end

function ObsidianTool:OnChargeDelta(old, new)
	local equipper = nil

	if self.inst.components.equippable and self.inst.components.equippable:IsEquipped() and self.inst.components.inventoryitem then
		equipper = self.inst.components.inventoryitem:GetGrandOwner()
	end

	local percentage = new/self.maxcharge
	local suffix = getAnimSuffix(self, percentage)

	-- self.inst.AnimState:PlayAnimation("idle"..suffix)
	self.inst.components.floater:UpdateAnimations("idle_water"..suffix, "idle"..suffix)

	if equipper then
		equipper.AnimState:OverrideSymbol("swap_object", "swap_"..self.tool_type.."_obsidian", "swap_"..self.tool_type..suffix)
	end

	if self.onchargedelta then
		self.onchargedelta(self.inst, old, new)
	end
end

return ObsidianTool%%+%%scripts/components/pickupable.lua%%-%%local function oncanbepickedup(self, canbepickedup)
    if canbepickedup then
        self.inst:AddTag("canbepickedup")
    else
        self.inst:RemoveTag("canbepickedup")
    end
end

local Pickupable = Class(function(self, inst)
	self.inst = inst
	-- self.onpickupfn = nil
	self.canbepickedup = true
end,
nil,
{
    canbepickedup = oncanbepickedup,
})

function Pickupable:OnRemoveFromEntity()
    self.inst:RemoveTag("canbepickedup")
end

function Pickupable:SetOnPickupFn(fn)
	self.onpickupfn = fn
end

function Pickupable:CanPickUp()
	-- if self.canpickupfn then
		-- return self.canpickupfn(self.inst)
	-- end

	return self.canbepickedup
end

-- If this function retrns true then it has destroyed itself and you shouldnt give it to the player
function Pickupable:OnPickup(pickupguy)
	if not self:CanPickUp() then return false end
	
	if self.inst.components.burnable and self.inst.components.burnable:IsSmoldering() then
		self.inst.components.burnable:SmotherSmolder(pickupguy)
	end

	-- self.inst.Transform:SetPosition(0,0,0)
	self.inst:PushEvent("onpickup", {owner = pickupguy})
	if self.onpickupfn and type(self.onpickupfn) == "function" then
		self.onpickupfn(self.inst, pickupguy)
	end
	
	return true
end

-- function Pickupable:CollectSceneActions(doer, actions, right)
	-- if right and self:CanPickUp() and doer.components.inventory and not (self.inst.components.burnable and self.inst.components.burnable:IsBurning()) then
		-- if self.inst:HasTag("aquatic") then
			-- table.insert(actions, ACTIONS.RETRIEVE)
		-- else
			-- table.insert(actions, ACTIONS.PACKUP)
		-- end
	-- end
-- end


return Pickupable
%%+%%scripts/components/poisonable.lua%%-%%

--Binary state problematic for non-players? should have a timer that gets set to infinite for players and some discrete time for non-players
local Poisonable = Class(function(self, inst)
    self.inst = inst

    self.poisoned = false

    self.fxdata = {}
    self.fxlevel = 1
    self.fxchildren = {}

    self.onpoisoned = nil
    self.oncured = nil

    self.show_fx = true
    self.loop_fx = true

    self.duration = TUNING.POISON_DURATION
    self.damage_per_interval = TUNING.POISON_DAMAGE_PER_INTERVAL
    self.interval = TUNING.POISON_INTERVAL

    self.severity = 1

    self.transfer_poison_on_attack = false

    self.start_time = nil

    self.inst:AddTag("poisonable")

    self.blockall = nil

    --self.inst:ListenForEvent("death", OnKilled)		
  end)

local function IsPoisonDisabled()
  return TheWorld and TheWorld.components.globalsettings and TheWorld.components.globalsettings.settings.poisondisabled and TheWorld.components.globalsettings.settings.poisondisabled == true
end

function Poisonable:IsPoisonBlockerEquiped()
  if IsPoisonDisabled() then
    return true
  end

  if self.blockall then
    return true
  end

  -- check armour
  if self.inst.components.inventory then
    for k,v in pairs (self.inst.components.inventory.equipslots) do
      if v.components.equippable and v.components.equippable:IsPoisonBlocker() then
        return true
      end		
    end
  end

  return false
end

function Poisonable:IsPoisonGasBlockerEquiped()
  if IsPoisonDisabled() then
    return true
  end

  if self.blockall then
    return true
  end

  -- check armour
  if self.inst.components.inventory then
    for k,v in pairs (self.inst.components.inventory.equipslots) do
      if v.components.equippable and v.components.equippable:IsPoisonGasBlocker() then
        return true
      end		
    end
  end

  return false
end

function Poisonable:CanBePoisoned(gas)
  if IsPoisonDisabled() then
    return false
  end

  if self.poisoned or self.blockall then
    -- already poisoned
    return false
  end

  -- Normal poison, check normal blockers
  if not gas and self:IsPoisonBlockerEquiped() then
    return false
  end

  -- Gas poison, check gas blockers
  if gas and self:IsPoisonGasBlockerEquiped() then
    return false
  end

  if self.immune then
    return false
  end

  if not IA_CONFIG.poisonenabled then
    return false
  end

  return true
end

function Poisonable:SetOnPoisonedFn(fn)
  self.onpoisoned = fn
end

function Poisonable:SetOnPoisonDoneFn(fn)
  self.onpoisondone = fn
end

function Poisonable:SetOnCuredFn(fn)
  self.oncured = fn
end

--- Add an effect to be spawned when poisoning
-- @param prefab The prefab to spawn as the effect
-- @param offset The offset from the poisoning entity/symbol that the effect should appear at
-- @param followsymbol Optional symbol for the effect to follow
function Poisonable:AddPoisonFX(prefab, offset, followsymbol)
  table.insert(self.fxdata, {prefab=prefab, x = offset.x, y = offset.y, z = offset.z, follow=followsymbol})
end

function Poisonable:IsPoisoned()
  return self.poisoned
end

function Poisonable:GetDebugString()
  return string.format("%s ", self.poisoned and "POISONED" or "NOT POISONED")
end

function Poisonable:OnRemoveEntity()
  self:KillFX()
  if self.task then
    self.task:Cancel()
    self.task = nil
  end
end

function Poisonable:Poison(isGas, loadTime, strength)
  if loadTime or self:CanBePoisoned(isGas) then
    self.severity = strength and math.max(strength, self.severity) or self.severity
    self.inst:AddTag("poison")
    self.poisoned = true
    self.start_time = loadTime and (GetTime() - loadTime) or GetTime()

    if self.duration > 0 and self.show_fx then
      self:SpawnFX()
    end

    if self.onpoisoned then
      self.onpoisoned(self.inst)
    end

    if self.inst.components.areapoisoner and self.duration > 0 then
      self.inst.components.areapoisoner:StartSpreading(loadTime and -loadTime or self.duration)
    end

    if self.task then
      self.task:Cancel()
      self.task = nil
    end

    self:DoPoison()
  end
end

function Poisonable:GetDamageRampScale()
  if not self.start_time then
    return 0
  else
    local elapsed_time = GetTime() - self.start_time
    local scale = 1
    for i,v in pairs(TUNING.POISON_DAMAGE_RAMP) do
      if elapsed_time > v.time then
        scale = v.damage_scale
      else
        break
      end
    end

    return scale
  end
end

function Poisonable:GetIntervalRampScale()
  if not self.start_time then
    return 0
  else
    local elapsed_time = GetTime() - self.start_time
    local scale = 1
    for i,v in pairs(TUNING.POISON_DAMAGE_RAMP) do
      if elapsed_time > v.time then
        scale = v.interval_scale
      else
        break
      end
    end

    return scale
  end
end

function Poisonable:GetFXLevel()
  if not self.start_time then
    return 0
  else
    local elapsed_time = GetTime() - self.start_time
    local level = 1
    for i,v in pairs(TUNING.POISON_DAMAGE_RAMP) do
      if elapsed_time > v.time then
        level = v.fxlevel
      else
        break
      end
    end

    return level
  end
end

function Poisonable:DoPoison(dt)
    if self.poisoned then

        --print("Execute Poisonable:DoPoison on " .. tostring(self.inst) .. " -> duration = " .. tostring(self.duration) .. " / start time = " .. tostring(self.start_time) .. " / dt = " .. tostring(GetTime() - self.start_time))

        local ramp_scale = self:GetDamageRampScale()

        if self.duration > 0 then
            if self.start_time and GetTime() - self.start_time >= self.duration then
                if dt and self.inst.components.health and self.inst.components.health.vulnerabletopoisondamage then
                    local intervals = math.floor(dt / self.interval)
                    local damage = self.damage_per_interval*intervals*self.severity --Ignore ramp scale here since we're doing a bunch of catch up
                    self.inst.components.health:DoPoisonDamage(damage)
                    self.inst:PushEvent("poisondamage", {damage=damage})
                end
                self:DonePoisoning()
            else
                if not self.inst:IsInLimbo() then
                    if self.inst.components.health and self.inst.components.health.vulnerabletopoisondamage then
                        if not dt then dt = 1 end
                        local damage = self.damage_per_interval*dt*ramp_scale*self.severity
                        self.inst.components.health:DoPoisonDamage(damage)
                        self.inst:PushEvent("poisondamage", {damage=damage})
                        if not self.loop_fx and self.show_fx then self:SpawnFX() end
                    end
                end
            end
        else
            if self.inst.components.health and self.inst.components.health.vulnerabletopoisondamage then
                local damage = self.damage_per_interval*ramp_scale*self.severity
                self.inst.components.health:DoPoisonDamage(damage)
                self.inst:PushEvent("poisondamage", {damage=damage})
            end
            self:SpawnFX()
        end
    end

    if self.poisoned then
        local interval_scale = self:GetIntervalRampScale()
        self.task = self.inst:DoTaskInTime(self.interval*interval_scale, function() self:DoPoison() end)
    end
end

function Poisonable:DonePoisoning()
  self:KillFX()
  self.poisoned = false
  self.start_time = nil
  self.severity = 1
  self.inst:RemoveTag("poison")

  if self.task then
    self.task:Cancel()
    self.task = nil
  end

  if self.inst.components.areapoisoner then
    self.inst.components.areapoisoner:StopSpreading()
  end

  if self.onpoisondone then
    self.onpoisondone(self.inst)
  end
end

local function ImmunityOver(inst)
  local poisonable = inst.components.poisonable
  if poisonable then
    poisonable.immune = false
    poisonable:KillFX()
  end
end

function Poisonable:Cure(curer, give_immunity, immunity_duration)
  self:DonePoisoning()

  if curer and curer.components.finiteuses then
    curer.components.finiteuses:Use()
  elseif curer and curer.components.stackable then
    curer.components.stackable:Get(1):Remove()
  end

  if self.oncured then
    self.oncured()
  end

  if give_immunity then
    if self.immunetask then
      self.immunetask:Cancel()
    end
    self.immune = true
    self:SpawnFX()
    self.immunetask = self.inst:DoTaskInTime(immunity_duration or TUNING.POISON_IMMUNE_DURATION, ImmunityOver)
  end
end

function Poisonable:SetBlockAll(blockall)
  if not self.blockall then
    self:Cure()
  end

  self.blockall = blockall
end

function Poisonable:SpawnFX()
  self:KillFX()

  if not self.fxdata then
    self.fxdata = { prefab="poisonbubble", x = 0, y = 0, z = 0, level=self:GetFXLevel() }
  end

  if self.fxdata then
    for k,v in pairs(self.fxdata) do
      v.level = self:GetFXLevel()
      local loop = self.loop_fx and "_loop" or ""
      local fx = SpawnPrefab(v.prefab.."_level"..v.level..loop)
      if fx then
        fx.Transform:SetScale(self.inst.Transform:GetScale())
        if self.immune then
          fx.AnimState:SetMultColour(183/255,33/255,63/255,0.5)
        else
          fx.AnimState:SetMultColour(1,1,1,1)
        end
        if v.follow then
          local follower = fx.entity:AddFollower()
          follower:FollowSymbol( self.inst.GUID, v.follow, v.x,v.y,v.z)
        else
          self.inst:AddChild(fx)
          fx.Transform:SetPosition(v.x, v.y, v.z)
        end
        table.insert(self.fxchildren, fx)
      end
    end
  end
end

function Poisonable:KillFX()
  for k,v in pairs(self.fxchildren) do
    v:StopBubbles()
    self.fxchildren[k] = nil
  end
end

function Poisonable:OnRemoveFromEntity()
  self:Cure()
  self.inst:RemoveTag("poisonable")
  if self.task then
    self.task:Cancel()
    self.task = nil
  end
end

--#srosen need to save/load immune data too
function Poisonable:OnSave()    
  return 
  {
    poisoned = self.poisoned,
    poisontimeelapsed = self.start_time and (GetTime() - self.start_time) or nil,
  }
end

function Poisonable:OnLoad(data)
  if data.poisoned and data.poisontimeelapsed then
    if data.poisontimeelapsed > 0 then
      self:Poison(false, data.poisontimeelapsed)
      self.inst:DoTaskInTime(0, function(inst)
          if inst.player_classified then inst.player_classified.ispoisoned:set(true) end
        end)
    end
  end
end

return Poisonable
%%+%%scripts/components/poisonhealer.lua%%-%%local Poisonhealer = Class(function(self, inst)
	self.inst = inst
	self.enabled = true --Used for snakeoil. We don't want it to actually do anything.
  
  self.inst:AddTag("poison_antidote")
end)

function Poisonhealer:Cure(target)
	if target.components.poisonable then
		if self.enabled then

			if self.oncure then
				self.oncure(self.inst, target)
			end

			target.components.poisonable:Cure(self.inst)
		end
		return true
	end
end

return Poisonhealer
%%+%%scripts/components/rainbowjellymigration.lua%%-%%-- manages the migration event of the rainbowjellyfish


RainbowJellyfishMigrationManager = Class(function(self, inst)
    self.inst = inst
    -- number of jellyfish to be placed for effect during the migration
    self.isMigrationActive = false
    self.inst:ListenForEvent( "daycomplete", function(inst, data) self:OnDayComplete() end )
end)

function RainbowJellyfishMigrationManager:IsMigrationActive()
    -- if this becomes functional, then no need to save/load
    return self.isMigrationActive
end

function RainbowJellyfishMigrationManager:OnDayComplete()
    -- migration happens during a new moon, but during the very first one..
    if TheWorld.state.cycles > 3 and TheWorld.state.moonphase == "new" then
        self:StartMigration()
    else
        self:EndMigration()
    end
end

function RainbowJellyfishMigrationManager:OnSave()
    return { isMigrationActive = self.isMigrationActive }
end

function RainbowJellyfishMigrationManager:OnLoad(data)
    self.isMigrationActive = data.isMigrationActive or self.isMigrationActive
end


local function setupHomeAndMigrationDestination(jelly, migrationPos, teleport)
    -- make sure they remember their actual home
    local home = jelly.components.knownlocations:GetLocation("home")
    if home == nil then
        -- find out why it didnt know its home yet..
        jelly.components.knownlocations:RememberLocation("home", Vector3(jelly.Transform:GetWorldPosition()))
    end

    local offset = FindWaterOffset(migrationPos, math.random() * 2 * PI, math.random(2,25), 4)

    -- tell them about their new destination
    local jellyHome = Vector3(migrationPos.x + offset.x, migrationPos.y + offset.y, migrationPos.z + offset.z)
    jelly.components.knownlocations:RememberLocation("migration", jellyHome)

    if teleport then
        jelly.Transform:SetPosition(jellyHome.x, jellyHome.y, jellyHome.z)
    end
end

function RainbowJellyfishMigrationManager:StartMigration()
    if self.isMigrationActive == true then
        return
    end

    print("starting rainbow jellyfish migration..")
    self.isMigrationActive = true

    local theVolcano = TheSim:FindFirstEntityWithTag("theVolcano")
    local volcanoPos = Vector3(theVolcano.Transform:GetWorldPosition())

    -- migration home is towards the center of the map
    local dir = Vector3(0,0,0) - volcanoPos;
    dir:Normalize()
    local migrationHomePos = volcanoPos + (dir * 30.0);
    local jellies = TheSim:FindEntities(migrationHomePos.x, migrationHomePos.y, migrationHomePos.z, 9999, {"rainbowjellyfish"})

    local numJelliesToRelocate = math.floor(#jellies * 1.0)
    local numJelliesAtVolcano = math.floor(numJelliesToRelocate * 0.1)

    print("Migrating " .. tostring(numJelliesToRelocate) .. " rainbowjellyfish")

    -- setup crowd at volcano
    for i=1, numJelliesAtVolcano, 1 do
        setupHomeAndMigrationDestination(jellies[i], migrationHomePos, true)
    end

    local streetDestination = volcanoPos + (dir * 30.0)
    local mainAngle = -math.atan2(dir.z, dir.x)
    local streetAngles = { mainAngle - PI * 0.25, mainAngle, mainAngle + PI * 0.25 }

    local numJelliesPerStreet = (numJelliesToRelocate - numJelliesAtVolcano) / #streetAngles

    -- setup the streets
    local i = numJelliesAtVolcano

    for s=1, #streetAngles, 1 do
        local p = streetDestination
        local angle = streetAngles[s]

        for j=1, numJelliesPerStreet, 1 do            
            setupHomeAndMigrationDestination(jellies[i], migrationHomePos, false)

            -- hop through the water in increments to build a path towards the middle
            local angleVariation = math.random(-1, 1) * PI * 0.25
            local offset = FindWaterOffset(p, angle + angleVariation, 7 + (j * 0.2), 4)
            if offset == nil then
                print("Unable to build full jelly fish straight.. aborting")
                break
            end

            -- place a jellyfish
            local jellyPos = p + offset
            jellies[i].Transform:SetPosition(jellyPos.x, jellyPos.y, jellyPos.z)

            -- continue on straight
            p = p + offset

            i = i + 1
        end

    end

end

function RainbowJellyfishMigrationManager:EndMigration()

    if self.isMigrationActive == false then
        return
    end

    print("ending rainbow jellyfish migration..")
    self.isMigrationActive = false

    -- this part isn't needed, just let the jellies go back to their homes normally. 
    --[[
    local theVolcano = TheSim:FindFirstEntityWithTag("theVolcano")
    local volcanoPos = Vector3(theVolcano.Transform:GetWorldPosition())

    -- return all jellyfish to their spawn location
    local jellies = TheSim:FindEntities(volcanoPos.x, volcanoPos.y, volcanoPos.z, 9999, {"rainbowjellyfish"})
    local numJellyfish = #jellies

    for i=1, numJellyfish, 1 do
        local home = jellies[i].components.knownlocations:GetLocation("home")
        if home then
    		jellies[i].Transform:SetPosition(home.x, home.y, home.z)
    	else
    		print("!!ERROR: Could Not Find Jellyfish Home")
    	end
    end
    ]]
end

return RainbowJellyfishMigrationManager
%%+%%scripts/components/rowboatwakespawner.lua%%-%%
local RowboatWakeSpawner = Class(function(self, inst)
    self.inst = inst
    self.timeSinceSpawn = 0
    self.spawning = false
    self.spawnPeriod = 0.2
    self.lastWake = nil 
end)


function RowboatWakeSpawner:StartSpawning()
    self.inst:StartUpdatingComponent(self)
    self.spawning = true 
    self.timeSinceSpawn = self.spawnPeriod --So that one gets spawned as soon as the boat starts moving 
end 

function RowboatWakeSpawner:StopSpawning()
    self.inst:StopUpdatingComponent(self)
    self.spawning = false 
end 

function RowboatWakeSpawner:OnUpdate(dt)
    if self.lastWake then  --Hacky way to fix the animation facing the wrong direction for one frame
        self.lastWake:Show()
        self.lastWake = nil 
    end 

    if self.spawning then 
        self.timeSinceSpawn = self.timeSinceSpawn + dt
        if self.timeSinceSpawn > self.spawnPeriod then
            local x, y, z = self.inst.Transform:GetWorldPosition()
            if x and y and z then
                local wake = SpawnPrefab("rowboat_wake")                
                wake.Transform:SetPosition(x, y, z)
                wake.Transform:SetRotation(self.inst.Transform:GetRotation())
                self.lastWake = wake
                wake:Hide() --Hide for a frame, hacky fix 
                self.timeSinceSpawn = 0
            else 
               print("WAVE HAS NO LOCATION") 
            end
        end 
    end 
end




return RowboatWakeSpawner
%%+%%scripts/components/sailable.lua%%-%%local function onsailor(self)
    if self:IsOccupied() then
        self.inst:RemoveTag("sailable")
    else
        self.inst:AddTag("sailable")
    end
end

local function onhassailor(self, hassailor)
    if self.inst.replica and self.inst.replica.sailable then
        self.inst.replica.sailable._hassailor:set(hassailor)
    end
end

local Sailable =  Class(function(self, inst)
    self.inst = inst
    self.hassailor = false
    self.isembarking = false
    self.sanitydrain = 0
    self.maprevealbonus = 0
    self.movementbonus = 0
    self.hitmoisturerate = 1.0
    self.hit_immunity = 0.66 --time in seconds the boat is immune to hit state reactions after being hit.
    self.next_hit_time = 0
end, nil, {
    sailor = onsailor,
    isembarking = onsailor,
    hassailor = onhassailor,
})

function Sailable:OnRemoveFromEntity()
    self.inst:RemoveTag("sailable")
end

function Sailable:GetSailor()
    return self.sailor
end

function Sailable:IsOccupied()
    return self.sailor ~= nil or self.isembarking
end

function Sailable:CanDoHit()
    return self.next_hit_time <= GetTime()
end

function Sailable:GetHit()
    self.next_hit_time = GetTime() + self.hit_immunity
end

function Sailable:SetHitImmunity(time)
    self.hit_immunity = time
end

function Sailable:GetIsSailEquipped()
    if self.alwayssail then return true end
    
    if self.inst.components.container then 
        local equipped = self.inst.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
        if equipped and equipped:HasTag("sail") then 
            return true
        end 
    end 
    return false 
end 

function Sailable:OnEmbarked(sailor)
    self.sailor = sailor
    self.isembarking = false

    if self.inst.components.boathealth then
        self.inst.components.boathealth:StartConsuming()
    elseif self.inst.components.fueled then 
        self.inst.components.fueled:StartConsuming()
    end
	if self.inst.MiniMapEntity then
		self.inst.MiniMapEntity:SetEnabled(false)
	end

    self.inst:PushEvent("embarked", {sailor = sailor})

    if self.inst.components.workable then
        self.inst.components.workable.workable = false
    end
end

function Sailable:OnDisembarked(sailor)
    if self.sailor == sailor then 
        self.sailor = nil
    end

    if self.inst.components.boathealth then
        self.inst.components.boathealth:StopConsuming()
        self.inst.components.boathealth:SetIsMoving(false)
    elseif self.inst.components.fueled then 
        self.inst.components.fueled:StopConsuming()
    end
	if self.inst.MiniMapEntity then
		self.inst.MiniMapEntity:SetEnabled(true)
	end

    self.inst:PushEvent("disembarked", {sailor = sailor})

    if self.inst.components.workable then
        self.inst.components.workable.workable = true
    end

    self.inst.AnimState:PlayAnimation("run_loop", true)
end

function Sailable:GetMovementBonus()
    return self.movementbonus
end

function Sailable:GetSanityDrain()
    return self.sanitydrain
end 

function Sailable:GetHitMoistureRate()
    return self.hitmoisturerate
end

function Sailable:GetMapRevealBonus()
    return self.maprevealbonus
end

function Sailable:HasSailor()
    return self.hassailor
end

return Sailable%%+%%scripts/components/sailable_replica.lua%%-%%local Sailable = Class(function(self, inst)
    self.inst = inst

    self.prerowanimation = "row_pre"
    self.rowanimation = "row_loop"
    self.postrowanimation = "row_pst"

    self.presailanim = "sail_pre"
    self.sailanim = "sail_loop"
    self.postsailanim = "sail_pst"

    self.trawlover = "trawlover"

    self.idleanim = "idle_loop"

    self.creaksound = "ia/common/boat/creaks/creaks"

    self._hassailor = net_bool(inst.GUID, "sailable._hassailor")
end)

function Sailable:PlayPreRowAnims()
    self.inst.AnimState:PlayAnimation(self.prerowanimation)
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayPreRowAnims()
    end
end

function Sailable:PlayRowAnims()
    if not self.inst.AnimState:IsCurrentAnimation(self.rowanimation) then
        self.inst.AnimState:PlayAnimation(self.rowanimation, true)
    end
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayRowAnims()
    end
end

function Sailable:PlayPostRowAnims()
    self.inst.AnimState:PlayAnimation(self.postrowanimation)
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayPostRowAnims()
    end
    self:PlayIdleAnims(true)
end

function Sailable:PlayPreSailAnims()
    self.inst.AnimState:PlayAnimation(self.presailanim)
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayPreSailAnims()
    end
end

function Sailable:PlaySailAnims()
    if not self.inst.AnimState:IsCurrentAnimation(self.sailanim) then
        self.inst.AnimState:PlayAnimation(self.sailanim, true)
    end
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlaySailAnims()
    end
end

function Sailable:PlayPostSailAnims()
    self.inst.AnimState:PlayAnimation(self.postsailanim)
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayPostSailAnims()
    end
    self:PlayIdleAnims(true)
end

function Sailable:PlayTrawlOverAnims()
    self.inst.AnimState:PlayAnimation(self.trawlover)
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayTrawlOverAnims()
    end
    self:PlayIdleAnims(true)
end

function Sailable:PlayIdleAnims(push)
    if push then
        self.inst.AnimState:PushAnimation(self.idleanim, true)
        for k, v in pairs(self.inst.boatvisuals) do
            k.components.boatvisualanims:PlayIdleAnims(true)
        end
        return
    end
    if not self.inst.AnimState:IsCurrentAnimation(self.idleanim) then
        self.inst.AnimState:PlayAnimation(self.idleanim, true)
    end
    for k, v in pairs(self.inst.boatvisuals) do
        k.components.boatvisualanims:PlayIdleAnims(false)
    end
end

function Sailable:HasSailor()
    if self.inst.components.sailable then
        return self.inst.components.sailable:HasSailor()
    else
        return self._hassailor:value()
    end
end

function Sailable:GetIsSailEquipped()
    if self.inst.components.sailable then
        return self.inst.components.sailable:GetIsSailEquipped()
    else
        if self.alwayssail then return true end
        
        if self.inst.replica.container then 
            local equipped = self.inst.replica.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
            if equipped and equipped:HasTag("sail") then 
                return true
            end 
        end 
        return false 
    end
end 

return Sailable%%+%%scripts/components/sailor.lua%%-%%--[[
local function PlayerHasLavae(item)
    return item.components.petleash and item.components.petleash.numpets > 0
end
--]]
local function onboat(self, boat)
    if self.inst.replica.sailor then
        self.inst.replica.sailor._boat:set(boat)
    end
end

local function onsailing(self, sailing)
    if sailing then
        self.inst:AddTag("sailing")
    else
        self.inst:RemoveTag("sailing")
    end
end

local Sailor = Class(function(self, inst)
    self.inst = inst
    self.boat = nil
    self.sailing = false
    self.durabilitymultiplier = 1.0
    self.warningthresholds = --Moved these back to sailor from wisecracker -Z
    {
      { percent = 0.5, string = "ANNOUNCE_BOAT_DAMAGED" },
      { percent = 0.3, string = "ANNOUNCE_BOAT_SINKING" },
      { percent = 0.1, string = "ANNOUNCE_BOAT_SINKING_IMMINENT" },
    }
end, 
nil, 
{
    boat = onboat,
    sailing = onsailing,
})

--[[
function Sailor:HandleFollowers(water)
    local ChangeScene
    if water then
        local entpt

        function ChangeScene(ent)
            if not ent:HasTag("INLIMBO") --is it already removed?
            and not (ent.components.inventoryitem and ent.components.inventoryitem.owner ~= nil)
            and not ent:CanOnWater() then

                SpawnAt("spawn_fx_small", ent)
                ent:RemoveFromScene()
            elseif ent:HasTag("INLIMBO") --is it already removed?
            and not (ent.components.inventoryitem and ent.components.inventoryitem.owner ~= nil)
            and ent:CanOnWater() then

                if not entpt then -- Only do this once, if needed
                    entpt = Vector3(GetNextTickPosition(self.inst, false, TickSpeedToSpeed(3)))
                    SpawnAt("spawn_fx_small", entpt)
                end
                ent.Transform:SetPosition(entpt:Get())
                ent:ReturnToScene()

                if ent.components.spawnfader ~= nil then
                    ent.components.spawnfader:FadeIn()
                end
            end
        end
    else
        local entpt

        function ChangeScene(ent)
            if not ent:HasTag("INLIMBO") --is it already removed?
            and not (ent.components.inventoryitem and ent.components.inventoryitem.owner ~= nil)
            and not ent:CanOnLand() then

                SpawnAt("spawn_fx_small", ent)
                ent:RemoveFromScene()
            elseif ent:HasTag("INLIMBO") --is it already removed?
            and not (ent.components.inventoryitem and ent.components.inventoryitem.owner ~= nil)
            and ent:CanOnLand() then

                if not entpt then -- Only do this once, if needed
                    entpt = Vector3(GetNextTickPosition(self.inst, false, TickSpeedToSpeed(3)))
                    SpawnAt("spawn_fx_small", entpt)
                end
                ent.Transform:SetPosition(entpt:Get())
                ent:ReturnToScene()

                if ent.components.spawnfader ~= nil then
                    ent.components.spawnfader:FadeIn()
                end
            end
        end
    end
    if self.inst.components.inventory ~= nil then
        for k, item in pairs(self.inst.components.inventory.itemslots) do
            if item.components.leader ~= nil then
                for follower, v in pairs(item.components.leader.followers) do
                    ChangeScene(follower)
                end
            end
        end
        --special special case, look inside equipped containers
        for k, equipped in pairs(self.inst.components.inventory.equipslots) do
            if equipped.components.container ~= nil then
                for j, item in pairs(equipped.components.container.slots) do
                    if item.components.leader ~= nil then
                        for follower, v in pairs(item.components.leader.followers) do
                            ChangeScene(follower)
                        end
                    end
                end
            end
        end
    end

    -- This can be an arbitrary number of items
    for i, item in pairs(self.inst.components.inventory:FindItems(PlayerHasLavae)) do
        for j, pet in pairs(item.components.petleash:GetPets()) do
            ChangeScene(pet)
        end
    end

    if self.inst.components.petleash then
        for i, pet in pairs(self.inst.components.petleash:GetPets()) do
            ChangeScene(pet)
        end
    end

    if self.inst.components.leader ~= nil and self.inst.components.leader:CountFollowers() > 0 then
        for follower, v in pairs(self.inst.components.leader.followers) do
            ChangeScene(follower)
        end
    end
end
--]]

function Sailor:GetBoat()
    return self.boat
end

function Sailor:AlignBoat(direction)
    if self.boat then
        local rot = self.inst.Transform:GetRotation()
        self.boat.Transform:SetRotation(rot)
        for visual, v in pairs(self.boat.boatvisuals) do
            visual.Transform:SetRotation(rot)
        end
    end
end

-- This needs to save, because we're removing the boat from the scene
-- to prevent the player from dying upon logging back in.
function Sailor:OnSave()
    local data = {}
    if self.boat ~= nil then
        data.boat = self.boat:GetSaveRecord()
        data.boat.prefab = self.boat.actualprefab or self.boat.prefab
    end
    return data
end

function Sailor:OnLoad(data)
    if data and data.boat ~= nil then
        local boat = SpawnSaveRecord(data.boat)
        if boat then
            self:Embark(boat)
            if boat.components.container then
                boat:DoTaskInTime(0.3, function()
                    if boat.components.container:IsOpen() then
                        boat.components.container:Close(true)
                    end
                end)
                boat:DoTaskInTime(1.5, function()
                    boat.components.container:Open(self.inst)
                end)
            end
        end 
    end
end

function Sailor:OnUpdate(dt)
    if self.boat ~= nil and self.boat:IsValid() then
        if self.boat.components.boathealth then 
            self.boat.components.boathealth.depletionmultiplier = 1.0/self.durabilitymultiplier
        end
        local rot = self.inst.Transform:GetRotation()
        self.boat.Transform:SetRotation(rot)
        for visual, v in pairs(self.boat.boatvisuals) do
            visual.Transform:SetRotation(rot)
        end
    end 
end

function Sailor:Disembark(pos, boat_to_boat)
    self.sailing = false
    self.inst:StopUpdatingComponent(self)

    if self.boat.onboatdelta then
        self.inst:RemoveEventCallback("boathealthchange", self.boat.onboatdelta, self.boat)
        self.boat.onboatdelta = nil
    end
    
    if self.boat.components.container then 
        self.boat.components.container:Close(true)
    end

    if self.inst.components.farseer then
        self.inst.components.farseer:RemoveBonus("boat")
    end

    if self.inst:HasTag("pirate") and self.boat.components.sailable then
        self.boat.components.sailable.sanitydrain = self.cachedsanitydrain
        self.cachedsanitydrain = nil
    end

    self.inst:RemoveChild(self.boat)

    if self.boat.Physics then
        self.boat.Physics:Teleport(self.inst.Transform:GetWorldPosition())
    else
        self.boat.Transform:SetPosition(self.inst.Transform:GetWorldPosition())
    end

    self.inst.components.locomotor.hasmomentum = false

    self.inst.components.locomotor:RemoveExternalSpeedAdder(self.boat, "SAILOR")

    self.inst:RemoveTag("aquatic")
    self.inst:RemoveTag("sailing")
    self.inst:PushEvent("disembarkboat", {target = self.boat, pos = pos, boat_to_boat = boat_to_boat})

    if self.OnDisembarked then
        self.OnDisembarked(self.inst)
    end

    if self.boat.components.sailable then
        self.boat.components.sailable:OnDisembarked(self.inst)
    end

    self.boat = nil

    --self:HandleFollowers(false)

    if pos then
        self.inst.sg:GoToState("jumpoffboatstart", pos)
    elseif boat_to_boat then
        self.inst.sg:GoToState("jumponboatstart")
    end
end

function Sailor:Embark(boat)
    if not boat or boat.components.sailable == nil then
        return
    end

    self.sailing = true
    self.boat = boat

    if self.inst:HasTag("pirate") then
        self.cachedsanitydrain = boat.components.sailable.sanitydrain
        boat.components.sailable.sanitydrain = 0
    end

    self.inst:StartUpdatingComponent(self)

    self.inst.AnimState:OverrideSymbol("flotsam", self.boat.components.sailable.flotsambuild, "flotsam")

    self.inst:AddTag("aquatic")
    self.inst:AddTag("sailing")
    self.inst.sg:GoToState("jumpboatland")

    if self.boat.Physics then
        self.boat.Physics:Teleport(0, -0.1, 0)
    else
        self.boat.Transform:SetPosition(0, -0.1, 0)
    end
    self.inst:AddChild(self.boat)
    
    self.inst.components.locomotor:SetExternalSpeedAdder(boat, "SAILOR", boat.components.sailable.movementbonus)

    self.inst.components.locomotor.hasmomentum = true

    --Listen for boat taking damage, talk if it is!
    boat.onboatdelta = function(boat, data)
        if data then
            local old = data.oldpercent
            local new = data.percent
            local message = nil
            for _, threshold in ipairs(self.warningthresholds) do
                if old > threshold.percent and new <= threshold.percent then
                    message = threshold.string
                end
            end

            if message then
                self.inst:PushEvent("boat_damaged", {message = message})
            end
        end
    end
    self.inst:ListenForEvent("boathealthchange", boat.onboatdelta, boat)

    if boat.components.boathealth then
        local percent = boat.components.boathealth:GetPercent()
        boat.onboatdelta(boat, {oldpercent = 1, percent = percent})
    end

    
    if self.inst.components.farseer and boat.components.sailable and boat.components.sailable:GetMapRevealBonus() then
        self.inst.components.farseer:AddBonus("boat", boat.components.sailable:GetMapRevealBonus())
    end
    

    if boat.components.container then
        if boat.components.container:IsOpen() then
            boat.components.container:Close(true)
        end
        boat:DoTaskInTime(0.25, function() boat.components.container:Open(self.inst) end)
    end

    --self:HandleFollowers(true)

    self.inst:PushEvent("embarkboat", {target = self.boat})

    if self.OnEmbarked then 
        self.OnEmbarked(self.inst)
    end

    if self.boat.components.sailable then
        self.boat.components.sailable:OnEmbarked(self.inst)
    end
end

function Sailor:IsSailing()
    return self.sailing and self.boat ~= nil
end

return Sailor%%+%%scripts/components/sailor_client.lua%%-%%local function onboat(self, boat)
    if boat then
        self.inst:StartUpdatingComponent(self)
    else
        self.inst:StopUpdatingComponent(self)
    end
end

local Sailor = Class(function(self, inst)
    self.inst = inst
    self.boat = self.inst.replica.sailor and self.inst.replica.sailor:GetBoat() or nil
end, 
nil, 
{
    boat = onboat,
})

function Sailor:OnUpdate(dt)
    if self.boat and self.boat:IsValid() then
        local rot = self.inst.Transform:GetRotation()
        self.boat.Transform:SetRotation(rot)
        for visual, v in pairs(self.boat.boatvisuals) do
            visual.Transform:SetRotation(rot)
        end
    end 
end

return Sailor%%+%%scripts/components/sailor_replica.lua%%-%%local function OnBoatAttacked(inst)
    inst.replica.sailor.boatattackedevent:set_local(true)
    inst.replica.sailor.boatattackedevent:set(true)
end

local function OnBoatDirty(sailor)
    if sailor._currentboat and sailor._currentboat:IsValid() then

        sailor._currentboat.prefab = sailor._currentboat.actualprefab
        sailor._currentboat.actualprefab = nil
        sailor._currentboat.nameoverride = nil
            
        RemoveLocalNOCLICK(sailor._currentboat)
    end
    if sailor._boat:value() then
        sailor._currentboat = sailor._boat:value()

        sailor._currentboat.actualprefab = sailor._currentboat.prefab
        sailor._currentboat.prefab = "player_"..sailor._currentboat.actualprefab
        sailor._currentboat.nameoverride = sailor._currentboat.actualprefab

        if sailor.inst == TheLocalPlayer then
            LocalNOCLICK(sailor._currentboat)
        end
    else
        sailor._currentboat = nil
    end
    if sailor.inst.components.sailor_client then
        sailor.inst.components.sailor_client.boat = sailor._currentboat
    end
end

local function OnBoatDirty_inst(inst)
	return OnBoatDirty(inst.replica.sailor)
end

local Sailor = Class(function(self, inst)
    self.inst = inst

    self._boat = net_entity(inst.GUID, "sailor._boat", "boatdirty")
    --boatattacked event only on remote clients
    self.boatattackedevent = net_bool(inst.GUID, "boathealth.boatattackedevent", not TheWorld.ismastersim and "boatattacked" or nil)

    self.inst:DoTaskInTime(0, function()
		self.inst:ListenForEvent("boatdirty", function()
			OnBoatDirty(self)
			self.inst:DoTaskInTime(1, OnBoatDirty_inst)
		end)
        OnBoatDirty(self)
    end)

    if TheWorld.ismastersim then
        inst:ListenForEvent("boatattacked", OnBoatAttacked)
    end
end)

--not in use, but leaving here since it doesn't really cause problems
function Sailor:IsSailing()
    return self.inst:HasTag("sailing")
end

function Sailor:GetBoat()
    if self.inst.components.sailor then
        return self.inst.components.sailor:GetBoat()
    end

    return self._currentboat
end

function Sailor:GetBoatHealth()
    local boat = self:GetBoat()
    return boat and boat.replica.boathealth and boat.replica.boathealth:GetPercent() or nil
end

function Sailor:AlignBoat(direction)
    if self.inst.components.sailor then
        self.inst.components.sailor:AlignBoat(direction)
    else
        local boat = self:GetBoat()
        if boat then
            boat.Transform:SetRotation(direction or self.inst.Transform:GetRotation())
        end
    end
end

return Sailor%%+%%scripts/components/seedable.lua%%-%%local Seedable = Class(function(self, inst)
    self.inst = inst
    self.growtime = 120
    self.product = nil
    self.minlevel = 1
end)

return Seedable%%+%%scripts/components/sentientball.lua%%-%%
local function OnIgnite(inst)
	inst.components.sentientball:Say(STRINGS.RAWLING.on_ignite)
end

local function OnExtinguish(inst)
	inst.components.sentientball:Say(STRINGS.RAWLING.on_extinguish)
end

local SentientBall = Class(function(self, inst)
	self.inst = inst

	-- this prevents saying too much on events
	self.last_say_time = 0

	self:ScheduleConversation(60 + math.random() * 60)
	
	
	inst:ListenForEvent("onignite", OnIgnite)
	inst:ListenForEvent("onextinguish", OnExtinguish)
end)


function SentientBall:OnDropped()
	self:Say(STRINGS.RAWLING.on_dropped)
end

function SentientBall:OnThrown()
	self:Say(STRINGS.RAWLING.on_thrown)
end

function SentientBall:OnEquipped()
	self:Say(STRINGS.RAWLING.equipped)
end



function SentientBall:Say(list)
	if GetTime() > self.last_say_time + 4 then
		self.inst.components.talker:Say(list[math.random(#list)])
		self.last_say_time = GetTime()
        self:ScheduleConversation(60 + math.random() * 60)
	end
end

local function OnMakeConvo(inst, self)
    self.convo_task = nil
    self:MakeConversation()
end

function SentientBall:ScheduleConversation(delay)
    if self.convo_task ~= nil then
        self.convo_task:Cancel()
    end
    self.convo_task = self.inst:DoTaskInTime(delay or 10 + math.random() * 5, OnMakeConvo, self)
end

function SentientBall:MakeConversation()
	local grand_owner = self.inst.components.inventoryitem:GetGrandOwner()
	local owner = self.inst.components.inventoryitem.owner
	local quiplist
	
	if owner == nil then
		--on the ground
		quiplist = STRINGS.RAWLING.on_ground
	elseif self.inst.components.equippable and self.inst.components.equippable:IsEquipped() then
		--currently equipped
		quiplist = STRINGS.RAWLING.equipped
    elseif owner.components.inventoryitem ~= nil and owner.components.inventoryitem.owner == self.owner then
        --in backpack
		quiplist = STRINGS.RAWLING.in_container
	elseif owner:HasTag("player") then
		--in player inventory
		quiplist = STRINGS.RAWLING.in_inventory
	else
		--owned by someone else
		quiplist = STRINGS.RAWLING.other_owner
	end

	if quiplist then
		self:Say(quiplist)
	end
end

return SentientBall
%%+%%scripts/components/stickable.lua%%-%%-- stickable as in getting poked by a stick

local function oncanbesticked(self, canbesticked)
  if canbesticked and not self.inst:HasTag("canbesticked") then
    self.inst:AddTag("canbesticked")
  elseif not canbesticked and self.inst:HasTag("canbesticked") then
    self.inst:RemoveTag("canbesticked")
  end
end

local Stickable = Class(function(self, inst)
    self.inst = inst
    
    self.inst:AddTag("canbesticked")
    
    self.canbesticked = true
    self.hasbeensticked = nil
    self.onpoked = nil
  end,
  nil,
  {
    canbesticked = oncanbesticked
  })

function Stickable:CanBeSticked()
  return self.canbesticked
end

function Stickable:SetOnPokeCallback(onpoked)
  self.onpoked = onpoked
end

function Stickable:Stuck()
  self.canbesticked = nil
  self.hasbeensticked = true
end

function Stickable:UnStuck()
  self.canbesticked = true
  self.hasbeensticked = nil
end

function Stickable:PokedBy(worker, stick)
  if self.onpoked then
    self.onpoked(self.inst, worker, stick)
  end
  self:Stuck()
end

function Stickable:OnSave()
  local data = {}

  data.canbesticked = self.canbesticked
  data.hasbeensticked = self.hasbeensticked

  if next(data) then
    return data
  end
end

function Stickable:OnLoad(data)
  self.canbesticked = data.canbesticked
  self.hasbeensticked = data.hasbeensticked
end

return Stickable
%%+%%scripts/components/sticker.lua%%-%%-- sticker as in the poking variety

local Sticker = Class(function(self, inst)
	self.inst = inst
  
  self.inst:AddTag("sticker")
  
	--self.stickervalue = 1
end)

return Sticker
%%+%%scripts/components/sunkenprefabinfo.lua%%-%%local SunkenPrefabInfo = Class(function(self, inst)
	self.inst = inst
	self.prefabinfo = {}
	self.sunktime = 0
	self.base_sunktime = 0
end)

function SunkenPrefabInfo:SetPrefab(prefab)
	self.prefabinfo = prefab:GetSaveRecord()
	self.sunktime = GetTime()
end

function SunkenPrefabInfo:GetSunkenPrefab()
	return self.prefabinfo
end

function SunkenPrefabInfo:GetTimeSubmerged()
	return (GetTime() - self.sunktime) + self.base_sunktime
end

function SunkenPrefabInfo:OnSave()
	local data = {}
	data.prefabinfo = self.prefabinfo
	data.sunktime = self:GetTimeSubmerged()
	return data
end

function SunkenPrefabInfo:OnLoad(data)
	if data then
		self.prefabinfo = data.prefabinfo
		self.base_sunktime = data.sunktime or 0
	end
end

return SunkenPrefabInfo%%+%%scripts/components/talkingbird.lua%%-%%local TalkingBird = Class(function(self, inst)
    self.inst = inst
    self.time_to_convo = 10

    self.inst:ListenForEvent("ondropped", function() self:OnDropped() end)
    self.inst:ListenForEvent("onputininventory", function(owner) self:OnPutInInventory(owner) end)

    local dt = 5 + math.random()
    self.inst:DoPeriodicTask(dt, function() self:OnUpdate(dt) end)
    self.warnlevel = 0
end)


function TalkingBird:OnDropped()
    self:Say(STRINGS.TALKINGBIRD.on_dropped)
    if self._owner then
        if self._onembark then
            self.inst:RemoveEventCallback("embarkboat", self._onembark, self._owner)
        end
        if self._ondisembark then
            self.inst:RemoveEventCallback("disembarkboat", self._ondisembark, self._owner)
        end
    end
    self._onembark = nil
    self._ondisembark = nil
    self._owner = nil
end

function TalkingBird:OnPutInInventory(owner)
    self._owner = owner
    if self._owner then
        self._onembark = function() self:OnEmbarked() end
        self._ondisembark = function() self:OnDisembarked() end
        self.inst:ListenForEvent("embarkboat", self._onembark, self._owner)
        self.inst:ListenForEvent("disembarkboat", self._ondisembark, self._owner)
    end
end

function TalkingBird:OnEmbarked()
    local grand_owner = self.inst.components.inventoryitem:GetGrandOwner()
    local owner = self.inst.components.inventoryitem.owner
    if (grand_owner and grand_owner:HasTag("player")) or (owner and owner:HasTag("player")) then
        self:Say(STRINGS.TALKINGBIRD.on_mounted)
    end
end

function TalkingBird:OnDisembarked()
    local grand_owner = self.inst.components.inventoryitem:GetGrandOwner()
    local owner = self.inst.components.inventoryitem.owner
    if (grand_owner and grand_owner:HasTag("player")) or (owner and owner:HasTag("player")) then
        self:Say(STRINGS.TALKINGBIRD.on_dismounted)
    end
end

function TalkingBird:OnUpdate(dt)
    self.time_to_convo = self.time_to_convo - dt
    if self.time_to_convo <= 0 then
        self:MakeConversation()
    end
end

function TalkingBird:Say(list, sound_override)
    self.sound_override = sound_override
    self.inst.components.talker:Say(list[math.random(#list)])
    self.time_to_convo = math.random(60, 120)
end


function TalkingBird:MakeConversation()
    if self.inst.components.freezable and self.inst.components.freezable:IsFrozen() then
        return
    end

    local grand_owner = self.inst.components.inventoryitem:GetGrandOwner()
    local owner = self.inst.components.inventoryitem.owner

    local quiplist = nil
    if owner and owner:HasTag("player") then
        if self.inst.components.equippable and self.inst.components.equippable:IsEquipped() then
            --currently equipped
        else
            --in player inventory
            quiplist = STRINGS.TALKINGBIRD.in_inventory
        end
    elseif owner == nil then
        --on the ground
        quiplist = STRINGS.TALKINGBIRD.on_ground
    elseif grand_owner and grand_owner ~= owner and grand_owner:HasTag("player") then
        --in a backpack
        quiplist = STRINGS.TALKINGBIRD.in_container
    elseif owner and owner.components.container then
        --in a container
        quiplist = STRINGS.TALKINGBIRD.in_container
    else
        --owned by someone else
        quiplist = STRINGS.TALKINGBIRD.other_owner
    end

    if quiplist then
        self:Say(quiplist)
    end
end

return TalkingBird
%%+%%scripts/components/telescope.lua%%-%%local function oncanuse(self)
    if self.canuse then
        self.inst:AddTag("telescope")
    else
        self.inst:RemoveTag("telescope")
    end
end

local Telescope = Class(function(self, inst)
    self.inst = inst
    self.range = TUNING.TELESCOPE_RANGE
    self.onusefn = nil
    self.canuse = true
end,
nil,
{
    canuse = oncanuse,
})

function Telescope:OnRemoveFromEntity()
    self.inst:RemoveTag("telescope")
end

function Telescope:SetOnUseFn(fn)
    self.onusefn = fn
end

function Telescope:SetRange(range)
    self.range = range
end

function Telescope:Peer(doer, pos)
	if doer and doer.player_classified then
		local x, y, z = doer.Transform:GetWorldPosition()
		local angle = - doer:GetAngleToPoint(pos.x, pos.y, pos.z) - (TUNING.TELESCOPE_ARC/2)
		local arc = TUNING.TELESCOPE_ARC
		local range = self.range
		local arclength = 0.5 * range * arc * DEGREES

		if not TheWorld.state.isday then
			range = range / 2
		end

		local i = 1
		while i < range do
			for j = 0, arclength, 4 do
				local a = angle + (j / (0.5 * range * DEGREES))
				--print(string.format("%4.2f = (%4.2f / %4.2f)\n", a, j, arclength))
				local c = math.cos(a * DEGREES)
				local s = math.sin(a * DEGREES)
				local x0, z0 = x + i * c, z + i * s
				doer.player_classified.MapExplorer:RevealArea(x0, 0, z0)
				-- local cx, cy, cz = TheWorld.Map:GetTileCenterPoint(x0, 0, z0)
				-- if cx and cy and cz then
					-- doer.player_classified.MapExplorer:RevealArea(cx, cy, cz)
					-- minimap:ShowArea(cx, cy, cz, 30)
					-- map:VisitTile(map:GetTileCoordsAtPoint(cx, cy, cz))
				-- end
			end
			i = i + 8
		end

		--Toggle map
		if doer.player_classified.peertelescope then
			doer.player_classified.peertelescope:push()
		end
		-- doer:PushEvent("peertelescope")

		if self.onusefn ~= nil then
			self.onusefn(self.inst, doer, pos)
		end

		return true
	end
end

return Telescope
%%+%%scripts/components/throwable.lua%%-%%local Throwable = Class(function(self, inst)
    self.inst = inst

    self.inst:AddTag("Throwable")

    self.onthrown = nil
    -- self.onland = nil
    self.throwdistance_controller = 10
    self.random_angle = 10

    self.yOffset = 1

    self.speed = 10
end)

function Throwable:GetThrowPoint()
    --For use with controller.
    local owner = self.inst.components.inventoryitem.owner
    if not owner then return end
    local pt = nil
    local rotation = owner.Transform:GetRotation()*DEGREES
    local pos = owner:GetPosition()

    for r = self.throwdistance_controller, 1, -1 do
        local numtries = 2*PI*r
        pt = FindValidPositionByFan(rotation, r, numtries, function() return true end) --TODO: #BDOIG Might not need to be walkable?
        if pt then
            return pt + pos
        end
    end
end

function Throwable:Throw(pt, thrower)
    local tothrow = self.inst

    if thrower == nil and self.inst.components.inventoryitem then
        thrower = self.inst.components.inventoryitem:GetGrandOwner()
    end


    if thrower and self.inst.components.inventoryitem and self.inst.components.inventoryitem:GetGrandOwner() == thrower then
        tothrow = thrower.components.inventory:DropItem(self.inst)
        print("Item after being dropped from the inventory: " .. tostring(tothrow) .. " / prefab = " .. tostring(tothrow.prefab))
    end

    local grav = 36.66 --rough gravity value - I have no idea where this is actually set.
    local yOffset = self.yOffset
    local pos = (thrower and thrower:GetPosition()) or (self.inst:IsValid() and not self.inst:IsInLimbo() and self.inst:GetPosition()) or nil

    if pos == nil then
        return
    end

    local offset = Vector3(0, yOffset, 0)
    local distance = pos:Dist(pt)
    local totarget = pt - pos
    local angle = math.atan2(totarget.z, totarget.x) + (math.random()*self.random_angle - (self.random_angle * 0.5))*DEGREES
    local time_to_target = distance/self.speed

    local Viy = ((grav*0.5*(time_to_target^2))+yOffset)/time_to_target

    tothrow.Transform:SetPosition((pos + offset):Get()) 
    tothrow.Physics:SetVel(self.speed*math.cos(angle), Viy, self.speed*math.sin(angle))

    local dir = Vector3((time_to_target*self.speed)*math.cos(angle), 0, (time_to_target*self.speed)*math.sin(angle))

    local thrownpt = thrower:GetPosition() + dir

    if self.onthrown then
        self.onthrown(tothrow, thrower, thrownpt, time_to_target)
    end

    tothrow:AddTag("falling")

    return true
end

return Throwable
%%+%%scripts/components/thrower.lua%%-%%--Creates & Launches "throwable" items.
local Thrower = Class(function(self, inst)
    self.inst = inst

    self.inst:AddTag("Thrower")

    self.throwable_prefab = "coconade"
    self.range = 15
    self.onthrowfn = nil
end)

function Thrower:GetThrowPoint()
    --For use with controller.
    local owner = self.inst.components.inventoryitem.owner
    if not owner then return end
    local pt = nil
    local rotation = owner.Transform:GetRotation()*DEGREES
    local pos = owner:GetPosition()

    for r = self.range, 1, -1 do
        local numtries = 2*PI*r
        pt = FindValidPositionByFan(rotation, r, numtries, function() return true end) --TODO: #BDOIG Might not need to be walkable?
        if pt then
            return pt + pos
        end
    end
end

function Thrower:Throw(pt)
    local thrown = SpawnPrefab(self.throwable_prefab)
    local x, y, z
    if self.getthrowposition then
        x, y, z = self.getthrowposition(self.inst)
    else
        x, y, z = self.inst.Transform:GetWorldPosition()
    end
    thrown.Transform:SetPosition(x, y, z)
    thrown.components.throwable:Throw(pt, self.inst)

    if self.onthrowfn then
        self.onthrowfn(self.inst, thrown, pt)
    end
end

return Thrower%%+%%scripts/components/tigersharker.lua%%-%%--[[
Handles the spawning of the tigershark.
Listens for targets doing "interesting" actions & events (fishing, cooking, eating, surfing etc.)
Rolls a chance against how active the shark is that season & spawns

NOTE: target must be "aquatic" to spawn shark.
--]]

local DEBUG_ALWAYS_SPAWN = false

local SHARK_TUNING = {
    [SEASONS.AUTUMN] = {
        actions = {
            [ACTIONS.FISH] 		= 0.01,
            [ACTIONS.REEL] 		= 0.01,
            [ACTIONS.CATCH] 	= 0.01,
            [ACTIONS.BAIT] 		= 0.01,
            [ACTIONS.NET] 		= 0.01,
        },
        events = {},
        cooldown = TUNING.TOTAL_DAY_TIME * 7,
    },
    [SEASONS.WINTER] = {
        actions = {
            [ACTIONS.FISH] 		= 0.01,
            [ACTIONS.REEL] 		= 0.01,
            [ACTIONS.CATCH] 	= 0.01,
            [ACTIONS.ATTACK]	= 0.01,
            [ACTIONS.BAIT] 		= 0.03,
            [ACTIONS.NET] 		= 0.03,
            [ACTIONS.EAT] 		= 0.03,
        },
        events = {
            ["boostbywave"] = 0.01,
        },
        cooldown = TUNING.TOTAL_DAY_TIME * 5,
    },
    [SEASONS.SPRING] = {
        actions = {
            [ACTIONS.FISH] 		= 0.02,
            [ACTIONS.REEL] 		= 0.02,
            [ACTIONS.CATCH] 	= 0.02,
            [ACTIONS.ATTACK]	= 0.02,
            [ACTIONS.BAIT] 		= 0.06,
            [ACTIONS.NET] 		= 0.06,
            [ACTIONS.EAT] 		= 0.06,
        },
        events = {
            ["boostbywave"] = 0.05,
        },
        cooldown = TUNING.TOTAL_DAY_TIME * 3,
    },
    [SEASONS.SUMMER] = {
        actions = {
            [ACTIONS.FISH] 		= 0.01,
            [ACTIONS.REEL] 		= 0.01,
            [ACTIONS.CATCH] 	= 0.01,
            [ACTIONS.BAIT] 		= 0.01,
            [ACTIONS.NET] 		= 0.01,
        },
        events = {},
        cooldown = TUNING.TOTAL_DAY_TIME * 10,
    },
}

if SEASONS.MILD then
    SHARK_TUNING[SEASONS.MILD] = SHARK_TUNING[SEASONS.AUTUMN]
end

if SEASONS.WET then
    SHARK_TUNING[SEASONS.WET] = SHARK_TUNING[SEASONS.WINTER]
end

if SEASONS.GREEN then
    SHARK_TUNING[SEASONS.GREEN] = SHARK_TUNING[SEASONS.SPRING]
end

if SEASONS.DRY then
    SHARK_TUNING[SEASONS.DRY] = SHARK_TUNING[SEASONS.SUMMER]
end

local function OnPlayerJoined(src,player)
    if TheWorld.components.tigersharker.targets[player] then
        return
    end
    TheWorld.components.tigersharker:TrackTarget(player)
end

local function OnPlayerLeft(src,player)
    if TheWorld.components.tigersharker.targets[player] then
        TheWorld.components.tigersharker:StopTrackingTarget(player)
    end
end

local TigerSharker = Class(function(self, inst)
    self.inst = inst

    self.respawn_time = TUNING.TOTAL_DAY_TIME * 20

    self.shark_prefab = "tigershark"
    self.shark = nil --a reference to the shark entity.
    self.shark_data = nil

    self.shark_home = nil --a reference to the shark's home nest

    self.actions = {} --the actions the current season cares about
    self.events = {} --the events the current season cares about	
    self.targets = {} --the targets the spawner cares about

    self.appearance_cooldown = TUNING.TOTAL_DAY_TIME * 5 --Time between shark appearances.
    self.appearance_timer = 0 --Time left until the shark and show up again

    self.respawn_cooldown = TUNING.TOTAL_DAY_TIME * 10 --If the shark dies, how long before it can respawn
    self.respawn_timer = 0 --Time left until shark respawns.

    self.action_chance_mod = 1.0
    self.event_chance_mod = 1.0
    self.cooldown_mod = 1.0
    self.respawn_mod = 1.0

    self.inst:WatchWorldState("season", function() 
        if SHARK_TUNING[TheWorld.state.season] then
            self:SetTuning(SHARK_TUNING[TheWorld.state.season])
        end 
    end)
    if SHARK_TUNING[TheWorld.state.season] then
        self:SetTuning(SHARK_TUNING[TheWorld.state.season])
    end 

    self.inst:DoTaskInTime(0, function()
        for i, v in ipairs(AllPlayers) do
            self:TrackTarget(v)
        end
        self.inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
        self.inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)

        inst.components.tigersharker:FindHome()
    end)
end)

function TigerSharker:TrackTarget(target)
    if not target then
        print("No target passed into TigerSharker:TrackTarget!")
        return
    end

    self.targets[target] = {}

    self.targets[target]["actionsuccess"] = function(inst, data) self:OnAction(data.action, inst) end
    self.inst:ListenForEvent("actionsuccess", self.targets[target]["actionsuccess"], target)

    for event, chance in pairs(self.events) do
        target[event] = function(doer) self:OnEvent(event, doer) end
        self.inst:ListenForEvent(event, target[event], target)
    end
end

function TigerSharker:StopTrackingTarget(target)
    if self.targets[target] then
        for event, fn in pairs(self.targets[target]) do
            self.inst:RemoveEventCallback(event, fn, target)
        end
    end
end

function TigerSharker:FindHome()
    if self.shark_home then
        --There should only ever be one shark home in a world.
        --If you already have a home you don't need to look for it again.
        return
    end

    self.shark_home = FindEntity(self.inst, 10000, nil, {"sharkhome"}, {"FX", "NOCLICK"})
end

function TigerSharker:GetHomePosition()
    if not self.shark_home then
        print("TigerSharker has no home set so it can't return a position!")
        return
    end

    return self.shark_home:GetPosition()
end

function TigerSharker:GetAngleToHome(ent) --Radians
    local home_pos = self:GetHomePosition()

    if not home_pos then return end

    local ent_pos = ent:GetPosition()
    local home_vec =  ent_pos - home_pos
    return math.atan2(home_vec.z, home_vec.x)
end

function TigerSharker:TimeUntilRespawn()
    return math.max(self.respawn_timer - GetTime(), 0)
end

function TigerSharker:TimeUntilCanAppear()
    return math.max(self.appearance_timer - GetTime(), 0)
end

function TigerSharker:CanSpawn(ignore_cooldown, ignore_death)
    return (self:TimeUntilCanAppear() <= 0 or ignore_cooldown) and (self:TimeUntilRespawn() <= 0 or ignore_death) and not self.shark and self.shark_home and (self.action_chance_mod > 0.0 or self.event_chance_mod > 0.0)
end

function TigerSharker:OnEvent(event, doer)
    --If we're listening for this and the doer is on the water.
    if self.events[event] and doer:HasTag("aquatic") then
        --Roll against the chance for this event to trigger a spawn.
        if math.random() <= self.event_chance_mod * self.events[event] or DEBUG_ALWAYS_SPAWN then
            self:DoSharkEvent(doer)
        end
    end
end

function TigerSharker:OnAction(action, doer)
    --If we're listening for this and the doer is on the water.
    if self.actions[action.action] and doer:HasTag("aquatic") then
        --Roll against the chance for this event to trigger a spawn.
        if math.random() <= self.action_chance_mod * self.actions[action.action] or DEBUG_ALWAYS_SPAWN then
            self:DoSharkEvent(doer)
        end
    end
end

function TigerSharker:StartApperanceCooldown(timeoverride)
    self.appearance_timer = (timeoverride or (self.appearance_cooldown * self.cooldown_mod)) + GetTime()
end

function TigerSharker:StartRespawnCooldown(timeoverride)
    self.respawn_timer = (timeoverride or (self.respawn_cooldown * self.cooldown_mod)) + GetTime()
end

function TigerSharker:TakeOwnership(shark)
    self.shark = shark

    shark.ts_death_fn = function()
        self.shark_data = nil
        self:Abandon(shark)
        self:StartApperanceCooldown()
        self:StartRespawnCooldown()
    end

    shark.ts_sleep_fn = function()
        shark.shark_wake_fn = function()
            shark:RemoveEventCallback("entitywake", shark.shark_wake_fn)
            shark.shark_remove_task:Cancel()
        end

        shark:ListenForEvent("entitywake", shark.shark_wake_fn)

        shark.shark_remove_task = shark:DoTaskInTime(1, function() 
            self:DespawnShark() 
        end)
    end

    self.inst:ListenForEvent("death", shark.ts_death_fn, shark)
    self.inst:ListenForEvent("entitysleep", shark.ts_sleep_fn, shark)
end

function TigerSharker:Abandon(shark)
    if shark.ts_death_fn then
        self.inst:RemoveEventCallback("death", shark.ts_death_fn, shark)
        shark.ts_death_fn = nil
    end

    if shark.ts_sleep_fn then
        self.inst:RemoveEventCallback("entitysleep", shark.ts_sleep_fn, shark)
        shark.ts_sleep_fn = nil
    end

    self.shark = nil
end

function TigerSharker:GetNearbySpawnPoint(target)
    local to_home = self:GetAngleToHome(target)

    if to_home then
        local properties = {target:GetPosition(), -to_home, 40, 12}

        local offset = FindWaterOffset(unpack(properties))

        if not offset then
            offset = FindWalkableOffset(unpack(properties))
        end

        return (offset and target:GetPosition() + offset) or nil
    end
end

function TigerSharker:DoSharkEvent(target)
    local spawnpt = self:GetNearbySpawnPoint(target)

    if spawnpt then
        local shark = self:SpawnShark()

        if shark then
            shark.Transform:SetPosition(spawnpt:Get())

            local home_pos = self:GetHomePosition()
            shark.components.knownlocations:RememberLocation("point_owaf_interest", home_pos)

            --Look around the target for something you can interact with (kill)
            local possible_target = FindEntity(target, 20, 
            function(tar) return shark.components.combat:CanTarget(tar) end, 
                nil, {"prey", "player", "companion", "bird", "butterfly", "sharkitten"})

            shark.components.combat:SuggestTarget(possible_target)
        end
    end
end

function TigerSharker:SpawnShark(ignore_cooldown, ignore_death)
    if not self:CanSpawn(ignore_cooldown) then
        return
    end

    local shark = nil

    if self.shark_data then
        shark = SpawnSaveRecord(self.shark_data)
    else
        shark = SpawnPrefab(self.shark_prefab)
    end

    if shark.components.health:GetPercent() < 0.25 then
        shark.components.health:SetPercent(0.25)
    end

    self:TakeOwnership(shark)
    self:StartApperanceCooldown()

    return shark
end

function TigerSharker:DespawnShark()
    if not self.shark then
        return
    end

    local shark = self.shark

    --If the shark isn't dead save the data here
    if shark and not shark.components.health:IsDead() then
        self.shark_data = shark:GetSaveRecord()
    end

    self:Abandon(shark)
    shark:Remove()
end

function TigerSharker:SetTuning(tbl)
    --Stop listening to old events
    for target, listeners in pairs(self.targets) do
        for event, fn in pairs(listeners) do
            --Only remove the listeners in the "events" table. [Don't remove listener for actionsuccess]
            if self.events[event] then 
                self.inst:RemoveEventCallback(event, fn, target)
            end
        end
        listeners = {}
    end

    self.actions = {}
    for action, chance in pairs(tbl.actions) do
        self.actions[action] = chance
    end

    self.events = {}
    for event, chance in pairs(tbl.events) do
        self.events[event] = chance
    end

    --Needs to listen to each event on each tracked target.
    for target, listeners in pairs(self.targets) do
        for event, chance in pairs(self.events) do
            target[event] = function(doer) self:OnEvent(event, doer) end
            self.inst:ListenForEvent(event, target[event], target)
        end
    end

    self.appearance_cooldown = tbl.cooldown
end

function TigerSharker:LongUpdate(dt)
    self.appearance_timer = self.appearance_timer - dt
    self.respawn_timer = self.respawn_timer - dt
end

function TigerSharker:GetDebugString()
    local s = ""

    s = s.."\nACTIONS -- "
    for k,v in pairs(self.actions) do
        local name = k.str
        if type(k.str) == "table" then
            name = k.str["GENERIC"]
        end
        s = s..string.format("%s : %2.1f%%, ", name, v * 100)
    end


    s = s.."\nEVENTS -- "
    for k,v in pairs(self.events) do
        s = s..string.format("%s : %2.1f%%, ", k, v * 100)
    end

    s = s..string.format("\n-- Can Appear In: %2.2f", self:TimeUntilCanAppear() or 0)
    s = s..string.format("\n-- Can Respawn In: %2.2f", self:TimeUntilRespawn() or 0)
    s = s..string.format("\n-- Shark: %s", tostring(self.shark) or "NONE")
    return s
end

function TigerSharker:OnSave()
    local data = {}
    local references = {}

    if self.shark then
        data.shark = self.shark.GUID
        table.insert(references, self.shark.GUID)
    end

    if self.shark_home then
        data.shark_home = self.shark_home.GUID
        table.insert(references, self.shark_home.GUID)
    end

    data.appearance_timer = self:TimeUntilCanAppear()
    data.respawn_timer = self:TimeUntilRespawn()

    data.action_chance_mod = self.action_chance_mod
    data.event_chance_mod = self.event_chance_mod
    data.cooldown_mod = self.cooldown_mod
    data.respawn_mod = self.respawn_mod

    return data, references
end

function TigerSharker:OnLoad(data)
    if data then
        self.action_chance_mod = data.action_chance_mod or self.action_chance_mod
        self.event_chance_mod = data.event_chance_mod or self.event_chance_mod
        self.cooldown_mod = data.cooldown_mod or self.cooldown_mod
        self.respawn_mod = data.respawn_mod or self.respawn_mod

        self:StartApperanceCooldown(data.appearance_timer or 0)
        self:StartRespawnCooldown(data.respawn_timer or 0)
    end
end

function TigerSharker:LoadPostPass(ents, data)
    if data.shark then
        local shark = ents[data.shark]
        if shark then
            shark = shark.entity
            self:TakeOwnership(shark)
        end
    end

    if data.shark_home then
        local shark_home = ents[data.shark_home]
        if shark_home then
            self.shark_home = shark_home.entity
        end
    end
end

function TigerSharker:SetChanceModifier(action, event)
    self.action_chance_mod = action or 1.0
    self.event_chance_mod = event or 1.0
end

function TigerSharker:SetCooldownModifier(appear, respawn)
    self.cooldown_mod = appear or 1.0
    self.respawn_mod = respawn or 1.0
end

return TigerSharker%%+%%scripts/components/tiled.lua%%-%%return Class(function(self, inst)
    self.inst = inst


    function self:IsLandTileAtPoint(pos)
        return not IsOnWater(pos.x, pos.y, pos.z)
    end

    function self:IsWaterTileAtPoint(pos)
        return IsOnWater(pos.x, pos.y, pos.z)
    end
end)%%+%%scripts/components/tiletracker.lua%%-%%-- if you want to keep something on land or water, consider using "keeponland" component instead

local TileTracker = Class(function(self, inst)
	self.inst = inst
	self.tile = nil
	self.tileinfo = nil
	self.ontilechangefn = nil
	self.onwater = nil
	self.onwaterchangefn = nil
end)

-- function TileTracker:OnEntitySleep()
-- end

-- function TileTracker:OnEntityWake()
-- end

function TileTracker:Start()
	self.inst:StartUpdatingComponent(self)
end

function TileTracker:Stop()
	self.inst:StopUpdatingComponent(self)
end

function TileTracker:OnUpdate(dt)
	local tile, tileinfo = self.inst:GetCurrentTileType()

	if tile and tile ~= self.tile then
		self.tile = tile
		if self.ontilechangefn then
			self.ontilechangefn(self.inst, tile, tileinfo)
		end

		if self.onwaterchangefn or self.inst:HasTag("amphibious") then
			local onwater = IsWater(tile)
			
			if onwater ~= self.onwater then
				if self.onwaterchangefn then 
					self.onwaterchangefn(self.inst, onwater)
				end 
				if self.inst:HasTag("amphibious") then 
					if onwater then 
						self.inst:AddTag("aquatic")
					else
						self.inst:RemoveTag("aquatic")
					end 
				end 
			end
			self.onwater = onwater
		end
	end
end

function TileTracker:SetOnTileChangeFn(fn)
	self.ontilechangefn = fn
end

function TileTracker:SetOnWaterChangeFn(fn)
	self.onwaterchangefn = fn
end

return TileTracker
%%+%%scripts/components/twisterspawner.lua%%-%%--------------------------------------------------------------------------
--[[ Dependencies ]]
--------------------------------------------------------------------------
local easing = require("easing")

--------------------------------------------------------------------------
--[[ Deerclopsspawner class definition ]]
--------------------------------------------------------------------------
return Class(function(self, inst)

assert(TheWorld.ismastersim, "Twisterspawner should not exist on client")

--------------------------------------------------------------------------
--[[ Private constants ]]
--------------------------------------------------------------------------

local PLAYER_DIST = 20
local HASSLER_SPAWN_DIST = 40
local HASSLER_KILLED_DELAY_MULT = 6

--------------------------------------------------------------------------
--[[ Public Member Variables ]]
--------------------------------------------------------------------------

self.inst = inst

--------------------------------------------------------------------------
--[[ Private Member Variables ]]
--------------------------------------------------------------------------
local _warning = false
local _timetoattack = nil
local _warnduration = 60
local _timetonextwarningsound = 0
local _announcewarningsoundinterval = 4
	
local _attacksperwinter = 1
local _attackduringoffseason = false
local _targetplayer = nil
local _activehassler = nil
local _storedhassler = nil

local _activeplayers = {}

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function AllowedToAttack()
	--print("Twisterspawner allowed to attack?", TheWorld.state.cycles, _attackduringoffseason, TheWorld.state.season)
    return  #_activeplayers > 0 and
            TheWorld.state.cycles > TUNING.NO_BOSS_TIME and  
                (_attackduringoffseason or
                TheWorld.state.season == "winter")
end

local function PickAttackTarget()
    _targetplayer = nil
    if #_activeplayers == 0 then
        return
    end

	local loopCount = 0
	local player = nil
    local numPlayers = 0
    for i, v in ipairs(AllPlayers) do
        local x,y,z = v.Transform:GetWorldPosition()
        local ents = TheSim:FindEntities(x,y,z, PLAYER_DIST, {"player"})
        if numPlayers < #ents then
            numPlayers = #ents
            player = v
        end
    end
	--print("Twister picked target", player)
	_targetplayer = player
end

local function PauseAttacks()
	_targetplayer = nil
    _warning = false
    self.inst:StopUpdatingComponent(self)
end

local function ResetAttacks()
    _timetoattack = nil
    PauseAttacks()
end

local function TryStartAttacks(killed)
    if AllowedToAttack() then
        if _activehassler == nil and _attacksperwinter > 0 and _timetoattack == nil then
            local timeLeftInSeason = (TheWorld.state.remainingdaysinseason - TheWorld.state.elapseddaysinseason) * TUNING.TOTAL_DAY_TIME

            local attackdelay = (TheWorld.state.winterlength - 1) * TUNING.TOTAL_DAY_TIME / (_attacksperwinter + 1)
            if killed == true then
                attackdelay = attackdelay * HASSLER_KILLED_DELAY_MULT
            end
            _timetoattack = attackdelay
        end

        self.inst:StartUpdatingComponent(self)
        self:StopWatchingWorldState("cycles", TryStartAttacks)
        self.inst.watchingcycles = nil
    else
        PauseAttacks()
        if not self.inst.watchingcycles then
            self:WatchWorldState("cycles", TryStartAttacks)  -- keep checking every day until NO_BOSS_TIME is up
            self.inst.watchingcycles = true
        end
    end
end

local function TargetLost()
    if _timetoattack < _warnduration and _warning then
        _warning = false
        _timetoattack = _warnduration + 1
    end

    PickAttackTarget()
    if _targetplayer == nil then
        PauseAttacks()
    end
end

local function GetSpawnPoint(pt)
    local offset = FindWalkableOffset(pt, math.random() * 2 * PI, HASSLER_SPAWN_DIST, 12, true)
    if offset ~= nil then
        offset.x = offset.x + pt.x
        offset.z = offset.z + pt.z
        return offset
    end
end

local function ReleaseHassler(targetPlayer)
    assert(targetPlayer)

    local hassler = TheSim:FindFirstEntityWithTag("twister")
    if hassler ~= nil then
        return hassler -- There's already a hassler in the world, we're done here.
    end

    local spawn_pt = GetSpawnPoint(targetPlayer:GetPosition())
    if spawn_pt ~= nil then
        if _storedhassler ~= nil then
            hassler = SpawnSaveRecord(_storedhassler, {})
            _storedhassler = nil
        else
            hassler = SpawnPrefab("twister")
        end

        if hassler ~= nil then
            hassler.Physics:Teleport(spawn_pt:Get())
            local target = targetPlayer
            return hassler
        end
    end
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function OnSeasonChange(self, season)
    TryStartAttacks()
end

local function OnPlayerJoined(src,player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            return
        end
    end
    table.insert(_activeplayers, player)

    TryStartAttacks()
end

local function OnPlayerLeft(src,player)
    for i, v in ipairs(_activeplayers) do
        if v == player then
            table.remove(_activeplayers, i)
            --
			-- if this was the activetarget...cease the attack
			if player == _targetplayer then
				TargetLost()
			end
            return
        end
    end
end

local function OnHasslerRemoved(src, hassler)
	_activehassler = nil
	TryStartAttacks()
end

local function OnStoreHassler(src, hassler)
	if hassler ~= nil then
		_storedhassler = hassler:GetSaveRecord()
	else
		_storedhassler = nil
	end
end

local function OnHasslerKilled(src, hassler)
	_activehassler = nil
	TryStartAttacks(true)
end

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

function self:SetAttacksPerSpring(attacks)
    _attacksperwinter = attacks
end

function self:OverrideAttacksPerSeason(name, num)
	if name == "TWISTER" then
		_attacksperwinter = num
	end
end

function self:OverrideAttackDuringOffSeason(name, bool)
	if name == "TWISTER" then
		_attackduringoffseason = bool
	end
end

local function _DoWarningSpeech(player)
    --ANNOUNCE_DEERCLOPS is used for twister aswell.
    player.components.talker:Say(GetString(player, "ANNOUNCE_DEERCLOPS"))
end

function self:DoWarningSpeech(_targetplayer)
    for i, v in ipairs(_activeplayers) do 
        if v == _targetplayer or v:IsNear(_targetplayer, HASSLER_SPAWN_DIST * 2) then
            v:DoTaskInTime(math.random() * 2, _DoWarningSpeech)
        end
    end
end

function self:DoWarningSound(_targetplayer)
    --Players near _targetplayer will hear the warning sound from the
    --same direction and volume offset from their own local positions
    SpawnPrefab("twisterwarning_lvl"..
        (((_timetoattack == nil or
        _timetoattack < 30) and "4") or
        (_timetoattack < 60 and "3") or
        (_timetoattack < 90 and "2") or
                                "1")
    ).Transform:SetPosition(_targetplayer.Transform:GetWorldPosition())
end

function self:OnUpdate(dt)
	--print("in OnUpdate", _timetoattack, _targetplayer, _activehassler)
    if not _timetoattack or _activehassler ~= nil then
        ResetAttacks()
        return
    end
	_timetoattack = _timetoattack - dt
	if _timetoattack <= 0 then
		_warning = false
		_timetoattack = nil
		if _targetplayer == nil then
			PickAttackTarget() -- In case a long update skipped the warning or something
		end
        if _targetplayer ~= nil then
            _activehassler = ReleaseHassler(_targetplayer)
            ResetAttacks()
        else
            TargetLost()
        end
	else
		if not _warning and _timetoattack < _warnduration then
			-- let's pick a random player here
			PickAttackTarget()
			if not _targetplayer then
				PauseAttacks()
				return
			end
			_warning = true
			_timetonextwarningsound = 0
		end
	end

	if _warning then
		_timetonextwarningsound	= _timetonextwarningsound - dt

		if _timetonextwarningsound <= 0 then
	        if _targetplayer == nil then
	        	PickAttackTarget()
	        	if _targetplayer == nil then
                    TargetLost()
		            return
		        end
	        end
			_announcewarningsoundinterval = _announcewarningsoundinterval - 1
			if _announcewarningsoundinterval <= 0 then
				_announcewarningsoundinterval = 10 + math.random(5)
				self:DoWarningSpeech(_targetplayer)
			end

            _timetonextwarningsound = _timetoattack < 30 and 10 + math.random(1) or 15 + math.random(4)
			self:DoWarningSound(_targetplayer)
		end
	end
end

function self:LongUpdate(dt)
	self:OnUpdate(dt)
end

--------------------------------------------------------------------------
--[[ Save/Load ]]
--------------------------------------------------------------------------

function self:OnSave()
	local data =
	{
		warning = _warning,
		timetoattack = _timetoattack,
		storedhassler = _storedhassler,
	}

	local ents = {}
	if _activehassler ~= nil then
		data.activehassler = _activehassler.GUID
		table.insert(ents, _activehassler.GUID)
	end

	return data, ents
end

function self:OnLoad(data)
	_warning = data.warning or false
	_timetoattack = data.timetoattack
	_storedhassler = data.storedhassler
end

function self:LoadPostPass(newents, savedata)
	if savedata.activehassler ~= nil and newents[savedata.activehassler] ~= nil then
		_activehassler = newents[savedata.activehassler].entity
	end
end


--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
	local s = ""
	if not _timetoattack then
	    s = s .. "DORMANT <no time>"
	elseif self.inst.updatecomponents[self] == nil then
		s = s .. "DORMANT ".._timetoattack
	elseif _timetoattack > 0 then
		s = s .. string.format("%s Twister is coming for %s in %2.2f", _warning and "WARNING" or "WAITING", tostring(_targetplayer) or "<nil>", _timetoattack)
	else
		s = s .. string.format("ATTACKING!!!")
	end
	s = s .. string.format(" active: %s", _activehassler ~= nil and tostring(_activehassler) or "<nil>")
	s = s .. string.format(" stored: %s", _storedhassler ~= nil and _storedhassler.prefab or "<nil>")
	return s
end

function self:SummonMonster(player)
	_timetoattack = 10
	self.inst:StartUpdatingComponent(self)
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------
for i, v in ipairs(AllPlayers) do
    table.insert(_activeplayers, v)
end

self.inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
self.inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)
self:WatchWorldState("season", OnSeasonChange)
self.inst:ListenForEvent("twisterremoved", OnHasslerRemoved, TheWorld)
self.inst:ListenForEvent("twisterkilled", OnHasslerKilled, TheWorld)
self.inst:ListenForEvent("storetwister", OnStoreHassler, TheWorld)

function self:OnPostInit()
    TryStartAttacks()
end

end)
%%+%%scripts/components/vacuum.lua%%-%%--[[
Copyright (C) 2018 Island Adventures Team

This file is part of Island Adventures.

The source code of this program is shared under the RECEX
SHARED SOURCE LICENSE (version 1.0).
The source code is shared for referrence and academic purposes
with the hope that people can read and learn from it. This is not
Free and Open Source software, and code is not redistributable
without permission of the author. Read the RECEX SHARED
SOURCE LICENSE for details 
The source codes does not come with any warranty including
the implied warranty of merchandise. 
You should have received a copy of the RECEX SHARED SOURCE
LICENSE in the form of a LICENSE file in the root of the source
directory. If not, please refer to 
<https://raw.githubusercontent.com/Recex/Licenses/master/SharedSourceLicense/LICENSE.txt>
]]

local Vacuum = Class(function(self, inst)
    self.inst = inst
    self.vacuumradius = 5
    self.vacuumspeed = 30 
    self.consumeradius = 1
    self.noTags = {"FX", "NOCLICK", "DECOR", "INLIMBO", "CLASSIFIED", "STUMP", "BIRD", "NOVACUUM", "player"}
    self.ignoreplayer = true
    self.playervacuumdamage = 50
    self.playervacuumsanityhit = 0
    self.playervacuumradius = 15
    self.player_hold_distance = 3
    self.spitplayer = false
    self.caught = {}
    self.allowmovement = {}
end)

function Vacuum:TurnOn()
    self.inst:StartUpdatingComponent(self)
end 

function Vacuum:TurnOff()
    self.inst:StopUpdatingComponent(self)
end

function Vacuum:SpitItem(item)
    if not item then
        local slot = math.random(1,self.inst.components.inventory:GetNumSlots())
        item = self.inst.components.inventory:DropItemBySlot(slot) 
    end

    if item and item.Physics then
        local x, y, z = self.inst.Transform:GetWorldPosition()
        y = 2
        item.Physics:Teleport(x,y,z)
        item:AddTag("NOVACUUM")
        item:DoTaskInTime(2, function() item:RemoveTag("NOVACUUM") end)

		if item.components.inventoryitem then
			item.components.inventoryitem:SetLanded(false, true)
		end

        local speed = 8 + (math.random() * 4)
        local angle =  (math.random() * 360) * DEGREES
        item.Physics:SetVel(math.cos(angle) * speed, 10, math.sin(angle) * speed)
    end
end 

local vacuumstate = {}
local RedirectSetMotorVel = {}

function EnterVacuumState(ent)
    vacuumstate[ent.Physics] = true
end

function LeaveVacuumState(ent)
    vacuumstate[ent.Physics] = nil
end

local _SetMotorVel = Physics.SetMotorVel
local _SetMotorVelOverride = Physics.SetMotorVelOverride
local _ClearMotorVelOverride = Physics.ClearMotorVelOverride
local _SetRotation = Physics.SetRotation

function Physics:SetMotorVel(...)
    if RedirectSetMotorVel[self] then
        return self:Real_SetMotorVelOverride(...)
    end
    if vacuumstate[self] then
        return nil
    end
    return _SetMotorVel(self, ...)
end

function Physics:Real_SetMotorVelOverride(...)
    --do this to prevent people from using Real_SetMotorVelOverride to bypass this.
    if not vacuumstate[self] then
        return nil
    end
    return _SetMotorVelOverride(self, ...)
end

function Physics:SetMotorVelOverride(...)
    if RedirectSetMotorVel[self] then
        return self:Real_SetMotorVelOverride(...)
    end
    if vacuumstate[self] then
        return nil
    end
    return _SetMotorVelOverride(self, ...)
end

function Physics:ClearMotorVelOverride(...)
    if vacuumstate[self] then
        return nil
    end
    return _ClearMotorVelOverride(self, ...)
end

function Physics:SetRotation(rotation, ...)
    --rotate the current momentum, so you dont do a weird.
    if vacuumstate[self] then
        local mx, my, mz = self:GetMotorVel()
        mx, mz = math.rotate(mx, mz, rotation - self:GetRotation())
        self:Real_SetMotorVelOverride(mx, my, mz)
    end
    return _SetRotation(self, rotation, ...)
end

function Vacuum:EnterVacuumState(player)
    print(player, "EnterVacuumState")
    --disable auto-disembark
    player.noautodisembark = true
    --mark this player as getting vacuumed by this entity so other vacuums cant grab this entity.
    player.invacuum = self.inst
    EnterVacuumState(player)
    --mark player as caught.
    self.caught[player] = true
end

function Vacuum:LeaveVacuumState(player, partial)
    print(player, "LeaveVacuumState")
    self.caught[player] = nil
    LeaveVacuumState(player)
    player.invacuum = nil
    player.noautodisembark = false
    if not partial then
        player:AddTag("NOVACUUM")
        player.Physics:SetMotorVel(0,0,0)
        if player.sg:HasStateTag("vacuum_in") then player.sg:GoToState("vacuumedland") end
        player:DoTaskInTime(5, function(inst) player:RemoveTag("NOVACUUM") end)
    end
end

function Vacuum:OnUpdate(dt)
    -- find entities within radius and vacuum them towards my location  
    local pt = self.inst:GetPosition()
    local ents = TheSim:FindEntities(pt.x, 0, pt.z, self.consumeradius, nil, self.noTags)

    for k,v in pairs(ents) do
        if v and v.components.inventoryitem and not v.components.inventoryitem:IsHeld() then
            if not self.inst.components.inventory:GiveItem(v) then
                self:SpitItem(v)
            end 
        end 
    end

    ents = TheSim:FindEntities(pt.x, pt.y, pt.z, self.vacuumradius, nil, self.noTags)

    for k,v in pairs(ents) do
        if v and v.Physics and v.components.inventoryitem and not v.components.inventoryitem:IsHeld() and CheckLOSFromPoint(self.inst:GetPosition(), v:GetPosition()) then
            local x, y, z = v:GetPosition():Get()
            y = .1
            v.Physics:Teleport(x,y,z)
            local dir =  v:GetPosition() - self.inst:GetPosition()
            local angle = math.atan2(-dir.z, -dir.x) 
            v.Physics:SetVel(math.cos(angle) * self.vacuumspeed, 0, math.sin(angle) * self.vacuumspeed)
        else
            v:AddTag("NOVACUUM")
            v:DoTaskInTime(1, function() v:RemoveTag("NOVACUUM") end)
        end
    end 

    if not self.ignoreplayer or GetTableSize(self.caught) > 0 then
        for i, player in ipairs(AllPlayers) do
            if not player.replica.health:IsDead() and not player:HasTag("playerghost") then
                if player.invacuum == nil or player.invacuum == self.inst then
                    local playerpos = player:GetPosition()
                    local displacement = playerpos - self.inst:GetPosition()
                    local dist = displacement:Length()
                    local angle = math.atan2(-displacement.z, -displacement.x)
                    --Allow the player to get closer if they're wearing something with windproofness
                    local playerDistanceMultiplier =  1 - (player.components.inventory:GetWindproofness() * 0.25)
                    if dist < self.playervacuumradius * playerDistanceMultiplier then
                        local angle = math.atan2(-displacement.z, -displacement.x)

                        if not player:HasTag("NOVACUUM") and (player.invacuum == self.inst or CheckLOSFromPoint(self.inst:GetPosition(), playerpos)) and (dist >= self.player_hold_distance or not self.caught[player]) and not self.spitplayer then--Pull player in 
                            --print("trying to vacuum in the player")
                            if not self.caught[player] then
                                self:EnterVacuumState(player)
                            end

                            local rx, rz = math.rotate(math.rcos(angle) * self.vacuumspeed, math.rsin(angle) * self.vacuumspeed, math.rad(player.Transform:GetRotation()))

                            RedirectSetMotorVel[player.Physics] = true
                            DoShoreMovement(player, {x = rx, z = rz}, function() player.Physics:Real_SetMotorVelOverride(rx, 0, rz) end)
                            RedirectSetMotorVel[player.Physics] = nil

                            player.components.locomotor:Clear()
                            player:PushEvent("vacuum_in")
                        elseif dist < self.player_hold_distance and self.caught[player] and player.sg and player.sg:HasStateTag("vacuum_in") and not self.spitplayer then
                            player.Physics:Real_SetMotorVelOverride(0, 0, 0)
                            player:PushEvent("vacuum_held")

                        elseif self.spitplayer and dist < self.player_hold_distance and player.sg and player.sg:HasStateTag("vacuum_held") then
                            local mult = self.playervacuumdamage / self.inst.components.combat.defaultdamage
                            self.inst.components.combat:DoAttack(player, nil, nil, nil, mult)
                            player.components.sanity:DoDelta(self.playervacuumsanityhit)

                            if not player.components.health:IsDead() then
                                --prevent this tag from getting added if you die
                                player:AddTag("NOVACUUM") --Shoot player out
                            end

                            self:LeaveVacuumState(player, true)

                            player:PushEvent("vacuum_out", {speed = -self.vacuumspeed})

                        elseif self.spitplayer and self.caught[player] then
                            self:LeaveVacuumState(player)

                        end
                    elseif self.caught[player] then
                        self:LeaveVacuumState(player)
                    end
                end
            end
        end
    end

    self.spitplayer = false
end

return Vacuum%%+%%scripts/components/visualvariant.lua%%-%%local function TryRecalc(inst)
	if inst and inst:IsValid()
	and inst.components.visualvariant
	and not inst.components.visualvariant.variant then
		inst.components.visualvariant:Recalc()
	end
end

local VisualVariant = Class(function(self, inst)
	self.inst = inst

	self.possible_variants = {}
	-- self.variant = "default"
	
	self.inst:DoTaskInTime(0,TryRecalc)
end)

function VisualVariant:OnSave()
	return {
		variant = self.variant,
	}
end

function VisualVariant:OnLoad(data)
	local variant
	if data then
		variant = data.variant or self.variant
	end
	if variant then
		self:Set(variant)
	else
		self:Recalc()
	end
end

function VisualVariant:Recalc()
	local valid_variants = {}
	local desired_variants = {}
	for k, v in pairs(self.possible_variants) do
		if v.testfn then
			if v.testfn(self.inst) then
				table.insert(desired_variants, k)
			end
		else
			table.insert(valid_variants, k)
		end
	end
	--if the current variant is still valid or desired, keep it
	if self.variant and (table.contains(valid_variants, self.variant) or table.contains(desired_variants, self.variant)) then
		--Change nothing
	elseif #desired_variants > 0 then
		--if default is desired, pick that
		if table.contains(desired_variants, "default") then
			self:Set()
		else
			self:Set(desired_variants[1])
		end
	else
		--if default is valid, pick that
		if table.contains(valid_variants, "default") then
			self:Set()
		else
			self:Set(valid_variants[1])
		end
	end
end

function VisualVariant:CopyOf(source)
	if not source then return end

	if source.components.visualvariant then
		return self:Set(source.components.visualvariant.variant)
	end

	for k, v in pairs(self.possible_variants) do
		if v.sourceprefabs and table.contains(v.sourceprefabs, source.prefab) then
			return self:Set(k)
		end
	end

end

function VisualVariant:Set(variant)
	local old_variant = self.variant
	if variant and self.possible_variants and self.possible_variants[variant] then
		self.variant = variant
	else
		self.variant = "default"
	end
	local variant_data = self.possible_variants[self.variant]
	if variant_data and self.variant ~= old_variant then
		if variant_data.name then
			if variant_data.name == "default" then
				if self.inst.components.named then
					if self.inst.components.named.possiblenames and #self.inst.components.named.possiblenames > 0 then
						self.inst.components.named:PickNewName()
					else
						self.inst.components.named:SetName()
					end
				end
			else
				if not self.inst.components.named then
					self.inst:AddComponent("named")
				end
				self.inst.components.named:SetName(STRINGS.NAMES[string.upper(variant_data.name)])
			end
		end
		if self.inst.AnimState then
			if variant_data.build then
				self.inst.AnimState:SetBuild(variant_data.build)
			end
			if variant_data.bank then
				self.inst.AnimState:SetBank(variant_data.bank)
			end
		end
		if self.inst.components.inventoryitem and variant_data.invimage
		--if items try to stack as soon as they spawn, they might not have a classified (apparently) -M
		and self.inst.replica.inventoryitem and self.inst.replica.inventoryitem.classified then
			if variant_data.invimage == "default" then
				self.inst.components.inventoryitem:ChangeImageName()
			else
				self.inst.components.inventoryitem:ChangeImageName(variant_data.invimage)
			end
		end
	end
end

return VisualVariant%%+%%scripts/components/volcanomanager.lua%%-%%
local WARN_QUAKE_DURATION = 0.7

-- waits 'delay' frames before actually listening for the event
local function EventLoader(inst, delay)
    if delay > 0 then
        inst:DoTaskInTime(0, EventLoader, delay-1)
    else
        inst:ListenForEvent("seasonChange", function(it, data)
            if data.season == SEASONS.DRY then
                inst.components.volcanomanager:StartDrySeason()
            end
        end)
    end
end

local VolcanoManager = Class(function(self, inst)
    self.inst = inst
    self.volcanoes = {}
    self.schedule = {}
    self.schedulesegs = {} --segments in the sechdule
    self.highest_schedule_seg = 0
    self.appeasesegs = 0
    self.staffstartseg = 0
    self.firerain_timer = 0
    self.firerain_delay = 0
    self.firerain_duration = 0
    self.firerain_spawn_rate = 0
    self.firerain_spawn_per_sec = 0
    self.firerain_intensity = 1.0
    self.smoke_timer = 0
    self.smoke_delay = 0
    self.smoke_duration = 0
    self.ash_timer = 0
    self.ash_delay = 0
    self.ash_duration = 0
    self.ash = nil
    self.intensity = 1.0 -- 1.0 = normal
    self.waserupting = false 

    -- gjans: We can't distinguish between loading events from the season manager and actual organic season changes, and since we use
    -- that event to "reset" the schedule, we'll just not listen for events until after loading (and the first DoTaskInTime(0,..) from 
    -- seasonmanager) have finished.
    EventLoader(self.inst, 2)
end)

function VolcanoManager:DoWarnQuake(duration, speed, scale)
    duration = duration or WARN_QUAKE_DURATION
    speed = speed or 0.02
    scale = scale or .75
    TheCamera:Shake("FULL", duration, speed, scale)
    self.inst.SoundEmitter:PlaySound("dontstarve/cave/earthquake", "earthquake")
    self.inst.SoundEmitter:SetParameter("earthquake", "intensity", 0.08)
    self.inst:DoTaskInTime(duration, function() self.inst.SoundEmitter:KillSound("earthquake") end)

    local player = GetPlayer()
    player.components.talker:Say(GetString(player.prefab, "ANNOUNCE_QUAKE"))
end

function VolcanoManager:DoEruptQuake(duration, speed, scale)
    duration = duration or 4.0
    speed = speed or 0.02
    scale = scale or 2.0
    TheCamera:Shake("FULL", duration, speed, scale)

    local player = GetPlayer()
    player.components.talker:Say(GetString(player.prefab, "ANNOUNCE_VOLCANO_ERUPT"))
    self.inst:PushEvent("OnVolcanoWarningQuake")
end

function VolcanoManager:DoEruption(data)
    if not data then
        print("DoEruption no data!")
        return
    end

    self:DoEruptQuake()
    self:StartSmoke(data.smoke_duration, data.smoke_delay)
    self:StartAshRain(data.ash_duration, data.ash_delay)
    self:StartFireRain(data.firerain_duration, data.firerain_delay, data.firerain_per_sec)
    self.waserupting = true 
    self.inst.SoundEmitter:PlaySound("dontstarve/cave/earthquake", "earthquake")
    self.inst.SoundEmitter:SetParameter("earthquake", "intensity", 0.08)
    self.inst:DoTaskInTime(data.firerain_duration + data.firerain_delay, function() self.inst.SoundEmitter:KillSound("earthquake") end)

    self.inst:PushEvent("OnVolcanoEruptionBegin")
end

function VolcanoManager:SpawnFireRain(x, y, z)
    local firerain
    if math.random() <= TUNING.VOLCANO_DRAGOONEGG_CHANCE then
        firerain = SpawnPrefab("dragoonegg_falling")
    else
        firerain = SpawnPrefab("firerain")
    end
    firerain.Transform:SetPosition(x, y, z)
    firerain:StartStep()
end

function VolcanoManager:RebuildDrySchedule()
    if self.intensity > 0.0 then
        print("VolcanoManager rebuilding schedule")
        local volcanoschedule = require("map/volcanoschedule")
        self.schedule[1], self.schedulesegs[1] = self:BuildSchedule(volcanoschedule.DrySeasonSchedule, self.highest_schedule_seg)
        self.inst:DoTaskInTime(1, function() self:SetActiveIcon() end)
        self.inst:StartUpdatingComponent(self)
    end
end

function VolcanoManager:StartDrySeason()
    print("VolcanoManager starting dry season")
    self.highest_schedule_seg = 0
    self:RebuildDrySchedule()
end

function VolcanoManager:StartEruption(smoke_duration, ash_duration, firerain_duration, firerain_spawn_per_sec)
    print("VolcanoManager start eruption", smoke_duration, ash_duration, firerain_duration, firerain_spawn_per_sec)
    local data =
    {
        firerain_delay=0, firerain_duration=firerain_duration, firerain_per_sec=firerain_spawn_per_sec,
        smoke_delay=0, smoke_duration=smoke_duration,
        ash_delay=0, ash_duration=ash_duration
    }
    self:DoEruption(data)
    self.inst:StartUpdatingComponent(self)
end

function VolcanoManager:ResumeStaffTrap(startsegs)
    print("VolcanoManager resume staff trap", startsegs)
    local volcanoschedule = require("map/volcanoschedule")
    self.staffstartseg = startsegs
    self.schedule[2], self.schedulesegs[2] = self:BuildSchedule(volcanoschedule.StaffTrapSchedule, self:GetCurrentStaffScheduleSegment())
    --self:Appease(self.schedulesegs[2]) --treat staff trap as appeasement to delay dry schedule
    self.inst:DoTaskInTime(1, function() self:SetActiveIcon() end)
    self.inst:StartUpdatingComponent(self)
end

function VolcanoManager:StartStaffTrap()
    print("VolcanoManager start staff trap")
    --self:DoWarnQuake()
    self:ResumeStaffTrap(math.floor(16 * (GetClock():GetNumCycles() + GetClock():GetNormTime())))
end

function VolcanoManager:StartStaffEffect(ash_timer)
    print("VolcanoManager start staff effect")
    self:DoEruptQuake()
    self:StartAshRain(ash_timer, 0)
    self.inst:StartUpdatingComponent(self)
end

function VolcanoManager:Stop()
    print("VolcanoManager stop")

    self.inst.SoundEmitter:KillSound("earthquake")
    self.appeasesegs = 0
    self:StopAshRain()
    self:StopFireRain()
    self.inst:StopUpdatingComponent(self)
end

function VolcanoManager:StartFireRain(firerain_duration, firerain_delay, firerain_spawn_per_sec)
    self.firerain_delay = firerain_delay
    self.firerain_duration = firerain_duration
    self.firerain_timer = self.firerain_delay + self.firerain_duration
    self.firerain_spawn_rate = 0.0
    self.firerain_spawn_per_sec = firerain_spawn_per_sec
end

function VolcanoManager:StopFireRain()
    self.firerain_timer = 0.0
    self.firerain_spawn_rate = 0.0
    self.firerain_spawn_per_sec = 0.0
end

function VolcanoManager:StartAshRain(ash_duration, ash_delay)
    self.ash_delay = ash_delay
    self.ash_duration = ash_duration
    self.ash_timer = self.ash_delay + self.ash_duration
    self.inst:PushEvent("ashstart")
end

function VolcanoManager:StopAshRain()
    if self.ash then
        self.ash:Remove()
    end
    self.ash = nil
    self.ash_timer = 0.0
    self.ash_delay = 0.0
    self.ash_duration = 0.0
    self.inst:PushEvent("ashstop")
end

function VolcanoManager:StartSmoke(smoke_duration, smoke_delay)
    self.smoke_delay = smoke_delay
    self.smoke_duration = smoke_duration
    self.smoke_timer = self.smoke_delay + self.smoke_duration
end

function VolcanoManager:StopSmoke()
    self.smoke_timer = 0.0
    self.smoke_delay = 0.0
    self.smoke_duration = 0.0
end

function VolcanoManager:RunSchedule(schedule, segs)
    if schedule and schedule[segs] then
        for i = 1, #schedule[segs], 1 do
            schedule[segs][i].fn(self, schedule[segs][i].data)
        end
        schedule[segs] = {}
    end
    self.highest_schedule_seg = math.max(self.highest_schedule_seg, segs)
end

function VolcanoManager:GetCurrentScheduleSegment()
    local sm = GetSeasonManager()
    local cycles = sm:GetPercentSeason() * sm:GetSeasonLength(SEASONS.DRY)
    local normTime = GetClock():GetNormTime()
    return math.floor(16 * (cycles + normTime)) - self.appeasesegs
end

function VolcanoManager:GetCurrentStaffScheduleSegment()
    return math.floor(16 * (GetClock():GetNumCycles() + GetClock():GetNormTime())) - self.staffstartseg
end

function VolcanoManager:GetDebugString()
    local sm = GetSeasonManager()
    local clock = GetClock()
    local cycles = clock:GetNumCycles()
    local normtime = clock:GetNormTime()
    local cursegs = math.floor(16 * (cycles + normtime))
    local str = "Volcano\n"
    
    if self.schedule[1] then
        str = str .. string.format("  dry segs %d, season %4.2f\n", self:GetCurrentScheduleSegment(), sm:GetPercentSeason())
    end
    if self.schedule[2] then
        str = str .. string.format("  staff segs %d, start seg %d\n", cursegs - self.staffstartseg, self.staffstartseg)
    end

    str = str .. string.format("  next quake %d, next eruption %d\n  cycles %d, normtime %f, cursegs %d\n  firerain timer %4.2f, delay %4.2f, dur %4.2f, int %4.2f, rate %4.2f, %4.2f/s\n  ash timer %4.2f, delay %4.2f, dur %4.2f, %d particles/tick\n  smoke timer %4.2f, delay %4.2f, dur %4.2f, rate %4.2f\n  appease segs %4.2f\n",
        self:GetNumSegmentsUntilQuake() or 0, self:GetNumSegmentsUntilEruption() or 0,
        cycles, normtime, cursegs,
        self.firerain_timer, self.firerain_delay, self.firerain_duration, self.firerain_intensity, self.firerain_spawn_rate, self.firerain_spawn_per_sec,
        self.ash_timer, self.ash_delay, self.ash_duration, (self.ash and self.ash.particles_per_tick) or 0,
        self.smoke_timer, self.smoke_delay, self.smoke_duration, self:GetSmokeRate(),
        self.appeasesegs)

    return str
end

function VolcanoManager:OnUpdate( dt )
    --print(self:GetDebugString())

    if self.schedule[1] then
        if GetSeasonManager():IsDrySeason() then
            local segs = self:GetCurrentScheduleSegment() 
            --print(string.format("segs %d (%d), %f, %f\n", segs, get_segs(), GetSeasonManager():GetPercentSeason(), GetClock():GetNormTime()))
            self:RunSchedule(self.schedule[1], segs)
            if segs > self.schedulesegs[1] then
                self:SetDormantIcon()
                self.schedule[1] = {}
            end
        else
            self:SetDormantIcon()
            self.schedule[1] = {}
        end
    end

    if self.schedule[2] then
        --local cursegs = math.floor(16 * (GetClock():GetNumCycles() + GetClock():GetNormTime()))
        local segs = self:GetCurrentStaffScheduleSegment() --cursegs - self.staffstartseg
        --print(string.format("segs %f, cursegs %f, cycles %d, normtime %f", segs, cursegs, GetClock():GetNumCycles(), GetClock():GetNormTime()))
        self:RunSchedule(self.schedule[2], segs)
        if segs > self.schedulesegs[2] then
            self:SetDormantIcon()
            self.schedule[2] = {}
        end
    end

    --update fire rain
    if self.firerain_timer > 0.0 and self.firerain_intensity > 0.0 then
        self.firerain_timer = self.firerain_timer - dt
        if self.firerain_timer <= self.firerain_duration then
            self.firerain_spawn_rate = self.firerain_spawn_rate + self.firerain_spawn_per_sec * self.firerain_intensity * dt
            while self.firerain_spawn_rate > 1.0 do
                local px, py, pz = GetPlayer().Transform:GetWorldPosition()
                local x, y, z = TUNING.VOLCANO_FIRERAIN_RADIUS * UnitRand() + px, py, TUNING.VOLCANO_FIRERAIN_RADIUS * UnitRand() + pz
                self:SpawnFireRain(x, y, z)
                self.firerain_spawn_rate = self.firerain_spawn_rate - 1.0
            end
        end
        if self.firerain_timer <= 0.0 then
            self.inst:PushEvent("OnVolcanoFireRainEnd")
        end
    end

    --update ash rain
    if self.ash_timer > 0.0 then
        self.ash_timer = self.ash_timer - dt
        if self.ash_timer <= self.ash_duration then
            if not self.ash then
                self.ash = SpawnPrefab( "ashfx" )
                self.ash.entity:SetParent( GetPlayer().entity )
            end
            self.ash.particles_per_tick = 20 * math.min(self.ash_timer / self.ash_duration, 1.0)
        elseif self.ash then
            self.ash.particles_per_tick = 0
        end
    elseif self.ash then
        self.ash.particles_per_tick = 0
    end

    if self.smoke_timer > 0.0 then
        self.smoke_timer = self.smoke_timer - dt
    end

    if self.waserupting and not self:IsErupting() then 
        self.waserupting = false
        self.inst:PushEvent("OnVolcanoEruptionEnd")
    end 

    if self:IsDormant() or self.intensity <= 0.0 then
        self:Stop()
    end
end

function VolcanoManager:LongUpdate(dt)
    --self:OnUpdate(dt)
end

function VolcanoManager:OnSave()
    return
    {
        appeasesegs = self.appeasesegs,
        staffstartseg = self.staffstartseg,
        highest_schedule_seg = self.highest_schedule_seg,
        firerain_timer = self.firerain_timer,
        firerain_delay = self.firerain_delay,
        firerain_duration = self.firerain_duration,
        firerain_spawn_per_sec = self.firerain_spawn_per_sec,
        firerain_intensity = self.firerain_intensity,
        smoke_timer = self.smoke_timer,
        smoke_delay = self.smoke_delay,
        smoke_duration = self.smoke_duration,
        ash_timer = self.ash_timer,
        ash_delay = self.ash_delay,
        ash_duration = self.ash_duration,
        erupting = self.waserupting,
        intensity = self.intensity,
        dry = self.schedule[1] ~= nil,
        staff = self.schedule[2] ~= nil
    }
end

function VolcanoManager:OnLoad(data)
    if data then
        self.appeasesegs = data.appeasesegs or self.appeasesegs
        self.staffstartseg = data.staffstartseg or self.staffstartseg
        self.highest_schedule_seg = data.highest_schedule_seg or self:GetCurrentScheduleSegment()
        self.firerain_timer = data.firerain_timer or self.firerain_timer
        self.firerain_delay = data.firerain_delay or self.firerain_delay
        self.firerain_duration = data.firerain_duration or self.firerain_duration
        self.firerain_spawn_per_sec = data.firerain_spawn_per_sec or self.firerain_spawn_per_sec
        self.firerain_intensity = data.firerain_intensity or self.firerain_intensity
        self.smoke_timer = data.smoke_timer or self.smoke_timer
        self.smoke_delay = data.smoke_delay or self.smoke_delay
        self.smoke_duration = data.smoke_duration or self.smoke_duration
        self.ash_timer = data.ash_timer or self.ash_timer
        self.ash_delay = data.ash_delay or self.ash_delay
        self.ash_duration = data.ash_duration or self.ash_duration
        self.waserupting = data.erupting or self.waserupting
        self.intensity = data.intensity or self.intensity
        local dry = data and data.dry
        local staff = data and data.staff

        if dry then
            print("restart dry schedule")
            self:RebuildDrySchedule()
        end
        if staff then
            print("restart staff schedule", self.staffstartseg)
            self:ResumeStaffTrap(self.staffstartseg)
        end
        if self.smoke_timer > 0 or self.ash_timer > 0 or self.firerain_timer > 0 then
            print("restart eruption")
            self.inst:StartUpdatingComponent(self)
            if self.firerain_timer < self.firerain_duration then 
                self.inst.SoundEmitter:PlaySound("dontstarve/cave/earthquake", "earthquake")
                self.inst.SoundEmitter:SetParameter("earthquake", "intensity", 0.08)
                self.inst:DoTaskInTime(self.firerain_timer, function() self.inst.SoundEmitter:KillSound("earthquake") end)
            end 
        end
    end
end

function VolcanoManager:AddVolcano(inst)
    self.volcanoes[inst] = inst
end

function VolcanoManager:RemoveVolcano(inst)
    self.volcanoes[inst] = nil
end

function VolcanoManager:SetActiveIcon()
    for k, v in pairs(self.volcanoes) do
        if v.MiniMapEntity then
            v.MiniMapEntity:SetIcon("volcano_active.png")
        end
    end
end

function VolcanoManager:SetDormantIcon()
    for k, v in pairs(self.volcanoes) do
        if v.MiniMapEntity then
            v.MiniMapEntity:SetIcon("volcano.png")
        end
    end
end

function VolcanoManager:GetClosestVolcano()
    local closest = nil 
    local closestdistsq = nil
    for k,v in pairs(self.volcanoes) do
        if v then
            local x, y, z = GetPlayer().Transform:GetWorldPosition()
            local vx, vy, vz = v.Transform:GetWorldPosition()
            local dx, dy, dz = x - vx, y - vy, z - vz
            local distSq = dx * dx + dy * dy + dz * dz
            if closest == nil or distSq < closestdistsq then 
                closestdistsq = distSq
                closest = v
            end 
        end
    end
    return closest

end 

function VolcanoManager:GetDistanceFromVolcano(x, y, z)
    local dist = 100000000
    for k,v in pairs(self.volcanoes) do
        if v then
            local x, y, z = GetPlayer().Transform:GetWorldPosition()
            local vx, vy, vz = v.Transform:GetWorldPosition()
            local dx, dy, dz = x - vx, y - vy, z - vz
            local distSq = dx * dx + dy * dy + dz * dz
            dist = math.sqrt(math.min(dist, distSq))
        end
    end
    return dist
end

function VolcanoManager:GetSmokeRate()
    if 0.0 < self.smoke_timer and self.smoke_timer <= self.smoke_duration then
        return self.smoke_timer / self.smoke_duration
    end
    return 0.0
end

function VolcanoManager:SetIntensity(intensity)
    self.intensity = intensity
end

function VolcanoManager:SetFirerainIntensity(intensity)
    self.firerain_intensity = intensity
end

function VolcanoManager:IsActive()
    --return not self:IsDormant()
    return (self.schedule[1] ~= nil and GetSeasonManager():IsDrySeason()) or self.schedule[2] ~= nil
end

function VolcanoManager:IsFireRaining()
    return self.firerain_timer > 0
end

function VolcanoManager:IsErupting()
    --return self.state == STATE_ERUPT
    --return self.firerain_timer > 0.0
    return self.smoke_timer > 0 or self.ash_timer > 0 or self:IsFireRaining()
end

function VolcanoManager:IsDormant()
    --return self.firerain_timer <= 0.0
    return not self:IsActive() and not self:IsErupting()
end

local warnquake =
{
    ["small"] = {duration = 0.7/2, speed = 0.02, scale = 0.75/2},
    ["med"] = {duration = 0.7, speed = 0.02, scale = 0.75},
    ["large"] = {duration = 2*0.7, speed = 0.02, scale = 2*0.75},
}

local function DoWarnQuake(inst, data)
    print("Warn Quake")
    if data and data.size and warnquake[data.size] then
        inst:DoWarnQuake(warnquake[data.size].duration, warnquake[data.size].speed, warnquake[data.size].scale)
    else
        inst:DoWarnQuake()
    end
end

local function DoEruption(inst, data)
    print("Erupt!")
    inst:DoEruption(data) --(60.0, 60.0, 60.0, 1 / 8)
end

function VolcanoManager:BuildSchedule(scheduledef, startseg)
    local newschedule = {}

    startseg = startseg or 0

    local lasterupt = 0
    local segs = 0
    for i = 1, #scheduledef, 1 do
        local erupt = scheduledef[i]
        segs = segs + 16 * (erupt.days or 0) + (erupt.segs or 0)
        if segs > startseg then
            if erupt.warnquake then
                for j = 1, #erupt.warnquake, 1 do
                    local quakesegs = segs - erupt.warnquake[j].segsprev
                    if quakesegs >= 0 and quakesegs >= startseg then
                        if newschedule[quakesegs] == nil then
                            newschedule[quakesegs] = {}
                        end
                        --print(string.format("warnquake %d", quakesegs))
                        table.insert(newschedule[quakesegs], {fn=DoWarnQuake, data={size=erupt.warnquake[j].size}})
                    end
                end
            end
            if newschedule[segs] == nil then
                newschedule[segs] = {}
            end

            local data = {}
            if erupt.data == nil then
                erupt.data = {}
            end
            local seg_time = TUNING.SEG_TIME
            data.firerain_delay = (erupt.data.firerain_delay or 0) * seg_time
            data.firerain_duration = (erupt.data.firerain_duration or 1) * seg_time
            data.firerain_per_sec = erupt.data.firerain_per_sec or 0.125
            data.ash_delay = (erupt.data.ash_delay or 0) * seg_time
            data.ash_duration = (erupt.data.ash_duration or 1) * seg_time
            data.smoke_delay = (erupt.data.smoke_delay or 0) * seg_time
            data.smoke_duration = (erupt.data.smoke_duration or 1) * seg_time
            data.total_segs = segs - lasterupt

            lasterupt = segs + (erupt.data.firerain_delay or 0) + (erupt.data.firerain_duration or 1)

            --print(string.format("erupt %d, %d, %4.2f", segs, data.total_segs, math.max(math.max(data.firerain_delay + data.firerain_duration, data.ash_delay + data.ash_duration), data.smoke_delay + data.smoke_duration) / seg_time))
            table.insert(newschedule[segs], {fn=DoEruption, data=data})
        else
            if erupt.data == nil then
                erupt.data = {}
            end
            lasterupt = segs + (erupt.data.firerain_delay or 0) + (erupt.data.firerain_duration or 1)
        end
    end

    --[[print("Volcano Schedule: segs", segs)
    for k, v in pairs(newschedule) do
        for i = 1, #v, 1 do
            --print(string.format("   %d %s\n", k, tostring(v[i])))
        end
    end]]

    return newschedule, segs
end

local function segs_until_event(eventfn, schedule, currentSeg)
    if schedule then
        local earliest = nil
        local ev = nil

        for k, v in pairs(schedule) do
            for i = 1, #v, 1 do
                if v[i].fn == eventfn then
                    local seg = k 
                    if earliest == nil or (seg > currentSeg and seg < earliest) then
                        earliest = seg
                        ev = v[i]
                    end
                end
            end
        end
        if earliest then
            return earliest - currentSeg, ev
        end
    end
    return nil, nil
end

function VolcanoManager:GetNumSegmentsUntilEvent(eventfn)
    local dry, dryev = segs_until_event(eventfn, self.schedule[1], self:GetCurrentScheduleSegment())
    local staff, staffev = segs_until_event(eventfn, self.schedule[2], self:GetCurrentStaffScheduleSegment())
    if not dry and not staff then
        return nil
    end
    return math.min(dry or math.huge, staff or math.huge)
end 

function VolcanoManager:GetNumSegmentsUntilEruption()
    return self:GetNumSegmentsUntilEvent(DoEruption)
end 

function VolcanoManager:GetNumSegmentsUntilQuake()
    return self:GetNumSegmentsUntilEvent(DoWarnQuake)
end 

function VolcanoManager:GetNumSegmentsOfEruption()
    local dry, dryev = segs_until_event(DoEruption, self.schedule[1], self:GetCurrentScheduleSegment())
    if dry and dryev and dryev.data and dryev.data.total_segs then
        return dryev.data.total_segs
    end
    return 66
end

function VolcanoManager:GetNextEruptionEvent()
    local ev = nil
    local dry, dryev = segs_until_event(DoEruption, self.schedule[1], self:GetCurrentScheduleSegment())
    local staff, staffev = segs_until_event(DoEruption, self.schedule[2], self:GetCurrentStaffScheduleSegment())
    if dryev and staffev then
        if dry < staff then
            ev = dryev
        else
            ev = staffev
        end
    elseif dryev then
        ev = dryev
    elseif staffev then
        ev = staffev
    end
    return ev
end

function VolcanoManager:Appease(segs)
    if segs < 0 then --Schedule is getting pushed forward from a wrath item 
        local numSegs = math.abs(segs)
        local doquake = false 
        local doerupt = false 
        
        local segsuntilquake = self:GetNumSegmentsUntilQuake() 
        local segsuntilerupt = self:GetNumSegmentsUntilEruption()

        if segsuntilquake and segsuntilquake < numSegs then 
            doquake = true 
        end 

        if segsuntilerupt and segsuntilerupt < numSegs then 
            doerupt = true 
        end 

        if doquake then 
            print("Wrath causing warn quake")
            DoWarnQuake(self)
            if doerupt then 
                print("and eruption")
                self.inst:DoTaskInTime(WARN_QUAKE_DURATION + 1.0 , function()
                    local erupt = self:GetNextEruptionEvent()
                    DoEruption(self, erupt.data)
                end)
            end 
        elseif doerupt then 
            print("Wrath causing eruption")
            DoEruption(self)
        end 

    end 
    self.appeasesegs = self.appeasesegs + segs
end

return VolcanoManager
%%+%%scripts/components/volcanometer.lua%%-%%local VolcanoMeter = Class(function(self, inst)
    self.inst = inst
    self.targetseg = 0
    self.curseg = 0
    self.maxseg = 1
    self.updatemeterfn = nil
    self.updatedonefn = nil
end)

function VolcanoMeter:GetDebugString()
    return string.format("VolcanoMeter cur %d, target %d, max %d, perc %4.2f", self.curseg, self.targetseg, self.maxseg, 1.0 - (self.curseg / self.maxseg))
end

function VolcanoMeter:Start()
    self.inst:StartUpdatingComponent(self)
end

function VolcanoMeter:Stop()
    self.inst:StopUpdatingComponent(self)
end

function VolcanoMeter:UpdateMeter()
    local perc = math.clamp(1.0 - (self.curseg / self.maxseg), 0.0, 1.0)
    if self.updatemeterfn then
        self.updatemeterfn(self.inst, perc)
    end
end

function VolcanoMeter:UpdateDone()
    if self.updatedonefn then
        self.updatedonefn(self.inst)
    end
    self:Stop()
end

function VolcanoMeter:OnUpdate(dt)
    local segs_per_sec = 2
    if self.curseg < self.targetseg then
        self.curseg = self.curseg + segs_per_sec * dt
        if self.curseg >= self.targetseg then
            self.curseg = self.targetseg
            self:UpdateDone()
        end
        self:UpdateMeter()
    elseif self.curseg > self.targetseg then
        self.curseg = self.curseg - segs_per_sec * dt
        if self.curseg <= self.targetseg then
            self.curseg = self.targetseg
            self:UpdateDone()
        end
        self:UpdateMeter()
    end
end

function VolcanoMeter:SetSeg(seg)
    self.targetseg = seg
    self:Start()
end

return VolcanoMeter%%+%%scripts/components/watervisuals.lua%%-%%return Class(function(self, inst)

--------------------------------------------------------------------------
--[[ Dependencies ]]
--------------------------------------------------------------------------

local easing = require("easing")
require("constants")

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local _map = inst.Map

--------------------------------------------------------------------------
--[[ Spawn functions ]]
--------------------------------------------------------------------------

local function isWater(x, y, z)
	return IsOnWater(x,y,z,true)
end

local function isSurroundedByWater(x, y, z, radius)
	-- TheSim:ProfilerPush("isSurroundedByWater")
	
	for i = -radius, radius, 1 do
		if not isWater(x - radius, y, z + i) or not isWater(x + radius, y, z + i) then
			return false
		end
	end
	for i = -(radius - 1), radius - 1, 1 do
		if not isWater(x + i, y, z -radius) or not isWater(x + i, y, z + radius) then
			return false
		end
	end

	-- TheSim:ProfilerPop()
	return true
end

local function GetWaveBearing(ex, ey, ez, lines)

	--TheSim:SetDebugRenderEnabled(true)
	--inst.draw = inst.entity:AddDebugRender()
	--inst.draw:Flush()
	--inst.draw:SetRenderLoop(true)
	--inst.draw:SetZ(0.15)

	local _offs =
	{
		{-2,-2}, {-1,-2}, {0,-2}, {1,-2}, {2,-2},
		{-2,-1}, {-1,-1}, {0,-1}, {1,-1}, {2,-1},
		{-2, 0}, {-1, 0},          {1, 0}, {2, 0},
		{-2, 1}, {-1, 1}, {0, 1}, {1, 1}, {2, 1},
		{-2, 2}, {-1, 2}, {0, 2}, {1, 2}, {2, 2}
	}

	-- local flooding = GetWorld().Flooding
	local width, height = TheWorld.Map:GetSize()
	local halfw, halfh = 0.5 * width, 0.5 * height
	--local ex, ey, ez = inst.Transform:GetWorldPosition()
	local x, y = TheWorld.Map:GetTileXYAtPoint(ex, ey, ez)
	local xtotal, ztotal, n = 0, 0, 0
	-- for i = 1, #_offs, 1 do
		-- local ground = _map:GetTile( x + _offs[i][1], y + _offs[i][2] )
		-- if _map:IsLand(ground) and not (flooding and flooding:OnFlood(ex + _offs[i][1] * TILE_SCALE, ey, ez + _offs[i][2] * TILE_SCALE)) then
			-- --if lines then table.insert(lines, {ex, ez, ((x + _offs[i][1] - halfw) * TILE_SCALE), ((y + _offs[i][2] - halfh) * TILE_SCALE), 1, 1, 0, 1}) end
			-- xtotal = xtotal + ((x + _offs[i][1] - halfw) * TILE_SCALE)
			-- ztotal = ztotal + ((y + _offs[i][2] - halfh) * TILE_SCALE)
			-- n = n + 1
		-- end
	-- end
	for offx = -2, 2 do
	for offy = -2, 2 do
		if offx ~= 0 or offy ~= 0 then
			if not isWater(ex + offx * TILE_SCALE, ey, ez + offy * TILE_SCALE) then
				xtotal = xtotal + ((x + offx - halfw) * TILE_SCALE)
				ztotal = ztotal + ((y + offy - halfh) * TILE_SCALE)
				n = n + 1
			end
		end
	end
	end

	local bearing = nil
	if n > 0 then
		local a = math.atan2(ztotal/n - ez, xtotal/n - ex)
		--if lines then table.insert(lines, {ex, ez, ex + 10 * math.cos(a), ez + 10 * math.sin(a), 0, 1, 0, 1}) end
		--if lines then table.insert(lines, {ex, ez, ex + math.cos(0), ez + math.sin(0), 1, 0, 1, 1}) end
		bearing = -a/DEGREES - 90
	end

	-- TheSim:ProfilerPop()

	return bearing
end

local function SpawnWaveShore(inst, pt)
	-- TheSim:ProfilerPush("SpawnWaveShore")
	--local lines = {}
	local bearing = GetWaveBearing(pt.x, pt.y, pt.z)
	if bearing then
		local wave = SpawnAt( "wave_shore", pt )
		wave.Transform:SetRotation(bearing)
		wave:SetAnim()

		--[[TheSim:SetDebugRenderEnabled(true)
		wave.draw = wave.entity:AddDebugRender()
		wave.draw:Flush()
		wave.draw:SetRenderLoop(true)
		wave.draw:SetZ(0.15)
		for i = 1, #lines, 1 do
			wave.draw:Line(lines[i][1], lines[i][2], lines[i][3], lines[i][4], lines[i][5], lines[i][6], lines[i][7], lines[i][8])
		end]]
	end
	-- TheSim:ProfilerPop()
end

local function SpawnWaveShimmerRiver(inst, pt)
	SpawnAt( "wave_shimmer_river", pt )
end
local function SpawnWaveShimmerShallow(inst, pt)
	SpawnAt( "wave_shimmer", pt )
end
local function SpawnWaveShimmerMedium(inst, pt)
	SpawnAt( "wave_shimmer_med", pt )
end
local function SpawnWaveShimmerDeep(inst, pt)
	SpawnAt( "wave_shimmer_deep",  pt)
end
local function SpawnWaveShimmerFlood(inst, pt)
	SpawnAt( "wave_shimmer_flood", pt )
end
local function SpawnWaveFlood(inst, pt)
	-- TheSim:ProfilerPush("SpawnWaveFlood")
	SpawnWaveShimmerFlood(inst, pt)
	SpawnWaveShore(inst, pt)
	-- TheSim:ProfilerPop()
end

local function checkflood(inst, x, y, z, ground)
	return IsOnFlood( x, y, z ) and isSurroundedByWater(x, y, z, 2)
end

local function checkground(inst, x, y, z, ground)
	return TheWorld.Map:GetTileAtPoint( x, y, z ) == ground
	and IsWater(TheWorld.Map:GetTileAtPoint( x+3, y, z+3 ))
	and IsWater(TheWorld.Map:GetTileAtPoint( x+3, y, z+3 ))
	and IsWater(TheWorld.Map:GetTileAtPoint( x-3, y, z-3 ))
	and IsWater(TheWorld.Map:GetTileAtPoint( x-3, y, z-3 ))
end

local function checkgroundnear(inst, x, y, z, ground)
	return TheWorld.Map:GetTileAtPoint( x, y, z ) == ground
	-- and IsWater(TheWorld.Map:GetTileAtPoint( x+1, y, z+1 ))
	-- and IsWater(TheWorld.Map:GetTileAtPoint( x+1, y, z+1 ))
	-- and IsWater(TheWorld.Map:GetTileAtPoint( x-1, y, z-1 ))
	-- and IsWater(TheWorld.Map:GetTileAtPoint( x-1, y, z-1 ))
end

local function checkshore(inst, x, y, z, ground)
	local tile = TheWorld.Map:GetTileAtPoint(x, y, z)
	if tile ~= GROUND.RIVER and tile ~= GROUND.IMPASSABLE and tile ~= GROUND.INVALID and IsWaterOrFlood(tile) then
		local gx, gy = TheWorld.Map:GetTileXYAtPoint(x, y, z)
		for i = -1, 1, 1 do
			if not IsWater(TheWorld.Map:GetTile(gx + 1, gy + i)) or not IsWater(TheWorld.Map:GetTile(gx - 1, gy + i)) then
				return true
			end
		end
		return not IsWater(TheWorld.Map:GetTile(gx, gy - 1)) or not IsWater(TheWorld.Map:GetTile(gx, gy + 1))
	end
end

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst
self.shimmer =
{
	[GROUND.RIVER] = {per_sec = 85, spawn_rate = 0, checkfn = checkgroundnear, spawnfn = SpawnWaveShimmerRiver},
	-- [GROUND.OCEAN_SHORE] = {per_sec = 85, spawn_rate = 0, checkfn = checkshore, spawnfn = SpawnWaveShore},
	[GROUND.OCEAN_SHALLOW] = {per_sec = 75, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerShallow},
	[GROUND.OCEAN_CORAL] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerShallow},
	-- [GROUND.OCEAN_CORAL_SHORE] = {per_sec = 85, spawn_rate = 0, checkfn = checkshore, spawnfn = SpawnWaveShore},
	[GROUND.OCEAN_MEDIUM] = {per_sec = 75, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerMedium},
	[GROUND.OCEAN_DEEP] = {per_sec = 70, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep},
	[GROUND.OCEAN_SHIPGRAVEYARD] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep},
	[GROUND.MANGROVE] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerShallow},
	-- [GROUND.MANGROVE_SHORE] = {per_sec = 85, spawn_rate = 0, checkfn = checkshore, spawnfn = SpawnWaveShore},
	FLOOD = {per_sec = 80, spawn_rate = 0, checkfn = checkflood, spawnfn = SpawnWaveFlood},
	SHORE =  {per_sec = 85, spawn_rate = 0, checkfn = checkshore, spawnfn = SpawnWaveShore},

-- R08_ROT_TURNOFTIDES
	-- [GROUND.OCEAN_COASTAL_SHORE] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves},
	-- [GROUND.OCEAN_REEF_SHORE] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves},

	-- [GROUND.OCEAN_COASTAL] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves},
	-- [GROUND.OCEAN_REEF] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves},
	-- [GROUND.OCEAN_SWELL] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerMedium},
	-- [GROUND.OCEAN_ROUGH] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep},
	-- [GROUND.OCEAN_HAZARDOUS] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep},
}

-- if CurrentRelease.GreaterOrEqualTo("R08_ROT_TURNOFTIDES") then
	-- self.shimmer[GROUND.OCEAN_COASTAL] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves}
	-- self.shimmer[GROUND.OCEAN_REEF] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaves}
	-- self.shimmer[GROUND.OCEAN_SWELL] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerMedium}
	-- self.shimmer[GROUND.OCEAN_ROUGH] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep}
	-- self.shimmer[GROUND.OCEAN_HAZARDOUS] = {per_sec = 80, spawn_rate = 0, checkfn = checkground, spawnfn = SpawnWaveShimmerDeep}
-- end

--Private
local _shimmer_per_sec_mod = TUNING.WATERVISUALSHIMMER
local _camera_per_sec_mod = TUNING.WATERVISUALCAMERA

--------------------------------------------------------------------------
--[[ Functions ]]
--------------------------------------------------------------------------

local function DebugDraw(inst)
	if inst.draw then
		inst.draw:Flush()
		inst.draw:SetRenderLoop(true)
		inst.draw:SetZ(0.15)

		local px, py, pz = inst.Transform:GetWorldPosition()
		local cx, cy, cz = TheWorld.components.ocean:GetCurrentVec3()

		inst.draw:Line(px, pz, 50 * cx + px, 50 * cz + pz, 0, 0, 255, 255)

		local rad = TheWorld.components.ocean:GetCurrentAngle() * DEGREES
		local x, z = 25 * math.cos(rad), 25 * math.sin(rad)

		inst.draw:Line(px, pz, px + x, pz + z, 0, 128, 255, 255)		
	else
		TheSim:SetDebugRenderEnabled(true)
		inst.draw = inst.entity:AddDebugRender()
	end
end

local function getShimmerRadius()
	-- From values from camera_volcano.lua, camera range 30 to 100
	local percent = (TheCamera:GetDistance() - 30) / (70)
	local radius = (75 - 30) * percent + 30
	--print("Shimmer ", TheCamera:GetDistance(), radius)
	return radius
end

local function getPerSecMult(min, max)
	-- From values from camera_volcano.lua, camera range 30 to 100
	local percent = (TheCamera:GetDistance() - 30) / (70)
	local mult = (1.5 - 1) * percent + 1 -- 1x to 1.5x 
	--print("Per sec", TheCamera:GetDistance(), mult)
	return mult
end

function self:OnUpdate(dt)
	
	local px, py, pz = self.inst.Transform:GetWorldPosition()
	local mult = getPerSecMult()

	
	local radius = getShimmerRadius()
	for g, shimmer in pairs(self.shimmer) do
		shimmer.spawn_rate = shimmer.spawn_rate + shimmer.per_sec * _shimmer_per_sec_mod * mult * dt
		while shimmer.spawn_rate > 1.0 do
			local dx, dz = radius * UnitRand(), radius * UnitRand()
			local x, y, z = px + dx, 0, pz + dz
			
			if shimmer.checkfn(self, x, y, z, g) then
				shimmer.spawnfn(self, Vector3(x, y, z))
			end
			shimmer.spawn_rate = shimmer.spawn_rate - 1.0
		end

	end

	if _shimmer_per_sec_mod <= 0.0 and _camera_per_sec_mod <= 0.0 then
		self.inst:StopUpdatingComponent(self)
	end

	-- DebugDraw(self.inst)
end

function self:SetWaveSettings(shimmer_per_sec, camera_per_sec)
	_shimmer_per_sec_mod = shimmer_per_sec or TUNING.WATERVISUALSHIMMER
	_camera_per_sec_mod = camera_per_sec or TUNING.WATERVISUALCAMERA
end

-- function self:OnSave()
	-- return {
		-- shimmer_per_sec_mod = _shimmer_per_sec_mod,
		-- camera_per_sec_mod = _camera_per_sec_mod
	-- }
-- end

-- function self:OnLoad(data)
	-- if data then
		-- _shimmer_per_sec_mod = data.shimmer_per_sec_mod or _shimmer_per_sec_mod
		-- _camera_per_sec_mod = data.camera_per_sec_mod or _camera_per_sec_mod
	-- end
-- end


--Register events
-- inst:ListenForEvent("overrideambientsound", OnOverrideAmbientSound)

inst:StartUpdatingComponent(self)

end)
%%+%%scripts/components/wavemanager_ia.lua%%-%%
--------------------------------------------------------------------------
--[[ Dependencies ]]
--------------------------------------------------------------------------

require("constants")
local easing = require("easing")

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function set_ocean_angle(inst)
	inst.currentAngle = 45 * math.random(0, 7) + 22.5 --math.random(0, 359)
end

local function SpawnWaveRipple(inst, x, y, z, angle, speed)
	-- TheSim:ProfilerPush("SpawnWaveRipple")
	local wave = SpawnPrefab( "wave_ripple" )
	wave.Transform:SetPosition( x, y, z )

	--we just need an angle...
	wave.Transform:SetRotation(angle)
	
	--motor vel is relative to the local angle, since we're now facing the way we want to go we just go forward
	wave.Physics:SetMotorVel(speed, 0, 0)

	wave.idle_time = inst.ripple_idle_time

	-- TheSim:ProfilerPop()
	return wave
end

local function SpawnRogueWave(inst, x, y, z, angle, speed)
	-- TheSim:ProfilerPush("SpawnRogueWave")
	local wave = SpawnPrefab( "wave_rogue" )
	wave.Transform:SetPosition( x, y, z )
	wave.Transform:SetRotation(angle)
	
	--motor vel is relative to the local angle, since we're now facing the way we want to go we just go forward
	wave.Physics:SetMotorVel(speed, 0, 0)

	wave.idle_time = inst.ripple_idle_time

	-- TheSim:ProfilerPop()
	return wave
end

local function getRippleRadius()
	-- From values from camera_volcano.lua, camera range 30 to 100
	-- local percent = (TheCamera:GetDistance() - 30) / (70)
	-- local row_radius = (24 - 16) * percent + 16
	-- local col_radius = (8 - 2) * percent + 2
	--print("Ripple ", row_radius, col_radius)
	-- return row_radius, col_radius
	return 24, 8
end

local function getPerSecMult(min, max)
	-- From values from camera_volcano.lua, camera range 30 to 100
	-- local percent = (TheCamera:GetDistance() - 30) / (70)
	-- local mult = (1.5 - 1) * percent + 1 -- 1x to 1.5x 
	--print("Per sec", TheCamera:GetDistance(), mult)
	-- return mult
	return 1.5
end

local function updateSeasonMod(self)
	if TheWorld.state.issummer then
		self.seasonmult = 0.5 * math.sin(PI * TheWorld.state.seasonprogress + (PI/2.0)) + 0.5
	else
		self.seasonmult = 1
	end
end

local function onisnight(self, isnight)
	if isnight and not TheWorld.state.hurricane then
		self.inst:DoTaskInTime(0.25 * math.random() * TUNING.SEG_TIME, function()
			self.currentSpeed = 0.0
			self.nightreset = true
			self.inst:DoTaskInTime(math.random(10, 15), function()
				self.currentSpeed = 1.0
				self.nightreset = false
				set_ocean_angle(self)
			end)
		end)
	end
end

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

local WaveManager = Class(function(self, inst)
	self.inst = inst
	
	self.currentAngle = 0
	self.currentSpeed = 1
	
	self.seasonmult = 1
	
	self.ripple_speed = 1.5 --TODO what even is this
	self.ripple_per_sec = 10
	self.ripple_idle_time = 5 
	self.ripple_spawn_rate = 0

	self.ripple_per_sec_mod = 1.0

	set_ocean_angle(self)
	updateSeasonMod(self)
	self:WatchWorldState("isnight", onisnight)
	self:WatchWorldState("cycles", updateSeasonMod)

	self.inst:StartUpdatingComponent(self)
end)

--------------------------------------------------------------------------
--[[ Functions ]]
--------------------------------------------------------------------------


function WaveManager:SpawnLaneWaveRipple(player, x, y, z, row_radius, col_radius)
	local cx, cy, cz = self:GetCurrentVec3() --assuming unit vector here
	local m1 = math.floor(math.random(-row_radius, row_radius)) --math.random(-16, 16)
	local m2 = TUNING.WAVE_LANE_SPACING * math.floor(math.random(-col_radius, col_radius)) --math.random(-2, 2)
	local dx, dz = 2 * m1 * cx + m2 * cz, 2 * m1 * cz + m2 * -cx
	local tx, ty, tz = x + dx, y, z + dz
	--don't spawn waves too close to worlds edge
	local w, h = TheWorld.Map:GetSize()
	w = (w * .5 - TUNING.MAPWRAPPER_WARN_RANGE) * TILE_SCALE 
	h = (h * .5 - TUNING.MAPWRAPPER_WARN_RANGE) * TILE_SCALE 
	if tx < -w or tx > w 
	or tz < -h or tz > h
	then return end
	--ok now check ground tiles
	local ground = TheWorld.Map:GetTileAtPoint( tx, ty, tz )
	if ground == GROUND.OCEAN_MEDIUM or ground == GROUND.OCEAN_DEEP then
		local noSpawn = TheSim:FindEntities(tx, ty, tz, 10, {"nowaves"})
		if noSpawn == nil or #noSpawn == 0 then
			--lastly, make sure there are no waves there already
			local ents = TheSim:FindEntities(tx, ty, tz, 4, {"lanewave"})

			if ents == nil or #ents == 0 then
				local wave
				if (TheWorld.state.isfullmoon --[[and (TheWorld.state.isnight or TheWorld.state.isdusk)]] and math.random() < 0.25)
				or (TheWorld.state.iswinter and math.random() < easing.inOutCirc(1 - ((TheWorld.state.winterlength - TheWorld.state.elapseddaysinseason) / TheWorld.state.winterlength), 0.0, 1.0, 1.0)) then
					wave = SpawnRogueWave(player, tx, ty, tz, -self:GetCurrentAngle(), self.ripple_speed * self:GetCurrentSpeed() * TUNING.ROGUEWAVE_SPEED_MULTIPLIER)
				else
					wave = SpawnWaveRipple(player, tx, ty, tz, -self:GetCurrentAngle(), self.ripple_speed * self:GetCurrentSpeed())
				end
				wave:AddTag("lanewave")
			end
		end
	end
end

function WaveManager:OnUpdate(dt)
	if TheWorld.Map == nil then
		return
	end

	local mult = getPerSecMult()
	local row_radius, col_radius = getRippleRadius()
	
	-- local w, h = TheWorld.Map:GetSize()
	local gridw, gridh = TUNING.WAVE_LANE_SPACING, TUNING.WAVE_LANE_SPACING
	
	if self:GetCurrentSpeed() > 0.0 then		
		self.ripple_spawn_rate = self.ripple_spawn_rate + self.ripple_per_sec * self.ripple_per_sec_mod * mult * self.seasonmult * dt

		while self.ripple_spawn_rate > 1.0 do --TODO maybe optimise by calculating the num to spawn
			for i, player in pairs(AllPlayers) do
				if player:IsValid() and player.entity:IsVisible() then
					local px, py, pz = player.Transform:GetWorldPosition()
					local ents = TheSim:FindEntities(px, py, pz, row_radius, { "lanewave" })
					if #ents < TUNING.MAX_WAVES then
						--snap to map lanes
						local lx, ly, lz = math.floor(px / gridw) * gridw, py, math.floor(pz / gridh) * gridh
						self:SpawnLaneWaveRipple(player, lx, ly, lz, row_radius, col_radius)
					end
				end
			end
			self.ripple_spawn_rate = self.ripple_spawn_rate - 1.0
		end

	end

	if self.ripple_per_sec_mod <= 0.0 then
		self.inst:StopUpdatingComponent(self)
	end

end

function WaveManager:OnSave()
	if self.nightreset == true then --don't accidentally save the idle phase permamently
		self.currentSpeed = 1.0
		set_ocean_angle(self)
	end
	return
	{
		currentAngle = self.currentAngle,
		currentSpeed = self.currentSpeed
	}
end

function WaveManager:OnLoad(data)
	if data then
		self.currentAngle = data.currentAngle or self.currentAngle
		self.currentSpeed = data.currentSpeed or self.currentSpeed
	end
end

function WaveManager:GetCurrentAngle()
	return self.currentAngle
end

function WaveManager:GetCurrentSpeed()
	return self.currentSpeed
end

function WaveManager:GetCurrentVec3()
	return self.currentSpeed * math.cos(self.currentAngle * DEGREES), 0, self.currentSpeed * math.sin(self.currentAngle * DEGREES)
	--return self.currentSpeed * math.sin(self.currentAngle * DEGREES), 0, self.currentSpeed * math.cos(self.currentAngle * DEGREES)
end

function WaveManager:SetWaveSettings(ripple_per_sec)
	self.ripple_per_sec_mod = ripple_per_sec or 1.0
end

return WaveManager
%%+%%scripts/components/waveobstacle.lua%%-%%local WaveObstacle = Class(function(self, inst)
    self.inst = inst
    self.hittestfn = nil
    self.oncollidefn = nil
    self.ondestroyfn = nil
    self.destroychance = 0.01
	
	self.inst:AddTag("waveobstacle")
end)

function WaveObstacle:IsHit(wave)
	return self.hittestfn == nil or self.hittestfn(self.inst, wave)
end

function WaveObstacle:OnCollide(wave)
	if self.oncollidefn then
		self.oncollidefn(self.inst, wave)
	end
	if self.ondestroyfn and math.random() < self.destroychance then
		self.ondestroyfn(self.inst)
	end
end

function WaveObstacle:SetOnCollideFn(fn)
	self.oncollidefn = fn
end

function WaveObstacle:SetOnDestroyFn(fn)
	self.ondestroyfn = fn
end

function WaveObstacle:SetDestroyChance(chance)
	self.destroychance = chance
end

return WaveObstacle%%+%%scripts/components/whalehunter.lua%%-%%--------------------------------------------------------------------------
--[[ Whalehunter class definition ]]
-- This is a copy of Hunter specifically for whale hunting
-- It has some hooks to make things easier for mods :)
--------------------------------------------------------------------------

-- c_whalehunt = nil --DEBUG

return Class(function(self, inst)

assert(TheWorld.ismastersim, "Whalehunter should not exist on client")

--------------------------------------------------------------------------
--[[ Dependencies ]]
--------------------------------------------------------------------------

local SourceModifierList = require("util/sourcemodifierlist")

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local HUNT_UPDATE = 2

local _dirt_prefab = "whale_bubbles"
local _track_prefab = "whale_track"
local _beast_prefabs = {"whale_blue"}
local _alternate_beast_prefabs = {function(beasts)
	if TheWorld.state.isspring or TheWorld.state.isautumn then
		table.insert(beasts, "whale_white")
	end
end}
local _spawnoverride = nil

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst
	
-- Private
local _activeplayers = {}
local _activehunts = {}

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local OnUpdateHunt
local ResetHunt

local function GetMaxHunts()
	return #_activeplayers
end

local function RemoveDirt(hunt)
	assert(hunt)
	--print("Whalehunter:RemoveDirt")
	if hunt.lastdirt ~= nil then
		--print("   removing old dirt")
		inst:RemoveEventCallback("onremove", hunt.lastdirt._ondirtremove, hunt.lastdirt)
		hunt.lastdirt:Remove()
		hunt.lastdirt = nil
	--else
		--print("   nothing to remove")
	end
end

local function StopHunt(hunt)
	assert(hunt)
	--print("Whalehunter:StopHunt")

	RemoveDirt(hunt)

	if hunt.hunttask ~= nil then
		--print("   stopping")
		hunt.hunttask:Cancel()
		hunt.hunttask = nil
	--else
		--print("   nothing to stop")
	end
end

local function BeginHunt(hunt)
	assert(hunt)
	--print("Whalehunter:BeginHunt")
	hunt.hunttask = inst:DoPeriodicTask(HUNT_UPDATE, OnUpdateHunt, nil, hunt)
	--print(hunt.hunttask ~= nil and "The Hunt Begins!" or "The Hunt ... failed to begin.")
end

local function StopCooldown(hunt)
	assert(hunt)
	--print("Whalehunter:StopCooldown")
	if hunt.cooldowntask ~= nil then
		--print("    stopping")
		hunt.cooldowntask:Cancel()
		hunt.cooldowntask = nil
		hunt.cooldowntime = nil
	--else
		--print("    nothing to stop")
	end
end

local function OnCooldownEnd(inst, hunt)
	assert(hunt)
	--print("Whalehunter:OnCooldownEnd")

	StopCooldown(hunt) -- clean up references
	StopHunt(hunt)

	BeginHunt(hunt)
end

local function RemoveHunt(hunt)
	StopHunt(hunt)
	for i,v in ipairs(_activehunts) do
		if v == hunt then
			table.remove(_activehunts, i)
			return
		end
	end
	assert(false)
end

local function StartCooldown(inst, hunt, cooldown)
	assert(hunt)
	local cooldown = cooldown or TUNING.WHALEHUNT_COOLDOWN + TUNING.WHALEHUNT_COOLDOWNDEVIATION * (math.random() * 2 - 1)
	--print("Whalehunter:StartCooldown", cooldown)

	StopHunt(hunt)
	StopCooldown(hunt)

	if #_activehunts > GetMaxHunts() then
		RemoveHunt(hunt)
		return
	end

	if cooldown and cooldown > 0 then
		--print("The Hunt begins in", cooldown)
		hunt.activeplayer = nil
		hunt.lastdirt = nil
		hunt.lastdirttime = nil

		hunt.cooldowntask = inst:DoTaskInTime(cooldown, OnCooldownEnd, hunt)
		hunt.cooldowntime = GetTime() + cooldown
	end
end

local function StartHunt()
	--print("Whalehunter:StartHunt")
	-- Given the way hunt is used, it should really be its own class now
	local newhunt =
	{
		lastdirt = nil,
		direction = nil,
		activeplayer = nil,
	}
	table.insert(_activehunts, newhunt)
	inst:DoTaskInTime(0, StartCooldown, newhunt)
	return newhunt
end

-- c_whalehunt = function() 
	-- for i = #_activehunts, 1, -1 do
		-- table.remove(_activehunts, i)
		-- StopHunt(_activehunts[i])
	-- end
	-- table.insert(_activehunts,{})
	-- BeginHunt(_activehunts[1])
-- end --DEBUG

local function IsValidWater(pt)
	--check if the point is too close to the edge fog (this should probably be a public util -M)
	local h, w = TheWorld.Map:GetSize()
	local tx, ty = TheWorld.Map:GetTileCoordsAtPoint(pt.x, pt.y, pt.z)
	if GetDistFromEdge(tx, ty, w, h ) < TUNING.MAPEDGE_PADDING then
		return false
	end
	local tile = TheWorld.Map:GetTileAtPoint(pt.x, pt.y, pt.z)
	-- return IsWater(tile)
	-- and tile ~= GROUND.RIVER
	-- and tile ~= GROUND.MANGROVE
	-- and tile ~= GROUND.OCEAN_SHALLOW
	-- and tile ~= GROUND.OCEAN_CORAL
	return tile == GROUND.OCEAN_MEDIUM
	or tile == GROUND.OCEAN_DEEP
	or tile == GROUND.OCEAN_SHIPGRAVEYARD
end

local function GetSpawnPoint(pt, radius, hunt)
	--print("Whalehunter:GetSpawnPoint", tostring(pt), radius)

	local angle = hunt.direction
	if angle then
		local offset = Vector3(radius * math.cos( angle ), 0, -radius * math.sin( angle ))
		local spawn_point = pt + offset
		
		if IsValidWater(spawn_point) then
			--print(string.format("Whalehunter:GetSpawnPoint RESULT %s, %2.2f", tostring(spawn_point), angle/DEGREES))
			return spawn_point
		end
	end
end

local function SpawnDirt(pt,hunt)
	assert(hunt)
	--print("Whalehunter:SpawnDirt")

	local spawn_pt = GetSpawnPoint(pt, TUNING.WHALEHUNT_SPAWN_DIST, hunt)
	if spawn_pt ~= nil then
		local spawned = SpawnPrefab(_dirt_prefab)
		if spawned ~= nil then
			spawned.Transform:SetPosition(spawn_pt:Get())
			hunt.lastdirt = spawned
			hunt.lastdirttime = GetTime()

			spawned._ondirtremove = function()
				hunt.lastdirt = nil
				ResetHunt(hunt)
			end
			inst:ListenForEvent("onremove", spawned._ondirtremove, spawned)

			return true
		end
	end
	--print("Whalehunter:SpawnDirt FAILED")
	return false
end

local function GetRunAngle(pt, angle, radius)
	local offset, result_angle = FindWalkableOffset(pt, angle, radius, 14, true, false, IsValidWater)
	--print("   found... ",offset)
	return result_angle
end

local function GetNextSpawnAngle(pt, direction, radius)
	--print("Whalehunter:GetNextSpawnAngle", tostring(pt), radius)

	local base_angle = direction or math.random() * 2 * PI
	local deviation = math.random(-TUNING.WHALEHUNT_TRACK_ANGLE_DEVIATION, TUNING.WHALEHUNT_TRACK_ANGLE_DEVIATION)*DEGREES

	local start_angle = base_angle + deviation
	--print(string.format("   original: %2.2f, deviation: %2.2f, starting angle: %2.2f", base_angle/DEGREES, deviation/DEGREES, start_angle/DEGREES))

	--[[local angle =]] return GetRunAngle(pt, start_angle, radius)
	--print(string.format("Whalehunter:GetSpawnPoint RESULT %s", tostring(angle and angle/DEGREES)))
	--return angle
end

local function StartDirt(hunt,position)
	assert(hunt)

	--print("Whalehunter:StartDirt")

	RemoveDirt(hunt)

	local pt = position --Vector3(player.Transform:GetWorldPosition())

	hunt.numtrackstospawn = math.random(TUNING.WHALEHUNT_MIN_TRACKS, TUNING.WHALEHUNT_MAX_TRACKS)
	hunt.trackspawned = 0
	hunt.direction = GetNextSpawnAngle(pt, nil, TUNING.WHALEHUNT_SPAWN_DIST)
	if hunt.direction ~= nil then
		--print(string.format("   first angle: %2.2f", hunt.direction/DEGREES))

		--print("    numtrackstospawn", hunt.numtrackstospawn)

		-- it's ok if this spawn fails, because we'll keep trying every HUNT_UPDATE
		local spawnRelativeTo =  pt
		if SpawnDirt(spawnRelativeTo, hunt) then
			--print("Suspicious dirt placed for player ")
		end
	--else
		--print("Failed to find suitable dirt placement point")
	end
end

-- are we too close to the last dirtpile of a hunt?
local function IsNearHunt(player)
	for i,hunt in ipairs(_activehunts) do
		if hunt.lastdirt ~= nil and player:IsNear(hunt.lastdirt, TUNING.MIN_JOINED_HUNT_DISTANCE) then
			return true
		end
	end
	return false
end

-- something went unrecoverably wrong, try again after a brief pause
ResetHunt = function(hunt, washedaway)
	assert(hunt)
	--print("Whalehunter:ResetHunt - The Hunt was a dismal failure, please stand by...")
	if hunt.activeplayer ~= nil then
		hunt.activeplayer:PushEvent("huntlosttrail", { washedaway = washedaway })
	end

	StartCooldown(inst, hunt, TUNING.WHALEHUNT_RESET_TIME)
end

-- Don't be tricked by the name. This is not called every frame
OnUpdateHunt = function(inst, hunt)
	assert(hunt)

	--print("Whalehunter:OnUpdateHunt")

	if hunt.lastdirttime ~= nil then
		if hunt.huntedbeast == nil and hunt.trackspawned >= 1 then
			local wet = TheWorld.state.wetness > 15 or TheWorld.state.israining
			if (wet and (GetTime() - hunt.lastdirttime) > (.75*TUNING.SEG_TIME))
				or (GetTime() - hunt.lastdirttime) > (1.25*TUNING.SEG_TIME) then
		
				-- check if the player is currently active in any other hunts
				local playerIsInOtherHunt = false
				for i,v in ipairs(_activehunts) do
					if v ~= hunt and v.activeplayer and hunt.activeplayer then
						if v.activeplayer == hunt.activeplayer then
							playerIsInOtherHunt = true
						end
					end
				end

				-- if the player is still active in another hunt then end this one quietly
				if playerIsInOtherHunt then
					StartCooldown(inst, hunt)
				else
					ResetHunt(hunt, wet) --Wash the tracks away but only if the player has seen at least 1 track
				end

				return
			end
		end
	end

	if hunt.lastdirt == nil then
		-- pick a player that is available, meaning, not being the active participant in a hunt
		local huntingPlayers = {}   
		for i,v in ipairs(_activehunts) do
			if v.activeplayer then
				huntingPlayers[v.activeplayer] = true
			end
		end

		local eligiblePlayers = {}
		for i,v in ipairs(_activeplayers) do
			if not huntingPlayers[v] and not IsNearHunt(v) then
				table.insert(eligiblePlayers, v)
			end
		end
		if #eligiblePlayers == 0 then
			-- Maybe next time?
			return
		end
		local player = eligiblePlayers[math.random(1,#eligiblePlayers)]
		--print("Start hunt for player",player)
		local position = player:GetPosition()
		StartDirt(hunt, position)
	else
		-- if no player near enough, then give up this hunt and start a new one
		local x, y, z = hunt.lastdirt.Transform:GetWorldPosition()
		
		if not IsAnyPlayerInRange(x, y, z, TUNING.MAX_WHALEHUNT_DISTANCE) then
			-- try again rather soon
			StartCooldown(inst, hunt, .1)
		end
	end
end

local function GetAlternateBeastChance()
	local day = TheWorld.state.cycles
	local chance = Lerp(TUNING.WHALEHUNT_ALTERNATE_BEAST_CHANCE_MIN, TUNING.WHALEHUNT_ALTERNATE_BEAST_CHANCE_MAX, day/100)
	return math.clamp(chance, TUNING.WHALEHUNT_ALTERNATE_BEAST_CHANCE_MIN, TUNING.WHALEHUNT_ALTERNATE_BEAST_CHANCE_MAX)
end

local function GetRandomBeastPrefab(t)
	local valid = {}
	for k,v in ipairs(t) do
		if type(v) == "string" then
			table.insert(valid, v)
		elseif type(v) == "function" then
			v(valid) --give the function complete control over the table, for mod madness :D -M
		end
	end
	return #valid > 0 and valid[math.random(#valid)] or nil
end

local function SpawnHuntedBeast(hunt, pt)
	assert(hunt)
	--print("Whalehunter:SpawnHuntedBeast")

	local spawn_pt = GetSpawnPoint(pt, TUNING.WHALEHUNT_SPAWN_DIST, hunt)
	if spawn_pt ~= nil then
		hunt.huntedbeast = SpawnPrefab(
			_spawnoverride or
			(math.random() <= GetAlternateBeastChance() and GetRandomBeastPrefab(_alternate_beast_prefabs)) or
			GetRandomBeastPrefab(_beast_prefabs)
		)

		if hunt.huntedbeast ~= nil then
			--print("Kill the Beast!")
			hunt.huntedbeast.Physics:Teleport(spawn_pt:Get())

			local function OnBeastDeath()
				--print("Whalehunter:OnBeastDeath")
				inst:RemoveEventCallback("onremove", OnBeastDeath, hunt.huntedbeast)
				hunt.huntedbeast = nil
				StartCooldown(inst, hunt)
			end

			inst:ListenForEvent("death", OnBeastDeath, hunt.huntedbeast)
			inst:ListenForEvent("onremove", OnBeastDeath, hunt.huntedbeast)

			hunt.huntedbeast:PushEvent("spawnedforhunt")
			return true
		end
	end
	--print("Whalehunter:SpawnHuntedBeast FAILED")
	return false
end

local function SpawnBubble(num, pt, direction)
	local bubble = SpawnPrefab(_track_prefab)
	local offset = Vector3((num * 5) * math.cos(direction), 0, -(num * 5) * math.sin(direction))
	bubble.Transform:SetPosition((pt + offset):Get())
end

local function HintDirection(pt, direction)
	--Spawn several bubbles in a line pointing towards the next track.
	for i = 0, 3 do
		inst:DoTaskInTime(i * 1.33 + 0.5, function() SpawnBubble(i, pt, direction) end)
	end
end

local function SpawnTrack(spawn_pt, hunt)
	--print("Whalehunter:SpawnTrack")

	if spawn_pt then
		local next_angle = GetNextSpawnAngle(spawn_pt, hunt.direction, TUNING.WHALEHUNT_SPAWN_DIST)
		if next_angle ~= nil then
			local spawned = SpawnPrefab(_track_prefab)
			if spawned ~= nil then
				spawned.Transform:SetPosition(spawn_pt:Get())

				hunt.direction = next_angle

				--print(string.format("   next angle: %2.2f", hunt.direction/DEGREES))
				spawned.Transform:SetRotation(hunt.direction/DEGREES - 90)

				hunt.trackspawned = hunt.trackspawned + 1
				--print(string.format("   spawned %u/%u", hunt.trackspawned, hunt.numtrackstospawn))
				return true
			end
		end
	end
	--print("Whalehunter:SpawnTrack FAILED")
	return false
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function KickOffHunt()
	-- schedule start of a new hunt
	if #_activehunts < GetMaxHunts() then
		StartHunt()
	end
end

local function OnPlayerJoined(src, player)
	for i,v in ipairs(_activeplayers) do
		if v == player then
			return
		end
	end
	table.insert(_activeplayers, player)
	-- one hunt per player. 
	KickOffHunt()
end

local function OnPlayerLeft(src, player)
	for i,v in ipairs(_activeplayers) do
		if v == player then
			table.remove(_activeplayers, i)
			return
		end
	end
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

for i, v in ipairs(AllPlayers) do
	OnPlayerJoined(self, v)
end

inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, TheWorld)
inst:ListenForEvent("ms_playerleft", OnPlayerLeft, TheWorld)

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

-- if anything fails during this step, it's basically unrecoverable, since we only have this one chance
-- to spawn whatever we need to spawn.  if that fails, we need to restart the whole process from the beginning
-- and hope we end up in a better place
function self:OnDirtInvestigated(pt, doer)
	assert(doer)

	--print("Whalehunter:OnDirtInvestigated (by "..tostring(doer)..")")

	local hunt = nil
	-- find the hunt this pile belongs to
	for i,v in ipairs(_activehunts) do
		if v.lastdirt ~= nil and v.lastdirt:GetPosition() == pt then
			hunt = v
			inst:RemoveEventCallback("onremove", v.lastdirt._ondirtremove, v.lastdirt)
			break
		end
	end

	if hunt == nil then
		-- we should probably do something intelligent here.
		--print("yikes, no matching hunt found for investigated dirtpile")
		return
	end

	hunt.activeplayer = doer

	if hunt.numtrackstospawn ~= nil and hunt.numtrackstospawn > 0 then
		if SpawnTrack(pt, hunt) then
			print("    ", hunt.trackspawned, hunt.numtrackstospawn)
			if hunt.trackspawned < hunt.numtrackstospawn then
				if SpawnDirt(pt, hunt) then
					HintDirection(pt, hunt.direction)
					--print("...good job, you found a track!")
				else
					--print("SpawnDirt FAILED! RESETTING")
					ResetHunt(hunt)
				end
			elseif hunt.trackspawned == hunt.numtrackstospawn then
				if SpawnHuntedBeast(hunt,pt) then
					--print("...you found the last track, now find the beast!")
					hunt.activeplayer:PushEvent("huntbeastnearby")
					StopHunt(hunt)
				else
					--print("SpawnHuntedBeast FAILED! RESETTING")
					ResetHunt(hunt)
				end
			end
		else
			-- print("SpawnTrack FAILED! RESETTING")
			ResetHunt(hunt)
		end
	end
end


-- Hooks for mods

function self:AddBeast(prefab)
	-- note: "prefab" can also be a function, in that case the function can add the prefab if conditions are met
	table.insert(_beast_prefabs, prefab)
	-- return #_beast_prefabs
end

function self:AddAlternateBeast(prefab)
	-- note: "prefab" can also be a function, in that case the function can add the prefab if conditions are met
	table.insert(_alternate_beast_prefabs, prefab)
	-- return #_alternate_beast_prefabs
end

--------------------------------------------------------------------------
--[[ Update ]]
--------------------------------------------------------------------------

function self:LongUpdate(dt)
	for i,hunt in ipairs(_activehunts) do
		if hunt.cooldowntask ~= nil and hunt.cooldowntime ~= nil then
			hunt.cooldowntask:Cancel()
			hunt.cooldowntask = nil
			hunt.cooldowntime = hunt.cooldowntime - dt
			hunt.cooldowntask = inst:DoTaskInTime(hunt.cooldowntime - GetTime(), OnCooldownEnd, hunt)
		end
	end
end

--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
	local str = ""
	for i, hunt in ipairs(_activehunts) do
		str = str.." Cooldown: ".. (hunt.cooldowntime and string.format("%2.2f", math.max(1, hunt.cooldowntime - GetTime())) or "-")
		if not hunt.lastdirt then
			str = str.." No last dirt."
			--str = str.." Distance: ".. (playerdata.distance and string.format("%2.2f", playerdata.distance) or "-")
			--str = str.."/"..tostring(TUNING.MIN_HUNT_DISTANCE)
		else
			str = str.." Dirt"
			--str = str.." Distance: ".. (playerdata.distance and string.format("%2.2f", playerdata.distance) or "-")
			--str = str.."/"..tostring(TUNING.MAX_DIRT_DISTANCE)
		end
	end
	return str
end

end)
%%+%%scripts/components/windproofer.lua%%-%%local WindProofer = Class(function(self, inst)
	self.inst = inst
	self.effectiveness = 1
    --Recommended to explicitly add tag to prefab pristine state
    inst:AddTag("windproofer")
end)

function WindProofer:OnRemoveFromEntity()
    self.inst:RemoveTag("windproofer")
end

function WindProofer:GetEffectiveness()
	return self.effectiveness
end

function WindProofer:SetEffectiveness(val)
	self.effectiveness = val
end

return WindProofer%%+%%scripts/components/windvisuals.lua%%-%%-- If we ever have more than 1 instance of this component, we probably should move these variables
local windfx_rate = 0
local windfx_per_sec = 16

local WindVisuals = Class(function(self, inst)
	self.inst = inst

	inst:StartUpdatingComponent(self)
end)

local function SpawnWindSwirl(x, y, z, angle)
	local swirl = SpawnPrefab("windswirl")
	swirl.Transform:SetPosition(x, y, z)
	swirl.Transform:SetRotation(angle + 180)
	--swirl.Physics:SetMotorVel(speed, 0, 0)
end

function WindVisuals:OnUpdate(dt)
	if TheWorld.state.hurricane and TheWorld.state.gustspeed > .1 and IsInIAClimate(self.inst) then
		windfx_rate = windfx_rate + windfx_per_sec * dt
		local px, py, pz = self.inst.Transform:GetWorldPosition()
		--print(string.format("wind %f, %4.2f, %4.f", sm:GetHurricaneWindSpeed(), self.windfx_rate, self:GetWindAngle()))
		while windfx_rate > 1.0 do
			local dx, dz = 16 * UnitRand(), 16 * UnitRand()
			local x, y, z = px + dx, py, pz + dz
			local angle = TheWorld.state.gustangle

			SpawnWindSwirl(x, 0, z, angle)
			windfx_rate = windfx_rate - 1.0
		end
	end
	
end

function WindVisuals:SetRate(rate)
	windfx_per_sec = rate or 16
end

return WindVisuals%%+%%scripts/components/worldislandtemperature.lua%%-%%--------------------------------------------------------------------------
--[[ WorldIslandTemperature class definition (mostly copied from WorldTemperature) ]]
--------------------------------------------------------------------------

return Class(function(self, inst)

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local NOISE_SYNC_PERIOD = 30

--------------------------------------------------------------------------
--[[ Temperature constants ]]
--------------------------------------------------------------------------

local TEMPERATURE_NOISE_SCALE = .025
local TEMPERATURE_NOISE_MAG = 8

local MIN_TEMPERATURE = 35
local MAX_TEMPERATURE = 65
local WINTER_CROSSOVER_TEMPERATURE = 40
local SUMMER_CROSSOVER_TEMPERATURE = 50

local SUMMER_RAIN_TEMP = -10 --TODO implement this
local HURRICANE_TEMP = -10
local HURRICANE_WIND_TEMP = -10

local PHASE_TEMPERATURES =
{
    day = 10,
    night = -5,
}

--------------------------------------------------------------------------
--[[ Member variables ]]
--------------------------------------------------------------------------

--Public
self.inst = inst

--Private
local _world = TheWorld
local _map = _world.Map
local _ismastersim = _world.ismastersim

--Temperature
local _seasontemperature
local _phasetemperature
local _hurricanetemperature
local _globaltemperaturemult = 1
local _globaltemperaturelocus = 0

--Light
local _daylight = true
local _season = "autumn"

--Network
local _noisetime = net_float(inst.GUID, "worldislandtemperature._noisetime")

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local function SetWithPeriodicSync(netvar, val, period, ismastersim)
    if netvar:value() ~= val then
        local trunc = val > netvar:value() and "floor" or "ceil"
        local prevperiod = math[trunc](netvar:value() / period)
        local nextperiod = math[trunc](val / period)

        if prevperiod == nextperiod then
            --Client and server update independently within current period
            netvar:set_local(val)
        elseif ismastersim then
            --Server sync to client when period changes
            netvar:set(val)
        else
            --Client must wait at end of period for a server sync
            netvar:set_local(nextperiod * period)
        end
    elseif ismastersim then
        --Force sync when value stops changing
        netvar:set(val)
    end
end

local ForceResync = _ismastersim and function(netvar)
    netvar:set_local(netvar:value())
    netvar:set(netvar:value())
end or nil

local function CalculateSeasonTemperature(season, progress)
    return (season == "winter" and math.sin(PI * progress) * (MIN_TEMPERATURE - WINTER_CROSSOVER_TEMPERATURE) + WINTER_CROSSOVER_TEMPERATURE)
        or (season == "spring" and Lerp(WINTER_CROSSOVER_TEMPERATURE, SUMMER_CROSSOVER_TEMPERATURE, progress))
        or (season == "summer" and math.sin(PI * progress) * (MAX_TEMPERATURE - SUMMER_CROSSOVER_TEMPERATURE) + SUMMER_CROSSOVER_TEMPERATURE)
        or Lerp(SUMMER_CROSSOVER_TEMPERATURE, WINTER_CROSSOVER_TEMPERATURE, progress)
end

local function CalculatePhaseTemperature(phase, timeinphase)
    return PHASE_TEMPERATURES[phase] ~= nil and PHASE_TEMPERATURES[phase] * math.sin(timeinphase * PI) or 0
end

local function CalculateHurricaneTemperature(windspeed, progress)
    return HURRICANE_TEMP * math.sin(PI * progress) + HURRICANE_WIND_TEMP * windspeed
end

local function CalculateTemperature()
    local temperaturenoise = 2 * TEMPERATURE_NOISE_MAG * perlin(0, 0, _noisetime:value() * TEMPERATURE_NOISE_SCALE) - TEMPERATURE_NOISE_MAG
    return (((temperaturenoise + _seasontemperature + _phasetemperature + _hurricanetemperature) - _globaltemperaturelocus) * _globaltemperaturemult) + _globaltemperaturelocus
end

local function PushTemperature()
    local data = CalculateTemperature()
    _world:PushEvent("islandtemperaturetick", data)
end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function OnSeasonTick(src, data)
    _seasontemperature = CalculateSeasonTemperature(data.season, data.progress)
    _season = data.season
    --_seasonprogress = data.progress
end

local function OnClockTick(src, data)
    _phasetemperature = CalculatePhaseTemperature(data.phase, data.timeinphase)
end

local function OnPhaseChanged(src, phase)
    _daylight = phase == "day"
end

local function OnHurricaneTick(src, data)
    _hurricanetemperature = CalculateHurricaneTemperature(data.windspeed, data.progress)
end

local OnSimUnpaused = _ismastersim and function()
    --Force resync values that client may have simulated locally
    ForceResync(_noisetime)
end or nil

--------------------------------------------------------------------------
--[[ Public member functions ]]
--------------------------------------------------------------------------

--This is only used by caves at time of writing, so we don't *need* to copy it from WorldTemperature -M
function self:SetTemperatureMod(multiplier, locus)
    _globaltemperaturemult = multiplier
    _globaltemperaturelocus = locus
    PushTemperature()
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

_seasontemperature = CalculateSeasonTemperature(_season, .5)
_phasetemperature = CalculatePhaseTemperature(_daylight and "day" or "dusk", 0)
_hurricanetemperature = CalculatePhaseTemperature(0, 0)

--Initialize network variables
_noisetime:set(0)

--Register events
inst:ListenForEvent("seasontick", OnSeasonTick, _world)
inst:ListenForEvent("clocktick", OnClockTick, _world)
inst:ListenForEvent("phasechanged", OnPhaseChanged, _world)
inst:ListenForEvent("hurricanetick", OnHurricaneTick, _world) --not yet sure how hurricane will actually work -M

if _ismastersim then
    --Register master simulation events
    inst:ListenForEvent("ms_simunpaused", OnSimUnpaused, _world)
end

PushTemperature()
inst:StartUpdatingComponent(self)

--------------------------------------------------------------------------
--[[ Update ]]
--------------------------------------------------------------------------

--[[
    Client updates temperature, moisture, precipitation effects, and snow
    level on its own while server force syncs values periodically. Client
    cannot start, stop, or change precipitation on its own, and must wait
    for server syncs to trigger these events.
--]]
function self:OnUpdate(dt)
    --Update noise
    SetWithPeriodicSync(_noisetime, _noisetime:value() + dt, NOISE_SYNC_PERIOD, _ismastersim)

    PushTemperature()
end

self.LongUpdate = self.OnUpdate

--------------------------------------------------------------------------
--[[ Save/Load ]]
--------------------------------------------------------------------------

if _ismastersim then function self:OnSave()
    return
    {
        daylight = _daylight or nil,
        season = _season,
        seasontemperature = _seasontemperature,
        phasetemperature = _phasetemperature,
        hurricanetemperature = _hurricanetemperature,
        noisetime = _noisetime:value(),
    }
end end

if _ismastersim then function self:OnLoad(data)
    _daylight = data.daylight == true
    _season = data.season or "autumn"
    _seasontemperature = data.seasontemperature or CalculateSeasonTemperature(_season, .5)
    _phasetemperature = data.phasetemperature or CalculatePhaseTemperature(_daylight and "day" or "dusk", 0)
    _hurricanetemperature = data.hurricanetemperature or CalculateHurricaneTemperatureTemperature(0, 0)
    _noisetime:set(data.noisetime or 0)

    PushTemperature()
end end

--------------------------------------------------------------------------
--[[ Debug ]]
--------------------------------------------------------------------------

function self:GetDebugString()
    local temperature = CalculateTemperature()
    return string.format("%2.2fC mult: %.2f locus %.1f", temperature, _globaltemperaturemult, _globaltemperaturelocus)
end

--------------------------------------------------------------------------
--[[ End ]]
--------------------------------------------------------------------------

end)
%%+%%scripts/map/rooms/ia/terrain_beach.lua%%-%%
AddRoom("BeachClear", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = 0,
      distributeprefabs =
      {
      },

      countprefabs = {
        beachresurrector = 1,
      }

    }
  })

AddRoom("BeachSand", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .25,
      distributeprefabs =
      {
        rock_limpet = .05,
        crabhole = .2,
        palmtree = .3,
        rocks = .03, --trying
        rock1 = .1, --trying
        --rock2 = .2,
        beehive = .01, --was .05, 
        --flower = .04, --trying
        grass = .2, --trying
        sapling = .2, --trying
        --fireflies = .02, --trying
        --spiderden = .03, --trying
        flint = .05,
        sanddune = .6,
        seashell_beached = .02,
        wildborehouse = .005,
        crate = .02,
      },

      countprefabs = {
        beachresurrector = 1,
        spoiled_fish = 0.5,
      }

    }
  })

AddRoom("BeachSandHome", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece"}, --, "Packim_Fishbone"
    contents =  {
      distributepercent = .3, --upped from .05
      distributeprefabs=
      {
        seashell_beached=.25,
        rock_limpet= .05, 
        crabhole = .1, --was 0.2
        palmtree = .3,
        rocks = .03, --trying
        rock1 = .05,
        rock_flintless = .1, --trying
        --beehive = .05, --trying
        --flower = .04, --trying
        grass = .5, --trying
        sapling = .2, --trying
        --fireflies = .02, --trying
        --spiderden = .03, --trying
        flint = .05,
        sanddune = .1, --was .6,
        crate = .025,
      },

      countprefabs =
      {
        flint = 1,
        sapling = 1,
      }

    }
  })

AddRoom("BeachSandHome_Spawn", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece"}, --, "Packim_Fishbone"
    contents =  {
      distributepercent = .3, --upped from .05
      distributeprefabs=
      {
        seashell_beached=.25,
        rock_limpet= .05, 
        crabhole = .1, --was 0.2
        palmtree = .3,
        rocks = .03, --trying
        rock1 = .05,
        rock_flintless = .1, --trying
        --beehive = .05, --trying
        --flower = .04, --trying
        grass = .5, --trying
        sapling = .2, --trying
        --fireflies = .02, --trying
        --spiderden = .03, --trying
        flint = .05,
        sanddune = .1, --was .6,
        crate = .025,
      },

      countprefabs =
      {
		spawnpoint = 1,
        flint = 1,
        sapling = 1,
      }

    }
  })

AddRoom("BeachUnkept", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece"}, --, "Packim_Fishbone"
    contents =  {
      distributepercent = .3, --lowered from .3
      distributeprefabs=
      {
        seashell_beached=0.125, 
        grass = .3, --down from 3
        sapling = .1, --lowered from 15
        --flower = 0.05,
        rock_limpet =.02,
        crabhole = .015, --was .03
        palmtree = .1,
        rocks = .003,
        beehive = .003,
        flint = .02,
        sanddune = .05,
        --rock2 = .01,
        dubloon = .001,
        wildborehouse = .005,
      },

      countprefabs = {

        beachresurrector = 1,
        spoiled_fish = 0.3,
      }

    }
  })

AddRoom("BeachUnkeptDubloon", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .3, 
      distributeprefabs=
      {
        seashell_beached=0.025, 
        grass = .1, --was .3
        sapling = .05, --was .15
        --flower = 0.05,
        rock_limpet =.02,
        --crabhole = .015, --was .03
        palmtree = .1,
        rocks = .003,
        --beehive = .003,
        flint = .01, --was .02,
        sanddune = .05,
        --rock2 = .01,
        goldnugget = .007,
        dubloon = .01, -- this should be relatively high on this island
        skeleton = .025,
        wildborehouse = .005,
      },

      countprefabs = {

        beachresurrector = 1,
      }

    }
  })

AddRoom("BeachGravel", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        rock_limpet = 0.01,
        rocks = 0.1,
        flint = 0.02,
        rock1 = 0.05,
        --rock2 = 0.05,
        rock_flintless = 0.05,
        grass = .05,
        --flower = 0.05, --removed as it's used on NoFlower island
        sanddune = .05,
        seashell_beached = .025, 
        wildborehouse = .005,
      },

      countprefabs = {

        beachresurrector = 1,
      }

    }
  })

--[[AddRoom("BeachSinglePalmTree", {
					colour={r=.66,g=.66,b=.66,a=.50},
					value = GROUND.BEACH,
					tags = {"ExitPiece", "Packim_Fishbone"},
					contents =  {
									countprefabs = {
										palmtree = 1, --one palm tree
										seashell_beached = 1, --one seashell
										--coconut = 1, --one coconut
										mandrake =0.05,
										beachresurrector = 1,
										sanddune = .05,
									}
					            }
					})
]]
AddRoom("BeachSinglePalmTreeHome", {
    colour={r=.66,g=.66,b=.66,a=.50},
    value = GROUND.BEACH,
    tags = {"ExitPiece"}, --, "Packim_Fishbone"
    contents =  {
      countprefabs = {
        palmtree = 1, --one palm tree
        seashell_beached = 1, --one seashell
        --coconut = 1, --one coconut
        -- boat_raft = 1, 
        --mandrake =0.05,
        beachresurrector = 1,
        sanddune = .05,
      }
    }
  })

AddRoom("DoydoyBeach", {
    colour={r=.66,g=.66,b=.66,a=.50},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        flower_evil = 0.5,
        fireflies = 1, -- results in an empty beach because these only show at night
        flower = .75,
        sanddune = .5,
      },
      countprefabs = {
        doydoy = 1,
        palmtree = 1, --one palm tree
        seashell_beached = 1, --one seashell
        --coconut = 1, --one coconut
        --mandrake =0.05,
        beachresurrector = 1,
        sanddune = .05,
      }
    }
  })

AddRoom("BeachWaspy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, -- just copied this whole thing from EvilFlowerPatch in terrain_grass
      distributeprefabs=
      {
        flower_evil =0.05,
        --fireflies = .1, -- was 1, now .1 (results in an empty beach because these only show at night)
        wasphive = .005,
        sanddune = .05,
        rock_limpet = 0.01,
        flint = .005,
        seashell_beached = .025, 
      },

      countprefabs = {

        beachresurrector = 1,
      }

    }
  })

AddRoom("BeachPalmForest", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        palmtree = .5,
        sanddune = .05,
        crabhole = .025,
        grass = .05,
        rock_limpet = .015,
        flint = .005,
        seashell_beached = .025, 
        wildborehouse = .005,
      },
    }
  })

AddRoom("BeachPiggy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .2, -- just copied this whole thing from EvilFlowerPatch in terrain_grass
      distributeprefabs=
      {
        sapling = 0.25,
        grass = .5,
        palmtree = .1,
        wildborehouse = .05,
        rock_limpet = 0.1,
        sanddune = .3,
        seashell_beached = .125, 
      },

      countprefabs = {

        beachresurrector = 1,
      },

    }
  })

AddRoom("BeesBeach", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .3, --Up from .025
      distributeprefabs=
      {
        seashell_beached=0.025,
        rock_limpet= .05, --reducing from .2 (everything is so low here)
        crabhole = .2,
        palmtree = .3,
        rocks = .03, --trying
        rock1 = .1, --trying
        beehive = .1, --was .5
        wasphive = .05,
        --flower = .04, --trying
        grass = .4, --trying
        sapling = .4, --trying
        --fireflies = .02, --trying
        --spiderden = .03, --trying
        flint = .05,
        sanddune = .4, --was .04
      },

      countprefabs = {
        beachresurrector = 1,
      }

    }
  })

AddRoom("BeachCrabTown", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .25,
      distributeprefabs=
      {
        rock_limpet = 0.005,
        crabhole = 1,
        sapling = .2,
        palmtree = .75,
        grass = .5,
        --flower=.1,
        seashell_beached=.01,
        rocks=.1,
        rock1=.2,
        --fireflies=.1,
        --spiderden=.001,
        flint=.01,
        sanddune=.3,
      },

    }
  })

AddRoom("BeachDunes", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, 
      distributeprefabs=
      {
        sanddune = 1.5,
        grass = 1,
        seashell_beached = .5,
        sapling = 1,
        rock1 = .5,
        rock_limpet = 0.1,
        wildborehouse = .05,
      },

    }
  })

AddRoom("BeachGrassy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .2, --was .1
      distributeprefabs=
      {
        grass = 1.5,
        rock_limpet = .25,
        beehive = .1,
        sanddune = 1, 
        rock1 = .5,
        crabhole = .5,
        flint = .05,
        seashell_beached = .25, 
      },

    }
  })

AddRoom("BeachSappy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, 
      distributeprefabs=
      {
        sapling = 1,
        crabhole = .5,
        palmtree = 1,
        rock_limpet = 0.1,
        flint = .05,
        seashell_beached = .25, 
      },

    }
  })

AddRoom("BeachRocky", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, 
      distributeprefabs=
      {
        rock1 = 1,
        --rock2 = 1, removing to take gold vein rocks out of all beaches
        rocks = 1,
        rock_flintless = 1,
        grass = 2, 
        crabhole = 2,
        rock_limpet = 0.01,
        flint = .05,
        seashell_beached = .25, 
        wildborehouse = .05,
      },

    }
  })

AddRoom("BeachLimpety", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, 
      distributeprefabs=
      {
        rock_limpet = 1,
        rock1 = 1,
        grass = 1,
        seashell = 1,
        sapling = .5,
        flint = .05,
        seashell_beached = .25, 
        wildborehouse = .05,
      },

      countprefabs = {

        beachresurrector = 1,
        spoiled_fish = 0.8,
      }

    }
  })

AddRoom("BeachSpider", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        rock_limpet = 0.01,
        spiderden = 1,
        palmtree = 1,
        grass = 1,
        rocks = 0.5,
        sapling = 0.2,
        flint = .05,
        seashell_beached = .25, 
        wildborehouse = .025,
      },

    }
  })

AddRoom("BeachNoFlowers", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, --Lowered a bit
      distributeprefabs=
      {
        seashell_beached=0.0025,
        rock_limpet= .005, --reducing from .03 (everything is so low here)
        crabhole = .002,
        palmtree = .3,
        rocks = .003, --trying
        beehive = .005, --trying
        grass = .3, --trying
        sapling = .2, --trying
        --fireflies = .002, --trying
        flint = .05,
        sanddune =.055,
      },

    }
  })

AddRoom("BeachFlowers", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .5, --was .1
      distributeprefabs =
      {
        beehive = .1, --was .5
        flower = 2, --was 1
        palmtree = .3,
        rock1 = .1,
        grass = .2,
        sapling = .1,
        seashell_beached = .025, 
        rock_limpet = 0.01,
        flint = .05,
      },

    }
  })

AddRoom("BeachNoLimpets", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, --Lowered a bit
      distributeprefabs=
      {
        seashell_beached = 0.0025,
        crabhole = .002,
        palmtree = .3,
        rocks = .003, --trying
        beehive = .0025, --trying
        --flower = 0.04, --trying
        grass = .3, --trying
        sapling = .2, --trying
        --fireflies = .002, --trying
        flint = .05,
        sanddune =.055,
        wildborehouse = .05,
      },

    }
  })

AddRoom("BeachNoCrabbits", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, --Lowered a bit
      distributeprefabs=
      {
        seashell_beached=0.0025,
        rock_limpet = 0.01,
        palmtree = .3,
        rocks = .003, --trying
        beehive = .005, --trying
        --flower = 0.04, --trying
        grass = .3, --trying
        sapling = .2, --trying
        --fireflies = .002, --trying
        flint = .05,
        sanddune =.055,
      },

    }
  })

AddRoom("BeachPalmCasino", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .1, --Lowered a bit
      distributeprefabs=
      {
        seashell_beached=0.025,
        rock_limpet = 0.01,
        palmtree = .3,
        rocks = .003, --trying
        beehive = .005, --trying
        --flower = 0.04, --trying
        grass = .3, --trying
        sapling = .2, --trying
        --fireflies = .002, --trying
        flint = .05,
        sanddune =.055,
      },

    }
  })

AddRoom("BeachShells", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .25, 
      distributeprefabs =
      {
        seashell_beached = 1.25, 
        rock_limpet = .05, 
        crabhole = .2,
        palmtree = .3,
        rocks = .03,
        rock1 = .025, --was .1,
        --rock2 = .05, --was .2,
        beehive = .02,
        --flower = .04,
        grass = .3, --was .2,
        sapling = .2,
        --fireflies = .02,
        --spiderden = .03,
        flint = .25,
        sanddune = .1, --was .6,
        wildborehouse = .05,
      },

      countprefabs = {
        beachresurrector = 1,
      }

    }
  })


AddRoom("BeachSkull", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {"ExitPiece", "Packim_Fishbone"},
    contents =  {
      distributepercent = .25,
      distributeprefabs =
      {
        rock_limpet = .05,
        crabhole = .2,
        palmtree = .3,
        rocks = .03,
        rock1 = .1,
        beehive = .01,
        grass = .2,
        sapling = .2,
        flint = .05,
        sanddune = .6,
        seashell_beached = .02,
        wildborehouse = .005,
        crate = .02,
      },

      treasures =
      {
        {name="DeadmansTreasure"}
      },

      --[[treasure_data =
									{
										[3600] = {name="DeadmansTreasure", stage=1}
									}]]

    }
  })

-- This one is meant for non-tropical area
AddRoom("BeachGeneric", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.BEACH,
    tags = {},
    contents =  {
      distributepercent = .2, 
      distributeprefabs =
      {
        seashell_beached = 1,
        --fireflies = .003,
        flint = .02,
        sanddune = .02,
        twigs = .02,
        log = .01,
        dug_sapling = .004,
        dug_grass = .003,
      },
    }
  })
%%+%%scripts/map/rooms/ia/terrain_jungle.lua%%-%%
--[[AddRoom("SampleRoom", { --Name to use in the 'room_choices' list
					--Used for debug stuff
					colour={r=.5,g=0.6,b=.080,a=.10},

					--Tile type to use. GROUND (tile types) are in constants.lua
					--Shipwrecked types: GROUND.JUNGLE, GROUND.BEACH, GROUND.SWAMP,
					--GROUND.OCEAN_SHALLOW, GROUND.OCEAN_MEDIUM, GROUND.OCEAN_DEEP
					value = GROUND.JUNGLE,

					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},

					--Room (biome) contents
					contents =  {
									--How densely items are placed on the biome 0 (few prefabs) to 1 (most prefabs)
					                distributepercent = 0.3,

					                --The prefabs to place on the biome. Higher number means more of that prefab.
					                --A precentage is determined by adding the values here.
					                --Look at the 'common_prefabs' table in prefabs/world.lua a lot are there
					                --prefabs/shipwrecked.lua too
					                distributeprefabs =
					                {
                                        fireflies = 0.2,
					                    palmtree = 1,
					                    jungletree = 6,
					                    rock1 = 0.05,
					                    flint = 0.05,
					                    grass = .07, -- was .05
					                    sapling = .8,
					                    berrybush2 = .05, -- was.03
					                    berrybush2_snake = 0.01,
					                    red_mushroom = .03,
					                    green_mushroom = .02,
					                    blue_mushroom = .02,
					                    flower = 0.75,
					                    primeapebarrel = .05,
					                },
					            }
					})]]

AddRoom("JungleClearing", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts={
        -- ["MushroomRingLarge"]=function()  
        -- if math.random(0,1000) > 985 then 
        -- return 1 
        -- end
        -- return 0 
        -- end
      },

      distributepercent = .2, --was .1
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = .05,
        jungletree = 1,
        rock1 = 0.03,
        rock1 = 0.03,
        flint = 0.03,
        grass = .03, --was .05
        --sapling = .8,
        --berrybush=.03,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = .5,
        wasphive = 0.125, --was 0.5
        spiderden = 0.2,
        --wildborehouse = 0.25,
      },
    }
  })

AddRoom("Jungle", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.35, --was 0.2
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.5, --lowered this from 6
        jungletree = 4,
        rock1 = 0.05, --was .01
        rock2 = 0.1, --was .05
        flint = 0.1, --was 0.03,
        --grass = .01, --was .05
        --sapling = .8,
        berrybush2 = .09, -- was .0003
        berrybush2_snake = 0.01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 1, --was 0.75,
        bambootree = 1,
        bush_vine = .2, -- was 1
        snakeden = 0.01, -- was 0.1
        primeapebarrel = .1, --was .05,
        spiderden = .05, --was .01,
        --wildborehouse = 0.25,
      },
    }
  })

AddRoom("JungleSparse", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.25,
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = .05,
        jungletree = 2, --.6,
        rock1 = 0.05,
        rock2 = 0.05,
        rocks = .3,
        flint = .1, --dropped
        --sapling = .8,
        berrybush2 = .05, --was .03
        berrybush2_snake = 0.01,
        --grass = 1,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = .5, --was 0.75
        bambootree = 1,
        bush_vine = .2, -- was 1
        snakeden = 0.01, -- was 0.1
        spiderden = 0.05,
        --wildborehouse = 0.25,
      },
    }
  })

AddRoom("JungleSparseHome", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "RoadPoison"}, --, "Packim_Fishbone"
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.3, -- upped from 0.15
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = .05,
        jungletree = .6,
        rock_flintless = 0.05,
        -- rock2 = 0.05, --gold rock
        flint = .1, --dropped
        --grass = .6, --raised from 05 
        --sapling = .8,
        berrybush2 = .05, --was .03
        berrybush2_snake = 0.01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 2, --was 0.75,
        bambootree = 1,
        bush_vine = 1,
        snakeden = 0.1,
        spiderden = .01,
        --wildborehouse = 0.25,
      },
    }
  })

AddRoom("JungleDense", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.4,
      distributeprefabs =
      {
        fireflies = 0.02, --was 0.2,
        --palmtree = 0.05,
        jungletree = 3, --was 4,
        rock1 = 0.05,
        rock2 = 0.1, --was .05
        --grass = 1, --was .05
        --sapling = .8,
        berrybush2 = .05,
        berrybush2_snake = 0.01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        flint = 0.1,
        spiderden = .1, --was .01
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.03, --was 0.015,
        primeapebarrel = .05,
      },
    }
  })

AddRoom("JungleDenseHome", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "RoadPoison"}, --, "Packim_Fishbone"
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.3, --lowered from 0.4
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 4,
        rock1 = 0.05,
        --rock2 = 0.05, --gold rock
        --grass = 1, --was .05
        --sapling = .8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = 0.03, --was 0.01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        flint = 0.1,
        spiderden = .01,
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.03, --was 0.015,
        --primeapebarrel=.05,
      },
    }
  })

AddRoom("JungleDenseMed", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.4, ---was 0.75
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --lowered from 6
        rock1 = 0.05,
        rock2 = 0.05,
        --grass = .02, --was .05
        --sapling = .8,
        berrybush2 = .06, --was .03,
        berrybush2_snake = .02, --was .01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        spiderden = .05, --was .01,
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.03, --was 0.015,
      },
    }
  })

AddRoom("JungleDenseBerries", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
        --["BerryBushBunch"]=1
      },
      distributepercent = 0.35,
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 4, --was 6
        rock1 = 0.05,
        rock2 = 0.05,
        --grass = .02, --was .05
        --sapling = .8,
        berrybush2 = .6, --was .03
        berrybush2_snake = .03, --was .01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        spiderden =.05, --was .01
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.15, --was 0.015,
      },
    }
  })

AddRoom("JungleDenseMedHome", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "RoadPoison"}, --, "Packim_Fishbone"
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.5, --was 0.75
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --was 6
        rock_flintless = 0.05,
        --rock2 = 0.05, --gold rock
        --grass = .8, --was .05
        --sapling = .8,
        berrybush2 = .06, --was .03,
        berrybush2_snake = .02, --was .01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1, -- was 1
        spiderden = .05, --was .01
        bush_vine = 0.8, -- was 1
        snakeden = 0.1,
        --wildborehouse = 0.015,
      },
    }
  })

AddRoom("JungleDenseVery", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .75, -- lowered from 1.0
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 1, --lowered from 6
        rock2 = 0.05,
        flint = 0.05,
        --grass = .02, --was .05
        --sapling = .8,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        spiderden = .05,
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.015,
        primeapebarrel = .125, --was .05,
      },
    }
  })

AddRoom("JunglePigs", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.3,
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 3,
        rock1 = 0.05,
        flint = 0.05,
        --grass = .025,
        --sapling = .8,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 0.75,
        bambootree = 1,
        spiderden = .05,
        bush_vine = 1,
        snakeden = 0.1,
        wildborehouse = 0.9, --was .015 and also was 2.15??
        --primeapebarrel=.05,
      },
    }
  })

AddRoom("JunglePigGuards", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      -- countstaticlayouts={["pigguard_berries_easy"]=1}, --adds 1 per room
      distributepercent = 0.3,
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 3,
        rock1 = 0.05,
        flint = 0.05,
        --grass = .025,
        --sapling = .8,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 0.75,
        bambootree = 1,
        spiderden = .05,
        bush_vine = 1,
        snakeden = 0.1,
        --primeapebarrel=.05,
      },
    }
  })

--[[AddRoom("JungleFroggy", {
					colour={r=.5,g=0.6,b=.080,a=.10},
					value = GROUND.JUNGLE,
					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
					contents =  {
					                distributepercent = 0.3,
					                distributeprefabs =
					                {
                                        fireflies = 0.2,
             		                    --palmtree = 0.05,
					                    jungletree = 3,
					                    rock1 = 0.05,
					                    flint = 0.05,
					                    --grass = .025,
					                    --sapling = .8,
					                    berrybush2 = .05, --was .01,
					                    berrybush2_snake = .05, --was .01,
					                    red_mushroom = .06,
					                    green_mushroom = .04,
					                    blue_mushroom = .04,
					                    flower = 0.75,
					                    bambootree = 1,
					                    spiderden = .01, --was .001
					                    bush_vine = 1,
					                    snakeden = 0.1,
					                    pond = 1, --frog pond
					                },
					            }
					})
]]
AddRoom("JungleBees", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.3,
      distributeprefabs =
      {
        beehive = 0.5, 
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 4,
        rock1 = 0.05,
        flint = 0.05,
        --grass = .025,
        --sapling = .8,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 0.75,
        bambootree = 1,
        spiderden = .01, --was .001
        bush_vine = 1,
        snakeden = 0.1,
        -- pond = 1, --frog pond
      },
    }
  })

AddRoom("JungleFlower", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --was 3
        rock1 = 0.05,
        --flint=0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 10,
        bambootree = 0.5,
        spiderden = .05, --was .001
        bush_vine = 1,
        snakeden = 0.1,
        --pond = 1, --frog pond
      },
      countprefabs =
      {
        butterfly_areaspawner = 6,
      },
    }
  })

AddRoom("JungleSpidersDense", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.5, --lowered from .5
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 4,
        rock1 = 0.05,
        rock2 = 0.05,
        --grass = 1, --was .05
        --sapling = .8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = .05, --was 0.01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 0.75,
        bambootree = 1,
        flint = 0.1,
        spiderden = .5,
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = 0.015,
        primeapebarrel = .15, --was .05,
      },
    }
  })

AddRoom("JungleSpiderCity", {
    colour={r=.30,g=.20,b=.50,a=.50},
    value = GROUND.JUNGLE,
    tags = {"RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      countprefabs = {
        goldnugget = function() return 3 + math.random(3) end,
      },
      distributepercent = 0.3,
      distributeprefabs = {
        jungletree = 3,
        spiderden = 0.3,
      },
      prefabdata = {
        spiderden = function() if math.random() < 0.2 then
          return { growable={stage=3}}
        else
          return { growable={stage=2}}
        end
      end,
    },
  }
})

-- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --  -- THIS IS DAN --
AddRoom("JungleBamboozled", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .75, --was .5, 
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = .09, 
        rock1 = 0.05,
        -- flint=0.05,
        --grass = .025,
        --sapling = .04,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 0.1,
        bambootree = 1, --was .5,
        spiderden = .05, --was .001,
        bush_vine = .04,
        snakeden = 0.1,

      },


    }
  })

AddRoom("JungleMonkeyHell", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .3, --was .5
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.3,
        jungletree = 2, --was .4, 
        rock1 = 0.125, --was 0.5,
        rock2 = 0.125, --was 0.5,
        primeapebarrel = .2, --was .8,
        skeleton = .1,
        flint = 0.5,
        --grass = .75,
        --sapling = .4,
        berrybush2 = .1,
        berrybush2_snake = .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .01,
        bambootree = 0.5,
        spiderden =.01,
        bush_vine = .04,
        snakeden = 0.01,

      },
    }
  })

AddRoom("JungleCritterCrunch", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .25,
      distributeprefabs =
      {
        fireflies = 3,
        --palmtree = 0.05,
        jungletree = 3, --was 3
        rock1 = 0.05,
        --flint=0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 2,
        bambootree = 1,
        spiderden = 1,
        bush_vine = 0.2,
        snakeden = 0.1,
        beehive = 1.5, --was 3,
        wasphive = 2,

      },
    }
  })

AddRoom("JungleDenseCritterCrunch", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.5, --was 0.75
      distributeprefabs =
      {
        fireflies = 2,
        --palmtree = 0.05,
        jungletree = 6,
        rock_flintless = 0.05,
        --rock2 = 0.05, --gold rock
        --grass = .05,
        --sapling = .8,
        berrybush2 = .75, --was 0.3
        berrybush2_snake = .02, --was .01,
        red_mushroom = .03,
        green_mushroom = .02,
        blue_mushroom = .02,
        flower = 1.5,
        bambootree = 1, --was 1
        spiderden = .05, --was .5,
        bush_vine = 0.8, --was 1
        snakeden = 0.1,
        --wildborehouse = 0.03, --was 0.015,
        beehive = .01, --was 2,
      },
    }
  })


AddRoom("JungleFrogSanctuary", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.35,
      distributeprefabs =
      {
        fireflies = 1,
        --palmtree = 0.5,
        jungletree = 1, --was 3
        rock1 = 0.05,
        --flint=0.05,
        --grass = .3,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 1,
        bambootree = 0.5,
        spiderden = .05, --was .001
        bush_vine = 0.6,
        snakeden = 0.1,
        pond = 4, --was 6


      },
    }
  })

AddRoom("JungleShroomin", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = .5,
        jungletree = 3,
        rock1 = 0.05,
        --flint=0.05,
        --grass = 1, --was .4,
        --sapling = .3,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = 3,
        green_mushroom = 3,
        blue_mushroom = 2,
        flower = 0.7,
        bambootree = 0.5,
        spiderden =.05, --was .001
        bush_vine = .5,
        snakeden = 0.1,

      },
    }
  })

AddRoom("JungleRockyDrop", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .35,
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 6,
        rock1 = 1, --was 3
        rock2 = .5, --was 2
        rock_flintless = 2,
        rocks = 3, 
        --flint = 0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .9,
        bambootree = 0.5,
        spiderden = .05, --was .001
        bush_vine = 1,
        snakeden = 0.1,
      },
    }
  })

AddRoom("JungleEyeplant", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --was 3
        --rock1 = 0.05,
        --flint = 0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = 1,
        bambootree = 0.5,
        spiderden = .25, --was .001
        bush_vine = 1,
        snakeden = 0.1,
        --wildborehouse = .5, --just added
        eyeplant = 4,
      },

      countprefabs =
      {
        lureplant = 2,
      },
    }
  })

AddRoom("JungleGrassy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --was 3
        rock1 = 0.05,
        --flint=0.05,
        --grass = 5,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .2,
        bambootree = 0.5,
        spiderden = .05, --was .001
        bush_vine = 1,
        snakeden = 0.1,
      },
    }
  })

AddRoom("JungleSappy", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 1.5, --was 3
        rock1 = 0.05,
        --flint = 0.05,
        --grass = .025,
        sapling = 6,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .3,
        bambootree = 0.5,
        spiderden = .001,
        bush_vine = 0.3,
        snakeden = 0.1,
      },
    }
  })

AddRoom("JungleEvilFlowers", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 2, --was 3
        rock1 = 0.05,
        --flint = 0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .9,
        bambootree = 0.5,
        spiderden = .05, --was .001
        bush_vine = 1,
        snakeden = 0.1,
        flower_evil = 10,
        wasphive = 0.25, --just added
      },

    }
  })

AddRoom("JungleParrotSanctuary", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.9,
      distributeprefabs =
      {
        --palmtree = 0.05,
        jungletree = .5,
        rock1 = 0.5,
        rock2 = 0.5,
        rocks = 0.4,
        --grass = 0.5, --was .05
        --sapling  = 8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = .05, --was .01,
        red_mushroom = 0.05,
        green_mushroom = 0.03,
        blue_mushroom = 0.02,
        flower = 0.2,
        bambootree = 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.05, --was 0.005,
        primeapebarrel = 0.05,
        fireflies = 0.02,
      },

    }
  })

--[[AddRoom("JungleNoGrass", {
					colour={r=.5,g=0.6,b=.080,a=.10},
					value = GROUND.JUNGLE,
					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
					contents =  {
					                distributepercent = 0.2,
					                distributeprefabs =
					                {
         			                    --palmtree = 0.05,
					                    jungletree = .5,
					                    rock1 = 0.5,
 				                        rock2 = 0.5,
 				                        rocks = 0.4,
					                    --sapling = .8,
					                    berrybush2 = .1, --was .05,
					                    berrybush2_snake = .05, --was .01,
					                    red_mushroom = 0.05,
					                    green_mushroom = 0.03,
					                    blue_mushroom = 0.02,
					                    flower = 0.2,
					                    bambootree = 0.5,
					                    flint = 0.001,
					                    spiderden = 0.5,
					                    bush_vine = 0.9,
					                    snakeden = 0.1,
					                    --wildborehouse = 0.025, --was 0.005,
					                    primeapebarrel = .15, --was .05,
					                    pond = 0.05,
					                    fireflies = 0.02,
					                },
					                
					            }
					})  ]]

AddRoom("JungleNoBerry", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.3,
      distributeprefabs =
      {
        --palmtree = 0.05,
        jungletree = 5, --was .5,
        rock1 = 0.5,
        rock2 = 0.5,
        rocks = 0.4,
        --grass = 0.6, --was .05
        --sapling = .8,
        red_mushroom = 0.05,
        green_mushroom = 0.03,
        blue_mushroom = 0.02,
        flower = 0.2,
        bambootree = 3, --was 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.05, --was 0.005,
        primeapebarrel = 0.05,
        fireflies = 0.02,
      },

    }
  })

AddRoom("JungleNoRock", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.2,
      distributeprefabs =
      {
        --palmtree = 0.05,
        jungletree = 5,
        --grass = 0.6, --was .05
        --sapling = .8,
        berrybush2 = .05,
        berrybush2_snake = 0.01,
        red_mushroom = 0.05,
        green_mushroom = 0.03,
        blue_mushroom = 0.02,
        flower = 0.2,
        bambootree = 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.005,
        primeapebarrel = .25, --was .05,
        fireflies = 0.02,
      },

    }
  })

AddRoom("JungleNoMushroom", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {

      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = 0.4, --was 0.2
      distributeprefabs =
      {
        --palmtree = 0.05,
        jungletree = 5,
        rock1 = 0.05,
        rock2 = 0.05,
        rocks = 0.04,
        --grass = 0.6, --was .05
        --sapling = .8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = .05, --was .01,
        flower = 0.2,
        bambootree = 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.05, --was 0.005,
        primeapebarrel = .15, --was .05,
        fireflies = 0.02,
      },

    }
  })

AddRoom("JungleNoFlowers", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {

      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },

      distributepercent = 0.2,
      distributeprefabs =
      {
        --palmtree = 0.05,
        jungletree = 5,
        rock1 = 0.05,
        rock2 = 0.05,
        rocks = 0.04,
        --grass = 0.6, --was .05
        --sapling = .8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = .05, --was .01,
        red_mushroom = 0.05,
        green_mushroom = 0.03,
        blue_mushroom = 0.02,
        bambootree = 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.25,
        primeapebarrel = .15, --was .05,
        --pond = 0.05,
        fireflies = 0.02,
      },

    }
  })



AddRoom("JungleMorePalms", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5,
      distributeprefabs =
      {
        --palmtree = 3,
        jungletree = .3,
        rock1 = 0.05,
        rock2 = 0.05,
        rocks = 0.04,
        --grass = 0.6, --was .05
        --sapling = .8,
        berrybush2 = .1, --was .05,
        berrybush2_snake = .05, --was .01,
        red_mushroom = 0.05,
        green_mushroom = 0.03,
        blue_mushroom = 0.02,
        flower = 0.6,
        bambootree = 0.5,
        flint = 0.001,
        spiderden = 0.5,
        bush_vine = 0.9,
        snakeden = 0.1,
        --wildborehouse = 0.005,
        primeapebarrel = .15, --was .05,
        fireflies = 0.02,
      },

    }
  })

AddRoom("JungleSkeleton", {
    colour={r=.5,g=0.6,b=.080,a=.10},
    value = GROUND.JUNGLE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts=
      {
        ["LivingJungleTree"]= function() return (math.random() > TUNING.LIVINGJUNGLETREE_CHANCE and 1) or 0 end	
      },
      distributepercent = .5, --was 0.35
      distributeprefabs =
      {
        fireflies = 0.2,
        --palmtree = 0.05,
        jungletree = 1.5, --was 3
        rock1 = 0.05,
        --flint = 0.05,
        --grass = .025,
        --sapling = .4,
        berrybush2 = .05, --was .01,
        berrybush2_snake = .05, --was .01,
        red_mushroom = .06,
        green_mushroom = .04,
        blue_mushroom = .04,
        flower = .9,
        bambootree = 0.5,
        spiderden =.05, --was .001
        bush_vine = 1,
        snakeden = 0.1,
        flower_evil = .001,
        skeleton = 1.25,
      },
    }
  })

AddRoom("SW_Graveyard", {
    colour={r=.010,g=.010,b=.10,a=.50},
    value = GROUND.JUNGLE,
    tags = {"Town", "RoadPoison"},
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        grass = .1, --down from 3
        sapling = .1, --lowered from 15
        flower_evil = 0.05,
        rocks = .03,
        beehive = .0003,
        flint = .02,
      },

      countprefabs= {
        jungletree = 3,
        goldnugget = function() return math.random(5) end,
        gravestone = function () return 4 + math.random(4) end,
        mound = function () return 4 + math.random(4) end
      }
    }
  })
%%+%%scripts/map/rooms/ia/terrain_magmafield.lua%%-%%
AddRoom("Magma", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .25,
      distributeprefabs=
      {
        magmarock = 2, --nitre
        magmarock_gold = 1,
        rock1 = .75,
        rock2 = .25, --gold 
        rocks = 1.5,
        flint= 1.5, -- lowered from 3
        -- rock_ice = 1,
        --tallbirdnest= --2, --.1,
        spiderden=.1,
        sapling = 1.5,
      },
    }
  })

AddRoom("MagmaHome", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        magmarock_gold = 2,
        magmarock = 2,
        rock1 = .5, --nitre
        --rock2 = 2, --gold
        rock_flintless = 2, 
        rocks = 1, --was 0.5
        flint = 1, -- lowered from 3
        -- rock_ice = 1,
        --tallbirdnest= --2, --.1,
        spiderden=.1,
        sapling = 1.5,

      },

      countprefabs =
      {
        flint = 4
      }
    }
  })

AddRoom("MagmaHomeBoon", {  
    colour={r=.66,g=.66,b=.66,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        magmarock = 1,
        magmarock_gold = 1,
        --rock1 = 2, --nitre
        rock2 = 1, --gold
        rock_flintless = 2, 
        rocks = 0.8,
        flint = 1, -- lowered from 3
        -- rock_ice = 1,
        --tallbirdnest= --2, --.1,
        spiderden=.1,
        sapling = 1.5,
      },

      countprefabs =
      {
        flint = 4
      }
    }
  })

AddRoom("BG_Magma", {  
    colour={r=.66,g=.66,b=.66,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        magmarock = 1,
        magmarock_gold = 1,
        flint = 0.5,
        rock1 = 1,
        rock2 = 1,
        rocks = 1,
        tallbirdnest = 0.08,
        sapling = 1.5,
        spiderden = .1,
      },
    }
  })
-- No trees, lots of rocks, rare tallbird nest, very rare spiderden
-- MR - Pasted in these 2 from Rocky, there is also Chessrocoky in the original.
--[[AddRoom("MagmaFOREDITING", {
					colour={r=.55,g=.75,b=.75,a=.50},
					value = GROUND.DIRT,
					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
					contents =  {
					                distributepercent = .1,
					                distributeprefabs=
					                {
					                    rock1 = 2,
					                    rock2 = 2,
					                    flint=0.5, -- MR Added
					                    --tallbirdnest= --10,--.1,
					                    spiderden=.01,
					                    
					                },
					            }
					}) ]]

AddRoom("GenericMagmaNoThreat", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .25,
      distributeprefabs =
      {
        magmarock = 2,
        magmarock_gold = 1,
        rock1 = 0.5,
        rock2 = 0.3,
        --rock_ice = .75,
        rocks = 2,
        flint = 1.5,
        sapling = .05,
        blue_mushroom = .002,
        green_mushroom = .002,
        red_mushroom = .002,
        sapling = .5,
        spiderden=.1,
      },
    }
  })

AddRoom("MagmaVolcano", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        magmarock = 1,
        magmarock_gold = 1,
        rock1 = 2,
        rock2 = 2,
        rocks = 1,
        flint= 1,
        sapling = .5,
        spiderden=.1,
      },

      countprefabs =
      {
        volcano = 1
      }
    }
  })


AddRoom("MagmaSpiders", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        magmarock = 2,
        magmarock_gold = 1,
        rock1 = 2, --nitre
        rock2 = 2, --gold
        rock_flintless = 2, 
        rocks = 1,
        flint= 1, -- lowered from 3
        -- rock_ice = 1,
        tallbirdnest= .2, --.1,
        spiderden=1.5, --.5,
        sapling = .5,

      },
    }
  })

AddRoom("MagmaGold", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD, 
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = .3,
      distributeprefabs =
      {
        magmarock = 0.8,
        magmarock_gold = 1.2, --gold
        rock1 = 0.5,
        rock2 = 0.3,
        rock_flintless = .5,
        rocks = 1,
        flint = .5,
        goldnugget = .25,
        tallbirdnest= .2,
        sapling = .5,
        spiderden=.1,
      },
    }
  })

AddRoom("MagmaGoldBoon", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD, 
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = .25,
      distributeprefabs =
      {
        magmarock_gold = 1,
        rock1 = 0.5,
        rock2 = 0.3,
        rocks = 3,
        flint = 1,
        goldnugget = 1,
        tallbirdnest= .2,
        sapling = .5,
        spiderden=.1,
      },
    }
  })

AddRoom("MagmaTallBird", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD, 
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = .3,
      distributeprefabs =
      {
        magmarock = 1,
        magmarock_gold = 0.75,
        rock1 = 0.5,
        rock2 = 0.3,
        rocks = 1,
        rock_flintless = 1,
        tallbirdnest = .25,
        sapling = .5,
        spiderden=.1,
      },
    }
  })

AddRoom("MagmaForest", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.MAGMAFIELD, 
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = .4,
      distributeprefabs =
      {
        magmarock = 1,
        magmarock_gold = 0.25,
        rock1 = 0.5,
        rock2 = 0.3,
        rocks = 2,
        rock_flintless = 1,
        jungletree = 5,
        sapling = 2,
        spiderden = .1,
      },

      --[[countprefabs =
					                {
					                	jungletree = math.random(8, 16),
					                },]]
      prefabdata =
      {
        jungletree = {burnt=true},
      }
    }
  })%%+%%scripts/map/rooms/ia/terrain_mangrove.lua%%-%%
AddRoom("Mangrove", {
    colour={r=0.0,g=0.0,b=.280,a=.50},
    value = GROUND.MANGROVE,
    type = "water",
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = 0.3,
      distributeprefabs=
      {
        mangrovetree = 2,
        fishinhole = 1,
        grass_water = 3,
        --     	ox = 0.1,
      },
    }
  })


AddRoom("BG_Mangrove", {
    colour={r=.8,g=.8,b=.2,a=.50},
    value = GROUND.MANGROVE,
    type = "water",
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .3,--.1,
      distributeprefabs=
      {
        ox = .1, 
        grass_water = 9,
        mangrovetree = 3,
        fishinhole = 0.5,
        -- reeds = 2,
      },
    }
  })
-- Very few Trees, very few rocks, rabbit holes, some beefalow, some grass

-- Rabbit holes, Beefalow hurds if bigger
AddRoom("BareMangrove", {					colour={r=.5,g=.5,b=.45,a=.50},
    value = GROUND.MANGROVE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = .3,--.1,
      distributeprefabs=
      {
        grass_water = .8,
        mangrovetree = 0.25,
        ox = 0.1, --was .2
        fishinhole = 0.01,
        -- reeds = .1,
      },
    }
  })

AddRoom("NoOxMangrove", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MANGROVE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        grass_water = .4,
        fishinhole = 0.05,
        mangrovetree = 0.3,
      },
    }
  })

AddRoom("MangroveOxBoon", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MANGROVE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = .3, --was .1,
      distributeprefabs=
      {
        mangrovetree = 2,
        fishinhole = 1,
        grass_water = 3,
        ox = .5,
      },
    }
  })

AddRoom("MangroveWetlands", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MANGROVE,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = .2,
      distributeprefabs=
      {
        mangrovetree = 2,
        fishinhole = 2,
        grass_water = 3,
        ox = 0.75, 
        -- reeds = .1,
      },
    }
  })%%+%%scripts/map/rooms/ia/terrain_meadow.lua%%-%%
local meadow_fairy_rings =
{
  -- ["MushroomRingLarge"] = function() if math.random(1, 1000) > 985 then return 1 end return 0 end,
  -- ["MushroomRingMedium"] = function() if math.random(1, 1000) > 985 then return 1 end return 0 end,
  -- ["MushroomRingSmall"] = function() if math.random(1, 1000) > 985 then return 1 end return 0 end
}

AddRoom("NoOxMeadow", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts = meadow_fairy_rings,
      distributepercent = .4,--.1, --lowered from .2
      distributeprefabs=
      {
        flint = 0.01,
        grass = .4,
        -- ox = 0.05,
        sweet_potato_planted = 0.05,
        beehive = 0.003,
        rocks = 0.003,
        rock_flintless = 0.01, 
        flower = .25,
      },
    }
  })

AddRoom("MeadowOxBoon", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts = meadow_fairy_rings,
      distributepercent = .4, --was .1,
      distributeprefabs=
      {
        ox = .5, --was 1,
        grass = 1,
        flower = .5,
        beehive = 0.1,
      },
    }
  })

AddRoom("MeadowFlowery", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts = meadow_fairy_rings,
      distributepercent = .5,--.1, --lowered from .2
      distributeprefabs=
      {
        flower = .5,
        beehive = .05,  --was .4
        grass = .4,
        rocks = .05,
        mandrake = 0.005, 
      },
    }
  })

AddRoom("MeadowBees", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts = meadow_fairy_rings,
      distributepercent = .4,--.1, --lowered from .2
      distributeprefabs=
      {
        flint = 0.05, --was .01
        grass = 3, --was .4,
        --ox = 3,
        sweet_potato_planted = 0.1, --was .05,
        rock_flintless = 0.01,
        flower = 0.15,
        beehive = 0.5, -- lowered from 1
      },
    }
  })

AddRoom("MeadowCarroty", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts = meadow_fairy_rings,
      distributepercent = .35, --was .1
      distributeprefabs=
      { 
        sweet_potato_planted = 1, 
        grass = 1.5,
        rocks = .2,
        flower = .5,
      },
    }
  })

--[[AddRoom("MeadowWetlands", {
					colour={r=.8,g=.4,b=.4,a=.50},
					value = GROUND.MEADOW,
					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
					contents =  {
					                distributepercent = .2,
					                distributeprefabs=
					                {
					                    --pond = 1,
					                    pond_mos = .8,
					                    grass = .5,
					                    flower = .3,
					                    sapling = .2,
					                    sweet_potato_planted = .1,  
					                },
					            }
					})
]]
AddRoom("MeadowSappy", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        grass = 3,
        --sapling = 1,
        flower = .5,
        beehive = .1, --was 1,
        sweet_potato_planted = 0.3,
        wasphive = 0.01, --was 0.001
      },    
    }
  })

AddRoom("MeadowSpider", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      distributepercent = .4, --was .2
      distributeprefabs =
      {
        spiderden = .5,
        grass = 1,
        --sapling = .8,
        ox = .5,
        flower = .5,
      },
    }
  })

AddRoom("MeadowRocky", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {

      distributepercent = .4, --was .1,
      distributeprefabs =
      {
        rock_flintless = 1,
        rocks = 1,
        rock1 = 1,
        rock2 = 1,
        grass = 4, --was 2
        flower = 1,
      },
    }
  })

AddRoom("MeadowMandrake", {
    colour={r=.8,g=.4,b=.4,a=.50},
    value = GROUND.MEADOW,
    contents =  {
      distributepercent = .3,
      distributeprefabs=
      {
        grass = .8,
        --sapling = .8,
        sweet_potato_planted = 0.05,
        rocks = 0.003,
        rock_flintless = 0.01, 
        flower = .25,
      },
      countprefabs =
      {
        mandrake = math.random(1, 3)
      }
    }
  })%%+%%scripts/map/rooms/ia/terrain_ocean.lua%%-%%
AddRoom("OceanShallow", {
    colour={r=0.0,g=0.0,b=.280,a=.50},
    value = GROUND.OCEAN_SHALLOW,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.0,
      distributeprefabs =
      {
      },
    }
  })

AddRoom("OceanShallowSeaweedBed", {
    colour={r=0.0,g=0.0,b=.280,a=.50},
    value = GROUND.OCEAN_SHALLOW,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.075,
      distributeprefabs =
      {
        seaweed_planted = 0.5,
        mussel_farm = 0.5,
      },
    }
  })

AddRoom("OceanShallowReef", {
    colour={r=0.0,g=0.0,b=.280,a=.50},
    value = GROUND.OCEAN_SHALLOW,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.05, --was 0.1
      distributeprefabs =
      {
        rock_coral = 1
      },
    }
  })

AddRoom("OceanMedium", {
    colour={r=0.0,g=0.0,b=.180,a=.30},
    value = GROUND.OCEAN_MEDIUM,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.0005,
      distributeprefabs =
      {
        barrel_gunpowder = 1,
      },
    }
  })

AddRoom("OceanMediumSeaweedBed", {
    colour={r=0.0,g=0.0,b=.180,a=.30},
    value = GROUND.OCEAN_MEDIUM,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.05,
      distributeprefabs =
      {
        seaweed_planted = 1
      },

      --[[countprefab =
					                {
					                	oceanspawner_seaweed = 1
					            	},

					            	prefabdata =
					            	{
					            		oceanspawner_seaweed =
					            		{
					            			range = 10,
					            			density = math.random(8, 24),
					            			basetime = math.random(2, 4) * TUNING.SEG_TIME,
					            			randtime = TUNING.SEG_TIME,
					            		}
					            	}]]
    }
  })

AddRoom("OceanMediumShoal", {
    colour={r=0.0,g=0.0,b=.180,a=.30},
    value = GROUND.OCEAN_MEDIUM,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.025,
      distributeprefabs =
      {
        fishinhole = 1,
        seaweed_planted = .5,
      },
    }
  })

AddRoom("OceanDeep", {
    colour={r=0.0,g=0.0,b=.080,a=.10},
    value = GROUND.OCEAN_DEEP,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.0005,
      distributeprefabs =
      {
        barrel_gunpowder = 1,
      },
    }
  })

AddRoom("OceanCoral", {
    colour={r=0.0,g=0.0,b=.280,a=.50},
    value = GROUND.OCEAN_CORAL,
    tags = {"RoadPoison"},
    type = "water",
    contents =  {
      distributepercent = 0.05,
      distributeprefabs =
      {
        rock_coral = .1,
        fishinhole = 1,
        seaweed_planted = 10,
        solofish = 1,
      },
    }
  })%%+%%scripts/map/rooms/ia/terrain_tidalmarsh.lua%%-%%
AddRoom("TidalMarsh", {
    colour={r=0,g=.5,b=.5,a=.10},
    value = GROUND.TIDALMARSH,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts =
      {
        -- ["TidalpoolMedium"] = function() return math.random(0, 6) end,
        -- ["TidalpoolLarge"] = function() return math.random(0, 3) end,
      },

      distributepercent = 0.3,
      distributeprefabs =
      {
        jungletree = .05,
        marsh_bush = .05,
        tidalpool = 1,
        reeds =  4,
        spiderden = .01,
        green_mushroom = 2.02,
        mermhouse = 0.1, --was 0.04
        mermhouse_fisher = 0.05,
        poisonhole = 2,
        -- seaweed_planted = 0.5,
        -- fishinhole = .1,
        flupspawner = 1,
        flup = 3,
      },
    }
  })

AddRoom("TidalMermMarsh", {
    colour={r=0,g=.5,b=.5,a=.10},
    value = GROUND.TIDALMARSH,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts =
      {
        -- ["TidalpoolMedium"] = function() return math.random(0, 6) end,
        -- ["TidalpoolLarge"] = function() return math.random(0, 3) end,
      },

      distributepercent = 0.3,
      distributeprefabs =
      {
        jungletree = .05,
        marsh_bush = .05,
        tidalpool = 1,
        reeds =  2,
        spiderden=.01,
        green_mushroom = 2.02,
        mermhouse = 0.8,
        mermhouse_fisher = 0.4,
        poisonhole = 1,
        -- seaweed_planted = 0.5,
        -- fishinhole = .1,
        flupspawner_sparse = 1,
        flup = 1,
      },
    }
  })


--[[AddRoom("TidalFrogMarsh", {
					colour={r=0,g=.5,b=.5,a=.10},
					value = GROUND.TIDALMARSH,
					tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
					contents =  {
					                distributepercent = 0.3,
					                distributeprefabs =
					                {
					                    jungletree = .05,
					                    marsh_bush = .05,
					                    tidalpool = 1,
					                    reeds =  3,
					                    spiderden=.01,
					                    green_mushroom = 2.02,
					                    mermhouse = 0.004,
					                    mermhouse_fisher = 0.02,
					                    poisonhole = 1,
					                    seaweed_planted = 0.5,
					                    fishinhole = .1,
					                    flupspawner = 1,
					                    flup = 1,
					                },
					            }
					})
]]
AddRoom("ToxicTidalMarsh", {
    colour={r=0,g=.5,b=.5,a=.10},
    value = GROUND.TIDALMARSH,
    tags = {"ExitPiece", "Packim_Fishbone", "RoadPoison"},
    contents =  {
      countstaticlayouts =
      {
        -- ["TidalpoolMedium"] = function() return math.random(0, 6) end,
        -- ["TidalpoolLarge"] = function() return math.random(0, 3) end,
      },

      distributepercent = 0.3,
      distributeprefabs =
      {
        jungletree = .05,
        marsh_bush = .05,
        tidalpool = 1,
        reeds = 2, --was 4
        spiderden = .01,
        green_mushroom = 2.02,
        mermhouse = 0.1, --was 0.04
        mermhouse_fisher = 0.05,
        poisonhole = 3, --was 2
        -- seaweed_planted = 0.5,
        -- fishinhole = .1,
        flupspawner_dense = 1,
        flup = 2,
      },
    }
  })%%+%%scripts/map/rooms/ia/volcano.lua%%-%%
AddRoom("Volcano", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = .5,
        magmarock_gold = .5,
        rock_obsidian = .5,
        rock_charcoal = .5,
        volcano_shrub = .5,
        --rocks = 1,
        --goldnugget = 0.05,
        obsidian = 0.02,
        charcoal = 0.04,
        skeleton = 0.1,
        --elephantcactus = 0.3,
        --coffeebush = 0.25,
        dragoonden = .05,
      },

      countprefabs =
      {
        --palmtree = math.random(8, 16),
        volcanofog = math.random(1, 2)
      },

      prefabdata =
      {
        magmarock = {regen=true},
        magmarock_gold = {regen=true}
      }
    }
  })

AddRoom("VolcanoRock", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .15,
      distributeprefabs=
      {
        magmarock = .5,
        magmarock_gold = .5,
        flint= .5,
        obsidian = .02,
        --rocks = 1,
        charcoal = 0.04,
        skeleton = 0.25,
        --elephantcactus = 0.3,

        --coffeebush = 0.25,
        --dragoonden = .2,
      },

      countprefabs =
      {
        --palmtree = math.random(8, 16),
        volcanofog = math.random(1, 2)
      },
      prefabdata =
      {
        --palmtree = {burnt=true},
        --coffeebush = {makebarren=true}
      }
    }
  })

AddRoom("VolcanoAsh", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.ASH,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      -- countstaticlayouts={["CoffeeBushBunch"]=1}, --adds 1 per room
      distributepercent = .15,
      distributeprefabs=
      {
        --rocks = 1,
        charcoal = 0.04,
        skeleton = 0.25,
        elephantcactus = 0.3,
        coffeebush = .5,
        --dragoonden = .2,
      },

      countprefabs =
      {
        --palmtree = math.random(4, 8),
        volcanofog = math.random(1, 2)
      },
    }
  })

AddRoom("VolcanoObsidian", { 
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = 1,
        magmarock_gold = 1,
        charcoal = 0.04,
        skeleton = 0.25,
      },

      countprefabs =
      {
        volcanofog = math.random(1, 2)
      },
    }
  })

AddRoom("VolcanoStart", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO_ROCK, --VOLCANO_NOISE,
    tags = {"ExitPiece", "RoadPoison"},
    custom_tiles = {
      -- GeneratorFunction = VolcanoNoise.GeneratorFunction,
      data = {}
    },
    contents =  {
      countstaticlayouts=
      {
        -- ["VolcanoStart"] = 1
      },
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = .5,
        magmarock_gold = .5,
        rock_obsidian = .5,
        rock_charcoal = .5,
        volcano_shrub = .5,
        charcoal = 0.04,
        skeleton = 0.1,
      },

      countprefabs =
      {
        volcanofog = math.random(1, 2)
      },

      prefabdata =
      {
        magmarock = {regen=true},
        magmarock_gold = {regen=true}
      }
    }
  })

AddRoom("VolcanoNoise", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO_ROCK, --VOLCANO_NOISE,
    tags = {"ExitPiece", "RoadPoison"},
    custom_tiles = {
      -- GeneratorFunction = VolcanoNoise.GeneratorFunction,
      data = {}
    },
    contents =  {
      countstaticlayouts=
      {
        -- ["CoffeeBushBunch"] = function()
        -- if math.random() < 0.25 then
        -- return 1
        -- else
        -- return 0
        -- end
        -- end
      },
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = .5,
        magmarock_gold = .5,
        rock_obsidian = .5,
        rock_charcoal = .5,
        volcano_shrub = .5,
        charcoal = 0.04,
        skeleton = 0.1,
        dragoonden = .05,
        elephantcactus = 1,
        coffeebush = 1,
      },

      countprefabs =
      {
        volcanofog = math.random(1, 2)
      },

      prefabdata =
      {
        magmarock = {regen=true},
        magmarock_gold = {regen=true}
      }
    }
  })

AddRoom("VolcanoObsidianBench", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = 1,
        magmarock_gold = 1,
        obsidian = .2,
        charcoal = 0.04,
        skeleton = 0.5,
      },
      countprefabs = 
      {
        volcanofog = math.random(1, 2)
      },
      countstaticlayouts = {
        ["ObsidianWorkbench"] = 1,
      },
      prefabdata =
      {
        magmarock = {regen=true},
        magmarock_gold = {regen=true}
      }
    }
  })

AddRoom("VolcanoAltar", {
    colour={r=.55,g=.75,b=.75,a=.50},
    value = GROUND.VOLCANO,
    tags = {"ExitPiece", "RoadPoison"},
    contents =  {
      distributepercent = .1,
      distributeprefabs=
      {
        magmarock = 1,
        charcoal = 0.04,
        skeleton = 0.5
      },

      countprefabs=
      {
        volcanofog = math.random(1, 2)
      },

      countstaticlayouts = {
        ["VolcanoAltar"] = 1,
      },

      prefabdata =
      {
        magmarock = {regen=true},
        magmarock_gold = {regen=true}
      }
    }
  })


-- AddRoom("VolcanoCage", {
-- colour={r=.55,g=.75,b=.75,a=.50},
-- value = GROUND.VOLCANO,
-- tags = {"ExitPiece", "RoadPoison"},
-- contents =  {
-- distributepercent = .1,
-- distributeprefabs=
-- {
-- magmarock = 1,
-- charcoal = 0.04,
-- skeleton = 0.5,
-- dragoonden = .2,
-- coffeebush = 0.25,
-- },

-- countstaticlayouts = {
-- ["WoodlegsUnlock"] = 1,
-- },

-- countprefabs=
-- {
-- volcanofog = math.random(1, 2)
-- },
-- }
-- })

AddRoom("VolcanoLava", {
    colour={r=1.0,g=0.55,b=0,a=.50},
    value = GROUND.VOLCANO_LAVA,
    type = "blank",
    tags = {"RoadPoison"},
    contents =  {
      distributepercent = 0,
      distributeprefabs = {},
    }
  })
%%+%%scripts/map/static_layouts/berrybushbunch.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 16,
  height = 16,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 16,
      height = 16,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0, 38, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 64,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 176,
          y = 80,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 208,
          y = 176,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 144,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 48,
          y = 192,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 32,
          y = 112,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 112,
          y = 112,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 160,
          y = 144,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "berrybush2",
          shape = "rectangle",
          x = 112,
          y = 176,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 96,
          y = 32,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "bambootree",
          shape = "rectangle",
          x = 144,
          y = 48,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "fireflies",
          shape = "rectangle",
          x = 208,
          y = 112,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "bush_vine",
          shape = "rectangle",
          x = 80,
          y = 144,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower",
          shape = "rectangle",
          x = 160,
          y = 192,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 16,
          y = 16,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower",
          shape = "rectangle",
          x = 208,
          y = 48,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/casino.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 8,
  height = 8,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 128,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 8,
      height = 8,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        9, 0, 0, 0, 9, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        9, 0, 0, 0, 9, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "slotmachine",
          shape = "rectangle",
          x = 64,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "skeleton",
          shape = "rectangle",
          x = 64,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "skeleton",
          shape = "rectangle",
          x = 128,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "dubloon",
          shape = "rectangle",
          x = 0,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "dubloon",
          shape = "rectangle",
          x = 64,
          y = 0,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/doydoy1.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 40,
  height = 40,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 40,
      height = 40,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 528,
          y = 384,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 384,
          y = 160,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 112,
          y = 192,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 224,
          y = 336,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "doydoy",
          shape = "rectangle",
          x = 336,
          y = 288,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seeds",
          shape = "rectangle",
          x = 224,
          y = 240,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flint",
          shape = "rectangle",
          x = 432,
          y = 368,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 480,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 256,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 336,
          y = 400,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    },
    {
      type = "objectgroup",
      name = "Object Layer 2",
      visible = false,
      opacity = 1,
      properties = {},
      objects = {}
    }
  }
}
%%+%%scripts/map/static_layouts/doydoy2.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 40,
  height = 40,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 40,
      height = 40,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 528,
          y = 384,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 384,
          y = 160,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 112,
          y = 192,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "depleted_grass",
          shape = "rectangle",
          x = 224,
          y = 336,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "doydoy",
          shape = "rectangle",
          x = 336,
          y = 288,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seeds",
          shape = "rectangle",
          x = 224,
          y = 240,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flint",
          shape = "rectangle",
          x = 432,
          y = 368,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 480,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 256,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 336,
          y = 400,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    },
    {
      type = "objectgroup",
      name = "Object Layer 2",
      visible = false,
      opacity = 1,
      properties = {},
      objects = {}
    }
  }
}
%%+%%scripts/map/static_layouts/ia_start.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 16,
  height = 16,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 16,
      height = 16,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "welcomitem",
          shape = "rectangle",
          x = 192,
          y = 80,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "welcomitem",
          shape = "rectangle",
          x = 128,
          y = 48,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "welcomitem",
          shape = "rectangle",
          x = 32,
          y = 144,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "multiplayer_portal",
          shape = "rectangle",
          x = 160,
          y = 160,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "spawnpoint_master",
          shape = "rectangle",
          x = 160,
          y = 160,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/livingjungletree.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 12,
  height = 12,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../klei/DLC_Shipwrecked/tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../klei/DLC_Shipwrecked/tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 12,
      height = 12,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "livingjungletree",
          shape = "rectangle",
          x = 84,
          y = 105,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 47,
          y = 168,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 29,
          y = 61,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 128,
          y = 106,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 97,
          y = 20,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 29,
          y = 139,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 163,
          y = 145,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flower_evil",
          shape = "rectangle",
          x = 130,
          y = 36,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/oasis2.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 36,
  height = 36,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 36,
      height = 36,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 40, 0, 0, 0, 40, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "fishinhole",
          shape = "rectangle",
          x = 256,
          y = 320,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 480,
          y = 240,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 480,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.75"
          }
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 112,
          y = 464,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "fishingrod",
          shape = "rectangle",
          x = 288,
          y = 416,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 80,
          y = 352,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 416,
          y = 448,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 432,
          y = 352,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 96,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 160,
          y = 528,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "seaweed_planted",
          shape = "rectangle",
          x = 320,
          y = 192,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "seaweed_planted",
          shape = "rectangle",
          x = 176,
          y = 400,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "seaweed_planted",
          shape = "rectangle",
          x = 336,
          y = 320,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 368,
          y = 80,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.5"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 480,
          y = 208,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 80,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.75"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 64,
          y = 224,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.75"
          }
        },
        {
          name = "",
          type = "wall_limestone",
          shape = "rectangle",
          x = 464,
          y = 208,
          width = 0,
          height = 0,
          visible = true,
          properties = {
            ["data.health.percent"] = "0.25"
          }
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/resurrectionstone_sw.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 8,
  height = 8,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 8,
      height = 8,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        9, 0, 0, 0, 9, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        9, 0, 0, 0, 9, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "resurrectionstone",
          shape = "rectangle",
          x = 64,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "wildborehead",
          shape = "rectangle",
          x = 64,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "wildborehead",
          shape = "rectangle",
          x = 128,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "wildborehead",
          shape = "rectangle",
          x = 0,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "wildborehead",
          shape = "rectangle",
          x = 64,
          y = 0,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/sharkhome.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 16,
  height = 16,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 16,
      height = 16,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 65,
          y = 62,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sharkittenspawner",
          shape = "rectangle",
          x = 128,
          y = 129,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 145,
          y = 27,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 211,
          y = 84,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rock_limpet",
          shape = "rectangle",
          x = 34,
          y = 118,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 103,
          y = 176,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 163,
          y = 188,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 113,
          y = 59,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 231,
          y = 231,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 30,
          y = 166,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 125,
          y = 235,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 221,
          y = 151,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 194,
          y = 33,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "grass",
          shape = "rectangle",
          x = 61,
          y = 33,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 23,
          y = 20,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "seashell_beached",
          shape = "rectangle",
          x = 21,
          y = 64,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rock_limpet",
          shape = "rectangle",
          x = 231,
          y = 33,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "palmtree",
          shape = "rectangle",
          x = 35,
          y = 221,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/skull_isle2.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 76,
  height = 76,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "ground",
      firstgid = 1,
      filename = "../../../../../tools/tiled/dont_starve/ground.tsx",
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 384,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 76,
      height = 76,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 45, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 720,
          y = 416,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 736,
          y = 432,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 704,
          y = 448,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 400,
          y = 448,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 368,
          y = 432,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 368,
          y = 464,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 688,
          y = 416,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 688,
          y = 464,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 400,
          y = 432,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 432,
          y = 464,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 416,
          y = 448,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "magmarock_gold",
          shape = "rectangle",
          x = 720,
          y = 480,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "sapling",
          shape = "rectangle",
          x = 640,
          y = 912,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "buriedtreasure",
          shape = "rectangle",
          x = 544,
          y = 624,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_1",
          shape = "rectangle",
          x = 256,
          y = 704,
          width = 576,
          height = 192,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_2",
          shape = "rectangle",
          x = 640,
          y = 512,
          width = 320,
          height = 192,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_3",
          shape = "rectangle",
          x = 768,
          y = 256,
          width = 128,
          height = 256,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_4",
          shape = "rectangle",
          x = 192,
          y = 512,
          width = 256,
          height = 192,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_5",
          shape = "rectangle",
          x = 64,
          y = 256,
          width = 288,
          height = 256,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_6",
          shape = "rectangle",
          x = 320,
          y = 128,
          width = 256,
          height = 128,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_7",
          shape = "rectangle",
          x = 576,
          y = 192,
          width = 256,
          height = 64,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_8",
          shape = "rectangle",
          x = 352,
          y = 256,
          width = 416,
          height = 144,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_9",
          shape = "rectangle",
          x = 448,
          y = 400,
          width = 224,
          height = 112,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "area_10",
          shape = "rectangle",
          x = 256,
          y = 960,
          width = 576,
          height = 192,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/volcano_altar.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 32,
  height = 32,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../klei/DLC_Shipwrecked/tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 447,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 32,
      height = 32,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 160,
          y = 256,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 256,
          y = 160,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 352,
          y = 256,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 256,
          y = 352,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar",
          shape = "rectangle",
          x = 256,
          y = 256,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 384,
          y = 384,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 128,
          y = 384,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 128,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 384,
          y = 128,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/volcano_start.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 24,
  height = 24,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../klei/DLC_Shipwrecked/tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 447,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 24,
      height = 24,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "spawnpoint",
          shape = "rectangle",
          x = 222,
          y = 163,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_exit",
          shape = "rectangle",
          x = 193,
          y = 195,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "skeleton",
          shape = "rectangle",
          x = 198,
          y = 307,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 95,
          y = 268,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 119,
          y = 106,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 240,
          y = 297,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 247,
          y = 95,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "skeleton",
          shape = "rectangle",
          x = 77,
          y = 77,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "volcano_altar_pillar",
          shape = "rectangle",
          x = 301,
          y = 194,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/volcano_workbench.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 20,
  height = 20,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../klei/DLC_Shipwrecked/tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 447,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 20,
      height = 20,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        26, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0, 26, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "obsidian_workbench",
          shape = "rectangle",
          x = 166,
          y = 170,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 223,
          y = 91,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "obsidian",
          shape = "rectangle",
          x = 208,
          y = 235,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "obsidian",
          shape = "rectangle",
          x = 95,
          y = 167,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 170,
          y = 45,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 40,
          y = 221,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 275,
          y = 222,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "rocks",
          shape = "rectangle",
          x = 64,
          y = 104,
          width = 0,
          height = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
%%+%%scripts/map/static_layouts/water_boon.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 8,
  height = 8,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "tiles",
      firstgid = 1,
      tilewidth = 64,
      tileheight = 64,
      spacing = 0,
      margin = 0,
      image = "../../../../tools/tiled/dont_starve/tiles.png",
      imagewidth = 512,
      imageheight = 128,
      properties = {},
      tiles = {}
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 8,
      height = 8,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "item_area",
          shape = "rectangle",
          x = 3,
          y = 0,
          width = 44,
          height = 124,
          visible = true,
          properties = {
            ["scenario"] = "random_damage"
          }
        },
        {
          name = "",
          type = "resource_area",
          shape = "rectangle",
          x = 81,
          y = 2,
          width = 44,
          height = 123,
          visible = true,
          properties = {}
        },
      }
    }
  }
}
%%+%%scripts/map/static_layouts/wreck.lua%%-%%return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 12,
  height = 12,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {},
  layers = {
    {
      type = "tilelayer",
      name = "BG_TILES",
      x = 0,
      y = 0,
      width = 12,
      height = 12,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
      }
    },
    {
      type = "objectgroup",
      name = "FG_OBJECTS",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "ship_area",
          shape = "rectangle",
          x = 6,
          y = 5,
          width = 62,
          height = 62,
          visible = true,
          properties = {
            ["data.isnamed"] = "true",
            ["data.wrecktype"] = "hull"
          }
        },
        {
          name = "",
          type = "debris_area",
          shape = "rectangle",
          x = 69,
          y = 68,
          width = 119,
          height = 120,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "mast_area",
          shape = "rectangle",
          x = 86,
          y = 86,
          width = 37,
          height = 37,
          visible = true,
          properties = {
            ["data.wrecktype"] = "mast"
          }
        }
      }
    }
  }
}
%%+%%scripts/map/tasks/island.lua%%-%%require "map/rooms/ia/terrain_beach"
require "map/rooms/ia/terrain_jungle"
require "map/rooms/ia/terrain_magmafield"
require "map/rooms/ia/terrain_mangrove"
require "map/rooms/ia/terrain_meadow"
require "map/rooms/ia/terrain_ocean"
require "map/rooms/ia/terrain_tidalmarsh"
require "map/rooms/ia/volcano"
require "map/rooms/ia/water_content"

--[[
AddTask("SampleTask", { --Name to use in the 'tasks' or 'optionaltasks' list
		--This is the lock that require to use the task
		locks=LOCKS.ISLAND1,

		--These are the key(s) given when the task is used. KEYS.ISLAND2 unlocks LOCK.ISLAND2
		keys_given={KEYS.ISLAND2},

		--This is new in DST, it groups tasks into a region separate from the mainland
		region_id = "islandadventures0",
		
		--This is new in DST, it applies tags to all the rooms of the task
		room_tags={"RoadPoison", "not_mainland"},

		--This is used add links between biomes in an island which can make interesting shapes
		--0-1 seems to be a good amount
		crosslink_factor=math.random(0,1),

		--When an island is generated this gives a chance the island ends will be connected making
		--a round island and sometimes lagoons
		make_loop=math.random(0, 100) < 50,
		
		-- This is a SW-exclusive feature, it is not available in IA.
		-- From a quick glance, it seems to not have done anything special anyways.
		gen_method = "lagoon",

		-- Mark this as an actual island, else it becomes part of the mainland.
		island=true,
		
		--The rooms (biomes) that the task (island) contains.
		--Rooms can be found in the map/rooms/ folder
		--Shipwrecked files: terrain_beach.lua, terrain_island.lua, terrain_jungle.lua, terrain_ocean.lua, terrain_swamp.lua
		--See map/rooms/terrain_jungle.lua for room info
		room_choices={
			--From terrain_jungle.lua, add 2 to 5 JungleClearing biomes to the island
			["JungleClearing"] = 2 + math.random(0, 3),

			--From terrain_savanna.lua, add 1 BareMangrove biome to the island
			["BareMangrove"] = 1,

			--From terrain_savanna.lua, add 3 + 0 to 3 Plain biomes to the island
			["Plain"] = 3 + math.random(0, 3),

			--From terrain_forest.lua, add 1 Clearing biome to the island
			["Clearing"] = 1,

			--From terrain_rocky.lua, add 1 to 4 Rocky biomes to the island
			["RockyIsland"] = 1 + math.random(0, 3),

			--From graveyard.lua, add 0 to 1 Graveyard biomes to the island
			["Graveyard"] = math.random(0, 1),

			--From terrain_jungle.lua, add 0 to 2 JungleDenseVery biomes to the island
			["JungleDenseVery"] = math.random(0, 2),

				--From terrain_jungle.lua, add 0 to 2 JungleDenseVery biomes to the island
			["BeachPalmForest"] = math.random(0, 2),
		},

		--This is a backup basically, a background room of just this tile type is added to the task
		--GROUND (tile types) are in constants.lua
		room_bg=GROUND.JUNGLE,

		background_room="BeachSand",

		--Used for debug stuff
		colour={r=1,g=1,b=0,a=1}
	})
]]

AddTask("HomeIslandVerySmall", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandVerySmall",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMedHome"] = 1, --changed from JungleDense to remove monkeys
			["BeachSandHome"] = 2,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandSmall", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandSmall",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMedHome"] = 2, --changed from JungleDense to remove monkeys
			["BeachUnkept"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandSmallBoon", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandSmallBoon",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseHome"] = 2,
			["JungleDenseMedHome"] = 1, --changed from JungleDense to remove monkeys
			["BeachSandHome"] = 1, 
			["BeachUnkept"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome", --removed BeachUnkept, added unkept above
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandSmallBoon_Road", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND1, KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={},
		--region_id="ia_HomeIslandSmallBoon",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseHome"] = 2,
			["JungleDenseMedHome"] = 1, --changed from JungleDense to remove monkeys
			["BeachSandHome"] = 1,
			["BeachUnkept"] = 1,
		},
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome", --removed BeachUnkept, added unkept above
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1},
	})

AddTask("HomeIslandSingleTree", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandSingleTree",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["OceanShallow"] = 1, -- was BeachSinglePalmTreeHome
		}, 
		room_bg=GROUND.OCEAN_SHALLOW,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandMed", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandMed",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMedHome"] = 3 + math.random(0, 3), --changed from JungleDense to remove monkeys
			["BeachUnkept"] = 1, 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandLarge", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandLarge",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMedHome"] = 3 + math.random(0, 3), --changed from JungleDense to remove monkeys
			["BeachUnkept"] = 2
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HomeIslandLargeBoon", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HomeIslandLargeBoon",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMedHome"] = 3 + math.random(0, 3), --changed from JungleDense to remove monkeys
			["BeachUnkept"] = 2, 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
--[[
AddTask("LagoonTest", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		gen_method = "lagoon",
		room_choices={
			{
				["OceanShallow"] = 2
			},
			{
				["BeachSand"] = 5,
			},
			{
				["JungleDense"] = 10,
			},
			{
				["BeachUnkept"] = 18 -- was 3*18
			}, 
		}, 
		room_bg=GROUND.JUNGLE,
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
]]
AddTask("DesertIsland", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_DesertIsland",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1 + math.random(0, 3),
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

-- AddTask("VolcanoIsland",
		-- locks=LOCKS.NONE, --LOCKS.ISLAND1,
		-- keys_given={KEYS.ISLAND1},
		-- crosslink_factor=math.random(0,1),
		-- make_loop=math.random(0, 100) < 50,
		-- island=true,
		-- room_choices={
			-- ["VolcanoRock"] = 1,
			-- ["MagmaVolcano"] = 1,
			-- ["VolcanoObsidian"] = 1,
			-- ["VolcanoObsidianBench"] = 1,
			-- ["VolcanoAltar"] = 1,
			-- ["VolcanoLava"] = 1
		-- }, 
		-- room_bg=GROUND.BEACH,
		-- background_room="OceanDeep",
		-- colour={r=1,g=1,b=0,a=1}
	-- })

AddTask("JungleMarsh", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["TidalMarsh"] = 2,
			["JungleDense"] = 6, 
			["JungleDenseBerries"] = 2
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BeachJingleS", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachJingleS",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMed"] = 3, 
			["BeachUnkept"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
	
AddTask("BeachBothJungles", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachBothJungles",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMed"] = 1,
			["JungleDense"] = 2, 
			["BeachSand"] = 3 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BeachJungleD", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachJungleD",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDense"] = 2, 
			["BeachSand"] = 1 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BeachSavanna", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachSavanna",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 2, 
			["NoOxMeadow"] = 2 
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("GreentipA", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_GreentipA",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 2,
			["MeadowCarroty"] = 1, 
			["JungleDenseMed"] = 3,
			["BeachUnkept"] = 1 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("GreentipB", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_GreentipB",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1, 
			["NoOxMangrove"] = 2, 
			["JungleDense"] = 2 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HalfGreen", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_HalfGreen",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 3,
			["Mangrove"] = 1,
			["JungleDenseMed"] = 1,
			["NoOxMeadow"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BeachRockyland", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachRockyland",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["Magma"] = 1
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("LotsaGrass", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_LotsaGrass",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["NoOxMangrove"] = 1,
			["JungleDenseMed"] = 1,
			["NoOxMeadow"] = 2
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("AllBeige", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_AllBeige",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["Magma"] = 1,
			["NoOxMangrove"] = 1
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BeachMarsh", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BeachMarsh",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["TidalMarsh"] = 2
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("Verdant", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Verdant",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["BeachPiggy"] = 1,
			["JungleDenseMed"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("VerdantMost", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_VerdantMost",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["BeachSappy"] = 1,
			["JungleDenseMed"] = 1,
			["JungleDenseBerries"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("Vert", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Vert",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
			["MeadowCarroty"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("JungleSparse", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleSparse",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseMed"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseMed",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleBoth", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleBoth",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleSparse"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room={"JungleSparse", "JungleDense"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
]]
AddTask("Florida Timeshare", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Florida Timeshare",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 1,
			["JungleDenseMed"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleSRockyland", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["JungleDenseMed"] = 2,
			["Magma"] = 6
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleSparse",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleSSavanna", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleSSavanna",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BareMangrove"] = 1, --BareMangrove includes Ox
			["JungleDenseMed"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleSparse",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleBeige", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleBeige",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BareMangrove"] = 1,
			["Magma"] = 1,
			["JungleDenseMed"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="NoOxMangrove",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("FullofBees", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_FullofBees",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeesBeach"] = 2,
			--["SavannaBees"] = 1,
			["JungleDense"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleBees", --was NoOxMangrove and JungleSparse
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDense", {------THIS IS A GOOD EXAMPLE OF THEMED ISLAND
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 1,
			["JungleFlower"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDMarsh", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleDMarsh",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="TidalMermMarsh",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDRockyland", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["JungleDense"] = 2,
			["Magma"] = 4
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDRockyMarsh", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["TidalMarsh"] = 2,
			["JungleDense"] = 4,
			["Magma"] = 2
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDSavanna", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleDSavanna",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BareMangrove"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("JungleDSavRock", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_JungleDSavRock",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BareMangrove"] = 1,
			["Magma"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense", --"NoOxMangrove",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("HotNSticky", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 2,
			["JungleDenseMed"] = 1,
			["JungleDense"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("Marshy", { -- not being called
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 1,
			["TidalMermMarsh"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="TidalMarsh",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("NoGreen A", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_NoGreen A",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["TidalMarsh"] = 1,
			["Magma"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="TidalMarsh",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("NoGreen B", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_NoGreen B",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["ToxicTidalMarsh"] = 2,
			["Magma"] = 1,
			["BareMangrove"] = 1
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="TidalMarsh",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("Savanna", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Savanna",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachUnkept"] = 1,
			["BareMangrove"] = 1 
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachNoCrabbits",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("Rockyland", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Rockyland",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["Magma"] = 2, --was 1
			["ToxicTidalMarsh"] = math.random(0, 1),
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("PalmTreeIsland", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_PalmTreeIsland",
		crosslink_factor=1,
		make_loop=true,
		island=true,
		room_choices={
			["BeachSinglePalmTree"] = 1,
			["OceanShallowSeaweedBed"] = 1,
			["OceanShallow"] = 1,
		}, 
		room_bg=GROUND.OCEAN_SHALLOW,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("DoydoyIslandGirl", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND1},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_DoydoyIslandGirl",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
				["JungleSparse"] = 2,
		}, 
		set_pieces={
			{name="DoydoyGirl"}
		},
		room_bg=GROUND.OCEAN_SHALLOW,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("DoydoyIslandBoy", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND1},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_DoydoyIslandBoy",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
				["JungleSparse"] = 2,
		},
		set_pieces={
			{name="DoydoyBoy"}
		},
		room_bg=GROUND.OCEAN_SHALLOW,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandCasino", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_IslandCasino",
		crosslink_factor=1, --math.random(0,1),
		make_loop=true, --math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachPalmCasino"] = 1, -- MR went from 1-5
			["Mangrove"] = math.random(1, 2)
		}, 
		set_pieces={
			{name="Casino"}
		},
		room_bg=GROUND.OCEAN_SHALLOW,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("KelpForest", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_KelpForest",
		crosslink_factor=1,
		make_loop=true,
		island=true,
		room_choices={
			["OceanMediumSeaweedBed"] = math.random(1, 3), --CM was 2, 5
		},
		room_bg=GROUND.OCEAN_MEDIUM,
		background_room="OceanMediumSeaweedBed",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("GreatShoal", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_GreatShoal",
		crosslink_factor=1,
		make_loop=true,
		island=true,
		room_choices={
			["OceanMediumShoal"] = math.random(1, 3), --CM was 2, 5
		},
		room_bg=GROUND.OCEAN_MEDIUM,
		background_room="OceanMediumShoal",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("BarrierReef", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_BarrierReef",
		crosslink_factor=0,
		make_loop=false,
		island=true,
		room_choices={
			["OceanCoral"] = math.random(1, 3), --CM was 2, 5
		},
		room_bg=GROUND.OCEAN_CORAL,
		background_room="OceanCoral",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--Test tasks ================================================================================================================================================================
AddTask("IslandParadise", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.PICKAXE,KEYS.AXE,KEYS.GRASS,KEYS.WOOD,KEYS.TIER1,KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_IslandParadise",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1, --CM + math.random(0, 2),
			["Jungle"] = 2, --CM + math.random(0, 1),
			["MeadowMandrake"] = 1,
			["Magma"] = 1, --CM + math.random(0, 1),
			["JungleDenseVery"] = math.random(0, 1),
			["BareMangrove"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachGravel",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("ThemePigIsland", {
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND1},
		gen_method = "lagoon",
		room_choices={
			{
				["JunglePigs"] = 1, 
				["JungleDenseMed"] = 2
			},
			{
				["JunglePigGuards"] = 5 + math.random(0, 3), --was 5 +
			},
		},
		set_pieces={
			{name="DefaultPigking"}
		},
		--room_bg=GROUND.IMPASSABLE,
		--background_room="BGImpassable",
		room_bg=GROUND.TIDALMARSH,
		background_room={"BeachSand","BeachPiggy","BeachPiggy","BeachPiggy","TidalMarsh"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0,b=1,a=1}
	})
]]
AddTask("PiggyParadise", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3,KEYS.ISLAND4},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["JungleDenseBerries"] = 3,
			["BeachPiggy"] = 5 + math.random(1, 3),
		},
		--[[set_pieces={
			{name="DefaultPigking"}
		},]]
		--room_bg=GROUND.IMPASSABLE,
		--background_room="BGImpassable",
		room_bg=GROUND.TIDALMARSH,
		background_room="BeachPiggy",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0,b=1,a=1}
	})

AddTask("BeachPalmForest", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3,KEYS.ISLAND4},
		island=true,
		room_choices={
			["BeachPalmForest"] = 1 + math.random(0, 3),
		}, 
		--room_bg=GROUND.IMPASSABLE,
		--background_room="BGImpassable",
		room_bg=GROUND.TIDALMARSH,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0,b=1,a=1}
	})

AddTask("ThemeMarshCity", {
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		island=true,
		room_choices={
			["TidalMermMarsh"] = 1 + math.random(0, 1),
			["ToxicTidalMarsh"] = 1 + math.random(0, 1),
			["JungleSpidersDense"] = 1, --CM was 3,
		}, 
		--room_bg=GROUND.IMPASSABLE,
		--background_room="BGImpassable",
		room_bg=GROUND.TIDALMARSH,
		background_room="BeachSand","BeachPiggy","TidalMarsh",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0,b=1,a=1}
	})

AddTask("Spiderland", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_Spiderland",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MagmaSpiders"] = 1,
			["JungleSpidersDense"] = 2,
			["JungleSpiderCity"] = 1 --need to make this jungly instead of using basegame trees and ground
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="BeachGravel", --removed MagmaSpiders
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleBamboozled", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleBamboozled"] = 1 + math.random(0,1), -- added the random bonus room
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="OceanShallow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleMonkeyHell", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleMonkeyHell"] = 3,
			--["JungleDenseBerries"] =1,
			--["JungleDenseMedHome"] =1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="Jungle",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleCritterCrunch", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleCritterCrunch"] = 2,
			["JungleDenseCritterCrunch"] = 1,
			--["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseCritterCrunch",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandMagmaJungle", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MagmaForest"] = 1,
			--["JungleClearing"] = 1,
			["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		--background_room={"JungleClearing"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
]]
AddTask("IslandJungleShroomin", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleShroomin"] = 2,
			--["JungleDenseMed"] = 1,
			--["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseMedHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleRockyDrop", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["MagmaSpiders"] = 2,
			["JungleRockyDrop"] = 4, 
			["Jungle"] = 2
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseMedHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleEyePlant", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleEyeplant"] = 1,
			["TidalMarsh"] = 1,
			--["JungleDense"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseMedHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandJungleGrassy", {  
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleGrassy"] = 1,
			["JungleDenseBerries"] = 1,
			["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		--background_room={"JungleClearing", "JungleDense"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleSappy", {  
		locks=LOCKS.NONE, --LOCKS.ISLAND1,
		keys_given={KEYS.ISLAND2},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleSappy"] = 1,
			["JungleDenseMedHome"] = 1,
			["JungleDenseVery"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		--background_room={"JungleClearing", "Jungle"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleNoGrass", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleNoGrass"] = 2, --CM + math.random(0, 3),
			--["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		--background_room={"JungleSparseHome", "JungleDenseMed"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	}) ]]

AddTask("IslandJungleBerries", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleDenseBerries"] = 4,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="Jungle",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleNoBerry", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleNoBerry"] = 3,
			--[[ ["Jungle"] = 1,
			["JungleDenseVery"] = 1, ]]
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleSparse",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleNoRock", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleNoRock"] = 1,
			--["JungleEyeplant"] = 1,
			["TidalMarsh"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDense",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleNoMushroom", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleNoMushroom"] = 1,
			--["Jungle"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleNoMushroom",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleNoFlowers", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleNoFlowers"] = math.random(3,5),
			--["JungleDenseMedHome"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="Jungle",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandJungleEvilFlowers", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleEvilFlowers"] = 2,
			["ToxicTidalMarsh"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="JungleDenseMed",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandJungleMorePalms", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleMorePalms"] = math.random(2,3),
			--["JungleDense"] = 1,
			--["JungleDenseBerries"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		--background_room={"JungleSparse", "JungleDense"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	}) ]]

AddTask("IslandJungleSkeleton", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["JungleSkeleton"] = 1,
			["JungleDenseMedHome"] = 1,
			["TidalMermMarsh"] = 1,
		}, 
		room_bg=GROUND.JUNGLE,
		background_room="Jungle",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachCrabTown", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachCrabTown"] = math.random(1,3),
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachDunes", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachDunes"] = 1,
			["BeachUnkept"] = 1,
			-- ["BeachSinglePalmTree"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachGrassy", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachGrassy"] = 1,
			["BeachPalmForest"]=1,
			["BeachSandHome"]=1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachGravel",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachSappy", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSappy"] = 1,
			["BeachSand"] = 1,
			["BeachUnkept"] = 1, --was BeachGravel
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachRocky", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachRocky"] = 1,
			--["BeachGravel"] = 1,
			["BeachUnkept"] = 1,
			["BeachSandHome"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSandHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachLimpety", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachLimpety"] = 1,
			["BeachSand"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept", --was BeachGravel instead of Unkept
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachForest", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachPalmForest"] = 1,
			["BeachSandHome"] = 1,
			-- ["BeachSinglePalmTree"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachSpider", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSpider"] = 2,
			--["BeachUnkept"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept", --was BeachGravel instead of Unkept
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachNoFlowers", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachNoFlowers"] = 1,
			["BeachUnkept"] = 1, --was BeachGravel
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandBeachFlowers", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachFlowers"] = 1,
			--["BeachSandHome"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room={"BeachSandHome", "BeachSand"}, --removed BeachGravel
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	}) ]]

AddTask("IslandBeachNoLimpets", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachNoLimpets"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandBeachNoCrabbits", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachNoCrabbits"] = 2,
			--["BeachSinglePalmTree"] = 1, -- this leaves a lot of empty space possibly the size of a whole screen
			--["BeachSandHome"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept", --was BeachGravel instead of Unkept
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandMangroveOxBoon", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MangroveOxBoon"] = 1,
			["MangroveWetlands"] = 1,
			["JungleNoRock"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		background_room="BeachGravel",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandMeadowWetlands", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MeadowWetlands"] = 2,
			["BG_Mangrove"] = 1,
			["BareMangrove"] = 1,
			--["NoOxMangrove"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		--background_room={"BareMangrove", "Plain"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandSavannaFlowery", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["SavannaFlowery"] = 2,
			--["BG_Mangroves"] = 1,
			--["Plain"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		--background_room={"BG_Mangroves", "BareMangrove"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})
]]
AddTask("IslandMeadowBees", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MeadowBees"] = 1,
			["NoOxMeadow"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		background_room="NoOxMeadow",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandMeadowCarroty", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MeadowCarroty"] = 1,
			["NoOxMeadow"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		--background_room="BareMangrove", --do not use "Plain", it's Savanna
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandSavannaSappy", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["SavannaSappy"] = 1,
			--["BareMangrove"] = 1,
			--["BG_Mangroves"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		background_room={"SavannaSappy", "SavannaSappy", "SavannaSappy", "BareMangrove", "BeachSappy", "BeachUnkept"}, --was BeachGravel instead of Unkept
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandSavannaSpider", {  
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["SavannaSpider"] = 3,
			--["BareMangrove"] = 1,
			--["NoOxMangrove"] = 1,
			--["Plain"] = 1,
		}, 
		room_bg=GROUND.MANGROVE,
		--background_room={"NoOxMangrove", "BG_Mangroves"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandSavannaRocky", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		gen_method = "lagoon",
		room_choices={
			{
				["SavannaRocky"] = 2
			},
			{
				["BeachRocky"] = 3,  --CM was 4
				["BeachSand"] = 3 --CM was 4
			},
		}, 
		room_bg=GROUND.MANGROVE,
		--background_room={"BareMangrove", "Plain"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	}) ]]

AddTask("IslandRockyGold", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MagmaGoldBoon"] = 1,
			["MagmaGold"] = 1,
			["BeachSandHome"] = 1,
		}, 
		room_bg=GROUND.BEACH ,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

--[[AddTask("IslandRockyBlueMushroom", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["RockyBlueMushroom"] = 1,
			["MolesvilleRockyIsland"] = 1,
			["BeachSand"] = 1,
		}, 
		room_bg=GROUND.BEACH ,
		--background_room={"BeachGravel", "BeachUnkept"},
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	}) ]]

AddTask("IslandRockyTallBeach", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MagmaTallBird"] = 1,
			["GenericMagmaNoThreat"] = 1,
			["BeachUnkept"] = 1, --was BeachGravel
		}, 
		room_bg=GROUND.BEACH ,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("IslandRockyTallJungle", {  
		locks=LOCKS.ISLAND3,
		keys_given={KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["MagmaTallBird"] = 1,
			["BG_Magma"] = 1,
			["JungleDenseMed"] = 1,
		}, 
		room_bg=GROUND.JUNGLE ,
		background_room="JungleSparseHome",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

-- AddTask("Chess", {
		-- locks=LOCKS.ISLAND2,
		-- keys_given={KEYS.ISLAND3},
		-- crosslink_factor=math.random(0,1),
		-- make_loop=math.random(0, 100) < 50,
		island=true,
		-- room_choices={
			-- ["MarbleForest"] = 1,
			-- ["ChessArea"] = 1,
			-- --["ChessMarsh"] = 1,
			-- --["ChessForest"] = 1,
		-- },
		-- colour={r=0.5,g=0.7,b=0.5,a=0.3},						
	-- })

AddTask("PirateBounty", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_PirateBounty",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachUnkeptDubloon"] = 1,
		},
		set_pieces={
			{name="Xspot"}
		},
		room_bg=GROUND.BEACH ,
		background_room="OceanShallowSeaweedBed", --removed "OceanShallowReef"
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0.7,b=0.5,a=0.3},						
	})

AddTask("IslandOasis", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_IslandOasis",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["Jungle"] = 1,
		},
		set_pieces={
			{name="JungleOasis"}
		},
		room_bg=GROUND.BEACH ,
		background_room="OceanShallowSeaweedBed", --removed "OceanShallowReef"
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0.7,b=0.5,a=0.3},						
	})

AddTask("ShellingOut", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3, KEYS.ISLAND4},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_ShellingOut",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachShells"] = 2,
		},
		room_bg=GROUND.BEACH ,
		background_room="OceanShallow", --removed "OceanShallowReef"
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0.7,b=0.5,a=0.3},						
	})

AddTask("Cranium", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		gen_method = "lagoon",
		island=true,
		room_choices={
			["BeachSkull"] = 1,
			["Jungle"] = 6,
		},
		--[[treasures = { 
			{name="DeadmansTreasure"} 
		},]]
		room_bg=GROUND.BEACH,
		background_room="BeachSand",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("CrashZone", {
		locks=LOCKS.ISLAND2,
		keys_given={KEYS.ISLAND3},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_CrashZone",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["Jungle"] = 2,
			["MagmaForest"] = 1,
		}, 
		room_bg=GROUND.BEACH,
		background_room="BeachUnkept",
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=1,g=1,b=0,a=1}
	})

AddTask("SharkHome", {
		locks=LOCKS.ISLAND4,
		keys_given={KEYS.ISLAND5},
		--region_id="islandadventures0",
		room_tags={"RoadPoison", "not_mainland"},
		--region_id="ia_SharkHome",
		crosslink_factor=math.random(0,1),
		make_loop=math.random(0, 100) < 50,
		island=true,
		room_choices={
			["BeachSand"] = 1,
		},
		set_pieces={
			{name="SharkHome"}
		},
		room_bg=GROUND.BEACH ,
		background_room="OceanShallowSeaweedBed", --removed "OceanShallowReef"
		--cove_room_name = "Empty_Cove",
		--cove_room_chance = 1,
		--cove_room_max_edges = 2,
		colour={r=0.5,g=0.7,b=0.5,a=0.3},						
	})%%+%%scripts/prefabs/antivenom.lua%%-%%local assets =
{
  Asset("ANIM", "anim/poison_antidote.zip"),
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("poison_antidote")
  inst.AnimState:SetBuild("poison_antidote")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst, "antivenom")

  inst:AddComponent("poisonhealer")

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "antivenom", fn, assets) 

%%+%%scripts/prefabs/ashfx.lua%%-%%local TEXTURE = "images/fx/ash.tex"

local SHADER = "shaders/vfx_particle.ksh"

local COLOUR_ENVELOPE_NAME = "ashcolourenvelope"
local SCALE_ENVELOPE_NAME = "ashscaleenvelope"

local assets =
{
    Asset("IMAGE", TEXTURE),
    Asset("SHADER", SHADER),
}

local function IntColour(r, g, b, a)
    return {r / 255.0, g / 255.0, b / 255.0, a / 255.0}
end

local function InitEnvelope()
    EnvelopeManager:AddColourEnvelope(COLOUR_ENVELOPE_NAME, {
        {0, IntColour(50, 50, 50, 120)},
        {1, IntColour(50, 50, 50, 180)},})

    local max_scale = 1
    EnvelopeManager:AddVector2Envelope(SCALE_ENVELOPE_NAME, {
        {0, {max_scale, max_scale}},
        {1, {max_scale, max_scale}},})
    InitEnvelope = nil
    IntColour = nil
end

local MAX_LIFETIME = 7
local MIN_LIFETIME = 4

local function emit_fn(effect, emitter_shape)
    local vx, vy, vz = 0, 0, 0
    local lifetime = MIN_LIFETIME + ( MAX_LIFETIME - MIN_LIFETIME ) * UnitRand()
    local px, py, pz = emitter_shape()

    effect:AddParticle(
        0,
        lifetime,           -- lifetime
        px, py, pz,         -- position
        vx, vy, vz          -- velocity
    )
end

local function InitParticles(inst)
    --Dedicated server does not need to spawn local particle fx
    if TheNet:IsDedicated() then
        return
    elseif InitEnvelope ~= nil then
        InitEnvelope()
    end

    local effect = inst.entity:AddVFXEffect()
    effect:InitEmitters(1)
    effect:SetRenderResources(0, softresolvefilepath(TEXTURE), SHADER)
    effect:SetMaxNumParticles(0, 4800)
    effect:SetMaxLifetime(0, MAX_LIFETIME)
    effect:SetColourEnvelope(0, COLOUR_ENVELOPE_NAME)
    effect:SetScaleEnvelope(0, SCALE_ENVELOPE_NAME)
    effect:SetBlendMode(0, BLENDMODE.Premultiplied)
    effect:SetSortOrder(0, 3)
    effect:SetAcceleration(0, -1, -9.80/2, 1)
    effect:SetDragCoefficient(0, 0.8)
    effect:EnableDepthTest(0, true)

    -----------------------------------------------------

    local tick_time = TheSim:GetTickTime()

    local desired_particles_per_second = 0
    inst.particles_per_tick = desired_particles_per_second * tick_time

    local num_particles_to_emit = inst.particles_per_tick

    local bx, by, bz = 0, 20, 0
    local emitter_shape = CreateBoxEmitter(bx, by, bz, bx + 20, by, bz + 20)

    EmitterManager:AddEmitter(inst, nil, function()
        while num_particles_to_emit > 1 do
            emit_fn(effect, emitter_shape)
            num_particles_to_emit = num_particles_to_emit - 1
        end
        num_particles_to_emit = num_particles_to_emit + inst.particles_per_tick
    end)
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()

    inst:AddTag("FX")

    InitParticles(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false

    return inst
end

return Prefab("ashfx", fn, assets) 
 
%%+%%scripts/prefabs/babyox.lua%%-%%require "brains/babybeefalobrain"
require "stategraphs/SGBeefalo"

local assets=
{
  Asset("ANIM", "anim/beefalo_basic.zip"),
  Asset("ANIM", "anim/beefalo_actions.zip"),
  Asset("ANIM", "anim/beefalo_baby_build.zip"),
  Asset("SOUND", "sound/beefalo.fsb"),
}

local prefabs =
{
  "smallmeat",
  "meat",
  "poop",
  "ox",
}

local babyloot = {"smallmeat","smallmeat","smallmeat"}
local toddlerloot = {"smallmeat","smallmeat","smallmeat","smallmeat"}
local teenloot = {"meat","meat","meat"}

local sounds =
{
  walk = "dontstarve/creatures/beefalo_baby/walk",
  grunt = "dontstarve/creatures/beefalo_baby/grunt",
  yell = "dontstarve/creatures/beefalo_baby/yell",
  swish = "dontstarve/creatures/beefalo_baby/tail_swish",
  curious = "dontstarve/creatures/beefalo_baby/curious",
  angry = "dontstarve/creatures/beefalo_baby/angry",
  sleep = "dontstarve/creatures/beefalo_baby/sleep",
}


local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, 30, function(dude)
      return dude:HasTag("ox") and not dude:HasTag("player") and not dude.components.health:IsDead()
    end, 5)
end

local function FollowGrownOx(inst)
  local nearest = FindEntity(inst, 30, function(guy)
      return guy.components.leader and guy.components.leader:CountFollowers() < 1
    end, {"ox"}, {"baby"})
  if nearest and nearest.components.leader then
    nearest.components.leader:AddFollower(inst)
  end
end

local function Grow(inst)
  if inst.components.sleeper:IsAsleep() then
    inst.hairGrowthPending = true
    inst.sg:GoToState("wake")
  else
    inst.sg:GoToState("hair_growth")
  end
end

local function GetGrowTime()
  return GetRandomWithVariance(TUNING.BABYBEEFALO_GROW_TIME.base, TUNING.BABYBEEFALO_GROW_TIME.random)
end

local function SetBaby(inst)
  local scale = 0.5
  inst.Transform:SetScale(scale, scale, scale)
  inst.components.lootdropper:SetLoot(babyloot)
  inst.components.sleeper:SetResistance(1)
end

local function SetToddler(inst)
  local scale = 0.7
  inst.Transform:SetScale(scale, scale, scale)
  inst.components.lootdropper:SetLoot(toddlerloot)
  inst.components.sleeper:SetResistance(2)
end

local function SetTeen(inst)
  local scale = 0.9
  inst.Transform:SetScale(scale, scale, scale)
  inst.components.lootdropper:SetLoot(teenloot)
  inst.components.sleeper:SetResistance(2)
end

local function SetFullyGrown(inst)
  local grown = SpawnPrefab("beefalo")
  grown.Transform:SetPosition(inst.Transform:GetWorldPosition() )
  grown.Transform:SetRotation(inst.Transform:GetRotation() )
  grown.sg:GoToState("hair_growth_pop")
  inst:Remove()
end

local growth_stages =
{
  {name="baby", time = GetGrowTime, fn = SetBaby},
  {name="toddler", time = GetGrowTime, fn = SetToddler, growfn = Grow},
  {name="teen", time = GetGrowTime, fn = SetTeen, growfn = Grow},
  {name="grown", time = GetGrowTime, fn = SetFullyGrown, growfn = Grow},
}

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.sounds = sounds
  local shadow = inst.entity:AddDynamicShadow()
  shadow:SetSize( 2.5, 1.25 )


  inst.Transform:SetSixFaced()
  inst.Transform:SetScale(0.5, 0.5, 0.5)

  MakeCharacterPhysics(inst, 100, .75)

  inst:AddTag("ox")
  inst:AddTag("baby")
  inst.AnimState:SetBank("beefalo")
  inst.AnimState:SetBuild("beefalo_baby_build")
  inst.AnimState:PlayAnimation("idle_loop", true)

  inst:AddTag("animal")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("eater")
  inst.components.eater:SetVegetarian()

  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "beefalo_body"

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.BABYBEEFALO_HEALTH)

  inst:AddComponent("lootdropper")

  inst:AddComponent("inspectable")
  inst:AddComponent("sleeper")

  inst:AddComponent("knownlocations")
  inst:AddComponent("herdmember")
  inst.components.herdmember.herdprefab = "oxherd"

  inst:AddComponent("follower")
  inst.components.follower.canaccepttarget = true

  inst:AddComponent("periodicspawner")
  inst.components.periodicspawner:SetPrefab("poop")
  inst.components.periodicspawner:SetRandomTimes(80, 110)
  inst.components.periodicspawner:SetDensityInRange(20, 2)
  inst.components.periodicspawner:SetMinimumSpacing(8)
  inst.components.periodicspawner:Start()

  inst:AddComponent("growable")
  inst.components.growable.stages = growth_stages
  inst.components.growable.growonly = true
  inst.components.growable:SetStage(1)
  inst.components.growable:StartGrowing()

  MakeLargeBurnableCharacter(inst, "swap_fire")

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.walkspeed = 2
  inst.components.locomotor.runspeed = 9

  MakeHauntablePanic(inst)

  inst:DoTaskInTime(1, FollowGrownOx)

  local brain = require "brains/babybeefalobrain"
  inst:SetBrain(brain)

  inst:SetStateGraph("SGBeefalo")

  inst:ListenForEvent("attacked", OnAttacked)

  return inst
end

return Prefab( "babyox", fn, assets, prefabs) 
%%+%%scripts/prefabs/ballphin.lua%%-%%local assets =
{
  Asset("ANIM", "anim/ballphin.zip"),
}

local prefabs =
{
  "fish_med",
  "fish_small",
  "messagebottleempty",
  "splash_water_drop",
  "ballphinpod",
  "dorsalfin",
}

local function ontalk(inst, script)
  inst.SoundEmitter:PlaySound("ia/creatures/balphin/taunt")
end

local brain = require "brains/ballphinbrain"


local SHARE_TARGET_DIST = 30

local function OnNewTarget(inst, data)
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end

local function retargetfn(inst)
  local dist = TUNING.BALLPHIN_TARGET_DIST
  return FindEntity(inst, dist, function(guy) 
      --return not guy:HasTag("wall") and not (guy:HasTag("ballphin") ) and inst.components.combat:CanTarget(guy)
      return guy.components.health and not guy.components.health:IsDead()
      and inst.components.combat:CanTarget(guy)
    end, {"monster"}, {"abigail"})
end

local function KeepTarget(inst, target)
  if inst:HasTag('ballphinfriend') then
    return inst.components.combat:CanTarget(target) and inst:GetDistanceSqToInst(target) <= (40*40)
  else
    return inst.components.combat:CanTarget(target) and inst:GetDistanceSqToInst(target) <= (TUNING.BALLPHIN_KEEP_TARGET_DIST*TUNING.BALLPHIN_KEEP_TARGET_DIST)
  end
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("ballphin")and not dude.components.health:IsDead() end, 5)
end

local function OnAttackOther(inst, data)
  inst.components.combat:ShareTarget(data.target, SHARE_TARGET_DIST, function(dude) return dude:HasTag("ballphin") and not dude.components.health:IsDead() end, 5)
  -- local splash = SpawnPrefab("splash_water_drop")
  -- local pos = inst:GetPosition()
  -- splash.Transform:SetPosition(pos.x, pos.y, pos.z)
end

local function CalcSanityAura(inst, observer)

  if inst.components.follower and inst.components.follower.leader == observer and inst.entity:IsVisible() then
    return TUNING.SANITYAURA_MED
  end

  return 0
end

local function ShouldAcceptItem(inst, item)
  if inst.components.sleeper:IsAsleep() then
    return false
  end

  if item.components.edible then

    if item.components.edible.foodtype == "MEAT" then
      if not item:HasTag("fishmeat") then
        return false
      end
      if inst.components.follower.leader and inst.components.follower:GetLoyaltyPercent() > 0.9 then
        return false
      end
    end

    if item.components.edible.foodtype == "VEGGIE" then
      -- print("being given food veggie")
      if not item:HasTag("hydrofarm") then
        return false
      end

      local last_eat_time = inst.components.eater:TimeSinceLastEating()
      if last_eat_time and last_eat_time < TUNING.BALLPHIN_MIN_POOP_PERIOD then
        return false
      end
    end

    return true
  end
end

local function OnGetItemFromPlayer(inst, giver, item)
  --I eat food
  if item.components.edible then

    --meat makes us friends (unless I'm a guard)
    if item:HasTag("fishmeat") then

      if inst.components.combat.target and inst.components.combat.target == giver then
        inst.components.combat:SetTarget(nil)
      elseif giver.components.leader and not inst:HasTag("guard") then
        inst.SoundEmitter:PlaySound("dontstarve/common/makeFriend")
        giver.components.leader:AddFollower(inst)
        local loyaltytime = math.min(TUNING.BALLPHIN_LOYALTY_MAX_TIME, item.components.edible:GetHunger() * TUNING.BALLPHIN_LOYALTY_PER_HUNGER)
        inst.components.follower:AddLoyaltyTime(loyaltytime)
      end

    end

    if inst.components.sleeper:IsAsleep() then
      inst.components.sleeper:WakeUp()
    end
  end

end

local function OnEat(inst, food)

end

local function OnRefuseItem(inst, item)
  --inst.sg:GoToState("refuse")
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end

local function preventdrowningtest(inst, leader)
	return inst:IsNear(leader, 32)
	and math.random() < TUNING.BALLPHIN_DROWN_RESCUE_CHANCE
end

local function fn()

  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  --local minimap = inst.entity:AddMiniMapEntity()
  --minimap:SetIcon( "fish.tex" )

  inst:AddTag("ballphin")
  inst:AddTag("aquatic")

  MakeCharacterPhysics(inst, 1, 0.5)
  -- inst.Physics:ClearCollisionMask()
  -- inst.Physics:CollidesWith(COLLISION.WORLD)
  inst.entity:AddSoundEmitter()

  inst.Transform:SetFourFaced()

  inst.entity:AddLightWatcher()

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.SOLOFISH_WALK_SPEED -- 2--3.0
  inst.components.locomotor.runspeed = TUNING.SOLOFISH_RUN_SPEED--5--6.0 

  inst:SetStateGraph("SGballphin")
  inst:SetBrain(brain)

  inst.AnimState:SetBank("ballphin")
  inst.AnimState:SetBuild("ballphin")  
  inst.AnimState:PlayAnimation("idle", true)

  inst:AddComponent("eater")
  inst.components.eater:SetOmnivore()
  inst.components.eater:SetCanEatHorrible()
  table.insert(inst.components.eater.preferseating, FOODTYPE.RAW)
  table.insert(inst.components.eater.caneat, FOODTYPE.RAW)
  inst.components.eater.strongstomach = true -- can eat monster meat!
  inst.components.eater:SetOnEatFn(OnEat)

  inst.AnimState:SetRayTestOnBB(true)

  inst:AddComponent("inspectable")
  inst.no_wet_prefix = true

  inst:AddComponent("herdmember")
  inst.components.herdmember.herdprefab = "ballphinpod"

  inst:AddComponent("teamattacker")
  inst.components.teamattacker.team_type = "ballphin"
  inst.components.teamattacker.leashdistance = 99999

  inst:AddComponent("knownlocations")

  inst:AddComponent("combat")
  inst.components.combat:SetDefaultDamage(TUNING.BALLPHIN_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.BALLPHIN_ATTACK_PERIOD)
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)
  inst.components.combat:SetHurtSound("ia/creatures/balphin/hit")	

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.BALLPHIN_HEALTH)

  inst:AddComponent("inventory")

  inst:AddComponent("named")
  inst.components.named.possiblenames = STRINGS.BALLPHINNAMES
  inst.components.named:PickNewName()

  inst:AddComponent("follower")
  inst.components.follower.maxfollowtime = TUNING.BALLPHIN_LOYALTY_MAX_TIME
  inst.components.follower:SetFollowExitDestinations({EXIT_DESTINATION.WATER})
  inst.components.follower.preventdrowningtest = preventdrowningtest


  inst:AddComponent("talker")
  inst.components.talker.ontalk = ontalk
  inst.components.talker.fontsize = 35
  inst.components.talker.font = TALKINGFONT
  inst.components.talker.offset = Vector3(0,-400,0)

  inst:AddComponent("trader")
  inst.components.trader:SetAcceptTest(ShouldAcceptItem)
  inst.components.trader.onaccept = OnGetItemFromPlayer
  inst.components.trader.onrefuse = OnRefuseItem

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aurafn = CalcSanityAura

  inst:AddComponent("sleeper")

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"fish_small", "fish_small", "dorsalfin"})
  inst.components.lootdropper:AddChanceLoot("messagebottleempty", TUNING.SNAKE_JUNGLETREE_CHANCE)

  inst:ListenForEvent("newcombattarget", OnNewTarget)
  inst:ListenForEvent("attacked", OnAttacked)
  inst:ListenForEvent("onattackother", OnAttackOther)
  inst:ListenForEvent("explosion", function(it, data)
      if inst.brain then
        inst.brain.afraid = true
        inst:DoTaskInTime(TUNING.SEG_TIME, function(inst)
            if inst and inst.brain then
              inst.brain.afraid = false
            end
          end)
      end
    end, TheWorld)
  inst:ListenForEvent("lightningstart", function(it, data)
      if inst.brain then
        inst.brain.afraid = true
        inst:DoTaskInTime(TUNING.SEG_TIME, function(inst)
            if inst and inst.brain then
              inst.brain.afraid = false
            end
          end)
      end
    end, TheWorld)

  MakeMediumFreezableCharacter(inst, "ballphin_body")

  return inst
end

return Prefab( "ballphin", fn, assets, prefabs)%%+%%scripts/prefabs/ballphinhouse.lua%%-%%require "prefabutil"
require "recipes"

local assets =
{
  Asset("ANIM", "anim/ballphin_house.zip"),
  Asset("SOUND", "sound/pig.fsb"),
}

local prefabs = 
{
  "ballphin",
}

local function onfar(inst) 

end

local function LightsOn(inst)
  if not inst:HasTag("burnt") then
    inst.Light:Enable(true)

    inst.AnimState:PlayAnimation("lit", true)
    inst.SoundEmitter:PlaySound("ia/common/ballphin_house/lit")
    inst.lightson = true
  end
end

local function LightsOff(inst)
  inst.Light:Enable(false)
  inst.AnimState:PlayAnimation("idle", true)
  inst.SoundEmitter:PlaySound("dontstarve/pig/pighut_lightoff")
  inst.lightson = false
end

local function getstatus(inst)
  if inst.components.spawner and inst.components.spawner:IsOccupied() then
    return "FULL"
  end
end

local function onnear(inst) 

end

local function onoccupied(inst, child)
  inst.SoundEmitter:PlaySound("ia/creatures/balphin/in_house_LP", "pigsound")
  inst.SoundEmitter:PlaySound("dontstarve/common/pighouse_door")

  if inst.doortask then
    inst.doortask:Cancel()
    inst.doortask = nil
  end

  inst.doortask = inst:DoTaskInTime(1, function() LightsOn(inst) end)

end

local function onvacate(inst, child)
  if inst.doortask then
    inst.doortask:Cancel()
    inst.doortask = nil
  end
  inst.SoundEmitter:PlaySound("dontstarve/common/pighouse_door")
  inst.SoundEmitter:KillSound("pigsound")

  if child then
    if child.components.health then
      child.components.health:SetPercent(1)
    end
  end    
end


local function onhammered(inst, worker)
  if inst:HasTag("fire") and inst.components.burnable then
    inst.components.burnable:Extinguish()
  end
  if inst.doortask then
    inst.doortask:Cancel()
    inst.doortask = nil
  end
  if inst.components.spawner then inst.components.spawner:ReleaseChild() end
  inst.components.lootdropper:DropLoot()
	local fx = SpawnPrefab("collapse_big")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("stone")
  inst:Remove()
end

local function ongusthammerfn(inst)
  onhammered(inst, nil)
end

local function onhit(inst, worker)
  if not inst:HasTag("burnt") then
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle")
  end
end

local function OnDay(inst)
  --print(inst, "OnDay")
  if not inst:HasTag("burnt") then
    if inst.components.spawner:IsOccupied() then
      LightsOff(inst)
      if inst.doortask then
        inst.doortask:Cancel()
        inst.doortask = nil
      end
      inst.doortask = inst:DoTaskInTime(1 + math.random()*2, function() inst.components.spawner:ReleaseChild() end)
    end
  end
end

local function onbuilt(inst)
  inst.SoundEmitter:PlaySound("ia/common/ballphin_house_craft")
  inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_medium")
  inst.AnimState:PlayAnimation("place")
  inst.AnimState:PushAnimation("idle")
end

local function onsave(inst, data)
  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end
end

local function onload(inst, data)
  if data and data.burnt then
    inst.components.burnable.onburnt(inst)
  end
end

local function fn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local light = inst.entity:AddLight()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon( "ballphinhouse.tex" )

  light:SetFalloff(1)
  light:SetIntensity(.5)
  light:SetRadius(2)
  light:Enable(false)
  light:SetColour(0/255, 180/255, 255/255)

  MakeObstaclePhysics(inst, 1)

  inst.AnimState:SetBank("ballphin_house")
  inst.AnimState:SetBuild("ballphin_house")
  inst.AnimState:PlayAnimation("idle", true)

  inst:AddTag("structure")

  MakeSnowCoveredPristine(inst)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("lootdropper")
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(4)
  inst.components.workable:SetOnFinishCallback(onhammered)
  inst.components.workable:SetOnWorkCallback(onhit)

  inst:AddComponent( "spawner" )
  inst.components.spawner:Configure( "ballphin", TUNING.TOTAL_DAY_TIME*4)
  inst.components.spawner.onoccupied = onoccupied
  inst.components.spawner.onvacate = onvacate
  inst:WatchWorldState( "isday", function() OnDay(inst) end)    

  inst:AddComponent( "playerprox" )
  inst.components.playerprox:SetDist(10,13)
  inst.components.playerprox:SetOnPlayerNear(onnear)
  inst.components.playerprox:SetOnPlayerFar(onfar)

  inst:AddComponent("inspectable")

  inst.components.inspectable.getstatus = getstatus

  MakeSnowCovered(inst, .01)

  inst:ListenForEvent("burntup", function(inst)
      if inst.doortask then
        inst.doortask:Cancel()
        inst.doortask = nil
      end
    end)
  inst:ListenForEvent("onignite", function(inst)
      if inst.components.spawner then
        inst.components.spawner:ReleaseChild()
      end
    end)

  inst.OnSave = onsave 
  inst.OnLoad = onload

  inst:ListenForEvent( "onbuilt", onbuilt)
  inst:DoTaskInTime(math.random(), function() 
      --print(inst, "spawn check day")
      if TheWorld.state.isday then 
        OnDay(inst)
      end 
    end)

  return inst
end

return Prefab( "ballphinhouse", fn, assets, prefabs ),
MakePlacer("ballphinhouse_placer", "ballphin_house", "ballphin_house", "idle", false, false, false)  
%%+%%scripts/prefabs/ballphinpod.lua%%-%%local assets =
{
  --Asset("ANIM", "anim/arrow_indicator.zip"),
}

local prefabs = 
{
  "ballphin",
}

local function InMood(inst)
  if inst.components.periodicspawner then
    inst.components.periodicspawner:Start()
  end
  if inst.components.herd then
    for k,v in pairs(inst.components.herd.members) do
      k:PushEvent("entermood")
    end
  end
end

local function LeaveMood(inst)
  if inst.components.periodicspawner then
    inst.components.periodicspawner:Stop()
  end
  if inst.components.herd then
    for k,v in pairs(inst.components.herd.members) do
      k:PushEvent("leavemood")
    end
  end
  inst.components.mood:CheckForMoodChange()
end

local function AddMember(inst, member)
  if inst.components.mood then
    if inst.components.mood:IsInMood() then
      member:PushEvent("entermood")
    else
      member:PushEvent("leavemood")
    end
  end
end

local function CanSpawn(inst)
  return inst.components.herd and not inst.components.herd:IsFull()
end

local function OnSpawned(inst, newent)
  if inst.components.herd then
    inst.components.herd:AddMember(newent)
  end
end

local function OnEmpty(inst)
  inst:Remove()
end

local function OnFull(inst)
  --TODO: mark some ballphin for death
end

local function fn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  -- inst.AnimState:SetBank("arrow_indicator")
  -- inst.AnimState:SetBuild("arrow_indicator")
  -- inst.AnimState:PlayAnimation("arrow_loop", true)

  inst:AddTag("herd")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("herd")
  inst.components.herd:SetMemberTag("ballphin")
  inst.components.herd:SetGatherRange(40)
  inst.components.herd:SetUpdateRange(20)
  inst.components.herd:SetOnEmptyFn(OnEmpty)
  inst.components.herd:SetOnFullFn(OnFull)
  inst.components.herd:SetAddMemberFn(AddMember)

  inst:AddComponent("mood")
  inst.components.mood:SetMoodTimeInDays(TUNING.BEEFALO_MATING_SEASON_LENGTH, TUNING.BEEFALO_MATING_SEASON_WAIT)
  inst.components.mood:SetMoodSeason(SEASONS.MILD)
  inst.components.mood:SetInMoodFn(InMood)
  inst.components.mood:SetLeaveMoodFn(LeaveMood)
  inst.components.mood:CheckForMoodChange()

  inst:AddComponent("periodicspawner")
  inst.components.periodicspawner:SetRandomTimes(TUNING.BEEFALO_MATING_SEASON_BABYDELAY, TUNING.BEEFALO_MATING_SEASON_BABYDELAY_VARIANCE)
  inst.components.periodicspawner:SetPrefab("ballphin")
  inst.components.periodicspawner:SetOnSpawnFn(OnSpawned)
  inst.components.periodicspawner:SetSpawnTestFn(CanSpawn)
  inst.components.periodicspawner:SetDensityInRange(20, 6)
  inst.components.periodicspawner:SetOnlySpawnOffscreen(true)

  return inst
end

return Prefab( "ballphinpod", fn, assets, prefabs)
%%+%%scripts/prefabs/ballphin_spawner.lua%%-%%local assets ={
}

local prefabs = 
{
  "ballphin",
  "ballphinpod",
}

local function spawnchildren(inst)
  local numChildren = 6
  local numBranches = 2
  local maxAngle = 120 * DEGREES
  local distanceBetween = 3
  local lastAngle = 0
  local x,y,z = inst.Transform:GetWorldPosition()
  local startAngle = math.random() * 360 * DEGREES
  local spawnedatleastone = false 

  for i = 1, numBranches do 
    local startAngle = startAngle + ((45 + math.random() * 270 ) * DEGREES)
    for ii = 1, numChildren do 


      local angle  = startAngle + -maxAngle/2 +  math.random() * maxAngle
      x = x + math.cos(angle) * distanceBetween
      z = z + math.sin(angle) * distanceBetween

      local onWater = inst:IsPosSurroundedByWater(x,y,z,2) 
      if not onWater then --If we're too close to land, bail out 
        break; 
      end 

      local child = SpawnPrefab("ballphin")
      child.Transform:SetPosition(x,y,z)
      spawnedatleastone = true 
      --x = x + distanceBetween
    end
  end
  if spawnedatleastone then 
    local herd = SpawnPrefab("ballphinpod")
    if herd then
      herd.Transform:SetPosition(inst.Transform:GetWorldPosition()) --Assumes the ballphinspawner was properly placed on the water during worldgen 
      if herd.components.herd then
        herd.components.herd:GatherNearbyMembers()
      end
    end
  end 

  inst:Remove() --Might want to keep this around to manage the spawned children, but for now just get rid of it
end

local function onsave(inst, data)
  if inst.targettime then
    local time = GetTime()
    if inst.targettime > time then
      data.time = math.floor(inst.targettime - time)
    end
  end
end
local function onload(inst, data)
  if data and data.time then
    local time = GetTime()
    local spawntime = data.time
    inst.targettime = time + spawntime
    inst.task = inst:DoTaskInTime(spawntime, spawnchildren)
  end
end

local function LongUpdate(inst, dt)

  if inst.targettime then

    if inst.task then
      inst.task:Cancel()
    end

    local time = GetTime()

    if inst.targettime > time + dt then
      --resechedule
      local spawntime = inst.targettime - time - dt

      inst.targettime = time + spawntime
      inst.task = inst:DoTaskInTime(spawntime, spawnchildren)
    else
      spawnchildren(inst)
    end
  end
end

local function fn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddNetwork()

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.OnLongUpdate = LongUpdate
  inst.OnSave = onsave
  inst.OnLoad = onload

  local spawntime = TUNING.TOTAL_DAY_TIME*15 + TUNING.TOTAL_DAY_TIME*math.random()

  inst.targettime = GetTime() + spawntime
  inst.task = inst:DoTaskInTime(spawntime, spawnchildren)

  return inst
end

return Prefab( "ballphin_spawner", fn, assets, prefabs) 
%%+%%scripts/prefabs/bamboo.lua%%-%%local assets=
{
  Asset("ANIM", "anim/bambootree.zip"),
  Asset("ANIM", "anim/bambootree_build.zip"),
}


local prefabs =
{
  "bamboo",
  "dug_bambootree",
  "hacking_bamboo_fx",
}

local function ontransplantfn(inst)
  if inst.components.hackable then
    inst.components.hackable:MakeBarren()
  end
end

local function dig_up(inst, chopper)
	if inst.components.hackable and inst.components.hackable:CanBeHacked() then
		inst.components.lootdropper:SpawnLootPrefab(inst.components.hackable.product)
	end
	
	if inst.components.diseaseable ~= nil and inst.components.diseaseable:IsBecomingDiseased() then
		SpawnDiseasePuff(inst)
		if chopper then
			chopper:PushEvent("digdiseasing")
		end
	end
	if inst.components.diseaseable ~= nil and inst.components.diseaseable:IsDiseased() then
		inst.components.lootdropper:SpawnLootPrefab("bamboo")
		SpawnDiseasePuff(inst)
	elseif inst.components.witherable and inst.components.witherable:IsWithered() then
		inst.components.lootdropper:SpawnLootPrefab("bamboo")
	else
		inst.components.lootdropper:SpawnLootPrefab("dug_bambootree")
	end
	inst:Remove()
end

local function onregenfn(inst)
  inst.AnimState:PlayAnimation("grow")
  inst.AnimState:PushAnimation("idle", true)
  inst.Physics:SetCollides(true)
end

local function makeemptyfn(inst)
  if not POPULATING and inst.components.witherable and inst.components.witherable:IsWithered() then
    inst.AnimState:PlayAnimation("dead_to_empty")
    inst.AnimState:PushAnimation("picked")
  else
    inst.AnimState:PlayAnimation("picked")
  end
  inst.Physics:SetCollides(false)
end

local function makebarrenfn(inst)
  if inst.components.witherable and inst.components.witherable:IsWithered() then
	if POPULATING then
		inst.AnimState:PlayAnimation("idle_dead")
	else
		if not inst.components.hackable.hasbeenhacked then
			inst.AnimState:PlayAnimation("full_to_dead")
		else
			inst.AnimState:PlayAnimation("empty_to_dead")
		end
		inst.AnimState:PushAnimation("idle_dead")
	end
  else
    inst.AnimState:PlayAnimation("idle_dead")
  end
  inst.Physics:SetCollides(true)
end


local function onhackedfn(inst, hacker, hacksleft)
	local fx = SpawnPrefab("hacking_bamboo_fx")
    local x, y, z= inst.Transform:GetWorldPosition()
    fx.Transform:SetPosition(x,y + math.random()*2,z)

	if(hacksleft <= 0) then

		inst.AnimState:PlayAnimation("picking")

		if inst.components.diseaseable and inst.components.diseaseable:IsDiseased() then
			SpawnDiseasePuff(inst)
		elseif inst.components.diseaseable and inst.components.diseaseable:IsBecomingDiseased() then
			SpawnDiseasePuff(inst)
			if hacker ~= nil then
				hacker:PushEvent("pickdiseasing")
			end
		end
			
		if inst.components.hackable and inst.components.hackable:IsBarren() then
			inst.AnimState:PushAnimation("idle_dead")
			inst.Physics:SetCollides(true)
		else
			inst.Physics:SetCollides(false)
			inst.SoundEmitter:PlaySound("ia/common/bamboo_drop")
			inst.AnimState:PushAnimation("picked")
		end
	else
		inst.AnimState:PlayAnimation("chop")
		inst.AnimState:PushAnimation("idle")
	end
	
	inst.SoundEmitter:PlaySound("ia/common/bamboo_hack")
end

--[[local function onguststart(inst, windspeed)
	if inst.components.hackable and inst.components.hackable:CanBeHacked() then
		inst.AnimState:PlayAnimation("blown_pre", false)
		inst.AnimState:PushAnimation("blown_loop", true)
		--inst.AnimState:PushAnimation("blown_pst", false)
		--inst.AnimState:PushAnimation("idle", true)
	end
end

local function ongustend(inst, windspeed)
	if inst.components.hackable and inst.components.hackable:CanBeHacked() then
		inst.AnimState:PushAnimation("blown_pst", false)
		inst.AnimState:PushAnimation("idle", true)
	end
end

local function ongusthackfn(inst)
	if inst.components.hackable and inst.components.hackable:CanBeHacked() then
        inst.components.hackable:MakeEmpty()
        inst.components.lootdropper:SpawnLootPrefab(inst.components.hackable.product)
	end
end]]

local function inspect_bambootree(inst)
  if inst:HasTag("burnt") then
    return "BURNT"
  elseif inst:HasTag("stump") then
    return "CHOPPED"
  end
end

local function makefn(stage)
  local function fn()
    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()
    local sound = inst.entity:AddSoundEmitter()
    local minimap = inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .35)

    minimap:SetIcon( "bambootree.tex" )

    inst.AnimState:SetBank("bambootree")
    inst.AnimState:SetBuild("bambootree_build")
    inst.AnimState:PlayAnimation("idle",true)
    inst.AnimState:SetTime(math.random()*2)
    local color = 0.75 + math.random() * 0.25
    inst.AnimState:SetMultColour(color, color, color, 1)

	inst:AddTag("witherable") -- added to pristine state for optimization
    inst:AddTag("gustable")
	inst:AddTag("plant")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("hackable")
    --inst.components.pickable.picksound = "dontstarve/wilson/pickup_reeds"

    --inst.components.pickable:SetUp("bamboo", TUNING.BAMBOO_REGROW_TIME)
    inst.components.hackable:SetUp("bamboo", TUNING.BAMBOO_REGROW_TIME)
    inst.components.hackable.onregenfn = onregenfn
    inst.components.hackable.onhackedfn = onhackedfn
    inst.components.hackable.makeemptyfn = makeemptyfn
    inst.components.hackable.makebarrenfn = makebarrenfn
    inst.components.hackable.max_cycles = 20
    inst.components.hackable.cycles_left = 20
    inst.components.hackable.ontransplantfn = ontransplantfn
    inst.components.hackable.hacksleft = TUNING.BAMBOO_HACKS
    inst.components.hackable.maxhacks = TUNING.BAMBOO_HACKS

	inst:AddComponent("witherable")
	
    if stage == 1 then
      inst.components.hackable:MakeBarren()
    end

    inst:AddComponent("lootdropper")
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_bambootree

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.DIG)
    inst.components.workable:SetOnFinishCallback(dig_up)
    inst.components.workable:SetWorkLeft(1)

	MakeHackableBlowInWindGust(inst, TUNING.BAMBOO_WINDBLOWN_SPEED, TUNING.BAMBOO_WINDBLOWN_FALL_CHANCE)
    --[[inst:AddComponent("blowinwindgust")
	    inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.BAMBOO_WINDBLOWN_SPEED)
	    inst.components.blowinwindgust:SetDestroyChance(TUNING.BAMBOO_WINDBLOWN_FALL_CHANCE)
	    inst.components.blowinwindgust:SetGustStartFn(onguststart)
	    inst.components.blowinwindgust:SetGustEndFn(ongustend)
	    inst.components.blowinwindgust:SetDestroyFn(ongusthackfn)
	    inst.components.blowinwindgust:Start()]]

    ---------------------

    MakeMediumBurnable(inst)
    MakeSmallPropagator(inst)
    --MakeNoGrowInWinter(inst)
    MakeHauntableIgnite(inst)
    ---------------------

    return inst
  end

  return fn
end


local function bamboo(name, stage)
  return Prefab(name, makefn(stage), assets, prefabs)
end

return bamboo("bambootree", 0),
bamboo("depleted_bambootree", 1)
%%+%%scripts/prefabs/barrel_gunpowder.lua%%-%%local assets =
{
    Asset("ANIM", "anim/gunpowder_barrel.zip"),
    Asset("ANIM", "anim/explode.zip"),
    Asset("MINIMAP_IMAGE", "barrel_gunpowder")
}

local prefabs =
{
    "explode_small",
}

local function OnIgnite(inst)
    inst.SoundEmitter:PlaySound("dontstarve/common/blackpowder_fuse_LP", "hiss")
end

local function OnExplode(inst)
    inst.SoundEmitter:KillSound("hiss")

    local pos = inst:GetPosition()
    SpawnWaves(inst, 6, 360, 5)
    local splash = SpawnPrefab("bombsplash")
    splash.Transform:SetPosition(pos.x, pos.y, pos.z)

    inst.SoundEmitter:PlaySound("ia/common/powderkeg/powderkeg")
    inst.SoundEmitter:PlaySound("ia/common/powderkeg/splash_medium")
end
local function OnHit(inst)
    if inst.components.burnable then
        inst.components.burnable:Ignite()
    end
    if inst.components.freezable then
        inst.components.freezable:UnFreeze()
    end
    if inst.components.health then
        inst.components.health:DoFireDamage(0)
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    
    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("barrel_gunpowder.tex")

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("gunpowder_barrel")
    inst.AnimState:SetBuild("gunpowder_barrel")
    inst.AnimState:PlayAnimation("idle_water")

    --MakeRipples(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    
    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(1000000)

    inst:AddComponent("combat")
    inst.components.combat:SetOnHit(OnHit)

    MakeSmallBurnable(inst, 3 + math.random() * 3)
    MakeSmallPropagator(inst)

    inst.components.burnable:SetOnBurntFn(nil)

    inst:AddComponent("explosive")
    inst.components.explosive:SetOnExplodeFn(OnExplode)
    inst.components.explosive:SetOnIgniteFn(OnIgnite)
    inst.components.explosive.explosiverange = TUNING.BARREL_GUNPOWDER_RANGE
    inst.components.explosive.explosivedamage = TUNING.BARREL_GUNPOWDER_DAMAGE
    inst.components.explosive.buildingdamage = 0

	-- er... this can't even go to the altar?
    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.WRATH_HUGE

    return inst
end

return Prefab("barrel_gunpowder", fn, assets, prefabs)%%+%%scripts/prefabs/bermudatriangle.lua%%-%%require "stategraphs/SGbermudatriangle"

local assets=
{
	Asset("ANIM", "anim/bermudatriangle.zip"),
	Asset("ANIM", "anim/teleporter_worm.zip"),
	Asset("ANIM", "anim/teleporter_worm_build.zip"),
    Asset("SOUND", "sound/common.fsb"),
}


local function GetStatus(inst)
	if inst.sg.currentstate.name ~= "idle" then
		return "OPEN"
	end
end

local function OnActivate(inst, doer, target)
	if doer:HasTag("player") then
        --ProfileStatsSet("wormhole_used", true)
		-- doer.components.health:SetInvincible(true)
		-- if TUNING.DO_SEA_DAMAGE_TO_BOAT and (doer.components.sailor and doer.components.sailor.boat and doer.components.sailor.boat.components.boathealth) then
			-- doer.components.sailor.boat.components.boathealth:SetInvincible(true)
		-- end
		-- doer.components.playercontroller:Enable(false)
		
		if inst.components.teleporter.targetTeleporter ~= nil then
			DeleteCloseEntsWithTag("WORM_DANGER", inst.components.teleporter.targetTeleporter, 15)
		end
		
        if doer.components.talker ~= nil then
            doer.components.talker:ShutUp()
        end
        if doer.components.sanity ~= nil then
            doer.components.sanity:DoDelta(-TUNING.SANITY_MED)
        end

		-- TheLocalPlayer.HUD:Hide()
		-- --TheFrontEnd:SetFadeLevel(1)
        -- TheCamera:SetTarget(inst)
		-- TheFrontEnd:Fade(false, 0.5)
		-- doer:DoTaskInTime(2, function()
            -- TheCamera:SetTarget(target)
            -- TheCamera:Snap()
			-- TheFrontEnd:Fade(true, 0.5)
			-- TheLocalPlayer.HUD:Show()
			-- --doer.sg:GoToState("wakeup")
			-- if doer.components.sanity then
				-- doer.components.sanity:DoDelta(-TUNING.SANITY_MED)
			-- end
		-- end)
		-- doer:DoTaskInTime(3.5, function()
			-- TheCamera:SetTarget(TheLocalPlayer)
			-- doer:PushEvent("bermudatriangleexit")
			-- doer.components.health:SetInvincible(false)
			-- if TUNING.DO_SEA_DAMAGE_TO_BOAT and (doer.components.sailor and doer.components.sailor.boat and doer.components.sailor.boat.components.boathealth) then
				-- doer.components.sailor.boat.components.boathealth:SetInvincible(false)
			-- end
			-- doer.components.playercontroller:Enable(true)
		-- end)
		--doer.SoundEmitter:PlaySound("ia/common/bermuda/travel", "wormhole_travel")
	elseif doer.SoundEmitter then
		-- inst.SoundEmitter:PlaySound("ia/common/bermuda/spark", "wormhole_swallow")
	end
end

local function OnDoneTeleporting(inst, obj)
    if inst.closetask ~= nil then
        inst.closetask:Cancel()
    end
    inst.closetask = inst:DoTaskInTime(1.5, function()
        if not (inst.components.teleporter:IsBusy() or
                inst.components.playerprox:IsPlayerClose()) then
            inst.sg:GoToState("closing")
        end
    end)
    -- inst.SoundEmitter:PlaySound("ia/common/bermuda/spark")

    if obj ~= nil and obj:HasTag("player") then
        obj:DoTaskInTime(1, obj.PushEvent, "bermudatriangleexit") -- for wisecracker
    end
end

local function OnActivateByOther(inst, source, doer)
    if not inst.sg:HasStateTag("open") then
        inst.sg:GoToState("opening")
    end
end

local function onnear(inst)
    if inst.components.teleporter:IsActive() and not inst.sg:HasStateTag("open") then
        inst.sg:GoToState("opening")
    end
end

local function onfar(inst)
    if not inst.components.teleporter:IsBusy() and inst.sg:HasStateTag("open") then
        inst.sg:GoToState("closing")
    end
end

local function onaccept(inst, giver, item)
    inst.components.inventory:DropItem(item)
    inst.components.teleporter:Activate(item)
end

local function StartTravelSound(inst, doer)
    -- inst.SoundEmitter:PlaySound("ia/common/bermuda/spark")
    -- doer:PushEvent("wormholetravel", WORMHOLETYPE.BERMUDA) --Event for playing local travel sound
	--TODO we should really use a custom event for this
	--or use the stategraph to hack it in?
		--doer.SoundEmitter:PlaySound("ia/common/bermuda/travel", "wormhole_travel")
end

local function fn(Sim)
	local inst = CreateEntity()
	
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("bermudatriangle.tex")
   
    inst.AnimState:SetBank("bermudatriangle")
    inst.AnimState:SetBuild("bermudatriangle")
    inst.AnimState:PlayAnimation("idle_loop", true)
	inst.AnimState:SetLayer(LAYER_BACKGROUND)
	inst.AnimState:SetSortOrder(3)
	inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
    
	local s = 1.3
	inst.Transform:SetScale(s,s,s)

    --trader, alltrader (from trader component) added to pristine state for optimization
    inst:AddTag("trader")
    inst:AddTag("alltrader")

    inst:AddTag("antlion_sinkhole_blocker")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
	
	inst:SetStateGraph("SGbermudatriangle")
    
    inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = GetStatus

	inst:AddComponent("playerprox")
	inst.components.playerprox:SetDist(4,5)
    inst.components.playerprox.onnear = onnear
    inst.components.playerprox.onfar = onfar

	inst:AddComponent("teleporter")
	inst.components.teleporter.onActivate = OnActivate
    inst.components.teleporter.onActivateByOther = OnActivateByOther
	inst.components.teleporter.offset = 0
	
    inst:ListenForEvent("starttravelsound", StartTravelSound) -- triggered by player stategraph
    inst:ListenForEvent("doneteleporting", OnDoneTeleporting)

	inst:AddComponent("inventory")

	inst:AddComponent("trader")
    inst.components.trader.acceptnontradable = true
    inst.components.trader.onaccept = onaccept
    inst.components.trader.deleteitemonaccept = false
	
	--print("Bermuda Spawned!")

    return inst
end

return Prefab( "bermudatriangle", fn, assets) 
%%+%%scripts/prefabs/berrybush2_snake.lua%%-%%local prefabs = {
    "berrybush2",
    "snake",
}

local function SpawnDiseasePuff(inst)
    SpawnPrefab("disease_puff").Transform:SetPosition(inst.Transform:GetWorldPosition())
end

local function setberries(inst, pct)
    if inst._setberriesonanimover then
        inst._setberriesonanimover = nil
        inst:RemoveEventCallback("animover", setberries)
    end

    local berries =
        (pct == nil and "") or
        (pct >= .9 and "berriesmost") or
        (pct >= .33 and "berriesmore") or
        "berries"

    for i, v in ipairs({ "berries", "berriesmore", "berriesmost" }) do
        if v == berries then
            inst.AnimState:Show(v)
        else
            inst.AnimState:Hide(v)
        end
    end
end

local function cancelsetberriesonanimover(inst)
    if inst._setberriesonanimover then
        setberries(inst, nil)
    end
end

local function shake(inst)
    if inst.components.pickable ~= nil and
        not inst.components.pickable:CanBePicked() and
        inst.components.pickable:IsBarren() then
        inst.AnimState:PlayAnimation("shake_dead")
        inst.AnimState:PushAnimation("dead", false)
    else
        inst.AnimState:PlayAnimation("shake")
        inst.AnimState:PushAnimation("idle")
    end
    cancelsetberriesonanimover(inst)
    inst.SoundEmitter:PlaySound("ia/creatures/snake/snake_bush")
end

local function spawn_snake(inst)
	local snake = SpawnPrefab("snake")
	local spawnpos = inst:GetPosition()
	local offset = FindWalkableOffset(spawnpos, math.random() * 2 * PI, 1, 8, true, false, IsPositionValidForEnt(inst, 2))
	spawnpos = offset ~= nil and spawnpos + offset or spawnpos
	snake.Transform:SetPosition(spawnpos:Get())
end

local function check_spawn_snake(inst)
    if inst:IsValid() then
        local distsq = inst:GetDistanceSqToClosestPlayer()

        if distsq < 4 then
            if math.random() > 0.75 then
				spawn_snake(inst)
                shake(inst)
            end
        end

        inst:DoTaskInTime(5+(math.random()*2), check_spawn_snake)
    end
end

local function OnHaunt(inst)
    shake(inst)
    if math.random() <= TUNING.HAUNT_CHANCE_RARE then
		spawn_snake(inst)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_COOLDOWN_LARGE
	else
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_COOLDOWN_TINY
    end
    return true
end

local function fn()
	local inst = Prefabs["berrybush2"].fn()
	
	if not inst.SoundEmitter then inst.entity:AddSoundEmitter() end

    inst.realprefab = "berrybush2_snake"

    inst:SetPrefabName("berrybush2")

	if not TheWorld.ismastersim then
		return inst
	end

    inst:DoTaskInTime(5+(math.random()*2), check_spawn_snake)

	AddHauntableCustomReaction(inst, OnHaunt, false, false, true)
	
	return inst
end


return Prefab("berrybush2_snake", fn, nil, prefabs)
%%+%%scripts/prefabs/bioluminescence.lua%%-%%local assets = {
    Asset("ANIM", "anim/bioluminescence.zip"),
}

--This has to be a multiple of 1/32 or else the float netvar loses precision and stays below INTENSITY
--Ideally, don't use a netvar for this at all. -M
local INTENSITY = .65625 --.65

local function randomizefadein()
    return math.random(1, 31)
end

local function randomizefadeout()
    return math.random(32, 63)
end

local function immediatefadeout()
    return 0
end

local function resolvefaderate(x)
    --immediate fadeout -> 0
    --randomize fadein -> INTENSITY * FRAMES / (1 + math.random())
    --randomize fadeout -> -INTENSITY * FRAMES / (.5 + math.random())
    return (x == 0 and 0)
        or (x < 32 and INTENSITY * FRAMES / (x / 31 + 1))
        or INTENSITY * FRAMES / ((32 - x) / 31 - 0.5)
end

local function updatefade(inst, rate)
    inst._fadeval:set_local(math.clamp(inst._fadeval:value() + rate, 0, INTENSITY))

    --Client light modulation is enabled:
    inst.Light:SetIntensity(inst._fadeval:value())

    if rate == 0 or
        (rate < 0 and inst._fadeval:value() <= 0) or
        (rate > 0 and inst._fadeval:value() >= INTENSITY) then
        inst._fadetask:Cancel()
        inst._fadetask = nil
        if inst._fadeval:value() <= 0 and TheWorld.ismastersim then
            inst:AddTag("NOCLICK")
            inst.Light:Enable(false)
            inst:Hide()
        end
    end
end

local function fadein(inst)
    local ismastersim = TheWorld.ismastersim
    if not ismastersim or resolvefaderate(inst._faderate:value()) <= 0 then
        if ismastersim then
            inst:RemoveTag("NOCLICK")
            inst.Light:Enable(true)
            inst:Show()
            inst.AnimState:PlayAnimation("idle_pre")
            inst.AnimState:PushAnimation("idle_loop", true)
            inst._faderate:set(randomizefadein())
        end
        if inst._fadetask ~= nil then
            inst._fadetask:Cancel()
            inst._fadetask = nil
        end
        local rate = resolvefaderate(inst._faderate:value()) * math.clamp(1 - inst._fadeval:value() / INTENSITY, 0, 1)
        inst._fadetask = inst:DoPeriodicTask(FRAMES, updatefade, nil, rate)
        if not ismastersim then
            updatefade(inst, rate)
        end
    end
end

local function fadeout(inst)
    local ismastersim = TheWorld.ismastersim
    if not ismastersim or resolvefaderate(inst._faderate:value()) > 0 then
        if ismastersim then
            inst.AnimState:PlayAnimation("idle_pst")
            inst._faderate:set(randomizefadeout())
        end
        if inst._fadetask ~= nil then
            inst._fadetask:Cancel()
            inst._fadetask = nil
        end
        local rate = resolvefaderate(inst._faderate:value()) * math.clamp(inst._fadeval:value() / INTENSITY, 0, 1)
        inst._fadetask = inst:DoPeriodicTask(FRAMES, updatefade, nil, rate)
        if not ismastersim then
            updatefade(inst, rate)
        end
    end
end

local function OnFadeRateDirty(inst)
    local rate = resolvefaderate(inst._faderate:value())
    if rate > 0 then
        fadein(inst)
    elseif rate < 0 then
        fadeout(inst)
    elseif inst._fadetask ~= nil then
        inst._fadetask:Cancel()
        inst._fadetask = nil
        inst._fadeval:set_local(0)

        --Client light modulation is enabled:
        inst.Light:SetIntensity(0)
    end
end

local function updatelight(inst)
    if TheWorld.state.phase ~= "day" and inst.components.inventoryitem.owner == nil then
        fadein(inst)
    elseif TheWorld.state.phase == "day" and inst.components.inventoryitem.owner == nil then
        fadeout(inst)
    end
end

local function ondropped(inst)
    inst.components.workable:SetWorkLeft(1)
    inst._fadeval:set(0)
    inst._faderate:set_local(immediatefadeout())
    fadein(inst)
    inst:DoTaskInTime(2 + math.random(), updatelight)
end

local function onpickup(inst)
    if inst._fadetask ~= nil then
        inst._fadetask:Cancel()
        inst._fadetask = nil
    end
    inst._fadeval:set_local(0)
    inst._faderate:set(immediatefadeout())
    inst.Light:SetIntensity(0)
    inst.Light:Enable(false)
end

local function onhitland(inst) 
    --When the game loads, these are temporarily not in an inventory.. so they were hitting the ground and being
    --destroyed. Delaying a frame waits until they have a chance to be inventoried before being removed. 
    --Load post pass might also have worked
    inst:DoTaskInTime(0, function()
        if not inst.components.inventoryitem.owner then   
            local x, y, z = inst.Transform:GetLocalPosition()
            local fx = SpawnPrefab("splash_water_drop")
            fx.Transform:SetPosition(x, y, z)
            inst:Remove()
        end
    end)
end

local function onlanded(inst)
	if IsOnWater(inst) then
		updatelight(inst)
	else
		onhitland(inst)
	end
end

local function onworked(inst, worker)
    if worker.components.inventory ~= nil then
        worker.components.inventory:GiveItem(inst, nil, inst:GetPosition())
    end
end

local function onphase(inst)
    inst:DoTaskInTime(2 + math.random(), updatelight)
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst.Light:SetFalloff(0.45)
    inst.Light:SetIntensity(INTENSITY)
    inst.Light:SetRadius(0.9)
    inst.Light:SetColour(0/255, 180/255, 255/255)
    inst.Light:SetIntensity(0)
    inst.Light:Enable(false)
    inst.Light:EnableClientModulation(true)

    inst.AnimState:SetBank("bioluminessence")
    inst.AnimState:SetBuild("bioluminessence")
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)
    inst.AnimState:SetRayTestOnBB(true)

    MakeInventoryPhysics(inst)

    inst.no_wet_prefix = true

    inst:AddTag("NOCLICK")
    inst:AddTag("NOBLOCK")
    inst:AddTag("unramable")
    inst:AddTag("aquatic")

    inst._fadeval = net_float(inst.GUID, "bioluminescence._fadeval")
    inst._faderate = net_smallbyte(inst.GUID, "bioluminescence._faderate", "onfaderatedirty")
    inst._fadetask = nil

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        inst:ListenForEvent("onfaderatedirty", OnFadeRateDirty)

        return inst
    end
    
    inst:Hide()

    inst:AddComponent("inspectable")

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.NET)
    inst.components.workable:SetWorkLeft(1)
    inst.components.workable:SetOnFinishCallback(onworked)

    inst:AddComponent("stackable")
    inst.components.stackable.forcedropsingle = true

    MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnDroppedFn(ondropped)
    inst.components.inventoryitem:SetOnPickupFn(onpickup)
    inst.components.inventoryitem.canbepickedup = false
    inst.components.inventoryitem.canbepickedupalive = true

    inst:AddComponent("fuel")
    inst.components.fuel.fuelvalue = TUNING.LARGE_FUEL
    inst.components.fuel.fueltype = "CAVE"

	inst:ListenForEvent("on_landed", onlanded)

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

    inst:WatchWorldState("phase", onphase)
    
    updatelight(inst)

    return inst
end

return Prefab("bioluminescence", fn, assets)%%+%%scripts/prefabs/bioluminescence_spawner.lua%%-%%local prefabs = {
	"bioluminescence",
}

local spawnchildren

local function regenchildren(inst)
    inst.regentime = nil
    spawnchildren(inst)
end

local function onchildworked(inst, child, data)
    table.removearrayvalue(inst.children, child)

    inst:RemoveEventCallback("onpickup", inst.onchildworked, child)
    inst:RemoveEventCallback("onremove", inst.onchildworked, child)

    if #inst.children == 0 then
        local st = TheWorld.state

        local timetoregen = ((st.autumnlength + st.winterlength + st.springlength + st.summerlength) / 2) * TUNING.TOTAL_DAY_TIME
        inst.regentime = timetoregen + GetTime()
        inst:DoTaskInTime(timetoregen, regenchildren)
    end
end

spawnchildren = function(inst)
    if #inst.children ~= 0 or inst.regentime ~= nil then return end

	local numChildren = 6
	local numBranches = 2
	local maxAngle = 120 * DEGREES
	local distanceBetween = 3
	local lastAngle = 0
	local x,y,z = inst.Transform:GetWorldPosition()
	local startAngle = math.random() * 360 * DEGREES
	
	for i = 1, numBranches do 
		local startAngle = startAngle + ((45 + math.random() * 270 ) * DEGREES)
		for ii = 1, numChildren do 
			local angle  = startAngle + -maxAngle/2 +  math.random() * maxAngle
			x = x + math.cos(angle) * distanceBetween
			z = z + math.sin(angle) * distanceBetween
			local onWater = inst:IsPosSurroundedByWater(x,y,z,2) 
			if not onWater then
				break
			end
			local child = SpawnPrefab("bioluminescence")
	     	child.Transform:SetPosition(x,y,z)
            inst.children[#inst.children + 1] = child
            inst:ListenForEvent("onpickup", inst.onchildworked, child)
            inst:ListenForEvent("onremove", inst.onchildworked, child)
		end 
	end
end

local function OnSave(inst, data)
    data.children = {}

    for i, v in ipairs(inst.children) do
        table.insert(data.children, v.GUID)
    end

    if inst.regentime ~= nil then
        data.regentime = inst.regentime - GetTime()
    end

    return #data.children >= 1 and data.children or nil
end

local function OnLoad(inst, data, newents)
    if data and data.regentime then
        inst.regentime = data.regentime + GetTime()
        inst:DoTaskInTime(data.regentime, regenchildren)
    end
end

local function OnLoadPostPass(inst, newents, data)
    if data and data.children then
        for i, v in ipairs(data.children) do
            local child = newents[v]
            if child then
                child = child.entity
                inst.children[i] = child
                inst:ListenForEvent("onpickup", inst.onchildworked, child)
                inst:ListenForEvent("onremove", inst.onchildworked, child)
            end
        end
    end
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	
	inst:AddTag("NOCLICK")
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
    inst.children = {}

    inst.onchildworked = function(child, data) onchildworked(inst, child, data) end

	inst:DoTaskInTime(5*FRAMES, spawnchildren)

    inst.OnSave = OnSave
    inst.OnLoad = OnLoad
    inst.OnLoadPostPass = OnLoadPostPass
	
    return inst
end

return Prefab("bioluminescence_spawner", fn, nil, prefabs) 
%%+%%scripts/prefabs/blubber.lua%%-%%local assets=
{
	Asset("ANIM", "anim/blubber.zip"),
}

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddNetwork()

	inst.AnimState:SetBank("blubber")
	inst.AnimState:SetBuild("blubber")
	inst.AnimState:PlayAnimation("idle")
	
	MakeInventoryPhysics(inst)
	
	inst:AddTag("fishmeat")
    inst:AddTag("waterproofer")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
	
	inst:AddComponent("inspectable")
	
	MakeInvItemIA(inst)
	inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM    
	
	inst:AddComponent("edible")
	inst.components.edible.foodtype = FOODTYPE.MEAT
	-- Does this thing just... not have any food values? -M

	inst:AddComponent("fuel")
	inst.components.fuel.fuelvalue = TUNING.LARGE_FUEL

	inst:AddComponent("waterproofer")
	inst.components.waterproofer.effectiveness = 0
	
	inst:AddComponent("tradable")
    inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

	return inst
end

return Prefab( "blubber", fn, assets) 
%%+%%scripts/prefabs/boatcannon.lua%%-%%local MakeVisualBoatEquip = require("prefabs/visualboatequip")

local assets = {
    Asset("ANIM", "anim/swap_cannon.zip"),
}

local prefabs = {
    "cannonshot",
    "collapse_small",
}

local woodlegs_assets = {
    Asset("ANIM", "anim/swap_cannon_pirate.zip"),
}

local woodlegs_prefabs = {
    "woodlegs_cannonshot",
    "collapse_small",
}

local function onequip(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:SpawnBoatEquipVisuals(inst, inst.prefab)
    end
    if inst.visual then
        inst.visual.AnimState:OverrideSymbol("swap_lantern", inst.swap_build, "swap_cannon")
    end
end

local function onunequip(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:RemoveBoatEquipVisuals(inst)
    end
    if inst.visual then
        inst.visual.AnimState:ClearOverrideSymbol("swap_lantern")
    end

    if inst.RemoveOnUnequip then
        inst:DoTaskInTime(2*FRAMES, inst.Remove)
    end
end

local function onthrowfn(inst)
    if inst.components.finiteuses then
        inst.components.finiteuses:Use()
    end
end

local function common()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()
    
    inst.AnimState:SetBank("cannon")
    inst.AnimState:SetBuild("swap_cannon")
    inst.AnimState:PlayAnimation("idle")

    MakeInventoryPhysics(inst)

    inst:AddComponent("reticule")
    inst.components.reticule.targetfn = function() 
        return inst.components.thrower:GetThrowPoint()
    end
    inst.components.reticule.ease = true

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst:AddTag("cannon")

    return inst
end

local function master(inst)
    MakeInvItemIA(inst)
        
    inst:AddComponent("inspectable")

    inst:AddComponent("equippable")
    inst.components.equippable.boatequipslot = BOATEQUIPSLOTS.BOAT_LAMP
    inst.components.equippable.equipslot = nil
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst:AddComponent("finiteuses")
    inst.components.finiteuses:SetMaxUses(TUNING.BOATCANNON_AMMO_COUNT)
    inst.components.finiteuses:SetUses(TUNING.BOATCANNON_AMMO_COUNT)
    inst.components.finiteuses:SetOnFinished(inst.Remove)

    --TODO use complexprojectile --how -Z?
    inst:AddComponent("thrower")
    inst.components.thrower.throwable_prefab = "cannonshot"
    inst.components.thrower.onthrowfn = onthrowfn

    function inst.components.thrower.getthrowposition(inst)
        if inst.visual then
            return inst.visual.AnimState:GetSymbolPosition("swap_lantern", 0, 0, 0)
        else 
            return inst.Transform:GetWorldPosition()
        end
    end

    return inst
end

local function cannon_fn()

    --NOTE!! Most of the logic for this happens in cannonshot.lua

    local inst = common()

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst = master(inst)

    inst.swap_build = "swap_cannon"

    return inst
end

local function woodlegs_fn()

    --NOTE!! Most of the logic for this happens in cannonshot.lua

    local inst = common()

    inst.AnimState:SetBuild("swap_cannon_pirate")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst = master(inst)

    inst:RemoveComponent("finiteuses")

    inst.RemoveOnUnequip = true
    
    inst.components.thrower.throwable_prefab = "woodlegs_cannonshot"

    inst.swap_build = "swap_cannon_pirate"

    return inst
end

function boatcannon_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_cannon")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_DOWN then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

function woodlegs_boatcannon_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_cannon_pirate")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_DOWN then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

return Prefab("boatcannon", cannon_fn, assets, prefabs),
    Prefab("woodlegs_boatcannon", woodlegs_fn, woodlegs_assets, woodlegs_prefabs),
    MakeVisualBoatEquip("boatcannon", assets, nil, boatcannon_visual_common),
    MakeVisualBoatEquip("woodlegs_boatcannon", woodlegs_assets, nil, woodlegs_boatcannon_visual_common)%%+%%scripts/prefabs/boatcontainer_classified.lua%%-%%--------------------------------------------------------------------------
--[[ Dependencies ]]
--------------------------------------------------------------------------

local containers = require("containers")
local EquipSlot = require("equipslotutil")

--------------------------------------------------------------------------
--[[ Constants ]]
--------------------------------------------------------------------------

local TIMEOUT = 2

--------------------------------------------------------------------------
--Common interface
--------------------------------------------------------------------------

local function InitializeSlots(inst, numslots)
    --Can't re-initialize slots after RegisterNetListeners
    assert(inst._slottasks == nil)

    local curslots = #inst._items
    if numslots > curslots then
        for i = curslots + 1, numslots do
            table.insert(inst._items, table.remove(inst._itemspool, 1))
        end
    elseif numslots < curslots then
        for i = curslots, numslots + 1, -1 do
            table.insert(inst._itemspool, 1, table.remove(inst._items))
        end
    end
end

--------------------------------------------------------------------------
--Server interface
--------------------------------------------------------------------------

local function SetSlotItem(inst, slot, item, src_pos)
    if inst._items[slot] ~= nil then
        inst._items[slot]:set(item)

        if item ~= nil and inst._items[slot]:value() == item then
            local inventoryitem = item.replica.inventoryitem
            inventoryitem:SerializeUsage()
            inventoryitem:SetPickupPos(src_pos)
        else
            inst._items[slot]:set(nil)
        end
    end
end

local function SetSlotBoatEquip(inst, eslot, item)
    if inst._boatequips[eslot] ~= nil then
        inst._boatequips[eslot]:set(item)

        if item ~= nil and inst._boatequips[eslot]:value() == item then
            item.replica.inventoryitem:SerializeUsage()
        else
            inst._boatequips[eslot]:set(nil)
        end
    end
end

--------------------------------------------------------------------------
--Client interface
--------------------------------------------------------------------------

local function OnRemoveEntity(inst)
    if inst._parent ~= nil then
        inst._parent.boatcontainer_classified = nil
    end
end

local function OnEntityReplicated(inst)
    inst._parent = inst.entity:GetParent()
    if inst._parent == nil then
        print("Unable to initialize classified data for container")
    elseif inst._parent.replica.container ~= nil then
        inst._parent.replica.container:AttachClassified(inst)
    else
        inst._parent.boatcontainer_classified = inst
        inst.OnRemoveEntity = OnRemoveEntity
    end
end

local function IsBusy(inst)
    return inst._busy or inst._parent == nil
end

local function CheckItem(item, target, checkcontainer)
    return target ~= nil
        and (item == target
            or (checkcontainer and
                target.replica.container ~= nil and
                target.replica.container:IsHolding(item, checkcontainer)))
end

local function IsHolding(inst, item, checkcontainer)
    if inst._itemspreview ~= nil then
        for k, v in pairs(inst._itemspreview) do
            if CheckItem(item, v, checkcontainer) then
                return true
            end
        end
    else
        for i, v in ipairs(inst._items) do
            if CheckItem(item, v:value(), checkcontainer) then
                return true
            end
        end
    end
    if inst._boatequipspreview ~= nil then
        for k, v in pairs(inst._boatequipspreview) do
            if CheckItem(item, v, checkcontainer) then
                return true
            end
        end
    else
        for k, v in pairs(inst._boatequips) do
            if CheckItem(item, v:value(), checkcontainer) then
                return true
            end
        end
    end
end

local function GetItemInSlot(inst, slot)
    if inst._itemspreview ~= nil then
        return inst._itemspreview[slot]
    end
    return inst._items[slot] ~= nil and inst._items[slot]:value() or nil
end

local function GetItemInBoatSlot(inst, slot)
    if inst._boatequipspreview ~= nil then
        return inst._boatequipspreview[slot]
    end
    return inst._boatequips[slot] ~= nil and inst._boatequips[slot]:value() or nil
end

local function GetItems(inst)
    if inst._itemspreview ~= nil then
        return inst._itemspreview
    end
    local items = {}
    for i, v in ipairs(inst._items) do
        items[i] = v:value()
    end
    return items
end

local function GetBoatEquips(inst)
    if inst._boatequipspreview ~= nil then
        return inst._boatequipspreview
    end
    local boatequips = {}
    for k, v in pairs(inst._boatequips) do
        boatequips[k] = v:value()
    end
    return boatequips
end

local function IsEmpty(inst)
    if inst._itemspreview ~= nil then
        for i, v in ipairs(inst._items) do
            if inst._itemspreview[i] ~= nil then
                return false
            end
        end
    else
        for i, v in ipairs(inst._items) do
            if v:value() ~= nil then
                return false
            end
        end
    end
    return true
end

local function IsFull(inst)
    if inst._itemspreview ~= nil then
        for i, v in ipairs(inst._items) do
            if inst._itemspreview[i] == nil then
                return false
            end
        end
    else
        for i, v in ipairs(inst._items) do
            if v:value() == nil then
                return false
            end
        end
    end
    return true
end

local function Count(item)
    return item.replica.stackable ~= nil and item.replica.stackable:StackSize() or 1
end

local function Has(inst, prefab, amount)
    local count = 0
    if inst._itemspreview ~= nil then
        for i, v in ipairs(inst._items) do
            local item = inst._itemspreview[i]
            if item ~= nil and item.prefab == prefab then
                count = count + Count(item)
            end
        end
    else
        for i, v in ipairs(inst._items) do
            local item = v:value()
            if item ~= nil and item.prefab == prefab then
                count = count + Count(item)
            end
        end
    end
    return count >= amount, count
end

--------------------------------------------------------------------------
--Client sync event handlers that translate and dispatch local UI messages
--------------------------------------------------------------------------

local function RefreshCrafting(inst)
    local player = TheLocalPlayer
    if player ~= nil and player.replica.inventory ~= nil then
        local overflow = player.replica.inventory:GetOverflowContainer()
        if overflow ~= nil and overflow.inst == inst._parent then
            player:PushEvent("refreshcrafting")
        end
    end
end

local function Refresh(inst)
    inst._refreshtask = nil
    inst._busy = false
    inst._itemspreview = nil
    inst._boatequipspreview = nil
    if inst._parent ~= nil then
        inst._parent:PushEvent("refresh")
        RefreshCrafting(inst)
    end
end

local function QueueRefresh(inst, delay)
    if inst._refreshtask == nil then
        inst._refreshtask = inst:DoTaskInTime(delay, Refresh)
        inst._busy = true
        RefreshCrafting(inst)
    end
end

local function CancelRefresh(inst)
    if inst._refreshtask ~= nil then
        inst._refreshtask:Cancel()
        inst._refreshtask = nil
    end
end

local function OnItemsDirty(inst, slot, netitem)
    inst._slottasks[netitem] = nil
    if inst._parent ~= nil then
        local item = netitem:value()
        if item ~= nil then
            local data =
            {
                item = item,
                slot = slot,
                src_pos = item.replica.inventoryitem ~= nil and item.replica.inventoryitem:GetPickupPos() or nil,
                ignore_stacksize_anim = true,
            }
            if (data.src_pos ~= nil or
                inst._itemspreview == nil or
                inst._itemspreview[slot] == nil or
                inst._itemspreview[slot].prefab ~= item.prefab) and
                inst._parent.replica.inventoryitem ~= nil and
                inst._parent.replica.inventoryitem:IsHeldBy(TheLocalPlayer) then
                TheLocalPlayer:PushEvent("gotnewitem", data)
            end
            inst._parent:PushEvent("itemget", data)
        else
            inst._parent:PushEvent("itemlose", { slot = slot })
        end
    end
    QueueRefresh(inst, 0)
end

local function OnBoatEquipsDirty(inst, eslot, netitem)
    inst._slottasks[netitem] = nil
    if inst._parent ~= nil then
        local item = netitem:value()
        if item ~= nil then
            inst._parent:PushEvent("equip", {item = item, eslot = eslot})
        elseif inst._boatequipspreview == nil or inst._boatequipspreview[eslot] ~= item then
            inst._parent:PushEvent("unequip", {item = item, eslot = eslot})
        end
    end
    QueueRefresh(inst, 0)
end

local function OnStackItemDirty(inst, item)
    inst._slottasks[item] = nil
    if not item:IsValid() then
        QueueRefresh(inst, 0)
        return
    end
    local data =
    {
        stacksize = item.replica.stackable:StackSize(),
        src_pos = item.replica.inventoryitem:GetPickupPos(),
    }
    item:PushEvent("stacksizechange", data)
    if (data.src_pos ~= nil or not IsBusy(inst)) and
        inst._parent ~= nil and
        inst._parent.replica.inventoryitem ~= nil and
        inst._parent.replica.inventoryitem:IsHeldBy(TheLocalPlayer) then
        for i, v in ipairs(inst._items) do
            if item == v:value() then
                data.item = item
                data.slot = i
                TheLocalPlayer:PushEvent("gotnewitem", data)
                break
            end
        end
    end
    QueueRefresh(inst, 0)
end

local function QueueSlotTask(inst, key, task)
    if inst._slottasks[key] ~= nil then
        inst._slottasks[key]:Cancel()
    end
    inst._slottasks[key] = task
end

local function RegisterNetListeners(inst)
    inst._slottasks = {}
    Refresh(inst)

    --Delay dirty handlers by one frame so that new items have time to replicate locally

    for i, v in ipairs(inst._items) do
        inst:ListenForEvent("items["..tostring(i).."]dirty", function()
            QueueSlotTask(inst, v, inst:DoTaskInTime(0, OnItemsDirty, i, v))
            CancelRefresh(inst)
        end)
    end

    for k, v in pairs(inst._boatequips) do
        inst:ListenForEvent("boatequips["..k.."]dirty", function()
            QueueSlotTask(inst, v, inst:DoTaskInTime(0, OnBoatEquipsDirty, k, v))
            CancelRefresh(inst)
        end)
    end

    inst:ListenForEvent("stackitemdirty", function(world, item)
        if IsHolding(inst, item) then
            QueueSlotTask(inst, item, inst:DoTaskInTime(0, OnStackItemDirty, item))
            CancelRefresh(inst)
        end
    end, TheWorld)
end

--------------------------------------------------------------------------
--Client preview actions while waiting for RPC response from server
--------------------------------------------------------------------------

local function SlotItem(item, slot)
    return item ~= nil and slot ~= nil and { item = item, slot = slot } or nil
end

local function SlotBoatEquip(item, eslot)
    return item ~= nil and eslot ~= nil and  { item = item, eslot = eslot } or nil
end

local function PushItemGet(inst, data, ignoresound)
    if data ~= nil then
        if inst._parent ~= nil then
            if not ignoresound and
                inst._parent.replica.inventoryitem ~= nil and
                inst._parent.replica.inventoryitem:IsHeldBy(TheLocalPlayer) then
                TheLocalPlayer:PushEvent("gotnewitem", data)
            end
            inst._parent:PushEvent("itemget", data)
        end
        if inst._itemspreview == nil then
            inst._itemspreview = inst:GetItems()
        end
        inst._itemspreview[data.slot] = data.item
        QueueRefresh(inst, TIMEOUT)
    end
end

local function PushItemLose(inst, data)
    if data ~= nil then
        if inst._parent ~= nil then
            inst._parent:PushEvent("itemlose", data)
        end
        if inst._itemspreview == nil then
            inst._itemspreview = inst:GetItems()
        end
        inst._itemspreview[data.slot] = nil
        QueueRefresh(inst, TIMEOUT)
    end
end

local function PushBoatEquip(inst, data)
    if data ~= nil then
        if inst._boatequipspreview == nil then
            inst._boatequipspreview = inst:GetBoatEquips()
        end
        inst._boatequipspreview[data.eslot] = data.item
        if inst._parent ~= nil then
            inst._parent:PushEvent("equip", data)
        end
        QueueRefresh(inst, TIMEOUT)
    end
end

local function PushBoatUnequip(inst, data)
    if data ~= nil then
        if inst._boatequipspreview == nil then
            inst._boatequipspreview = inst:GetBoatEquips()
        end
        inst._boatequipspreview[data.eslot] = nil
        if inst._parent ~= nil then
            inst._parent:PushEvent("unequip", data)
        end
        QueueRefresh(inst, TIMEOUT)
    end
end

local function PushStackSize(inst, inventory, item, stacksize, animatestacksize, activestacksize, animateactivestacksize, selfonly, sounddata)
    if item ~= nil and item.replica.stackable ~= nil then
        if sounddata ~= nil then
            local player = TheLocalPlayer
            local inventory = player ~= nil and player.replica.inventory ~= nil and player.replica.inventory.classified or nil
            local overflow = inventory ~= nil and inventory:GetOverflowContainer() or nil
            if overflow ~= nil and overflow.classified == inst then
                TheLocalPlayer:PushEvent("gotnewitem", sounddata)
            end
        end
        local oldstacksize = item.replica.stackable:StackSize()
        item:PushEvent("stacksizepreview",
        {
            stacksize = stacksize,
            animatestacksize = animatestacksize,
            activestacksize = activestacksize,
            animateactivestacksize = animateactivestacksize,
            activecontainer = selfonly and inst._parent or nil,
        })
        if (stacksize ~= nil and stacksize ~= oldstacksize) or
            (activestacksize ~= nil and activestacksize ~= oldstacksize) then
            if inst._itemspreview == nil then
                for i, v in ipairs(inst._items) do
                    if v:value() == item then
                        inst._itemspreview = inst:GetItems()
                        break
                    end
                end
            end
            if inst._boatequipspreview == nil then
                for k, v in pairs(inst._boatequips) do
                    if v:value() == item then
                        inst._boatequipspreview = inst:GetBoatEquips()
                        break
                    end
                end
            end
            QueueRefresh(inst, TIMEOUT)
            if inventory ~= nil then
                inventory:QueueRefresh(TIMEOUT)
            end
        end
    end
end

--------------------------------------------------------------------------
--InvSlot click action handlers
--------------------------------------------------------------------------

local function QueryActiveItem()
    local player = TheLocalPlayer
    local inventory = player ~= nil and player.replica.inventory ~= nil and player.replica.inventory.classified or nil
    return inventory, inventory ~= nil and inventory:GetActiveItem() or nil, inventory == nil or inventory:IsBusy()
end

local function ReturnActiveItemToSlot(inst, slot)
    --inventory_classified:ReturnActiveItem will call PushNewActiveItem and SendRPCToServer
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local item = inst:GetItemInSlot(slot)
            if item == nil then
                local giveitem = SlotItem(active_item, slot)
                PushItemGet(inst, giveitem, true)
            elseif item.replica.stackable ~= nil and (item.prefab == active_item.prefab and item.skinname == active_item.skinname) then
                local stacksize = item.replica.stackable:StackSize() + active_item.replica.stackable:StackSize()
                local maxsize = item.replica.stackable:MaxSize()
                PushStackSize(inst, nil, item, math.min(stacksize, maxsize), true)
            end
        end
    end
end

local function PutOneOfActiveItemInSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local giveitem = SlotItem(active_item, slot)
            PushItemGet(inst, giveitem, true)
            PushStackSize(inst, inventory, active_item, 1, false, active_item.replica.stackable:StackSize() - 1, true)
            SendRPCToServer(RPC.PutOneOfActiveItemInSlot, slot, inst._parent)
        end
    end
end

local function PutAllOfActiveItemInSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local giveitem = SlotItem(active_item, slot)
            inventory:PushNewActiveItem()
            PushItemGet(inst, giveitem, true)
            SendRPCToServer(RPC.PutAllOfActiveItemInSlot, slot, inst._parent)
        end
    end
end

local function TakeActiveItemFromHalfOfSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and inventory ~= nil and active_item == nil then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil then
                local takeitem = SlotItem(item, slot)
                inventory:PushNewActiveItem(takeitem, inst, slot)
                local stacksize = item.replica.stackable:StackSize()
                local halfstacksize = math.floor(stacksize / 2)
                PushStackSize(inst, inventory, item, stacksize - halfstacksize, true, halfstacksize, false)
                SendRPCToServer(RPC.TakeActiveItemFromHalfOfSlot, slot, inst._parent)
            end
        end
    end
end

local function TakeActiveItemFromAllOfSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and inventory ~= nil and active_item == nil then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil then
                local takeitem = SlotItem(item, slot)
                PushItemLose(inst, takeitem)
                inventory:PushNewActiveItem(takeitem, inst, slot)
                SendRPCToServer(RPC.TakeActiveItemFromAllOfSlot, slot, inst._parent)
            end
        end
    end
end

local function AddOneOfActiveItemToSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil and (item.prefab == active_item.prefab and item.skinname == active_item.skinname) then
                PushStackSize(inst, nil, item, item.replica.stackable:StackSize() + 1, true)
                PushStackSize(inst, inventory, active_item, nil, nil, active_item.replica.stackable:StackSize() - 1, true)
                SendRPCToServer(RPC.AddOneOfActiveItemToSlot, slot, inst._parent)
            end
        end
    end
end

local function AddAllOfActiveItemToSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil and (item.prefab == active_item.prefab and item.skinname == active_item.skinname) then
                local stacksize = item.replica.stackable:StackSize() + active_item.replica.stackable:StackSize()
                local maxsize = item.replica.stackable:MaxSize()
                if stacksize <= maxsize then
                    inventory:PushNewActiveItem()
                    PushStackSize(inst, nil, item, stacksize, true)
                else
                    PushStackSize(inst, nil, item, maxsize, true)
                    PushStackSize(inst, inventory, active_item, stacksize - maxsize, false)
                end
                SendRPCToServer(RPC.AddAllOfActiveItemToSlot, slot, inst._parent)
            end
        end
    end
end

local function SwapActiveItemWithSlot(inst, slot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil then
                local takeitem = SlotItem(item, slot)
                local giveitem = SlotItem(active_item, slot)
                PushItemLose(inst, takeitem)
                inventory:PushNewActiveItem(takeitem, inst, slot)
                PushItemGet(inst, giveitem)
                SendRPCToServer(RPC.SwapActiveItemWithSlot, slot, inst._parent)
            end
        end
    end
end

local function BoatEquipActiveItem(inst)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local giveitem = SlotBoatEquip(active_item, active_item.replica.equippable:BoatEquipSlot())
            inventory:PushNewActiveItem()
            PushBoatEquip(inst, giveitem)
            SendModRPCToServer(MOD_RPC["Island Adventure"]["BoatEquipActiveItem"], inst._parent)
        end
    end
end

local function SwapBoatEquipWithActiveItem(inst)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item ~= nil then
            local eslot = active_item.replica.equippable:BoatEquipSlot()
            local item = inst:GetItemInBoatSlot(eslot)
            if item ~= nil then
                local takeequip = SlotBoatEquip(item, eslot)
                local giveequip = SlotBoatEquip(active_item, eslot)
                PushBoatUnequip(inst, takeequip)
                inventory:PushNewActiveItem(item.replica.inventoryitem ~= nil and item.replica.inventoryitem:CanGoInContainer() and takeequip or nil)
                PushBoatEquip(inst, giveequip)
                SendModRPCToServer(MOD_RPC["Island Adventure"]["SwapBoatEquipWithActiveItem"], inst._parent)
            end
        end
    end
end

local function TakeActiveItemFromBoatEquipSlot(inst, eslot)
    if not IsBusy(inst) then
        local inventory, active_item, busy = QueryActiveItem()
        if not busy and active_item == nil then
            local item = inst:GetItemInBoatSlot(eslot)
            if item ~= nil then
                if item.replica.inventoryitem ~= nil and item.replica.inventoryitem:CanGoInContainer() then
                    local takeequip = SlotBoatEquip(item, eslot)
                    PushBoatUnequip(inst, takeequip)
                    inventory:PushNewActiveItem(takeequip)
                else
                    QueueRefresh(inst, TIMEOUT)
                end
                SendModRPCToServer(MOD_RPC["Island Adventure"]["TakeActiveItemFromBoatEquipSlot"], EquipSlot.BoatToID(eslot), inst._parent)
            end
        end
    end
end

local function MoveItemFromAllOfSlot(inst, slot, container)
    if not IsBusy(inst) then
        local container_classified = container ~= nil and container.replica.inventory ~= nil and container.replica.inventory.classified or (container.replica.container ~= nil and container.replica.container.classified or nil)
        if container_classified ~= nil and not container_classified:IsBusy() then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil then
                local remainder = nil
                local player = TheLocalPlayer
                if player ~= nil and player.components.constructionbuilderuidata ~= nil and player.components.constructionbuilderuidata:GetContainer() == container then
                    local targetslot = player.components.constructionbuilderuidata:GetSlotForIngredient(item.prefab)
                    if targetslot ~= nil then
                        remainder = container_classified:ReceiveItem(item, nil, targetslot)
                    end
                else
                    remainder = container_classified:ReceiveItem(item)
                end
                if remainder ~= nil then
                    if remainder > 0 then
                        PushStackSize(inst, nil, item, nil, nil, remainder, false, true)
                    else
                        local takeitem = SlotItem(item, slot)
                        PushItemLose(inst, takeitem)
                    end
                    SendRPCToServer(RPC.MoveItemFromAllOfSlot, slot, inst._parent, container.replica.container ~= nil and container or nil)
                end
            end
        end
    end
end

local function MoveItemFromHalfOfSlot(inst, slot, container)
    if not IsBusy(inst) then
        local container_classified = container ~= nil and container.replica.inventory ~= nil and container.replica.inventory.classified or (container.replica.container ~= nil and container.replica.container.classified or nil)
        if container_classified ~= nil and not container_classified:IsBusy() then
            local item = inst:GetItemInSlot(slot)
            if item ~= nil then
                local remainder = nil
                local player = TheLocalPlayer
                if player ~= nil and player.components.constructionbuilderuidata ~= nil and player.components.constructionbuilderuidata:GetContainer() == container then
                    local targetslot = player.components.constructionbuilderuidata:GetSlotForIngredient(item.prefab)
                    if targetslot ~= nil then
                        remainder = container_classified:ReceiveItem(item, math.floor(item.replica.stackable:StackSize() / 2), targetslot)
                    end
                else
                    remainder = container_classified:ReceiveItem(item, math.floor(item.replica.stackable:StackSize() / 2))
                end
                if remainder ~= nil then
                    if remainder > 0 then
                        PushStackSize(inst, nil, item, nil, nil, remainder, true, true)
                    else
                        local takeitem = SlotItem(item, slot)
                        PushItemLose(inst, takeitem)
                    end
                    SendRPCToServer(RPC.MoveItemFromHalfOfSlot, slot, inst._parent, container.replica.container ~= nil and container or nil)
                end
            end
        end
    end
end

local function ReceiveItem(inst, item, count, forceslot)
    if not IsBusy(inst) and (forceslot == nil or (forceslot >= 1 and forceslot <= #inst._items)) then
        local isstackable = item.replica.stackable ~= nil
        local originalstacksize = isstackable and item.replica.stackable:StackSize() or 1
        if not isstackable or inst._parent.replica.container == nil or not inst._parent.replica.container:AcceptsStacks() then
            for i = forceslot or 1, forceslot or #inst._items do
                if inst._items[i]:value() == nil then
                    local giveitem = SlotItem(item, i)
                    PushItemGet(inst, giveitem)
                    if originalstacksize > 1 then
                        PushStackSize(inst, nil, item, nil, nil, 1, false, true)
                        return originalstacksize - 1
                    else
                        return 0
                    end
                end
            end
        else
            local originalcount = count and math.min(count, originalstacksize) or originalstacksize
            count = originalcount
            local emptyslot = nil
            for i = forceslot or 1, forceslot or #inst._items do
                local slotitem = inst._items[i]:value()
                if slotitem == nil then
                    if emptyslot == nil then
                        emptyslot = i
                    end
                elseif (slotitem.prefab == item.prefab and slotitem.skinname == item.skinname) and
                    slotitem.replica.stackable ~= nil and
                    not slotitem.replica.stackable:IsFull() then
                    local stacksize = slotitem.replica.stackable:StackSize() + count
                    local maxsize = slotitem.replica.stackable:MaxSize()
                    if stacksize > maxsize then
                        count = math.max(stacksize - maxsize, 0)
                        stacksize = maxsize
                    else
                        count = 0
                    end
                    PushStackSize(inst, nil, slotitem, stacksize, true, nil, nil, nil, SlotItem(slotitem, i))
                    if count <= 0 then
                        break
                    end
                end
            end
            if count > 0 and emptyslot ~= nil then
                local giveitem = SlotItem(item, emptyslot)
                PushItemGet(inst, giveitem)
                if count ~= originalstacksize then
                    PushStackSize(inst, nil, item, nil, nil, count, false, true)
                end
                count = 0
            end
            if count ~= originalcount then
                return originalstacksize - (originalcount - count)
            end
        end
    end
end

local function ConsumeByName(inst, prefab, amount)
    if amount <= 0 then
        return
    end

    for i, v in ipairs(inst._items) do
        local item = v:value()
        if item ~= nil and item.prefab == prefab then
            local stacksize = item.replica.stackable ~= nil and item.replica.stackable:StackSize() or 1
            if stacksize <= amount then
                local takeitem = SlotItem(item, i)
                PushItemLose(inst, takeitem)
                if amount <= stacksize then
                    return
                end
                amount = amount - stacksize
            else
                PushStackSize(inst, nil, item, stacksize - amount, true)
                return
            end
        end
    end
end

local function TakeActionItem(inst, item, slot)
    if not IsBusy(inst) and inst:GetItemInSlot(slot) == item then
        local takeitem = SlotItem(item, slot)
        PushItemLose(inst, takeitem)
    end
end

--------------------------------------------------------------------------

local function fn()
    local inst = CreateEntity()

    if TheWorld.ismastersim then
        inst.entity:AddTransform() --So we can follow parent's sleep state
    end
    inst.entity:AddNetwork()
    inst.entity:Hide()
    inst:AddTag("CLASSIFIED")

    --Variables for tracking local preview state;
    --Whenever a server sync is received, all local dirty states are reverted
    inst._refreshtask = nil
    inst._busy = true
    inst._itemspreview = nil
    inst._boatequipspreview = nil

    --Network variables
    inst._items = {}
    inst._itemspool = {}

    for i = 1, containers.MAXITEMSLOTS do
        table.insert(inst._itemspool, net_entity(inst.GUID, "container._items["..tostring(i).."]", "items["..tostring(i).."]dirty"))
    end

    inst._boatequips = {}

    for k, v in pairs(BOATEQUIPSLOTS) do
        inst._boatequips[v] = net_entity(inst.GUID, "container._boatequips["..v.."]", "boatequips["..v.."]dirty")
    end

    inst._slottasks = nil

    inst.entity:SetPristine()

    --Common interface
    inst.InitializeSlots = InitializeSlots

    if not TheWorld.ismastersim then
        --Client interface
        inst.OnEntityReplicated = OnEntityReplicated
        inst.IsHolding = IsHolding
        inst.GetItemInSlot = GetItemInSlot
        inst.GetItemInBoatSlot = GetItemInBoatSlot
        inst.GetItems = GetItems
        inst.GetBoatEquips = GetBoatEquips
        inst.IsEmpty = IsEmpty
        inst.IsFull = IsFull
        inst.Has = Has
        inst.ReturnActiveItemToSlot = ReturnActiveItemToSlot
        inst.PutOneOfActiveItemInSlot = PutOneOfActiveItemInSlot
        inst.PutAllOfActiveItemInSlot = PutAllOfActiveItemInSlot
        inst.TakeActiveItemFromHalfOfSlot = TakeActiveItemFromHalfOfSlot
        inst.TakeActiveItemFromAllOfSlot = TakeActiveItemFromAllOfSlot
        inst.AddOneOfActiveItemToSlot = AddOneOfActiveItemToSlot
        inst.AddAllOfActiveItemToSlot = AddAllOfActiveItemToSlot
        inst.SwapActiveItemWithSlot = SwapActiveItemWithSlot
        inst.BoatEquipActiveItem = BoatEquipActiveItem
        inst.SwapBoatEquipWithActiveItem = SwapBoatEquipWithActiveItem
        inst.TakeActiveItemFromBoatEquipSlot = TakeActiveItemFromBoatEquipSlot
        inst.MoveItemFromAllOfSlot = MoveItemFromAllOfSlot
        inst.MoveItemFromHalfOfSlot = MoveItemFromHalfOfSlot

        --Exposed for inventory
        inst.ReceiveItem = ReceiveItem
        inst.ConsumeByName = ConsumeByName
        inst.TakeActionItem = TakeActionItem
        inst.IsBusy = IsBusy

        --Delay net listeners until after initial values are deserialized
        inst:DoTaskInTime(0, RegisterNetListeners)
        return inst
    end

    --Server interface
    inst.SetSlotItem = SetSlotItem
    inst.SetSlotBoatEquip = SetSlotBoatEquip

    inst.persists = false

    return inst
end

return Prefab("boatcontainer_classified", fn)%%+%%scripts/prefabs/boatlamps.lua%%-%%local MakeVisualBoatEquip = require("prefabs/visualboatequip")

local lanternassets = {
    Asset("ANIM", "anim/swap_lantern_boat.zip"),
}

local torchassets = {
    Asset("ANIM", "anim/swap_torch_boat.zip"),
}

local lanternprefabs = {
    "boat_lantern_light",
}

local torchprefabs = {
    "boat_torch_light",
}

local function fuelupdate(inst)
    if inst._light ~= nil then
        local fuelpercent = inst.components.fueled:GetPercent()
        inst._light.Light:SetIntensity(Lerp(0.4, 0.6, fuelpercent))
        inst._light.Light:SetRadius(Lerp(3, 5, fuelpercent))
        inst._light.Light:SetFalloff(0.9)
    end
end

local function setswapsymbol(inst, symbol)
    if inst.visual then
        inst.visual.AnimState:OverrideSymbol("swap_lantern", inst.visualbuild, symbol)
    end
end

local function turnon(inst)
    if not inst.components.fueled:IsEmpty() then
        if inst.onsound then
            for i, v in ipairs(inst.onsound) do
                inst.SoundEmitter:PlaySound(v)
            end
        end

        if not inst.SoundEmitter:PlayingSound("boatlamp") then 
            inst.SoundEmitter:PlaySound("ia/common/boatlantern_lp", "boatlamp")
        end

        if inst.components.fueled then
            inst.components.fueled:StartConsuming()        
        end
        
        if inst._light == nil or not inst._light:IsValid() then
            inst._light = SpawnPrefab(inst.prefab .."_light")
            if inst.components.fueled.accepting then
                fuelupdate(inst)
            end
        end

        local owner = inst.components.inventoryitem.owner

        inst._light.entity:SetParent((owner or inst).entity)
        setswapsymbol(inst, "swap_lantern")
    end

    inst.components.inventoryitem:ChangeImageName(inst.prefab)
end

local function turnoff(inst)
    inst.SoundEmitter:KillSound("boatlamp")
    
    if inst.offsound then
        for i, v in ipairs(inst.offsound) do
            inst.SoundEmitter:PlaySound(v)
        end
    end

    if inst.components.fueled then
        inst.components.fueled:StopConsuming()        
    end

    setswapsymbol(inst, "swap_lantern_off")
	
	if inst._light ~= nil then
        if inst._light:IsValid() then
            inst._light:Remove()
        end
        inst._light = nil
	end

    inst.components.inventoryitem:ChangeImageName(inst.prefab.."_off")
end

local function toggleon(inst)
    turnon(inst)
end

local function toggleoff(inst)
    turnoff(inst)
end

local function onequip(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:SpawnBoatEquipVisuals(inst, inst.visualprefab)
    end
    setswapsymbol(inst, inst.components.equippable:IsToggledOn() and "swap_lantern" or "swap_lantern_off")
end

local function onunequip(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:RemoveBoatEquipVisuals(inst)
    end
    inst.components.equippable:ToggleOff()
end

local function nofuel(inst)
    if inst.components.fueled.accepting then
        inst.components.equippable.togglable = false
        turnoff(inst)
    else
        inst:Remove()
    end
end

local function takefuel(inst)
    if inst.components.equippable and inst.components.equippable:IsEquipped() then
        inst.components.equippable.togglable = true
        turnon(inst)
    end
end

local function OnRemove(inst)
    if inst._light ~= nil then
        if inst._light:IsValid() then
            inst._light:Remove()
        end
        inst._light = nil
    end
end

local function ondropped(inst)
    turnoff(inst)
end
    
local function commonpristinefn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("lantern_boat")
    inst.AnimState:SetBuild("swap_lantern_boat")
    inst.AnimState:PlayAnimation("idle")

    inst.visualbuild = "swap_lantern_boat"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    return inst
end

local function serverfn(inst)
    
    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnDroppedFn(ondropped)
    inst.components.inventoryitem:ChangeImageName("boat_lantern_off")

    inst:AddComponent("fueled")
    inst.components.fueled:SetDepletedFn(nofuel)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
        
    inst:AddComponent("equippable")
    inst.components.equippable.boatequipslot = BOATEQUIPSLOTS.BOAT_LAMP
    inst.components.equippable.equipslot = nil
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)
    inst.components.equippable.togglable = true
    inst.components.equippable.toggledonfn = toggleon
    inst.components.equippable.toggledofffn = toggleoff

    MakeHauntableLaunch(inst)
    
    inst.OnRemove = OnRemove
    
    return inst
end

local function lanternfn()
    local inst = commonpristinefn()

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.onsound = {"ia/common/boatlantern_turnon"}
    inst.offsound = {"ia/common/boatlantern_turnoff"}

    serverfn(inst)

    inst.visualprefab = "boat_lantern"

    inst.components.fueled.fueltype = "CAVE" --For using fireflies as the fuel 
    inst.components.fueled:InitializeFuelLevel(TUNING.BOAT_LANTERN_LIGHTTIME)
    inst.components.fueled:SetUpdateFn(fuelupdate)
    inst.components.fueled.ontakefuelfn = takefuel
    inst.components.fueled.accepting = true

    MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
    MakeSmallPropagator(inst)
    
    return inst
end

local function torchfn()
    local inst = commonpristinefn()

    inst.AnimState:SetBuild("swap_torch_boat")

    inst.visualbuild = "swap_torch_boat"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.onsound = {"dontstarve/wilson/torch_swing"}
    inst.offsound = {"ia/common/boatlantern_turnoff", "dontstarve/common/fireOut"}

    serverfn(inst)

    inst.visualprefab = "boat_torch"

    inst.components.inventoryitem:ChangeImageName("boat_torch_off")

    inst.components.fueled.fueltype = "BURNABLE"
    inst.components.fueled:InitializeFuelLevel(TUNING.BOAT_TORCH_LIGHTTIME)
    
    return inst
end

local function commonpristinelightfn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddLight()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    return inst
end

local function serverlightfn(inst)    
    inst.persists = false

    return inst
end

local function lanternlightfn()
    local inst = commonpristinelightfn()
    
    inst.Light:SetColour(180/255, 195/255, 150/255)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    return serverlightfn(inst)
end

local function torchlightfn()
    local inst = commonpristinelightfn()
    
    inst.Light:SetColour(200/255, 200/255, 50/255)
    inst.Light:SetRadius(2)
    inst.Light:SetIntensity(0.75)
    inst.Light:SetFalloff(0.5)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    return serverlightfn(inst)
end

local function lightfn()
    local inst = commonpristinelightfn()
    
    inst.Light:SetColour(200/255, 200/255, 50/255)
    inst.Light:SetRadius(2)
    inst.Light:SetIntensity(0.75)
    inst.Light:SetFalloff(0.5)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    return serverlightfn(inst)
end

function lantern_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_lantern_boat")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_DOWN then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

function torch_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_torch_boat")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_DOWN then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end


return Prefab("boat_lantern", lanternfn, lanternassets, lanternprefabs),
    Prefab("boat_torch", torchfn, torchassets, torchprefabs),
    MakeVisualBoatEquip("boat_lantern", lanternassets, nil, lantern_visual_common),
    MakeVisualBoatEquip("boat_torch", torchassets, nil, torch_visual_common),
    Prefab("boat_lantern_light", lanternlightfn),
    Prefab("boat_torch_light", torchlightfn)%%+%%scripts/prefabs/boatrepairkit.lua%%-%%local assets = {
    Asset("ANIM", "anim/boat_repair_kit.zip"),
}

local function onfinished(inst)
    inst:Remove()
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("boat_repair_kit")
    inst.AnimState:SetBuild("boat_repair_kit")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("finiteuses")
    inst.components.finiteuses:SetMaxUses(TUNING.BOAT_REPAIR_KIT_USES)
    inst.components.finiteuses:SetUses(TUNING.BOAT_REPAIR_KIT_USES)
    inst.components.finiteuses:SetOnFinished(onfinished)

    inst:AddComponent("repairer")
    inst.components.repairer.healthrepairvalue = TUNING.BOAT_REPAIR_KIT_HEALING
    inst.components.repairer.repairmaterial = "boat"

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    return inst
end

return Prefab("boatrepairkit", fn, assets) 

%%+%%scripts/prefabs/boats.lua%%-%%local rowboatassets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
    Asset("ANIM", "anim/rowboat_build.zip"),
    Asset("ANIM", "anim/rowboat_idles.zip"),
    Asset("ANIM", "anim/rowboat_paddle.zip"),
    Asset("ANIM", "anim/rowboat_trawl.zip"),
    Asset("ANIM", "anim/swap_sail.zip"),
    Asset("ANIM", "anim/swap_lantern_boat.zip"),
    Asset("ANIM", "anim/boat_hud_row.zip"),
    Asset("ANIM", "anim/boat_inspect_row.zip"),
    Asset("ANIM", "anim/flotsam_rowboat_build.zip"),
}

local raftassets = {
    Asset("ANIM", "anim/raft_basic.zip"),
    Asset("ANIM", "anim/raft_build.zip"),
    Asset("ANIM", "anim/raft_idles.zip"),
    Asset("ANIM", "anim/raft_paddle.zip"),
    Asset("ANIM", "anim/raft_trawl.zip"),
    Asset("ANIM", "anim/boat_hud_raft.zip"),
    Asset("ANIM", "anim/boat_inspect_raft.zip"),
    Asset("ANIM", "anim/flotsam_bamboo_build.zip"),
}

local surfboardassets = {
    Asset("ANIM", "anim/raft_basic.zip"),
    Asset("ANIM", "anim/raft_surfboard_build.zip"),
    Asset("ANIM", "anim/raft_idles.zip"),
    Asset("ANIM", "anim/raft_paddle.zip"),
    Asset("ANIM", "anim/raft_trawl.zip"),
    Asset("ANIM", "anim/boat_hud_raft.zip"),
    Asset("ANIM", "anim/boat_inspect_raft.zip"),
    Asset("ANIM", "anim/flotsam_surfboard_build.zip"),
    Asset("ANIM", "anim/surfboard.zip"),
}

local cargoassets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
    Asset("ANIM", "anim/rowboat_cargo_build.zip"),
    Asset("ANIM", "anim/rowboat_idles.zip"),
    Asset("ANIM", "anim/rowboat_paddle.zip"),
    Asset("ANIM", "anim/rowboat_trawl.zip"),
    Asset("ANIM", "anim/swap_sail.zip"),
    Asset("ANIM", "anim/swap_lantern_boat.zip"),
    Asset("ANIM", "anim/boat_hud_cargo.zip"),
    Asset("ANIM", "anim/boat_inspect_cargo.zip"),
    Asset("ANIM", "anim/flotsam_cargo_build.zip"),
}

local armouredboatassets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
    Asset("ANIM", "anim/rowboat_armored_build.zip"),
    Asset("ANIM", "anim/rowboat_idles.zip"),
    Asset("ANIM", "anim/rowboat_paddle.zip"),
    Asset("ANIM", "anim/rowboat_trawl.zip"),
    Asset("ANIM", "anim/swap_sail.zip"),
    Asset("ANIM", "anim/swap_lantern_boat.zip"),
    Asset("ANIM", "anim/boat_hud_row.zip"),
    Asset("ANIM", "anim/boat_inspect_row.zip"),
    Asset("ANIM", "anim/flotsam_armoured_build.zip"),
}

local encrustedboatassets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
    Asset("ANIM", "anim/rowboat_encrusted_build.zip"),
    Asset("ANIM", "anim/rowboat_idles.zip"),
    Asset("ANIM", "anim/rowboat_paddle.zip"),
    Asset("ANIM", "anim/rowboat_trawl.zip"),
    Asset("ANIM", "anim/swap_sail.zip"),
    Asset("ANIM", "anim/swap_lantern_boat.zip"),
    Asset("ANIM", "anim/boat_hud_encrusted.zip"),
    Asset("ANIM", "anim/boat_inspect_encrusted.zip"),
  -- TODO: add encrusted flotsam
    Asset("ANIM", "anim/flotsam_armoured_build.zip"),
}

local lograftassets = {
    Asset("ANIM", "anim/raft_basic.zip"),
    Asset("ANIM", "anim/raft_log_build.zip"),
    Asset("ANIM", "anim/raft_idles.zip"),
    Asset("ANIM", "anim/raft_paddle.zip"),
    Asset("ANIM", "anim/raft_trawl.zip"),
    Asset("ANIM", "anim/boat_hud_raft.zip"),
    Asset("ANIM", "anim/boat_inspect_raft.zip"),
    Asset("ANIM", "anim/flotsam_lograft_build.zip"),
}

local woodlegsboatassets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
    Asset("ANIM", "anim/pirate_boat_build.zip"),
    Asset("ANIM", "anim/rowboat_idles.zip"),
    Asset("ANIM", "anim/rowboat_paddle.zip"),
    Asset("ANIM", "anim/rowboat_trawl.zip"),
    Asset("ANIM", "anim/boat_hud_raft.zip"),
    Asset("ANIM", "anim/boat_inspect_raft.zip"),
    Asset("ANIM", "anim/flotsam_rowboat_build.zip"),
    Asset("ANIM", "anim/pirate_boat_placer.zip"),
}

local prefabs = {
    "rowboat_wake",
    "boat_hit_fx",
    "boat_hit_fx_raft_log",
    "boat_hit_fx_raft_bamboo",
    "boat_hit_fx_rowboat",
    "boat_hit_fx_cargoboat",
    "boat_hit_fx_armoured",
    "flotsam_armoured",
    "flotsam_bamboo",
    "flotsam_cargo",
    "flotsam_lograft",
    "flotsam_rowboat",
    "flotsam_surfboard",
}

local function sink(inst)
    local sailor = inst.components.sailable:GetSailor()
    if sailor then
        sailor.components.sailor:Disembark()

        if sailor.components.health then
            sailor.components.health:Drown()
        end

        inst.SoundEmitter:PlaySound(inst.sinksound) --Not sure why this is here and not in the SG -M
    end
    if inst.components.container then 
        inst.components.container:DropEverything()
    end
    
    inst:Remove()
end

local function onhit(inst, worker)
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("run_loop", true)
end

local function onworked(inst, worker)
    inst.components.lootdropper:DropLoot()
    if inst.components.container then
        inst.components.container:DropEverything()
    end
    SpawnAt("collapse_small", inst)
    inst.SoundEmitter:PlaySound("dontstarve/common/destroy_wood")
    inst:Remove()
end

local function onrepaired(inst, doer, repair_item)
    inst.SoundEmitter:PlaySound("ia/common/boatrepairkit")
end

local function ondisembarked(inst)
    inst.components.workable.workable = false
end

local function onembarked(inst)
    inst.components.workable.workable = true
end

local function onopen(inst)
    if inst.components.sailable.sailor == nil then
        inst.SoundEmitter:PlaySound("ia/common/boat/inventory_open")
    end
end

local function onclose(inst)
    if inst.components.sailable.sailor == nil then
        inst.SoundEmitter:PlaySound("ia/common/boat/inventory_close")
    end
end

local function common()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
    inst.entity:AddPhysics()
    inst.entity:AddMiniMapEntity()

    inst:AddTag("boat")
    inst:AddTag("sailable")

    inst.Transform:SetFourFaced()
    inst.MiniMapEntity:SetPriority(5)

    inst.Physics:SetCylinder(0.25,2)

    inst.no_wet_prefix = true

    inst.sailmusic = "sailing"

    inst.boatvisuals = {}

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    inst:AddComponent("sailable")

    inst.components.sailable.sanitydrain = TUNING.RAFT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.RAFT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_bamboo_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_RAFT_BONUS

    inst.landsound = "ia/common/boatjump_land_bamboo"
    inst.sinksound = "ia/common/boat/sinking/bamboo"

    inst.waveboost = TUNING.WAVEBOOST

    inst:AddComponent("rowboatwakespawner")

    inst:AddComponent("boathealth")
    inst.components.boathealth:SetDepletedFn(sink)
    inst.components.boathealth:SetHealth(TUNING.RAFT_HEALTH, TUNING.RAFT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.RAFT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/bamboo"
    inst.components.boathealth.hitfx = "boat_hit_fx_raft_bamboo"

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onworked)
    inst.components.workable:SetOnWorkCallback(onhit)

    inst:AddComponent("lootdropper")

    inst:AddComponent("repairable")
    inst.components.repairable.repairmaterial = "boat"
    inst.components.repairable.onrepaired = onrepaired

    inst:ListenForEvent("embarked", onembarked)
    inst:ListenForEvent("disembarked", ondisembarked)

    inst.onworked = onworked

    inst:AddComponent("flotsamspawner")

    inst.components.flotsamspawner.flotsamprefab = "flotsam_bamboo"

    inst:AddSpoofedComponent("boatcontainer", "container")

    inst.components.container.onopenfn = onopen
    inst.components.container.onclosefn = onclose

    inst:AddComponent("boatvisualmanager")

    return inst
end

local function raftfn()
    local inst = common()

    inst.AnimState:SetBank("raft")
    inst.AnimState:SetBuild("raft_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_raft.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/bamboo"
        end
        return inst
    end
    
    inst.components.container:WidgetSetup("boat_raft")

    inst.components.boathealth:SetHealth(TUNING.RAFT_HEALTH, TUNING.RAFT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.RAFT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/bamboo"
    inst.components.boathealth.hitfx = "boat_hit_fx_raft_bamboo"

    inst.landsound = "ia/common/boatjump_land_bamboo"
    inst.sinksound = "ia/common/boat/sinking/bamboo"

    inst.components.sailable.sanitydrain = TUNING.RAFT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.RAFT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_bamboo_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_RAFT_BONUS
    inst.components.sailable.hitmoisturerate = TUNING.RAFT_HITMOISTURERATE

    inst.replica.sailable.creaksound = "ia/common/boat/creaks/bamboo"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_bamboo"

    return inst
end

local function lograftfn()
    local inst = common()

    inst.AnimState:SetBank("raft")
    inst.AnimState:SetBuild("raft_log_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_lograft.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/log"
        end
        return inst
    end
    
    inst.components.container:WidgetSetup("boat_lograft")

    inst.components.boathealth:SetHealth(TUNING.LOGRAFT_HEALTH, TUNING.LOGRAFT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.LOGRAFT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/log"
    inst.components.boathealth.hitfx = "boat_hit_fx_raft_log"

    inst.landsound = "ia/common/boatjump_land_log"
    inst.sinksound = "ia/common/boat/sinking/log_cargo"

    inst.components.sailable.sanitydrain = TUNING.LOGRAFT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.LOGRAFT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_lograft_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_LOGRAFT_BONUS
    inst.components.sailable.hitmoisturerate = TUNING.RAFT_HITMOISTURERATE

    inst.components.boathealth.damagesound = "ia/common/boat/damage/log"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_lograft"

    return inst
end

local function rowboatfn()
    local inst = common()

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("rowboat_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_row.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)

        end
        return inst
    end
    
    inst.components.container:WidgetSetup("boat_row")

    inst.components.boathealth:SetHealth(TUNING.ROWBOAT_HEALTH, TUNING.ROWBOAT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.ROWBOAT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/row"
    inst.components.boathealth.hitfx = "boat_hit_fx_rowboat"

    inst.landsound = "ia/common/boatjump_land_wood"
    inst.sinksound = "ia/common/boat/sinking/row"

    inst.components.sailable.sanitydrain = TUNING.ROWBOAT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.ROWBOAT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_rowboat_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_ROWBOAT_BONUS

    inst.components.flotsamspawner.flotsamprefab = "flotsam_rowboat"

    return inst 
end

local function armouredboatfn()
    local inst = common()

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("rowboat_armored_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_armoured.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/armoured"
        end
        return inst
    end

    inst.components.container:WidgetSetup("boat_armoured")

    inst.components.boathealth:SetHealth(TUNING.ARMOUREDBOAT_HEALTH, TUNING.ARMOUREDBOAT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.ARMOUREDBOAT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/armoured"
    inst.components.boathealth.hitfx = "boat_hit_fx_armoured"

    inst.landsound = "ia/common/boatjump_land_shell"
    inst.sinksound = "ia/common/boat/sinking/row"

    inst.components.sailable.sanitydrain = TUNING.ARMOUREDBOAT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.ARMOUREDBOAT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_armoured_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_ARMOUREDBOAT_BONUS
    inst.components.sailable:SetHitImmunity(TUNING.ARMOUREDBOAT_HIT_IMMUNITY)

    inst.replica.sailable.creaksound = "ia/common/boat/creaks/armoured"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_armoured"

    return inst
end

local function encrustedboatfn()
    local inst = common()

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("rowboat_encrusted_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_encrusted.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/encrusted"
        end
        return inst
    end

    inst.waveboost = TUNING.ENCRUSTEDBOAT_WAVEBOOST

    inst.components.container:WidgetSetup("boat_encrusted")

    inst.components.boathealth:SetHealth(TUNING.ENCRUSTEDBOAT_HEALTH, TUNING.ENCRUSTEDBOAT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.ENCRUSTEDBOAT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/encrusted"
    inst.components.boathealth.hitfx = "boat_hit_fx_armoured"

    inst.landsound = "ia/common/boatjump_land_shell"
    inst.sinksound = "ia/common/boat/sinking/row"

    inst.components.sailable.sanitydrain = TUNING.ENCRUSTEDBOAT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.ENCRUSTEDBOAT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_armoured_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_ENCRUSTEDBOAT_BONUS
    inst.components.sailable:SetHitImmunity(TUNING.ENCRUSTEDBOAT_HIT_IMMUNITY)

    inst.replica.sailable.creaksound = "ia/common/boat/creaks/encrusted"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_armoured"

    return inst
end

local function cargofn()
    local inst = common()

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("rowboat_cargo_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_cargo.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/cargo"
        end
        return inst
    end

    inst.components.container:WidgetSetup("boat_cargo")

    inst.components.boathealth:SetHealth(TUNING.CARGOBOAT_HEALTH, TUNING.CARGOBOAT_PERISHTIME)
    inst.components.boathealth.damagesound = "ia/common/boat/damage/cargo"
    inst.components.boathealth.hitfx = "boat_hit_fx_cargoboat"

    inst.landsound = "ia/common/boatjump_land_wood"
    inst.sinksound = "ia/common/boat/sinking/log_cargo"

    inst.components.sailable.sanitydrain = TUNING.CARGOBOAT_SANITY_DRAIN
    inst.components.sailable.movementbonus = TUNING.CARGOBOAT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_rowboat_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_CARGOBOAT_BONUS

    inst.replica.sailable.creaksound = "ia/common/boat/creaks/cargo"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_cargo"

    return inst
end

local function woodlegsboatfn()
    local inst = common()

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("pirate_boat_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("boat_woodlegs.tex")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.sailable.creaksound = "ia/common/boat/creaks/armoured"
        end
        return inst
    end

    inst.components.container:WidgetSetup("boat_woodlegs")

    inst.components.boathealth:SetHealth(TUNING.WOODLEGSBOAT_HEALTH, TUNING.ARMOUREDBOAT_PERISHTIME)
    inst.components.boathealth.leakinghealth = TUNING.WOODLEGSBOAT_LEAKING_HEALTH
    inst.components.boathealth.damagesound = "ia/common/boat/damage/armoured"
    inst.components.boathealth.hitfx = "boat_hit_fx_armoured"

    inst.landsound = "ia/common/boatjump_land_shell"
    inst.sinksound = "ia/common/boat/sinking/row"

    inst.components.sailable.sanitydrain = 0
    inst.components.sailable.movementbonus = TUNING.WOODLEGSBOAT_SPEED
    inst.components.sailable.flotsambuild = "flotsam_armoured_build"
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_WOODLEGSBOAT_BONUS
    inst.components.sailable:SetHitImmunity(TUNING.WOODLEGSBOAT_HIT_IMMUNITY)

    inst.replica.sailable.creaksound = "ia/common/boat/creaks/armoured"

    inst.components.flotsamspawner.flotsamprefab = "flotsam_rowboat"

    inst:DoTaskInTime(0.1, function(inst)
        local sailitem = inst.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
        if sailitem == nil then
            local sail = SpawnPrefab("sail_woodlegs")
            inst.components.container:Equip(sail)
        end
        local torchitem = inst.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_LAMP)
        if torchitem == nil then
            local cannon = SpawnPrefab("woodlegs_boatcannon")
            inst.components.container:Equip(cannon)
        end
    end)

    return inst
end

local function pickupfn(inst, guy)
    local board = SpawnPrefab("surfboard_item")
    guy.components.inventory:GiveItem(board)
    --  board.components.pocket:GiveItem("surfboard", inst)
    return true
end

local function surfboardfn()
    local inst = common()

    inst.AnimState:SetBank("raft")
    inst.AnimState:SetBuild("raft_surfboard_build")
    inst.AnimState:PlayAnimation("run_loop", true)
    inst.MiniMapEntity:SetIcon("surfboard.tex")

    inst:AddTag("surfboard")

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)

        end
        return inst
    end

    inst.components.container:WidgetSetup("surfboard")

    inst.sinksound = "ia/common/boat/sinking/log_cargo"
    inst.sailsound = "ia/common/sail_LP/surfboard"
    inst.sailmusic = "surfing"

    inst.waveboost = TUNING.SURFBOARD_WAVEBOOST
    inst.wavesanityboost = TUNING.SURFBOARD_WAVESANITYBOOST

    inst.components.sailable.movementbonus = TUNING.SURFBOARD_SPEED
    inst.components.sailable.maprevealbonus = TUNING.MAPREVEAL_RAFT_BONUS
    inst.components.sailable.hitmoisturerate = TUNING.SURFBOARD_HITMOISTURERATE

    --inst.components.sailable.flotsambuild = "flotsam_rowboat_build"

    inst.perishtime = TUNING.SURFBOARD_PERISHTIME
    inst.components.boathealth.maxhealth = TUNING.SURFBOARD_HEALTH
    inst.components.boathealth:SetHealth(TUNING.SURFBOARD_HEALTH, inst.perishtime)

    inst.components.boathealth.damagesound = "ia/common/boat/damage/surfboard"

    --  inst:AddComponent("characterspecific")
    --  inst.components.characterspecific:SetOwner("walani")

    --  inst:AddComponent("pickupable")
    --  inst.components.pickupable:SetOnPickupFn(pickupfn)
    --  inst:SetInherentSceneAltAction(ACTIONS.RETRIEVE)

    inst.components.flotsamspawner.flotsamprefab = "flotsam_surfboard"

    return inst
end

local function surfboard_ondropped(inst)
    --If this is a valid place to be deployed, auto deploy yourself.
    if inst.components.deployable and inst.components.deployable:CanDeploy(inst:GetPosition()) then
        inst.components.deployable:Deploy(inst:GetPosition(), inst)
    end
end

local function surfboarditemfn(Sim)
    local inst = CreateEntity()

    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetPriority( 5 )
    minimap:SetIcon("surfboard.tex")

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    MakeInventoryPhysics(inst)
    inst.entity:AddNetwork()

    inst:AddTag("boat")

    inst.AnimState:SetBank("surfboard")
    inst.AnimState:SetBuild("surfboard")
    inst.AnimState:PlayAnimation("idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    inst:AddComponent("inventoryitem")
    inst.components.inventoryitem:SetOnDroppedFn(surfboard_ondropped)

    inst:AddComponent("deployable")
    inst.components.deployable.ondeploy = ondeploy
    inst.components.deployable.placer = "surfboard_placer"
    inst.components.deployable.test = deploytest
    inst.components.deployable.deploydistance = 3

    --inst:AddComponent("characterspecific")
    --inst.components.characterspecific:SetOwner("walani")

    return inst
end

return Prefab("boat_raft", raftfn, raftassets, prefabs),
Prefab("boat_lograft", lograftfn, lograftassets, prefabs),
Prefab("boat_row", rowboatfn, rowboatassets, prefabs),
Prefab("boat_armoured", armouredboatfn, armouredboatassets, prefabs),
Prefab("boat_encrusted", encrustedboatfn, encrustedboatassets, prefabs),
Prefab("boat_cargo", cargofn, cargoassets, prefabs),
Prefab("boat_woodlegs", woodlegsboatfn, woodlegsboatassets, prefabs),
Prefab("boat_surfboard", surfboardfn, surfboardassets, prefabs),
Prefab("inv_surfboard", surfboarditemfn, surfboardassets, prefabs),
MakePlacer("boat_raft_placer", "raft", "raft_build", "run_loop"),
MakePlacer("boat_lograft_placer", "raft", "raft_log_build", "run_loop"),
MakePlacer("boat_row_placer", "rowboat", "rowboat_build", "run_loop"), 
MakePlacer("boat_armoured_placer", "rowboat", "rowboat_armored_build", "run_loop"), 
MakePlacer("boat_encrusted_placer", "rowboat", "rowboat_encrusted_build", "run_loop"), 
MakePlacer("boat_cargo_placer", "rowboat", "rowboat_cargo_build", "run_loop"), 
MakePlacer("boat_surfboard_placer", "raft", "raft_surfboard_build", "run_loop"), 
MakePlacer("boat_woodlegs_placer", "rowboat", "pirate_boat_build", "run_loop")%%+%%scripts/prefabs/bottlelantern.lua%%-%%local assets =
{
	Asset("ANIM", "anim/lantern_bottle.zip"),
	Asset("ANIM", "anim/swap_bottlle_lantern.zip"),
}

local prefabs =
{
	"bottlelanternlight",
}

local function DoTurnOffSound(inst, owner)
	inst._soundtask = nil
	(owner ~= nil and owner:IsValid() and owner.SoundEmitter or inst.SoundEmitter):PlaySound("ia/common/bottlelantern_turnoff")
end

local function PlayTurnOffSound(inst)
	if inst._soundtask == nil and inst:GetTimeAlive() > 0 then
		inst._soundtask = inst:DoTaskInTime(0, DoTurnOffSound, inst.components.inventoryitem.owner)
	end
end

local function PlayTurnOnSound(inst)
	if inst._soundtask ~= nil then
		inst._soundtask:Cancel()
		inst._soundtask = nil
	elseif not POPULATING then
		inst._light.SoundEmitter:PlaySound("ia/common/bottlelantern_turnon")
	end
end

local function fuelupdate(inst)
	if inst._light ~= nil then
		local fuelpercent = inst.components.fueled:GetPercent()
		inst._light.Light:SetIntensity(Lerp(.4, .65, fuelpercent))
		inst._light.Light:SetRadius(Lerp(3, 5, fuelpercent))
		inst._light.Light:SetFalloff(.9)
	end
end

local function onremovelight(light)
	light._lantern._light = nil
end

local function stoptrackingowner(inst)
	if inst._owner ~= nil then
		inst:RemoveEventCallback("equip", inst._onownerequip, inst._owner)
		inst._owner = nil
	end
end

local function starttrackingowner(inst, owner)
	if owner ~= inst._owner then
		stoptrackingowner(inst)
		if owner ~= nil and owner.components.inventory ~= nil then
			inst._owner = owner
			inst:ListenForEvent("equip", inst._onownerequip, owner)
		end
	end
end

local function turnon(inst)
	if not inst.components.fueled:IsEmpty() then
		inst.components.fueled:StartConsuming()

		local owner = inst.components.inventoryitem.owner

		if inst._light == nil then
			inst._light = SpawnPrefab("lanternlight")
			inst._light._lantern = inst
			inst:ListenForEvent("onremove", onremovelight, inst._light)
			fuelupdate(inst)
			PlayTurnOnSound(inst)
		end
		inst._light.entity:SetParent((owner or inst).entity)

		inst.components.floater:UpdateAnimations("idle_on_water", "idle_on")

		if owner ~= nil and inst.components.equippable:IsEquipped() then
			owner.AnimState:OverrideSymbol("swap_object", "swap_bottlle_lantern", "swap_lantern_on")
			owner.AnimState:Show("LANTERN_OVERLAY")
		end

		inst.components.machine.ison = true
		inst.components.inventoryitem:ChangeImageName("bottlelantern")
		inst:PushEvent("lantern_on")
	end
end

local function turnoff(inst)
	stoptrackingowner(inst)

	inst.components.fueled:StopConsuming()

	if inst._light ~= nil then
		inst._light:Remove()
		PlayTurnOffSound(inst)
	end

	inst.components.floater:UpdateAnimations("idle_water", "idle_off")

	if inst.components.equippable:IsEquipped() then
		local owner = inst.components.inventoryitem.owner
		owner.AnimState:OverrideSymbol("swap_object", "swap_bottlle_lantern", "swap_lantern_off")
		owner.AnimState:Hide("LANTERN_OVERLAY")
	end

	inst.components.machine.ison = false
	inst.components.inventoryitem:ChangeImageName("bottlelantern_off")
	inst:PushEvent("lantern_off")
end

local function OnRemove(inst)
	if inst._light ~= nil then
		inst._light:Remove()
	end
	if inst._soundtask ~= nil then
		inst._soundtask:Cancel()
	end
end

local function ondropped(inst)
	turnoff(inst)
	turnon(inst)
end

local function onequip(inst, owner)
    if owner.sg:HasStateTag("rowing") then return end
	owner.AnimState:OverrideSymbol("swap_object", "swap_bottlle_lantern", "swap_lantern_off")
	owner.AnimState:OverrideSymbol("lantern_overlay", "swap_bottlle_lantern", "lantern_overlay")

	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")

	if inst.components.fueled:IsEmpty() then
		owner.AnimState:OverrideSymbol("swap_object", "swap_bottlle_lantern", "swap_lantern_off")
		owner.AnimState:Hide("LANTERN_OVERLAY")
	else
		owner.AnimState:OverrideSymbol("swap_object", "swap_bottlle_lantern", "swap_lantern_on")
		owner.AnimState:Show("LANTERN_OVERLAY")
		turnon(inst)
	end
end

local function onunequip(inst, owner)
	owner.AnimState:Hide("ARM_carry")
	owner.AnimState:Show("ARM_normal")
	owner.AnimState:ClearOverrideSymbol("lantern_overlay")
	owner.AnimState:Hide("LANTERN_OVERLAY")

	if inst.components.machine.ison then
		starttrackingowner(inst, owner)
	end
end

local function nofuel(inst)
	if inst.components.equippable:IsEquipped() and inst.components.inventoryitem.owner ~= nil then
		local data =
		{
			prefab = inst.prefab,
			equipslot = inst.components.equippable.equipslot,
		}
		turnoff(inst)
		inst.components.inventoryitem.owner:PushEvent("torchranout", data)
	else
		turnoff(inst)
	end
end

local function ontakefuel(inst)
	if inst.components.equippable:IsEquipped() then
		turnon(inst)
	end
end

--------------------------------------------------------------------------

local function OnLightWake(inst)
	if not inst.SoundEmitter:PlayingSound("loop") then
		inst.SoundEmitter:PlaySound("ia/common/bottlelantern_lp", "loop")
	end
end

local function OnLightSleep(inst)
	inst.SoundEmitter:KillSound("loop")
end

--------------------------------------------------------------------------

local function lanternlightfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddLight()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst:AddTag("FX")

	inst.Light:SetColour(0 / 255, 180 / 255, 255 / 255)

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.persists = false

	inst.OnEntityWake = OnLightWake
	inst.OnEntitySleep = OnLightSleep

	return inst
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("lantern_bottle")
	inst.AnimState:SetBuild("lantern_bottle")
	inst.AnimState:PlayAnimation("idle_off")

	inst:AddTag("light")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_off")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)

	inst.components.inventoryitem:SetOnDroppedFn(ondropped)
	inst.components.inventoryitem:SetOnPutInInventoryFn(turnoff)

	inst:AddComponent("equippable")

	inst:AddComponent("fueled")

	inst:AddComponent("machine")
	inst.components.machine.turnonfn = turnon
	inst.components.machine.turnofffn = turnoff
	inst.components.machine.cooldowntime = 0

	inst.components.fueled.fueltype = FUELTYPE.CAVE
	inst.components.fueled:InitializeFuelLevel(TUNING.BOTTLE_LANTERN_LIGHTTIME)
	inst.components.fueled:SetDepletedFn(nofuel)
	inst.components.fueled:SetUpdateFn(fuelupdate)
	inst.components.fueled:SetTakeFuelFn(ontakefuel)
	inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
	inst.components.fueled.accepting = true

	inst._light = nil

	MakeHauntableLaunch(inst)

	inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)

	inst.OnRemoveEntity = OnRemove

	inst._onownerequip = function(owner, data)
		if data.item ~= inst and
			(   data.eslot == EQUIPSLOTS.HANDS or
				(data.eslot == EQUIPSLOTS.BODY and data.item:HasTag("heavy"))
			) then
			turnoff(inst)
		end
	end

    inst:ListenForEvent("startrowing", function(inst, data)
        turnoff(inst)
    end)  

    inst:ListenForEvent("stoprowing", function(inst, data)
        turnon(inst)
    end)

	return inst
end

return Prefab("bottlelantern", fn, assets, prefabs),
	Prefab("bottlelanternlight", lanternlightfn)
%%+%%scripts/prefabs/buoy.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/buoy.zip"),
}

local prefabs = {
    "collapse_small",
}

local function onhammered(inst, worker)
    if inst:HasTag("fire") and inst.components.burnable then
        inst.components.burnable:Extinguish()
    end
    inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("metal")
    inst:Remove()
end

local function onhit(inst, worker)
    inst.sg:GoToState("hit")
end

local function onbuilt(inst)
    inst.sg:GoToState("place")
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .2)    
    
    inst.MiniMapEntity:SetIcon("buoy.tex")
    
    inst.AnimState:SetBank("buoy")
    inst.AnimState:SetBuild("buoy")
    inst.AnimState:PlayAnimation("idle", true)

    inst.Light:Enable(true)
    inst.Light:SetIntensity(.75)
    inst.Light:SetColour(223/255,246/255,255/255)
    inst.Light:SetFalloff(0.5)
    inst.Light:SetRadius(2)

    inst:AddTag("structure")
    
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end
    
    inst:AddComponent("inspectable")
    inst:AddComponent("lootdropper") 
    
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)
    MakeSnowCovered(inst, .01)  

    inst:ListenForEvent("onbuilt", onbuilt)

    inst:SetStateGraph("SGbuoy")

    return inst
end

return Prefab("buoy", fn, assets, prefabs),
    MakePlacer("buoy_placer", "buoy", "buoy", "idle") 
%%+%%scripts/prefabs/cannonshot.lua%%-%%local assets=
{
    Asset("ANIM", "anim/coconade.zip"),
    Asset("ANIM", "anim/swap_coconade.zip"),
}

local prefabs = 
{
    "impact",
    "explode_small",
    "bombsplash",
}

local function addfirefx(inst, owner)
    if not inst.fire then
        inst.SoundEmitter:KillSound("hiss")
        inst.SoundEmitter:PlaySound("dontstarve/common/blackpowder_fuse_LP", "hiss")
        inst.fire = SpawnPrefab("torchfire")
        local follower = inst.fire.entity:AddFollower()
        if owner then
            follower:FollowSymbol(owner.GUID, "swap_object", 40, -140, 1 )
        else
            follower:FollowSymbol(inst.GUID, "swap_flame", 0, 0, 0.1 )
        end
    end
end

local function removefirefx(inst)
    if inst.fire then
        inst.fire:Remove()
        inst.fire = nil
    end
end

local function LightTaskFn(inst)
	local pos = inst:GetPosition()

	if pos.y <= 0.3 then
		inst.components.explosive:OnBurnt()
	end

	if inst.fire then
		local rad = math.clamp(Lerp(2, 0, pos.y/6), 0, 2)
		local intensity = math.clamp(Lerp(0.8, 0.5, pos.y/7), 0.5, 0.8)
		local fire = inst.fire._light
		fire.Light:SetRadius(rad)
		fire.Light:SetIntensity(intensity)
	end
end

local function onthrown(inst, thrower, pt)
    inst.components.burnable:Ignite()
    inst.Physics:SetFriction(.2)
    inst.Transform:SetFourFaced()
    inst:FacePoint(pt:Get())
    inst.AnimState:PlayAnimation("throw", true)

    inst.SoundEmitter:PlaySound("ia/common/cannon_fire")

    local smoke = SpawnPrefab("collapse_small")

    local x, y, z = inst.Transform:GetWorldPosition()
    y = y + 1

    if thrower and thrower.visual then
        smoke.Transform:SetPosition(thrower.visual.AnimState:GetSymbolPosition("swap_lantern", 0, 0, 0))
    else 
        smoke.Transform:SetPosition(x, y, z)
    end 

    inst.LightTask = inst:DoPeriodicTask(FRAMES, LightTaskFn)
end

local function onexplode(inst)
    local pos = inst:GetPosition()

    inst.SoundEmitter:PlaySound("ia/common/cannon_hit")
    if inst:GetIsOnWater() then
        SpawnWaves(inst, 6, 360, 5)
        local splash = SpawnPrefab("bombsplash")
        splash.Transform:SetPosition(pos.x, pos.y, pos.z)

        inst.SoundEmitter:PlaySound("ia/common/cannon_impact")
        inst.SoundEmitter:PlaySound("ia/common/volcano/rock_splash")

    else
        local explode = SpawnPrefab("explode_small")
        explode.Transform:SetPosition(pos.x, pos.y, pos.z)
    end
end

local function onremove(inst)
    inst.SoundEmitter:KillSound("hiss")
    removefirefx(inst)
    if inst.LightTask then
        inst.LightTask:Cancel()
    end
end

local function onignite(inst)
    addfirefx(inst)
end

local function fn(CANNON_DAMAGE)
    local inst = CreateEntity()
    
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
    
    inst.AnimState:SetBank("coconade")
    inst.AnimState:SetBuild("coconade")
    inst.AnimState:PlayAnimation("idle")
    
    inst:AddTag("thrown")
    inst:AddTag("projectile")
    inst:AddTag("NOCLICK")

	--This used to be floatable for some obscure reason. It isn't even an inventory item! -M
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeInventoryPhysics(inst)
    
    inst:AddComponent("throwable")
    inst.components.throwable.onthrown = onthrown
    inst.components.throwable.maxdistance = 20

    inst:AddComponent("explosive")
    inst.components.explosive:SetOnExplodeFn(onexplode)
    inst.components.explosive.explosivedamage = CANNON_DAMAGE
    inst.components.explosive.explosiverange = TUNING.BOATCANNON_RADIUS
    inst.components.explosive.buildingdamage = TUNING.BOATCANNON_BUILDINGDAMAGE

    inst:AddComponent("burnable")
    inst.components.burnable.onignite = onignite
    inst.components.burnable.nofx = true

    inst.persists = false
    inst.OnRemoveEntity = onremove

    return inst
end

return Prefab("cannonshot", function() return fn(TUNING.BOATCANNON_DAMAGE) end, assets, prefabs),
    Prefab("woodlegs_cannonshot", function() return fn(TUNING.WOODLEGS_BOATCANNON_DAMAGE) end, assets, prefabs)%%+%%scripts/prefabs/chefpack.lua%%-%%local assets = {
    Asset("ANIM", "anim/swap_chefpack.zip"),
}

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_body", "swap_chefpack", "backpack")
    owner.AnimState:OverrideSymbol("swap_body", "swap_chefpack", "swap_body")
	
	-- if owner:HasTag("warly") then
		-- inst:AddTag("fridge")
	-- end
	
    if inst.components.container ~= nil then
        inst.components.container:Open(owner)
    end
end

local function onunequip(inst, owner)
    owner.AnimState:ClearOverrideSymbol("swap_body")
    owner.AnimState:ClearOverrideSymbol("backpack")

	-- inst:RemoveTag("fridge")
	
    if inst.components.container ~= nil then
        inst.components.container:Close(owner)
    end
end

local function onburnt(inst)
    if inst.components.container ~= nil then
        inst.components.container:DropEverything()
        inst.components.container:Close()
    end

    SpawnAt("ash", inst)

    inst:Remove()
end

local function onignite(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = false
    end
end

local function onextinguish(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = true
    end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("chefpack")
    inst.AnimState:SetBuild("swap_chefpack")
    inst.AnimState:PlayAnimation("anim")

    inst:AddTag("backpack")
    inst:AddTag("fridge")
    inst:AddTag("nocool")

    inst.MiniMapEntity:SetIcon("chefpack.tex")

    inst.foleysound = "dontstarve/movement/foley/backpack"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)
    inst.components.inventoryitem.cangoincontainer = false

    inst:AddComponent("equippable")
    inst.components.equippable.equipslot = EQUIPSLOTS.BACK

    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)
    
    inst:AddComponent("container")
    inst.components.container:WidgetSetup("chefpack")

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    inst.components.burnable:SetOnBurntFn(onburnt)
    inst.components.burnable:SetOnIgniteFn(onignite)
    inst.components.burnable:SetOnExtinguishFn(onextinguish)

    MakeHauntableLaunchAndDropFirstItem(inst)

    return inst
end

return Prefab("chefpack", fn, assets)%%+%%scripts/prefabs/chess_navy_spawner.lua%%-%%--sends chessnavy.lua an event on entity wake if activated.

local function OnEntitySleep(inst)
	inst.spawn_point_active = true
end

local function OnEntityWake(inst)
	if inst.spawn_point_active then
		inst:PushEvent("onentitywake")
	end
end

local function OnSave(inst, data)
	data.spawn_point_active = inst.spawn_point_active
end

local function OnLoad(inst, data)
	inst.spawn_point_active = data.spawn_point_active or false
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()

	inst:AddTag("NOCLICK")

	inst.spawn_point_active = false
	inst.OnEntitySleep = OnEntitySleep
	inst.OnEntityWake = OnEntityWake
	inst.OnSave = OnSave
	inst.OnLoad = OnLoad

	return inst
end

return Prefab("chess_navy_spawner", fn)%%+%%scripts/prefabs/chiminea.lua%%-%%require "prefabutil"

local assets = {
	Asset("ANIM", "anim/chiminea.zip"),
}

local prefabs = {
    "chimineafire",
    "collapse_small",
    "ash",
}

local function onhammered(inst, worker)
	inst.components.lootdropper:DropLoot()
	SpawnPrefab("ash").Transform:SetPosition(inst.Transform:GetWorldPosition())
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("stone")
	inst:Remove()
end

local function onhit(inst, worker)
	inst.AnimState:PlayAnimation("hit")
	inst.AnimState:PushAnimation("idle")
end

local function onextinguish(inst)
    if inst.components.fueled then
        inst.components.fueled:InitializeFuelLevel(0)
    end
end

local function ontakefuel(inst)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function onupdatefueled(inst)
    if inst.components.burnable and inst.components.fueled then
        inst.components.burnable:SetFXLevel(inst.components.fueled:GetCurrentSection(), inst.components.fueled:GetSectionPercent())
    end
end

local function onfuelchange(newsection, oldsection, inst, doer)
    if newsection <= 0 then
        inst.components.burnable:Extinguish()
    else
        if not inst.components.burnable:IsBurning() then
            inst.components.burnable:Ignite(nil, nil, doer)
        end
        inst.components.burnable:SetFXLevel(newsection, inst.components.fueled:GetSectionPercent())
    end
end

local SECTION_STATUS = {
    [0] = "OUT",
    [1] = "EMBERS",
    [2] = "LOW",
    [3] = "NORMAL",
    [4] = "HIGH",
}

local function getstatus(inst)
    return SECTION_STATUS[inst.components.fueled:GetCurrentSection()]
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle", false)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function OnHaunt(inst, haunter)
    if math.random() <= TUNING.HAUNT_CHANCE_RARE and
        inst.components.fueled ~= nil and
        not inst.components.fueled:IsEmpty() then
        inst.components.fueled:DoDelta(TUNING.MED_FUEL)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    --#HAUNTFIX
    --elseif math.random() <= TUNING.HAUNT_CHANCE_HALF and
        --inst.components.workable ~= nil and
        --inst.components.workable:CanBeWorked() then
        --inst.components.workable:WorkedBy(haunter, 1)
        --inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        --return true
    end
    return false
end

local function OnInit(inst)
    if inst.components.burnable ~= nil then
        inst.components.burnable:FixFX()
    end
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
	inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()
  
    MakeObstaclePhysics(inst, .3)

	inst.MiniMapEntity:SetIcon("chiminea.tex")
	inst.MiniMapEntity:SetPriority(1)

    inst.AnimState:SetBank("chiminea")
    inst.AnimState:SetBuild("chiminea")
    inst.AnimState:PlayAnimation("idle",false)

    inst:AddTag("campfire")
    inst:AddTag("structure")
    inst:AddTag("wildfireprotected")

    --cooker (from cooker component) added to pristine state for optimization
    inst:AddTag("cooker")
    
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end

    -----------------------
    inst:AddComponent("burnable")
    --inst.components.burnable:SetFXLevel(2)
    inst.components.burnable:AddBurnFX("chimineafire", Vector3(0,0,0))
    inst:ListenForEvent("onextinguish", onextinguish)
    
    -------------------------
    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)

    -------------------------
    inst:AddComponent("cooker")
    -------------------------
    inst:AddComponent("fueled")
    inst.components.fueled.maxfuel = TUNING.CHIMINEA_FUEL_MAX
    inst.components.fueled.accepting = true
    
    inst.components.fueled:SetSections(4)
    inst.components.fueled.bonusmult = TUNING.CHIMINEA_BONUS_MULT
    inst.components.fueled:SetTakeFuelFn(ontakefuel)
    inst.components.fueled:SetUpdateFn(onupdatefueled)
    inst.components.fueled:SetSectionCallback(onfuelchange)
    inst.components.fueled:InitializeFuelLevel(TUNING.CHIMINEA_FUEL_START)

    -----------------------------

    inst:AddComponent("hauntable")
    inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_HUGE
    inst.components.hauntable:SetOnHauntFn(OnHaunt)
    
    -----------------------------
    
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

    inst:ListenForEvent("onbuilt", onbuilt)

    inst:DoTaskInTime(0, OnInit)
    
    return inst
end

return Prefab("chiminea", fn, assets, prefabs),
		MakePlacer("chiminea_placer", "chiminea", "chiminea", "preview") %%+%%scripts/prefabs/chimineafire.lua%%-%%local assets = {
    Asset("ANIM", "anim/chiminea_fire.zip"),
}

local heats = {70, 85, 100, 115}

local function GetHeatFn(inst)
    return heats[inst.components.firefx.level] or 20
end

local firelevels =
{
    {anim="level1", sound="ia/common/chiminea_fire_lp", radius=2, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.1},
    {anim="level2", sound="ia/common/chiminea_fire_lp", radius=3, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.3},
    {anim="level3", sound="ia/common/chiminea_fire_lp", radius=4, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.6},
    {anim="level4", sound="ia/common/chiminea_fire_lp", radius=5, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=1},
}

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("chiminea_fire")
    inst.AnimState:SetBuild("chiminea_fire")
    inst.AnimState:SetBloomEffectHandle("shaders/anim.ksh")
    inst.AnimState:SetRayTestOnBB(true)
    inst.AnimState:SetFinalOffset(-1)

    inst:AddTag("FX")

    --HASHEATER (from heater component) added to pristine state for optimization
    inst:AddTag("HASHEATER")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("heater")
    inst.components.heater.heatfn = GetHeatFn

    inst:AddComponent("firefx")
    inst.components.firefx.levels = firelevels
    inst.components.firefx:SetLevel(1)
    inst.components.firefx.usedayparamforsound = true

    return inst
end

return Prefab("chimineafire", fn, assets) 
%%+%%scripts/prefabs/coconade.lua%%-%%local assets=
{
	Asset("ANIM", "anim/coconade.zip"),
	Asset("ANIM", "anim/swap_coconade.zip"),

	Asset("ANIM", "anim/coconade_obsidian.zip"),
	Asset("ANIM", "anim/swap_coconade_obsidian.zip"),
	
	Asset("ANIM", "anim/explode_ring_fx.zip"),
}

local prefabs =
{
	"explode_large",
	"explodering_fx",
    "reticule",
}

local function addfirefx(inst, owner)
    if not inst.fire then
		inst.SoundEmitter:KillSound("hiss")
    	inst.SoundEmitter:PlaySound("ia/common/coconade_fuse", "hiss")
        inst.fire = SpawnPrefab( "torchfire" )
        inst.fire.entity:AddFollower()
    end
	if owner then
		inst.fire.Follower:FollowSymbol( owner.GUID, "swap_object", 40, -140, 1 )
	else
		inst.fire.Follower:FollowSymbol( inst.GUID, "swap_flame", 0, 0, 0.1 )
	end
end

local function removefirefx(inst)
    if inst.fire then
		inst.SoundEmitter:KillSound("hiss")
        inst.fire:Remove()
        inst.fire = nil
    end
end

local function onfuse(inst)
	inst.components.explosive:OnBurnt()
end

local function onuse(inst)
	-- if inst.fusetask then
		-- removefirefx(inst)
		-- inst.fusetask:Cancel()
		-- inst.fusetask = nil
	-- else
		local owner = inst.components.inventoryitem.owner
		-- if inst.components.burnable:IsBurning() then
			addfirefx(inst, owner)
		-- end
		inst.fusetarget = GetTime() + TUNING.COCONADE_FUSE
		inst.fusetask = inst:DoTaskInTime(TUNING.COCONADE_FUSE, onfuse)
		inst.fusestart:push()
	-- end
	-- inst.components.useableitem.inuse = false
end

local function onequip(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", inst.swapsymbol, inst.swapbuild)
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
	if inst.fusetask then
		addfirefx(inst, owner)
	end
end

local function onunequip(inst, owner)
	owner.AnimState:ClearOverrideSymbol("swap_object")
	owner.AnimState:Hide("ARM_carry")
	owner.AnimState:Show("ARM_normal")
	removefirefx(inst)
end

local function ondropped(inst)
	-- if inst.components.burnable:IsBurning() then
	if inst.fusetask then
		addfirefx(inst)
	end
end

local function onputininventory(inst)
    inst.Physics:SetFriction(.1) --no idea why we are setting friction here, but it does in SW -M
	removefirefx(inst)
	-- if inst.components.burnable:IsBurning() then
    	-- inst.SoundEmitter:PlaySound("ia/common/coconade_fuse", "hiss")
	-- end
end

local function updatelight(inst)
	if inst.fire then
		local pos = inst:GetPosition()
		local rad = math.clamp(Lerp(2, 0, pos.y/6), 0, 2)
		local intensity = math.clamp(Lerp(0.8, 0.5, pos.y/7), 0.5, 0.8)
		local fire = inst.fire._light
		fire.Light:SetRadius(rad)
		fire.Light:SetIntensity(intensity)
	end
end

local function onhitground(inst, thrower, target)
	inst.AnimState:PlayAnimation("idle")
	inst.components.floater:UpdateAnimations("idle_water", "idle") --is this needed?
    inst:RemoveTag("NOCLICK")
	inst.components.inventoryitem:OnDropped()
	-- inst:DoTaskInTime(2, function()
		-- if inst and inst.LightTask then
			-- inst.LightTask:Cancel()
			-- inst.LightTask = nil
		-- end
	-- end)
end

local function onthrown(inst)
	-- local fusetime = TUNING.COCONADE_FUSE
	-- if inst.fusetarget ~= nil and inst.fusetarget > GetTime() then
		-- fusetime = inst.fusetarget - GetTime()
	-- end
	-- inst.fusetask = inst:DoTaskInTime(fusetime, onfuse)
	
    inst:AddTag("NOCLICK")
	if inst.fusetask then
		addfirefx(inst)
	end
	
    inst.Physics:SetFriction(.2)
	inst.Transform:SetFourFaced()
	-- inst:FacePoint(pt:Get())
    inst.AnimState:PlayAnimation("throw", true)
    inst.SoundEmitter:PlaySound("ia/common/coconade_throw")

	-- inst.LightTask = inst:DoPeriodicTask(FRAMES, function()
		-- local pos = inst:GetPosition()

		-- if pos.y <= 0.1 then
			-- onhitground(inst)
		-- end
		
		-- updatelight(inst)
	-- end)
end

local function onexplode(inst, scale)
	scale = scale or 1

	local explode = SpawnPrefab("explode_large")
	local ring = SpawnPrefab("explodering_fx")
	local pos = inst:GetPosition()

	ring.Transform:SetPosition(pos.x, pos.y, pos.z)
	ring.Transform:SetScale(scale, scale, scale)

	explode.Transform:SetPosition(pos.x, pos.y, pos.z)
	-- explode.AnimState:SetBloomEffectHandle( "shaders/anim.ksh" )
	-- explode.AnimState:SetLightOverride(1)
	explode.Transform:SetScale(scale, scale, scale)
end

local function onexplode_obsid(inst)
	inst.SoundEmitter:PlaySound("ia/common/coconade_obsidian_explode")
	onexplode(inst, 1.3)
end

local function onignite(inst)
	-- inst.components.fuse:StartFuse()
    if inst.components.equippable:IsEquipped() then
    	local owner = inst.components.inventoryitem.owner
    	addfirefx(inst, owner)
    elseif not inst.components.inventoryitem:IsHeld() then
    	addfirefx(inst)
    end

	inst.fusestart:push()
	if inst.components.useableitem then
		inst.components.useableitem.inuse = true
	end
end

local function getstatus(inst)
    if inst.components.burnable:IsBurning() then
        return "BURNING"
    end
end

local function onremove(inst)
	inst.SoundEmitter:KillSound("hiss")
	removefirefx(inst)
	if inst.LightTask then
		inst.LightTask:Cancel()
	end
end

local function ReticuleTargetFn()
	-- return inst.components.throwable:GetThrowPoint()
    local player = TheLocalPlayer
    local ground = TheWorld.Map
    local pos = Vector3()
    --Attack range is 8, leave room for error
    --Min range was chosen to not hit yourself (2 is the hit range)
    for r = 6.5, 3.5, -.25 do
        pos.x, pos.y, pos.z = player.entity:LocalToWorldSpace(r, 0, 0)
        if ground:IsPassableAtPoint(pos:Get()) and not ground:IsGroundTargetBlocked(pos) then
            return pos
        end
    end
    return pos
end

local function fusestart(inst)
	inst.fusevalue = TUNING.COCONADE_FUSE
	inst:PushEvent("fusechanged")
	inst:DoPeriodicTask(1, function()
		--Do the countdown locally as to not clog the network, I guess. Really, I'm just being lazy here. -M
		inst.fusevalue = inst.fusevalue - 1
		inst:PushEvent("fusechanged")
	end)
end

local function commonfn()
	local inst = CreateEntity()
	
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)
	
	inst:AddTag("thrown")
	inst:AddTag("projectile")
	inst:AddTag("fuse") --UI optimisation
	
    inst:AddComponent("reticule")
    inst.components.reticule.targetfn = ReticuleTargetFn
    inst.components.reticule.ease = true

    inst.OnRemoveEntity = onremove

	--stuff for fuse UI
	--I'm too lazy to make this a component, and it's probably better for network -M
	inst.fusestart = net_event(inst.GUID, "fusestart")
	inst:ListenForEvent("fusestart", fusestart)
	
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
	return inst
end

local function masterfn(inst)

	inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = getstatus

	MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnDroppedFn(ondropped)
    inst.components.inventoryitem:SetOnPutInInventoryFn(onputininventory)

    -- inst:AddComponent("fuse")
    -- inst.components.fuse:SetFuseTime(TUNING.COCONADE_FUSE)
    -- inst.components.fuse.onfusedone = onfuse

	-- inst:AddComponent("burnable")
	-- inst.components.burnable.onignite = onignite
	-- inst.components.burnable.nofx = true
	
    MakeSmallBurnable(inst, TUNING.COCONADE_FUSE)
    -- MakeSmallPropagator(inst)
    --V2C: Remove default OnBurnt handler, as it conflicts with
    --explosive component's OnBurnt handler for removing itself
    inst.components.burnable:SetOnBurntFn(nil)
    inst.components.burnable:SetOnIgniteFn(onignite)

	inst:AddComponent("equippable")
	inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)

    inst:AddComponent("useableitem")
    inst.components.useableitem:SetOnUseFn(onuse)
    -- inst.components.useableitem:SetOnStopUseFn(onstopuse)

	-- consider using complexprojectile instead and dumping "throwable"
	-- action "TOSS" should be already suitable
	-- inst:AddComponent("throwable")
	-- inst.components.throwable.onthrown = onthrown
	
    -- inst:AddComponent("locomotor")

    inst:AddComponent("complexprojectile")
    inst.components.complexprojectile:SetHorizontalSpeed(12)
    -- inst.components.complexprojectile:SetGravity(-15)
    inst.components.complexprojectile.usehigharc = false
    inst.components.complexprojectile:SetLaunchOffset(Vector3(.25, 1, 0))
    inst.components.complexprojectile:SetOnLaunch(onthrown)
    inst.components.complexprojectile:SetOnHit(onhitground)
    inst.components.complexprojectile:SetOnUpdate(updatelight)
	
    -- inst:AddComponent("weapon")
    -- inst.components.weapon:SetDamage(0)
    -- inst.components.weapon:SetRange(8, 10)
	
	inst:AddComponent("explosive")

	inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.WRATH_LARGE
	
	return inst
end


local function firefn()
	local inst = commonfn()

	inst.AnimState:SetBank("coconade")
	inst.AnimState:SetBuild("coconade")
	inst.AnimState:PlayAnimation("idle")

	inst.swapsymbol = "swap_coconade"
	inst.swapbuild = "swap_coconade"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
	masterfn(inst)
	
	inst.components.explosive:SetOnExplodeFn(onexplode)
	inst.components.explosive.explosivedamage = TUNING.COCONADE_DAMAGE
	inst.components.explosive.explosiverange = TUNING.COCONADE_EXPLOSIONRANGE
	inst.components.explosive.buildingdamage = TUNING.COCONADE_BUILDINGDAMAGE

	return inst
end

local function obsidianfn()
	local inst = commonfn()

	inst.AnimState:SetBank("coconade_obsidian")
	inst.AnimState:SetBuild("coconade_obsidian")
	inst.AnimState:PlayAnimation("idle")

	inst.swapsymbol = "swap_coconade_obsidian"
	inst.swapbuild = "swap_coconade_obsidian"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
	masterfn(inst)

	inst.components.explosive:SetOnExplodeFn(onexplode_obsid)
	inst.components.explosive.explosivedamage = TUNING.COCONADE_OBSIDIAN_DAMAGE
	inst.components.explosive.explosiverange = TUNING.COCONADE_OBSIDIAN_EXPLOSIONRANGE
	inst.components.explosive.buildingdamage = TUNING.COCONADE_OBSIDIAN_BUILDINGDAMAGE

	return inst
end

return Prefab("coconade", firefn, assets, prefabs),
	Prefab("obsidiancoconade", obsidianfn, assets, prefabs)
%%+%%scripts/prefabs/coconut.lua%%-%%require "prefabutil"
local assets =
{
  Asset("ANIM", "anim/coconut.zip"),
}

local function plant(inst, growtime)
    local sapling = SpawnPrefab("coconut_sapling")
    sapling:StartGrowing(growtime)
    sapling.Transform:SetPosition(inst.Transform:GetWorldPosition())
    sapling.SoundEmitter:PlaySound("dontstarve/wilson/plant_tree")
    inst:Remove()
end

local function ondeploy (inst, pt) 
  inst = inst.components.stackable:Get()
  inst.Transform:SetPosition(pt:Get() )
  local timeToGrow = GetRandomWithVariance(TUNING.COCONUT_GROWTIME.base, TUNING.COCONUT_GROWTIME.random)
  plant(inst, timeToGrow)

  --tell any nearby leifs to chill out
  local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, TUNING.LEIF_PINECONE_CHILL_RADIUS, {"leif"})

  local played_sound = false
  for k,v in pairs(ents) do

    local chill_chance = TUNING.LEIF_PINECONE_CHILL_CHANCE_FAR
    if distsq(pt, Vector3(v.Transform:GetWorldPosition())) < TUNING.LEIF_PINECONE_CHILL_CLOSE_RADIUS*TUNING.PALMTREEGUARD_PINECONE_CHILL_CLOSE_RADIUS then
      chill_chance = TUNING.LEIF_PINECONE_CHILL_CHANCE_CLOSE
    end

    if math.random() < chill_chance then
      if v.components.sleeper then
        v.components.sleeper:GoToSleep(1000)
      end
    else
      if not played_sound then
        v.SoundEmitter:PlaySound("dontstarve/creatures/leif/taunt_VO")
        played_sound = true
      end
    end

  end

end

-- local notags = {'NOBLOCK', 'player', 'FX'}
-- local function test_ground(inst, pt)
  -- local tiletype = GetGroundTypeAtPosition(pt)
  -- local ground_OK = tiletype == GROUND.DIRT or tiletype == GROUND.BEACH
  -- inst:IsPosSurroundedByLand(pt.x, pt.y, pt.z, 1)

  -- if ground_OK then
    -- local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, 4, nil, notags) -- or we could include a flag to the search?
    -- local min_spacing = inst.components.deployable.min_spacing or 2

    -- for k, v in pairs(ents) do
      -- if v ~= inst and v:IsValid() and v.entity:IsVisible() and not v.components.placer and v.parent == nil then
        -- if distsq( Vector3(v.Transform:GetWorldPosition()), pt) < min_spacing*min_spacing then
          -- return false
        -- end
      -- end
    -- end
    -- return true
  -- end
  -- return false
-- end

local function OnLoad(inst, data)
  if data and data.growtime then
    plant(inst, data.growtime)
  end
end

local function clientcommon()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("coconut")
  inst.AnimState:SetBuild("coconut")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("coconut")
  inst:AddTag("cattoy")

	return inst
end

local function mastercommon(inst)
	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)

  inst:AddComponent("tradable")

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
  MakeSmallPropagator(inst)
  MakeHauntableLaunchAndPerish(inst)

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_PRESERVED)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst:AddComponent("edible")
  inst.components.edible.foodtype = FOODTYPE.RAW

  MakeInvItemIA(inst)
end

local function onhacked(inst)
  local nut = inst 
  if inst.components.inventoryitem then 
    local owner = inst.components.inventoryitem.owner
    if inst.components.stackable and inst.components.stackable.stacksize > 1 then 
      nut = inst.components.stackable:Get()
      inst.components.workable:SetWorkLeft(1)
    end 
    if owner then 
      local hacked = SpawnPrefab("coconut_halved")
      hacked.components.stackable.stacksize = 2
      if owner.components.inventory and not owner.components.inventory:IsFull() then
        owner.components.inventory:GiveItem(hacked)
      elseif owner.components.container and not owner.components.container:IsFull() then
        owner.components.container:GiveItem(hacked)
      else
        inst.components.lootdropper:DropLootPrefab(hacked)
      end
    else 
      inst.components.lootdropper:SpawnLootPrefab("coconut_halved")
      inst.components.lootdropper:SpawnLootPrefab("coconut_halved")
    end 
    inst.SoundEmitter:PlaySound("ia/common/bamboo_hack")
  end
  nut:Remove()

end 

local function raw()
  local inst = clientcommon()

	inst:AddTag("deployedplant")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

	mastercommon(inst)

  inst.components.inventoryitem.imagename = "coconut" --Why is this explicitly set to the prefab name? -M

  inst:AddTag("show_spoilage")
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HACK)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable:SetOnFinishCallback(onhacked)

  inst:AddComponent("lootdropper")

  inst:AddComponent("deployable")
  inst.components.deployable:SetDeployMode(DEPLOYMODE.PLANT)
  inst.components.deployable.ondeploy = ondeploy


  inst.components.edible.healthvalue = 0
  inst.components.edible.hungervalue = TUNING.CALORIES_TINY/2

  inst.OnLoad = OnLoad

  return inst
end 

local function cooked()
  local inst = clientcommon()

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("cooked_water", "cook")
	
  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

	mastercommon(inst)

  inst.components.inventoryitem.imagename = "coconut_cooked"

  inst.AnimState:PlayAnimation("cook")
  
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.hungervalue = TUNING.CALORIES_TINY
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
  inst.components.edible.foodtype = FOODTYPE.SEEDS

  return inst
end

local function halved()
  local inst = clientcommon()

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("chopped_water", "chiopped")
	
  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

	mastercommon(inst)

  inst.components.inventoryitem.imagename = "coconut_halved"

  inst:AddComponent("cookable")
  inst.components.cookable.product = "coconut_cooked"
  inst.AnimState:PlayAnimation("chopped")
  
  inst.components.edible.hungervalue = TUNING.CALORIES_TINY/2
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
  inst.components.edible.foodtype = FOODTYPE.SEEDS

  return inst
end


local function growtree(inst)
    local tree = SpawnPrefab("palmtree_short")
    if tree then
        tree.Transform:SetPosition(inst.Transform:GetWorldPosition())
        tree:growfromseed()
        inst:Remove()
    end
end

local function stopgrowing(inst)
    inst.components.timer:StopTimer("grow")
end

local function startgrowing(inst, growtime)
    if not inst.components.timer:TimerExists("grow") then
        growtime = growtime or GetRandomWithVariance(TUNING.COCONUT_GROWTIME.base, TUNING.COCONUT_GROWTIME.random)
        inst.components.timer:StartTimer("grow", growtime)
    end
end

local function ontimerdone(inst, data)
    if data.name == "grow" then
        growtree(inst)
    end
end

local function digup(inst, digger)
    inst.components.lootdropper:DropLoot()
    inst:Remove()
end

local function saplingfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst.AnimState:SetBank("coconut")
	inst.AnimState:SetBuild("coconut")
	inst.AnimState:PlayAnimation("planted")

	-- inst:AddTag("coconut")
	-- inst:AddTag("isgrowing")
	inst:AddTag("plant")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.StartGrowing = startgrowing

	inst:AddComponent("timer")
	inst:ListenForEvent("timerdone", ontimerdone)
	startgrowing(inst)

	inst:AddComponent("inspectable")

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetLoot({"twigs"})

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.DIG)
	inst.components.workable:SetOnFinishCallback(digup)
	inst.components.workable:SetWorkLeft(1)

	MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
	inst:ListenForEvent("onignite", stopgrowing)
	inst:ListenForEvent("onextinguish", startgrowing)
	MakeSmallPropagator(inst)

	MakeHauntableIgnite(inst)

	return inst
end

return Prefab( "coconut", raw, assets, prefabs),
Prefab( "coconut_sapling", saplingfn, assets),
Prefab( "coconut_cooked", cooked, assets),
Prefab( "coconut_halved", halved, assets),
MakePlacer( "coconut_placer", "coconut", "coconut", "planted" ) 


%%+%%scripts/prefabs/coffeebush.lua%%-%%require("prefabutil")

local assets = {
    Asset("ANIM", "anim/coffeebush.zip"),
}

local rawassets = {
    Asset("ANIM", "anim/coffeebeans.zip"),
}

local cookedassets = {
    Asset("ANIM", "anim/coffeebeans.zip"),
}

local prefabs = {
    "coffeebeans",
    "dug_coffeebush",
    "twigs",
}

local rawprefabs = {
    "coffeebeans_cooked",
    "spoiled_food",
}

local function makeemptyfn(inst)
    if POPULATING then
        inst.AnimState:PlayAnimation("empty", true)
        inst.AnimState:SetTime(math.random() * inst.AnimState:GetCurrentAnimationLength())
    elseif inst:HasTag("withered") or inst.AnimState:IsCurrentAnimation("idle_dead") then
        inst.AnimState:PlayAnimation("dead_to_empty")
        inst.AnimState:PushAnimation("empty")
    else
        inst.AnimState:PlayAnimation("empty", true)
    end
end

local function makebarrenfn(inst)
    if not POPULATING and (inst:HasTag("withered") or inst.AnimState:IsCurrentAnimation("idle")) then
        inst.AnimState:PlayAnimation("empty_to_dead")
        inst.AnimState:PushAnimation("idle_dead", false)
    else
        inst.AnimState:PlayAnimation("idle_dead")
    end
end

local function pickanim(inst)
    if inst.components.pickable then
        if inst.components.pickable:CanBePicked() then
            local percent = 0
            if inst.components.pickable then
                percent = inst.components.pickable.cycles_left / inst.components.pickable.max_cycles
            end
            if percent >= .9 then
                return "berriesmost"
            elseif percent >= .33 then
                return "berriesmore"
            else
                return "berries"
            end
        else
            if inst.components.pickable:IsBarren() then
                return "idle_dead"
            else
                return "idle"
            end
        end
    end

    return "idle"
end


local function shake(inst)
    if inst.components.pickable and inst.components.pickable:CanBePicked() then
        inst.AnimState:PlayAnimation("shake")
    else
        inst.AnimState:PlayAnimation("shake_empty")
    end
    inst.AnimState:PushAnimation(pickanim(inst), false)
end

local function onpickedfn(inst, picker)
    if inst.components.pickable ~= nil then
        local old_percent = (inst.components.pickable.cycles_left+1) / inst.components.pickable.max_cycles

        if old_percent >= .9 then
            inst.AnimState:PlayAnimation("berriesmost_picked")
        elseif old_percent >= .33 then
            inst.AnimState:PlayAnimation("berriesmore_picked")
        else
            inst.AnimState:PlayAnimation("berries_picked")
        end

        if inst.components.pickable:IsBarren() then
            inst.AnimState:PushAnimation("empty_to_dead")
            inst.AnimState:PushAnimation("idle_dead", false)
        else
            inst.AnimState:PushAnimation("idle")
        end
    end
end

local function ongustpickfn(inst)
    if inst.components.pickable and inst.components.pickable:CanBePicked() then
        inst.components.pickable:MakeEmpty()
        local pt = inst:GetPosition()
        pt.y = pt.y + (inst.components.pickable.dropheight or 0)
        inst.components.lootdropper:SpawnLootPrefab(inst.components.pickable.product, pt)
    end
end

local function getregentimefn(inst)
    local num_cycles_passed = math.max(0, inst.components.pickable.max_cycles - (inst.components.pickable.cycles_left or inst.components.pickable.max_cycles))
    return TUNING.BERRY_REGROW_TIME
        + TUNING.BERRY_REGROW_INCREASE * num_cycles_passed
        + TUNING.BERRY_REGROW_VARIANCE * math.random()
end

local function makefullfn(inst)
    local anim = "idle"
    local berries = nil
    if inst.components.pickable ~= nil then
        if inst.components.pickable:CanBePicked() then
            local percent = inst.components.pickable.cycles_left ~= nil and inst.components.pickable.cycles_left / inst.components.pickable.max_cycles or 1
            if percent >= .9 then
                anim = "berriesmost"
            elseif percent >= .33 then
                anim = "berriesmore"
            else
                anim = "berries"
            end
        elseif inst.components.pickable:IsBarren() then
            anim = "idle_dead"
        end
    end
    if anim == "idle_dead" then
        inst.AnimState:PlayAnimation(anim)
    elseif POPULATING then
        inst.AnimState:PlayAnimation(anim, true)
        inst.AnimState:SetTime(math.random() * inst.AnimState:GetCurrentAnimationLength())
    else
        inst.AnimState:PushAnimation(anim, true)
    end
end

local function digupcoffeebush(inst, chopper)   
    if inst.components.pickable and inst.components.lootdropper then
        local withered = inst.components.witherable ~= nil and inst.components.witherable:IsWithered()
    
        if withered or inst.components.pickable:IsBarren() then
            inst.components.lootdropper:SpawnLootPrefab("twigs")
            inst.components.lootdropper:SpawnLootPrefab("twigs")
        else
            if inst.components.pickable and inst.components.pickable:CanBePicked() then
                local pt = inst:GetPosition()
                pt.y = pt.y + (inst.components.pickable.dropheight or 0)
                inst.components.lootdropper:SpawnLootPrefab(inst.components.pickable.product, pt)
            end
        
            inst.components.lootdropper:SpawnLootPrefab("dug_"..inst.prefab)
        end
    end 
    inst:Remove()
end

local function ontransplantfn(inst)
    inst.AnimState:PlayAnimation("idle_dead")
    inst.components.pickable:MakeBarren()
end

local function OnLoad(inst, data)
    -- just from world gen really
    if data and data.makebarren then
        makebarrenfn(inst)
        inst.components.pickable:MakeBarren()
    end
end

local function OnHaunt(inst)
    if math.random() <= TUNING.HAUNT_CHANCE_ALWAYS then
        shake(inst)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_COOLDOWN_TINY
        return true
    end
    return false
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeSmallObstaclePhysics(inst, .1)

    inst.MiniMapEntity:SetIcon("coffeebush.tex")

    inst.AnimState:SetBank("coffeebush")
    inst.AnimState:SetBuild("coffeebush")
    inst.AnimState:PlayAnimation("berriesmost", false)

    inst:AddTag("bush")
    inst:AddTag("renewable")
    inst:AddTag("fire_proof")

    --witherable (from witherable component) added to pristine state for optimization
    inst:AddTag("witherable")

    MakeSnowCoveredPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
    
    inst.AnimState:SetTime(math.random() * inst.AnimState:GetCurrentAnimationLength())

    inst:AddComponent("pickable")
    inst.components.pickable.picksound = "dontstarve/wilson/harvest_berries"
    inst.components.pickable.onpickedfn = onpickedfn
    inst.components.pickable.makeemptyfn = makeemptyfn
    inst.components.pickable.makebarrenfn = makebarrenfn
    inst.components.pickable.makefullfn = makefullfn
    inst.components.pickable.ontransplantfn = ontransplantfn

    inst.components.pickable:SetUp("coffeebeans", TUNING.BERRY_REGROW_TIME)
    inst.components.pickable.getregentimefn = getregentimefn
    inst.components.pickable.max_cycles = TUNING.BERRYBUSH_CYCLES + math.random(2)
    inst.components.pickable.cycles_left = inst.components.pickable.max_cycles

    inst:AddComponent("witherable")
    inst.components.witherable.volcanic = true
        
    AddHauntableCustomReaction(inst, OnHaunt, false, false, true)

    inst:AddComponent("lootdropper")

    if not GetGameModeProperty("disable_transplanting") then
        inst:AddComponent("workable")
        inst.components.workable:SetWorkAction(ACTIONS.DIG)
        inst.components.workable:SetOnFinishCallback(digupcoffeebush)
        inst.components.workable:SetWorkLeft(1)
    end

    inst:AddComponent("inspectable")

    inst:ListenForEvent("onwenthome", shake)
    MakeSnowCovered(inst)
    MakeNoGrowInWinter(inst)

    --[[
    inst:AddComponent("blowinwindgust")
    inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.BERRYBUSH_WINDBLOWN_SPEED)
    inst.components.blowinwindgust:SetDestroyChance(TUNING.BERRYBUSH_WINDBLOWN_FALL_CHANCE)
    inst.components.blowinwindgust:SetDestroyFn(ongustpickfn)
    inst.components.blowinwindgust:Start()
    --]]

    inst.OnLoad = OnLoad

    return inst
end

local function rawfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("coffeebeans")
    inst.AnimState:SetBuild("coffeebeans")
    inst.AnimState:PlayAnimation("idle")

    --cookable (from cookable component) added to pristine state for optimization
    inst:AddTag("cookable")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("edible")
    inst.components.edible.healthvalue = 0
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY
    inst.components.edible.sanityvalue = 0      
    inst.components.edible.foodtype = FOODTYPE.VEGGIE

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("inspectable")
    MakeInvItemIA(inst)

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)

    ---------------------        

    inst:AddComponent("bait")

    ------------------------------------------------
    inst:AddComponent("tradable")

    ------------------------------------------------  

    inst:AddComponent("cookable")
    inst.components.cookable.product = "coffeebeans_cooked"

    MakeHauntableLaunchAndPerish(inst)

    return inst
end

local function cookedfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("coffeebeans")
    inst.AnimState:SetBuild("coffeebeans")
    inst.AnimState:PlayAnimation("cooked")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("cooked_water", "cooked")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_SLOW)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("edible") 
    inst.components.edible.healthvalue = 0
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY
    inst.components.edible.sanityvalue = -TUNING.SANITY_TINY
    inst.components.edible.foodtype = FOODTYPE.VEGGIE

    inst.components.edible.caffeinedelta = TUNING.CAFFEINE_FOOD_BONUS_SPEED
    inst.components.edible.caffeineduration = TUNING.FOOD_SPEED_AVERAGE

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("inspectable")
    MakeInvItemIA(inst)

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)

    ---------------------        

    inst:AddComponent("bait")

    ------------------------------------------------
    inst:AddComponent("tradable")

    MakeHauntableLaunchAndPerish(inst)

    return inst
end

return Prefab("coffeebush", fn, assets, prefabs),
    Prefab("coffeebeans", rawfn, rawassets, rawprefabs),
    Prefab("coffeebeans_cooked", cookedfn, cookedassets)
%%+%%scripts/prefabs/coral.lua%%-%%local assets =
{
  Asset("ANIM", "anim/coral.zip"),
}

local prefabs =
{
}

local function fn()
  local inst  = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("coral")
  inst.AnimState:SetBuild("coral")
  inst.AnimState:PlayAnimation("idle_water", true)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("tradable")

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

	if IA_CONFIG.limestonerepair then
		inst:AddComponent("repairer")
		inst.components.repairer.repairmaterial = MATERIALS.LIMESTONE
		inst.components.repairer.workrepairvalue = TUNING.REPAIR_CORAL_WORK
		inst.components.repairer.healthrepairvalue = TUNING.REPAIR_CORAL_HEALTH
	end

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab("coral", fn, assets, prefabs)%%+%%scripts/prefabs/corallarve.lua%%-%%local assets=
{
	Asset("ANIM", "anim/corallarve.zip"),
}

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("corallarve")
    inst.AnimState:SetBuild("corallarve")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.HEAVY, TUNING.WINDBLOWN_SCALE_MAX.HEAVY)
	
    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)

    inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM   

	inst:AddComponent("waterproofer")
    inst:AddComponent("bait")
    inst:AddTag("molebait")

	inst:AddComponent("repairer")
	inst.components.repairer.repairmaterial = "stone"
	inst.components.repairer.healthrepairvalue = TUNING.REPAIR_CUTSTONE_HEALTH

	return inst
end

return Prefab( "corallarve", fn, assets) 
%%+%%scripts/prefabs/coral_brain.lua%%-%%local assets = {
    Asset("ANIM", "anim/brain_coral.zip")
}

local prefabs = {
    "spoiled_food",
}

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("brain_coral")
    inst.AnimState:SetBuild("brain_coral")
    inst.AnimState:PlayAnimation("idle")

    inst:AddTag("fishmeat")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.HEAVY, TUNING.WINDBLOWN_SCALE_MAX.HEAVY)

    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.MEAT
    inst.components.edible.healthvalue = -10
    inst.components.edible.sanityvalue = TUNING.SANITY_HUGE
    inst.components.edible.hungervalue = 10

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_ONE_DAY)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    return inst
end

return Prefab("coral_brain", fn, assets, prefabs)
%%+%%scripts/prefabs/coral_brain_rock.lua%%-%%local assets = {
    Asset("ANIM", "anim/brain_coral_rock.zip")
}

local prefabs = {
    "coral_brain",
}

local CORALSTATE = {
    FULL = "_full",
    PICKED = "_picked",
    GLOW = "_glow",
}

local min_rad = 2.5
local max_rad = 3
local min_falloff = 0.8
local max_falloff = 0.7
local min_intensity = 0.8
local max_intensity = 0.7

local function pulse_light(inst)
    local s = GetSineVal(0.05, true, inst)
    local rad = Lerp(min_rad, max_rad, s)
    local intentsity = Lerp(min_intensity, max_intensity, s)
    local falloff = Lerp(min_falloff, max_falloff, s)
    inst.Light:SetFalloff(falloff)
    inst.Light:SetIntensity(intentsity)
    inst.Light:SetRadius(rad)
end

local function turnon(inst, time)
    inst.Light:Enable(true)

    local s = GetSineVal(0.05, true, inst, time)
    local rad = Lerp(min_rad, max_rad, s)
    local intentsity = Lerp(min_intensity, max_intensity, s)
    local falloff = Lerp(min_falloff, max_falloff, s)

    local startpulse = function()
        inst.light_pulse = inst:DoPeriodicTask(0.1, pulse_light)
    end

    inst.components.lighttweener:StartTween(inst.Light, rad, intentsity, falloff, nil, time, startpulse)
end

local function turnoff(inst, time)
    if inst.light_pulse then
        inst.light_pulse:Cancel()
        inst.light_pulse = nil
    end

    local lightoff = function() inst.Light:Enable(false) end

    inst.components.lighttweener:StartTween(inst.Light, 0, 0, nil, nil, time, lightoff)
end

local function onphase(inst, phase)
    local picked = inst.coralstate == CORALSTATE.PICKED

    if not picked then
        if phase ~= "day" and inst.coralstate ~= CORALSTATE.GLOW then
            turnon(inst, 5)
            inst.coralstate = CORALSTATE.GLOW
            inst.AnimState:PlayAnimation("glow_pre")
            inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
        elseif phase == "day" and inst.coralstate == CORALSTATE.GLOW then
            turnoff(inst, 5)
            inst.coralstate = CORALSTATE.FULL
            inst.AnimState:PushAnimation("glow_pst", false)
            inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
        end
    end
end

local function getregentimefn(inst)
    if inst.components.pickable then
        return TUNING.CORAL_BRAIN_REGROW
    end
end

local function makefullfn(inst)
    inst.AnimState:PlayAnimation("regrow")
    inst.coralstate = CORALSTATE.FULL
    inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
    --Check for dusk/ night, turn on.
    if not TheWorld.state.isday then
        turnon(inst, 5)
        inst.coralstate = CORALSTATE.GLOW
        inst.AnimState:PlayAnimation("glow_pre")
        inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
    end
end

local function onpickedfn(inst, picker)
    if inst.components.pickable then
        --turn off light.
        if inst.coralstate == CORALSTATE.GLOW then
            turnoff(inst, 1)
        end

        inst.AnimState:PlayAnimation("picked")
        inst.coralstate = CORALSTATE.PICKED
        inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
    end
end

local function makeemptyfn(inst)
    inst.AnimState:PlayAnimation("idle_picked", true)
end

local function onhammered(inst, worker)
    SpawnPrefab("collapse_small").Transform:SetPosition(inst.Transform:GetWorldPosition())
    inst.components.lootdropper:DropLoot()
    inst:Remove()
end

local function onhit(inst)
    inst.AnimState:PlayAnimation("hit"..inst.coralstate)
    inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
end

local function sanityaurafn(inst, observer)
    if inst.coralstate == CORALSTATE.GLOW then
        return TUNING.SANITYAURA_SMALL
    else
        return 0
    end
end

local function onsave(inst, data)
    data.coralstate = inst.coralstate
end

local function onload(inst, data)
    inst.coralstate = data and data.coralstate or CORALSTATE.FULL

    if inst.coralstate == CORALSTATE.GLOW then
        inst.AnimState:PlayAnimation("glow_pre")
        inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
        turnon(inst, 0)
    elseif inst.coralstate == CORALSTATE.PICKED then
        inst.AnimState:PushAnimation("idle"..inst.coralstate, true)
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddLight()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("coral_brain_rock.tex")

    inst.Light:SetColour(210/255, 247/255, 228/255)
    inst.Light:Enable(false)
    inst.Light:SetIntensity(0)
    inst.Light:SetFalloff(0.7)

    MakeObstaclePhysics(inst, 1)

    inst.AnimState:SetBank("brain_coral_rock")
    inst.AnimState:SetBuild("brain_coral_rock")
    inst.AnimState:PlayAnimation("idle_full", true)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    inst:AddComponent("lighttweener")

    inst:AddComponent("pickable")
    inst.components.pickable:SetUp("coral_brain", TUNING.CORAL_BRAIN_REGROW)
    inst.components.pickable.getregentimefn = getregentimefn
    inst.components.pickable.onpickedfn = onpickedfn
    inst.components.pickable.makeemptyfn = makeemptyfn
    inst.components.pickable.makefullfn = makefullfn
    inst.components.pickable.picksound = "ia/common/brain_coral_harvest"

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)

    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetLoot({"limestone", "limestone"})

    inst:AddComponent("sanityaura")
    inst.components.sanityaura.aurafn = sanityaurafn

    inst.coralstate = CORALSTATE.FULL

    inst:WatchWorldState("phase", onphase)

    inst.OnSave = onsave
    inst.OnLoad = onload

    return inst
end

return Prefab("coral_brain_rock", fn, assets, prefabs)%%+%%scripts/prefabs/crab.lua%%-%%require "stategraphs/SGcrab"

local assets=
{
  Asset("ANIM", "anim/crabbit_build.zip"),
  Asset("ANIM", "anim/crabbit_beardling_build.zip"),
  Asset("ANIM", "anim/beardling_crabbit.zip"),

  Asset("ANIM", "anim/crabbit.zip"),	
}

local prefabs =
{
  "fish_small",
  "fish_small_cooked",
  "beardhair",
}

local crabbitsounds = 
{
  scream = "ia/creatures/crab/scream",
  hurt = "ia/creatures/crab/scream_short",
}

local beardsounds = 
{
  scream = "ia/creatures/crab/bearded_crab",
  hurt = "ia/creatures/crab/scream_short",
}


local brain = require "brains/crabbrain"

local function IsCrazyGuy(guy)
  local sanity = guy ~= nil and guy.replica.sanity or nil
  return sanity ~= nil and (not sanity.IsInsanityMode or sanity:IsInsanityMode()) and sanity:GetPercentNetworked() <= (guy:HasTag("dappereffects") and TUNING.DAPPER_BEARDLING_SANITY or TUNING.BEARDLING_SANITY)
end

local function SetRabbitLoot(lootdropper)
    if not lootdropper.inst._fixedloot then
        lootdropper:SetLoot({"fish_small"})
    end
end

local function SetBeardlingLoot(lootdropper)
    if lootdropper.loot and not lootdropper.inst._fixedloot then
        lootdropper:SetLoot(nil)
        lootdropper:AddRandomLoot("beardhair", .5)
        lootdropper:AddRandomLoot("monstermeat", 1)
        lootdropper:AddRandomLoot("nightmarefuel", 1)
        lootdropper.numrandomloot = 1
    end
end

local function MakeInventoryRabbit(inst)
  inst._crazyinv = nil
  inst.components.inventoryitem:ChangeImageName("crab")
  inst.components.health.murdersound = inst.sounds.hurt
	SetRabbitLoot(inst.components.lootdropper)
end

local function MakeInventoryBeardMonster(inst)
  inst._crazyinv = true
  inst.components.inventoryitem:ChangeImageName("crabbit_beardling")
  inst.components.health.murdersound = beardsounds.hurt
	SetBeardlingLoot(inst.components.lootdropper)
end

local function UpdateInventoryState(inst)
  local viewer = inst.components.inventoryitem:GetGrandOwner()
  while viewer ~= nil and viewer.components.container ~= nil do
    viewer = viewer.components.container.opener
  end
  if IsCrazyGuy(viewer) then
    MakeInventoryBeardMonster(inst)
  else
    MakeInventoryRabbit(inst)
  end
end

local function BecomeRabbit(inst)
  if inst.components.health:IsDead() then
    return
  end

    inst.AnimState:SetBuild("crabbit_build")
    inst.sounds = crabbitsounds
    UpdateInventoryState(inst)
    if inst.components.hauntable ~= nil then
        inst.components.hauntable.haunted = false
    end
end

local function BecomeBeardling(inst)
    if inst.components.health:IsDead() then
        return
    end

    inst.AnimState:SetBuild("crabbit_beardling_build")
    inst.sounds = beardsounds
    UpdateInventoryState(inst)
    if inst.components.hauntable ~= nil then
        inst.components.hauntable.haunted = false
    end
end

local function StopWatchingSanity(inst)
  if inst._sanitywatching ~= nil then
    inst:RemoveEventCallback("sanitydelta", inst.OnWatchSanityDelta, inst._sanitywatching)
    inst._sanitywatching = nil
  end
end

local function WatchSanity(inst, target)
  StopWatchingSanity(inst)
  if target ~= nil then
    inst:ListenForEvent("sanitydelta", inst.OnWatchSanityDelta, target)
    inst._sanitywatching = target
  end
end

local function StopWatchingForOpener(inst)
  if inst._openerwatching ~= nil then
    inst:RemoveEventCallback("onopen", inst.OnContainerOpened, inst._openerwatching)
    inst:RemoveEventCallback("onclose", inst.OnContainerClosed, inst._openerwatching)
    inst._openerwatching = nil
  end
end

local function WatchForOpener(inst, target)
  StopWatchingForOpener(inst)
  if target ~= nil then
    inst:ListenForEvent("onopen", inst.OnContainerOpened, target)
    inst:ListenForEvent("onclose", inst.OnContainerClosed, target)
    inst._openerwatching = target
  end
end

local function OnPickup(inst, owner)
  if owner.components.container ~= nil then
    WatchForOpener(inst, owner)
    WatchSanity(inst, owner.components.container.opener)
  else
    StopWatchingForOpener(inst)
    WatchSanity(inst, owner)
  end
  UpdateInventoryState(inst)
end

local function OnDropped(inst)
  StopWatchingSanity(inst)
  UpdateInventoryState(inst)
  inst.sg:GoToState("stunned")
end

local function CalcSanityAura(inst, observer)
    return IsCrazyGuy(observer) and -TUNING.SANITYAURA_MED or 0
end

local function GetCookProductFn(inst, cooker, chef)
    return IsCrazyGuy(chef) and "cookedmonstermeat" or "fish_small_cooked"
end

local function OnCookedFn(inst)
  inst.SoundEmitter:PlaySound("ia/creatures/crab/scream_short")
end

local function LootSetupFunction(lootdropper)
    local guy = lootdropper.inst.causeofdeath
    if IsCrazyGuy(guy ~= nil and guy.components.follower ~= nil and guy.components.follower.leader or guy) then
        SetBeardlingLoot(lootdropper)
    else
        SetRabbitLoot(lootdropper)
    end
end

local function OnAttacked(inst, data)
  local x,y,z = inst.Transform:GetWorldPosition()
  local ents = TheSim:FindEntities(x,y,z, 30, {'crab'})

  local num_friends = 0
  local maxnum = 5
  for k,v in pairs(ents) do
    v:PushEvent("gohome")
    num_friends = num_friends + 1

    if num_friends > maxnum then
      break
    end
  end
end

local function OnDug(inst, worker)
  local rnd = math.random()
  local home = inst.components.homeseeker and inst.components.homeseeker.home
  if rnd >= 0.66 or not home then
    --Sometimes just go to stunned state

    inst:PushEvent("stunned")
  else
    --Sometimes return home instantly?
    worker:DoTaskInTime(1, function()
        worker:PushEvent("crab_fail")
      end)

    inst.components.lootdropper:SpawnLootPrefab("sand")
    local home = inst.components.homeseeker.home
    home.components.spawner:GoHome(inst)
  end
end

local function DisplayName(inst)
  if inst:HasTag("crab_hidden") then
    return STRINGS.NAMES.CRAB_HIDDEN
  end
  return STRINGS.NAMES.CRAB
end

local function getstatus(inst)
  if inst.sg:HasStateTag("invisible") then 
    return "HIDDEN"
  end
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddPhysics()
  inst.entity:AddNetwork()
  inst.entity:AddLightWatcher()
  inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()
  shadow:SetSize( 1.5, .5 )
  inst.Transform:SetFourFaced()

  MakeCharacterPhysics(inst, 1, 0.5)

  inst.AnimState:SetBank("crabbit")
  inst.AnimState:SetBuild("crabbit_build")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("animal")
  inst:AddTag("prey")
  inst:AddTag("rabbit")
  inst:AddTag("smallcreature")
  inst:AddTag("canbetrapped")
  inst:AddTag("cattoy")
  inst:AddTag("catfood")

  --cookable (from cookable component) added to pristine state for optimization
  inst:AddTag("cookable")

  inst.AnimState:SetClientsideBuildOverride("insane", "crabbit_build", "crabbit_beardling_build")

  MakeFeedableSmallLivestockPristine(inst)

  inst.displaynamefn = DisplayName

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.runspeed = TUNING.CRAB_RUN_SPEED
  inst.components.locomotor.walkspeed = TUNING.CRAB_WALK_SPEED
  inst:SetStateGraph("SGcrab")

  inst:SetBrain(brain)

  inst.data = {}

  inst:AddComponent("eater")
	local diet = { FOODTYPE.MEAT, FOODTYPE.VEGGIE, FOODTYPE.INSECT }
    inst.components.eater:SetDiet(diet, diet)

  MakeInvItemIA(inst)
  inst.components.inventoryitem.nobounce = true
  inst.components.inventoryitem.canbepickedup = false
    inst.components.inventoryitem.canbepickedupalive = true --This lets Krampus, eyeplants, etc. pick it up
	inst.components.inventoryitem:SetSinks(true)

  inst:AddComponent("sanityaura")
    inst.components.sanityaura.aurafn = CalcSanityAura

  inst:AddComponent("cookable")
  inst.components.cookable.product = GetCookProductFn
  inst.components.cookable:SetOnCookedFn(OnCookedFn)

  inst:AddComponent("knownlocations")
  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "eyes"
  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.CRAB_HEALTH)

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable.workable = false
  inst.components.workable:SetOnFinishCallback(OnDug)

  MakeSmallBurnableCharacter(inst, nil, Vector3(0, 0.1, 0))
  MakeTinyFreezableCharacter(inst, nil, Vector3(0, 0.1, 0))

  inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetLootSetupFn(LootSetupFunction)

  inst:AddComponent("tradable")

  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = getstatus
  inst:AddComponent("sleeper")

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_MEDIUM

  --declared here so it can be used for event handlers
  inst.OnWatchSanityDelta = function(viewer)
    if IsCrazyGuy(viewer) then
      if not inst._crazyinv then
        MakeInventoryBeardMonster(inst)
      end
    elseif inst._crazyinv then
      MakeInventoryRabbit(inst)
    end
  end

  inst.OnContainerOpened = function(container, data)
    WatchSanity(inst, data.doer)
    UpdateInventoryState(inst)
  end

  inst.OnContainerClosed = function()
    StopWatchingSanity(inst)
    UpdateInventoryState(inst)
  end

  inst._sanitywatching = nil
  inst._openerwatching = nil

  BecomeRabbit(inst)

  MakeHauntablePanic(inst)

  inst:ListenForEvent("attacked", OnAttacked)

  MakeFeedableSmallLivestock(inst, TUNING.TOTAL_DAY_TIME*2, OnPickup, OnDropped)

  return inst
end

return Prefab( "crab", fn, assets, prefabs) 
%%+%%scripts/prefabs/crabhole.lua%%-%%local assets =
{
    Asset("ANIM", "anim/rabbit_hole.zip"),
}

local prefabs =
{
    "crab",
    "smallmeat",
}

local function OnIsCollapsedDirty(inst)
    if inst.iscollapsed:value() then
        inst.wet_prefix = STRINGS.WET_PREFIX.CRABDEN
        inst.always_wet_prefix = true
    else
        inst.wet_prefix = STRINGS.WET_PREFIX.GENERIC
        inst.always_wet_prefix = nil
    end
end

local function dig_up(inst, digger)
    if inst.components.spawner:IsOccupied() then
        inst.components.lootdropper:SpawnLootPrefab("crab")
    end

    TheWorld:PushEvent("beginregrowth", inst)

    inst:Remove()
end

local function startspawning(inst)
    if inst.components.spawner ~= nil then
        inst.components.spawner:SetQueueSpawning(false)
        if not inst.components.spawner:IsSpawnPending() then
            inst.components.spawner:SpawnWithDelay(math.random(60, 180))
        end
    end
end

local function stopspawning(inst)
    if inst.components.spawner ~= nil then
        inst.components.spawner:SetQueueSpawning(true, math.random(60, 120))
    end
end

local function onoccupied(inst)
    if inst.springmode then
        if not inst.iscollapsed:value() then
            inst.AnimState:PlayAnimation("idle_flooded")
            inst.iscollapsed:set(true)
            OnIsCollapsedDirty(inst)
        end
    elseif TheWorld.state.isday and not TheWorld.state.isspring then
        startspawning(inst)
    end
end

local function OnIsDay(inst, isday)
    if isday
	and not TheWorld.state.isspring
	and inst.components.spawner ~= nil
	and inst.components.spawner:IsOccupied() then
		startspawning(inst)
    else
        stopspawning(inst)
    end
end

local function SetSpringMode(inst, force)
    inst.springtask = nil
    if (not inst.springmode and TheWorld.state.isspring)
	or inst.springmode == nil
	or force then
		inst.springmode = true

		inst:StopWatchingWorldState("isday", OnIsDay)
		stopspawning(inst)

		if inst.components.spawner:IsOccupied()
		or inst.components.spawner.child == nil then
			inst.AnimState:PlayAnimation("idle_flooded")
			inst.iscollapsed:set(true)
			OnIsCollapsedDirty(inst)
		end
    end
end

local function SetNormalMode(inst, force)
    inst.springtask = nil
    if (inst.springmode and not TheWorld.state.isspring)
	or inst.springmode == nil
	or force then
		inst.springmode = false

		inst:WatchWorldState("isday", OnIsDay)
		OnIsDay(inst, TheWorld.state.isday)

		inst.AnimState:PlayAnimation("idle")
		inst.iscollapsed:set(false)
		OnIsCollapsedDirty(inst)
    end
end

local function OnStartRain(inst)
    if inst.watchingrain then
        inst.watchingrain = nil
        inst:StopWatchingWorldState("startrain", OnStartRain)
    end

    if inst.springtask ~= nil then
        inst.springtask:Cancel()
        inst.springtask = nil
    end

    if not inst.springmode then
        inst.springtask = inst:DoTaskInTime(math.random(3, 20), SetSpringMode)
    end
end

local function OnIsSpring(inst, isspring)
    if inst.springtask ~= nil then
        inst.springtask:Cancel()
        inst.springtask = nil
    end

    local watchrain = false
    if isspring then
        if not inst.springmode then
            --It just became spring, and we're not in spring mode,
            --so watch for rain to start spring mode transition timer
            watchrain = true
        end
    elseif inst.springmode and not inst:HasTag("flooded") then
        --It is no longer spring, and we're in spring mode,
        --so start normal transition timer.
        inst.springtask = inst:DoTaskInTime(
			math.random(
				TUNING.MIN_CRAB_DEN_TRANSITION_TIME,
				TUNING.MAX_CRAB_DEN_TRANSITION_TIME),
			SetNormalMode)
    end

    if watchrain then
        if TheWorld.state.israining then
            --Special case where it's already raining, so there is no
            --need to watch for rain anymore, and just run the handler
            OnStartRain(inst)
        elseif not inst.watchingrain then
            inst.watchingrain = true
            inst:WatchWorldState("startrain", OnStartRain)
        end
    elseif inst.watchingrain then
        inst.watchingrain = nil
        inst:StopWatchingWorldState("startrain", OnStartRain)
    end
end

local function OnInit(inst, springmode)
    inst.inittask = nil

    --Set initial mode immediately
    if not TheWorld.state.isspring and not inst:HasTag("flooded") then
        SetNormalMode(inst)
    elseif springmode then
        SetSpringMode(inst)
    else
        SetNormalMode(inst)
        OnIsSpring(inst, true)
    end
    
    --Start watching for spring changes
    inst:WatchWorldState("isspring", OnIsSpring)
end

local function onStartFlooded(inst)
	--force collapse regardless of season
	SetSpringMode(inst, true)
end
local function onStopFlooded(inst)
	--undo collapse only if not Monsoon anymore
	SetNormalMode(inst)
end

local function OnSave(inst, data)
    data.springmode = inst.springmode or nil
end

local function OnLoad(inst, data)
    if data ~= nil and data.springmode and inst.inittask ~= nil then
        inst.inittask:Cancel()
        inst.inittask = inst:DoTaskInTime(0, OnInit, true)
    end
end

local function GetStatus(inst)
    return inst.iscollapsed:value() and "SPRING" or nil
end

local function OnHaunt(inst)
    return not (inst.springmode or TheWorld.state.isspring)
        and inst.components.spawner ~= nil
        and inst.components.spawner:IsOccupied()
        and inst.components.spawner:ReleaseChild()
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst:AddTag("cattoy")

    inst.AnimState:SetBank("rabbithole")
    inst.AnimState:SetBuild("rabbit_hole")
    inst.AnimState:PlayAnimation("idle")
    inst.AnimState:SetLayer( LAYER_BACKGROUND )
    inst.AnimState:SetSortOrder( 3 )

    inst.iscollapsed = net_bool(inst.GUID, "crabden.iscollapsed", "iscollapseddirty")
    OnIsCollapsedDirty(inst)

	inst:AddComponent("floodable")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        inst:ListenForEvent("iscollapseddirty", OnIsCollapsedDirty)

        return inst
    end

    inst:AddComponent("spawner")
    inst.components.spawner:Configure("crab", TUNING.CRAB_RESPAWN_TIME)

    inst.components.spawner:SetOnOccupiedFn(onoccupied)
    inst.components.spawner:SetOnVacateFn(stopspawning)

    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.DIG)
    inst.components.workable:SetOnFinishCallback(dig_up)
    inst.components.workable:SetWorkLeft(1)

    inst.springmode = nil
    inst.springtask = nil
    inst.watchingrain = nil
    inst.inittask = inst:DoTaskInTime(0, OnInit)

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = GetStatus

	inst.components.floodable:SetFX(nil,15 + math.random()*10) --longer update delay
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_SMALL)
    inst.components.hauntable:SetOnHauntFn(OnHaunt)

    inst.OnSave = OnSave
    inst.OnLoad = OnLoad

    return inst
end

return Prefab("crabhole", fn, assets, prefabs)%%+%%scripts/prefabs/crate.lua%%-%%local assets =
{
  Asset("ANIM", "anim/crates.zip"),
  Asset("MINIMAP_IMAGE", "crate")
}

local prefabs =
{
  "collapse_small",
  "boards",
  "rope",
  "tunacan",
  "messagebottleempty",
  "fabric",
  "dubloon"
}

local function setanim(inst, anim)
  inst.anim = anim
  inst.AnimState:PlayAnimation("idle" .. anim)
end

local function onsave(inst, data)
  data.anim = inst.anim
end

local function onload(inst, data)
  if data and data.anim then
    setanim(inst, data.anim)
  end
end

local function onhammered(inst)
  if inst:HasTag("fire") and inst.components.burnable then
    inst.components.burnable:Extinguish()
  end
  inst.components.lootdropper:DropLoot()
  SpawnPrefab("collapse_small").Transform:SetPosition(inst.Transform:GetWorldPosition())
  inst.SoundEmitter:PlaySound("dontstarve/common/destroy_wood")
  inst:Remove()
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  local minimap = inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()

  MakeObstaclePhysics(inst, 0.1)

  inst.AnimState:SetBank("crates")
  inst.AnimState:SetBuild("crates")
  setanim(inst, math.random(1, 10))

  minimap:SetIcon("crate.tex")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeSmallBurnable(inst)
  MakeSmallPropagator(inst)

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable:SetOnFinishCallback(onhammered)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:AddChanceLoot("boards", 1)
  inst.components.lootdropper:AddRandomLoot("boards", 10)
  inst.components.lootdropper:AddRandomLoot("rope", 10)
  inst.components.lootdropper:AddRandomLoot("tunacan", 5)
  inst.components.lootdropper:AddRandomLoot("messagebottleempty", 10)
  inst.components.lootdropper:AddRandomLoot("fabric", 10)
  inst.components.lootdropper:AddRandomLoot("dubloon", 1)
  inst.components.lootdropper.numrandomloot = 1

  inst:AddComponent("inspectable")

  inst.OnSave = onsave
  inst.OnLoad = onload

  return inst
end

return Prefab("crate", fn, assets, prefabs)%%+%%scripts/prefabs/crocodog.lua%%-%%require "stategraphs/SGcrocodog"

local trace = function() end

local assets=
{
  Asset("ANIM", "anim/crocodog_basic.zip"),
  Asset("ANIM", "anim/crocodog.zip"),
  Asset("ANIM", "anim/crocodog_poison.zip"),
  Asset("ANIM", "anim/crocodog_water.zip"),
  Asset("ANIM", "anim/crocodog_basic_water.zip"),
  Asset("ANIM", "anim/watercrocodog.zip"),
  Asset("ANIM", "anim/watercrocodog_poison.zip"),
  Asset("ANIM", "anim/watercrocodog_water.zip"),
}

local prefabs =
{
  "houndstooth",
  "monstermeat",
  "ice_puddle",
}

SetSharedLootTable( 'crocodog',
  {
    {'monstermeat', 1.000},
    {'houndstooth',  0.125},
    {'houndstooth',  0.125},
  })

SetSharedLootTable( 'crocodog_poison',
  {
    {'monstermeat', 1.0},
    {'houndstooth', 1.0},
    {'venomgland',      0.2},
  })

SetSharedLootTable( 'crocodog_water',
  {
    {'monstermeat', 1.0},
    {'houndstooth', 1.0},
    {'houndstooth', 1.0},
    {'seaweed',   0.2},
  })

local WAKE_TO_FOLLOW_DISTANCE = 8
local SLEEP_NEAR_HOME_DISTANCE = 10
local SHARE_TARGET_DIST = 30
local HOME_TELEPORT_DIST = 30

local NO_TAGS = {"FX", "NOCLICK","DECOR","INLIMBO"}

local function ShouldWakeUp(inst)
  return DefaultWakeTest(inst) or (inst.components.follower and inst.components.follower.leader and not inst.components.follower:IsNearLeader(WAKE_TO_FOLLOW_DISTANCE))
end

local function ShouldSleep(inst)
  return inst:HasTag("pet_hound")
  and not TheWorld.state.isday
  and not (inst.components.combat and inst.components.combat.target)
  and not (inst.components.burnable and inst.components.burnable:IsBurning() )
  and (not inst.components.homeseeker or inst:IsNear(inst.components.homeseeker.home, SLEEP_NEAR_HOME_DISTANCE))
end

local function OnEntityWake(inst)
  inst.components.tiletracker:Start()
end

local function OnNewTarget(inst, data)
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end


local function retargetfn(inst)
  local dist = TUNING.HOUND_TARGET_DIST
  if inst:HasTag("pet_hound") then
    dist = TUNING.HOUND_FOLLOWER_TARGET_DIST
  end
  local notags = {"FX", "NOCLICK","INLIMBO", "wall", "houndmound", "hound", "houndfriend"}
  return FindEntity(inst, dist, function(guy) 
      local shouldtarget = inst.components.combat:CanTarget(guy)
      return shouldtarget
    end, nil, notags)
end

local function KeepTarget(inst, target)
  local shouldkeep = inst.components.combat:CanTarget(target) and (not inst:HasTag("pet_hound") or inst:IsNear(target, TUNING.HOUND_FOLLOWER_TARGET_KEEP))
  return shouldkeep
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("hound") or dude:HasTag("houndfriend") and not dude.components.health:IsDead() end, 5)
end

local function OnAttackOther(inst, data)
  inst.components.combat:ShareTarget(data.target, SHARE_TARGET_DIST, function(dude) return dude:HasTag("hound") or dude:HasTag("houndfriend") and not dude.components.health:IsDead() end, 5)
end

local function GetReturnPos(inst)
  local rad = 2
  local pos = inst:GetPosition()
  trace("GetReturnPos", inst, pos)
  local angle = math.random()*2*PI
  pos = pos + Point(rad*math.cos(angle), 0, -rad*math.sin(angle))
  trace("    ", pos)
  return pos:Get()
end

local function DoReturn(inst)
  if inst.components.homeseeker and inst.components.homeseeker:HasHome()  then
    if inst:HasTag("pet_hound") then
      if inst.components.homeseeker.home:IsAsleep() and not inst:IsNear(inst.components.homeseeker.home, HOME_TELEPORT_DIST) then
        local x, y, z = GetReturnPos(inst.components.homeseeker.home)
        inst.Physics:Teleport(x, y, z)
        trace("hound warped home", x, y, z)
      end
    elseif inst.components.homeseeker.home.components.childspawner then
      inst.components.homeseeker.home.components.childspawner:GoHome(inst)
    end
  end
end

local function OnWaterChange(inst, onwater)
  inst.SoundEmitter:PlaySound("ia/creatures/crocodog/emerge")

  if onwater then
    if inst.DynamicShadow then
      inst.DynamicShadow:Enable(false)
    end

    inst.AnimState:SetBank("crocodog_water")
    if inst:HasTag("poisonous") then
      inst.AnimState:SetBuild("watercrocodog_poison")
    elseif inst:HasTag("waterous") then
      inst.AnimState:SetBuild("watercrocodog_water")
      inst:RemoveTag("enable_shake")
    else
      inst.AnimState:SetBuild("watercrocodog")
    end
  else
    if inst.DynamicShadow then
      inst.DynamicShadow:Enable(true)
    end

    inst.AnimState:SetBank("crocodog")
    if inst:HasTag("poisonous") then
      inst.AnimState:SetBuild("crocodog_poison")
    elseif inst:HasTag("waterous") then
      inst.AnimState:SetBuild("crocodog_water")
      inst:AddTag("enable_shake")
    else
      inst.AnimState:SetBuild("crocodog")
    end
  end

  local splash = SpawnPrefab("splash_water")
  local ent_pos = Vector3(inst.Transform:GetWorldPosition())
  splash.Transform:SetPosition(ent_pos.x, ent_pos.y, ent_pos.z)

  if inst.sg then
    inst.sg:GoToState("idle")
  end
end

local function OnNight(inst)
  if inst:IsAsleep() then
    DoReturn(inst)  
  end
end


local function OnEntitySleep(inst)
  inst.components.tiletracker:Stop()
  
  if not TheWorld.state.isday then
    DoReturn(inst)
  end
end

local function OnSave(inst, data)
  data.ispet = inst:HasTag("pet_hound")
end

local function OnLoad(inst, data)
  if data and data.ispet then
    inst:AddTag("pet_hound")

    if inst.sg then
      inst.sg:GoToState("idle")
    end
  end
end

local function fncommon()
  local inst = CreateEntity()
  inst.entity:AddNetwork()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local physics = inst.entity:AddPhysics()
  local sound = inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()
  shadow:SetSize( 3, 1.5 )
  inst.Transform:SetFourFaced()

  inst:AddTag("scarytoprey")
  inst:AddTag("monster")
  inst:AddTag("hostile")
  inst:AddTag("hound")
  inst:AddTag("crocodog")

  MakeAmphibiousCharacterPhysics(inst, 10, .5)

  inst.AnimState:SetBank("crocodog_water")
  inst.AnimState:SetBuild("watercrocodog")
  inst.AnimState:PlayAnimation("idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.runspeed = TUNING.HOUND_SPEED
  inst:SetStateGraph("SGcrocodog")

  inst:AddComponent("tiletracker")
  inst.components.tiletracker:SetOnWaterChangeFn(OnWaterChange)
  inst.wasintaunt = false

  local brain = require "brains/crocodogbrain"
  inst:SetBrain(brain)

  inst:AddComponent("follower")

  inst:AddComponent("eater")
  inst.components.eater:SetCarnivore()
  inst.components.eater:SetCanEatHorrible()

  inst.components.eater.strongstomach = true -- can eat monster meat!

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.HOUND_HEALTH)

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aura = -TUNING.SANITYAURA_MED


  inst:AddComponent("combat")
  inst.components.combat:SetDefaultDamage(TUNING.HOUND_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.HOUND_ATTACK_PERIOD)
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)
  inst.components.combat:SetHurtSound("ia/creatures/crocodog/hit")

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('crocodog')

  inst:AddComponent("inspectable")

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetResistance(3)
  inst.components.sleeper.testperiod = GetRandomWithVariance(6, 2)
  inst.components.sleeper:SetSleepTest(ShouldSleep)
  inst.components.sleeper:SetWakeTest(ShouldWakeUp)

  inst:ListenForEvent("newcombattarget", OnNewTarget)

  inst:WatchWorldState( "isdusk", function() 
      if TheWorld.state.isdusk then OnNight( inst ) end 
    end) 
  inst:WatchWorldState( "isnight", function() 
      if TheWorld.state.isdusk then OnNight( inst ) end 
    end) 
  inst.OnEntitySleep = OnEntitySleep

  inst.OnSave = OnSave
  inst.OnLoad = OnLoad
  inst.OnEntityWake = OnEntityWake
  inst.OnEntitySleep = OnEntitySleep

  inst:ListenForEvent("attacked", OnAttacked)
  inst:ListenForEvent("onattackother", OnAttackOther)

  return inst
end

local function fndefault()
  local inst = fncommon()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeMediumFreezableCharacter(inst, "Crocodog_Body") 
  MakeMediumBurnableCharacter(inst, "Crocodog_Body") 
  
  return inst
end

local function fnpoison()
  local inst = fncommon()
  inst.AnimState:SetBuild("watercrocodog_poison")

  inst:AddTag("poisonous")

  if not TheWorld.ismastersim then
    return inst
  end

  MakeMediumFreezableCharacter(inst, "Crocodog_Body") 
  inst.components.health.poison_damage_scale = 0 -- immune to poison

  inst.components.combat.poisonous = true
  inst.components.lootdropper:AddRandomLoot("venomgland", 1.00)

  inst.components.combat:SetDefaultDamage(TUNING.FIREHOUND_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.FIREHOUND_ATTACK_PERIOD)
  inst.components.locomotor.runspeed = TUNING.FIREHOUND_SPEED
  inst.components.health:SetMaxHealth(TUNING.FIREHOUND_HEALTH)
  inst.components.lootdropper:SetChanceLootTable('crocodog_poison')

  inst:ListenForEvent("death", function(inst)
      inst.SoundEmitter:PlaySound("ia/creatures/crocodog/death", "explosion")
    end)

  return inst
end

local function fnwater()
  local inst = fncommon()
  inst.AnimState:SetBuild("watercrocodog_water")
  inst:AddTag("waterous")

  if not TheWorld.ismastersim then
    return inst
  end

  MakeMediumBurnableCharacter(inst, "Crocodog_Body") 

  inst.components.combat:SetDefaultDamage(TUNING.ICEHOUND_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.ICEHOUND_ATTACK_PERIOD)
  inst.components.locomotor.runspeed = TUNING.ICEHOUND_SPEED
  inst.components.health:SetMaxHealth(TUNING.ICEHOUND_HEALTH)
  inst.components.lootdropper:SetChanceLootTable('crocodog_water')

  return inst
end


return Prefab( "crocodog", fndefault, assets, prefabs),
Prefab( "poisoncrocodog", fnpoison, assets, prefabs),
Prefab( "watercrocodog", fnwater, assets, prefabs)
%%+%%scripts/prefabs/cutlass.lua%%-%%local assets=
{
	Asset("ANIM", "anim/cutlass.zip"),
	Asset("ANIM", "anim/swap_cutlass.zip"),
}

local function owneronattack(attacker, data)
	if data.weapon and data.weapon.prefab == "cutlass" then --just to failsafe
		if data.target and data.target:HasTag("twister") then
			data.weapon.components.weapon:SetDamage(TUNING.CUTLASS_DAMAGE + TUNING.CUTLASS_BONUS_DAMAGE)
		else
			data.weapon.components.weapon:SetDamage(TUNING.CUTLASS_DAMAGE)
		end
	end
end

local function onequip(inst, owner) 
    owner.AnimState:OverrideSymbol("swap_object", "swap_cutlass", "swap_cutlass")
    owner.AnimState:Show("ARM_carry") 
    owner.AnimState:Hide("ARM_normal") 
	inst:ListenForEvent("onattackother", owneronattack, owner)
end

local function onunequip(inst, owner) 
    owner.AnimState:Hide("ARM_carry") 
    owner.AnimState:Show("ARM_normal") 
	inst:RemoveEventCallback("onattackother", owneronattack, owner)
end


local function fn(Sim)
	local inst = CreateEntity()
	local trans = inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("cutlass")
    inst.AnimState:SetBuild("cutlass")
    inst.AnimState:PlayAnimation("idle")
    
    inst:AddTag("sharp")
    inst:AddTag("cutlass")
	
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	MakeInvItemIA(inst)

    inst:AddComponent("weapon")
    inst.components.weapon:SetDamage(TUNING.CUTLASS_DAMAGE)
    
	-- inst:AddComponent("tool")
	-- inst.components.tool:SetAction(ACTIONS.HACK)

    inst:AddComponent("finiteuses")
    inst.components.finiteuses:SetMaxUses(TUNING.CUTLASS_USES)
    inst.components.finiteuses:SetUses(TUNING.CUTLASS_USES)
    inst.components.finiteuses:SetOnFinished( inst.Remove )
	-- inst.components.finiteuses:SetConsumption(ACTIONS.HACK, 1)

    inst:AddComponent("inspectable")
    
    inst:AddComponent("equippable")
    inst.components.equippable:SetOnEquip( onequip )
    inst.components.equippable:SetOnUnequip( onunequip )
    
	MakeHauntableLaunch(inst)

    return inst
end

return Prefab( "cutlass", fn, assets) 
%%+%%scripts/prefabs/dorsalfin.lua%%-%%local assets=
{
  Asset("ANIM", "anim/dorsalfin.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("dorsalfin")
  inst.AnimState:SetBuild("dorsalfin")
  inst.AnimState:PlayAnimation("idle")

  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeInvItemIA(inst)
  
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")
  inst:AddComponent("waterproofer")

  MakeSmallBurnable(inst)
  MakeSmallPropagator(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "HORRIBLE"


  return inst
end

return Prefab( "dorsalfin", fn, assets)
%%+%%scripts/prefabs/doydoy.lua%%-%%require "brains/doydoybrain"
require "stategraphs/SGdoydoy"

local assets_baby =
{
	Asset("ANIM", "anim/doydoy.zip"),
	Asset("ANIM", "anim/doydoy_baby.zip"),
	Asset("ANIM", "anim/doydoy_baby_build.zip"),
	Asset("ANIM", "anim/doydoy_teen_build.zip"),
}

local assets =
{
	Asset("ANIM", "anim/doydoy.zip"),
	Asset("ANIM", "anim/doydoy_adult_build.zip"),
}

local prefabs_baby =
{
	"doydoyfeather",
	"drumstick",
}

local prefabs =
{
	"doydoyfeather",
	"drumstick",
	"doydoy_mate_fx",
}

local babyloot = {"smallmeat","doydoyfeather"}
local teenloot = {"drumstick","doydoyfeather","doydoyfeather"}
local adultloot = {'meat', 'drumstick', 'drumstick', 'doydoyfeather', 'doydoyfeather'}

local babyfoodprefs = {"SEEDS"}
local teenfoodprefs = {"SEEDS", "VEGGIE"}
local adultfoodprefs = {"MEAT", "VEGGIE", "SEEDS", "ELEMENTAL", "WOOD"}

local babysounds = 
{
	eat_pre = "ia/creatures/doydoy/baby/eat_pre",
	swallow = "ia/creatures/doydoy/teen/swallow", --SW bug: baby has no swallow sound
	hatch = "ia/creatures/doydoy/baby/hatch",
	death = "ia/creatures/doydoy/baby/death",
	jump = "ia/creatures/doydoy/baby/jump",
	peck = "ia/creatures/doydoy/teen/peck",
}

local teensounds = 
{
	idle = "ia/creatures/doydoy/teen/idle",
	eat_pre = "ia/creatures/doydoy/teen/eat_pre",
	swallow = "ia/creatures/doydoy/teen/swallow",
	hatch = "ia/creatures/doydoy/teen/hatch",
	death = "ia/creatures/doydoy/teen/death",
	jump = "ia/creatures/doydoy/baby/jump",
	peck = "ia/creatures/doydoy/teen/peck",
}

local function TrackInSpawner(inst)
	if TheWorld.components.doydoyspawner then
		TheWorld.components.doydoyspawner:StartTracking(inst)
	end
end

local function StopTrackingInSpawner(inst)
	if TheWorld.components.doydoyspawner then
		TheWorld.components.doydoyspawner:StopTracking(inst)
	end
end

local function SetBaby(inst)
	inst:AddTag("baby")
	inst:RemoveTag("teen")

	inst.AnimState:SetBank("doydoy_baby")
	inst.AnimState:SetBuild("doydoy_baby_build")
	inst.AnimState:PlayAnimation("idle", true)

	inst.sounds = babysounds
	inst.components.combat:SetHurtSound("ia/creatures/doydoy/baby/hit")

	inst.Transform:SetScale(1, 1, 1)

	inst.components.health:SetMaxHealth(TUNING.DOYDOY_BABY_HEALTH)
	inst.components.locomotor.walkspeed = TUNING.DOYDOY_BABY_WALK_SPEED
	inst.components.locomotor.runspeed = TUNING.DOYDOY_BABY_WALK_SPEED
	inst.components.lootdropper:SetLoot(babyloot)
	inst.components.eater.foodprefs = babyfoodprefs

	inst.components.inventoryitem:ChangeImageName("doydoy_baby")

	inst.components.named:SetName(STRINGS.NAMES.DOYDOYBABY)
end

local function SetTeen(inst)
	inst:AddTag("teen")
	inst:RemoveTag("baby")

	inst.AnimState:SetBank("doydoy")
	inst.AnimState:SetBuild("doydoy_teen_build")
	inst.AnimState:PlayAnimation("idle", true)

	inst.sounds = teensounds
	inst.components.combat:SetHurtSound("ia/creatures/doydoy/hit")

	local scale = TUNING.DOYDOY_TEEN_SCALE
	inst.Transform:SetScale(scale, scale, scale)

	inst.components.health:SetMaxHealth(TUNING.DOYDOY_TEEN_HEALTH)
	inst.components.locomotor.walkspeed = TUNING.DOYDOY_TEEN_WALK_SPEED
	inst.components.locomotor.runspeed = TUNING.DOYDOY_TEEN_WALK_SPEED
	inst.components.lootdropper:SetLoot(teenloot)
	inst.components.eater.foodprefs = teenfoodprefs

	inst.components.inventoryitem:ChangeImageName("doydoy_teen")

	inst.components.named:SetName(STRINGS.NAMES.DOYDOYTEEN)
end

local function SetFullyGrown(inst)
	inst.needtogrowup = true
end

local function GetBabyGrowTime()
	return TUNING.DOYDOY_BABY_GROW_TIME
end

local function GetTeenGrowTime()
	return TUNING.DOYDOY_TEEN_GROW_TIME
end

local growth_stages =
{
	{name="baby", time = GetBabyGrowTime, fn = SetBaby},
	{name="teen", time = GetTeenGrowTime, fn = SetTeen},
	{name="grown", time = GetTeenGrowTime, fn = SetFullyGrown},
}

local function OnEntitySleep(inst)
	if inst.shouldGoAway then
		inst:Remove()
	end
end

local function OnEntityWake(inst)
	inst:ClearBufferedAction()
	--TODO this massive hack is done very improperly
	-- what about the inventory?
	if inst.needtogrowup then
		local grown = SpawnPrefab("doydoy")
		grown.Transform:SetPosition(inst.Transform:GetWorldPosition() )
		grown.Transform:SetRotation(inst.Transform:GetRotation() )
		
		inst:Remove()
	end
end

local function OnInventory(inst)
	inst:ClearBufferedAction()
	inst:AddTag("mating")
end

local function OnDropped(inst)
	inst.components.sleeper:GoToSleep()
	inst:AddTag("mating")
end

local function OnMate(inst, partner)
	
end

local function commonpristinefn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
    inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
    inst.entity:AddLightWatcher() --solely for cave sleeping
	inst.entity:AddNetwork()
	inst.entity:AddDynamicShadow()
    
	inst.DynamicShadow:SetSize(1.5, 0.8)
	
	inst.Transform:SetFourFaced()
	
	MakeCharacterPhysics(inst, 50, .5)

	inst.AnimState:SetBank("doydoy")
	inst.AnimState:SetBuild("doydoy_adult_build")
	inst.AnimState:PlayAnimation("idle", true)
	
	inst:AddTag("doydoy")
	inst:AddTag("companion")
	inst:AddTag("nosteal")
	--nosteal is not exactly SW-accurate, but I don't *want* to find out why SW Primeapes do not steal Doydoys. -M
	
	MakeFeedableSmallLivestockPristine(inst)
	
	return inst
end

local function commonmasterfn(inst)
	MakeInvItemIA(inst)
	inst.components.inventoryitem.nobounce = true
	inst.components.inventoryitem.canbepickedup = false
	inst.components.inventoryitem.longpickup = true
	inst.components.inventoryitem:SetSinks(true)

	inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_LARGE
	
	inst:AddComponent("health")
	-- inst:AddComponent("sizetweener")
	inst:AddComponent("sleeper")

	inst:AddComponent("lootdropper")
	
	inst:AddComponent("inspectable")

	inst:AddComponent("inventory")
	-- inst:AddComponent("entitytracker")
	
	inst:AddComponent("eater")
	-- inst.components.eater:SetCanEatTestFn(CanEatFn) --TODO cannot eat "doydoyegg" (tag)

	inst:ListenForEvent("entitysleep", OnEntitySleep)
	inst:ListenForEvent("entitywake", OnEntityWake)

    MakePoisonableCharacter(inst)
	MakeSmallBurnableCharacter(inst, "swap_fire")
	MakeSmallFreezableCharacter(inst, "mossling_body")

	inst:AddComponent("locomotor")

	inst:AddComponent("combat")
	
	TrackInSpawner(inst)
	inst:ListenForEvent("onremove", StopTrackingInSpawner)

	inst:ListenForEvent("gotosleep", function(inst) inst.components.inventoryitem.canbepickedup = true end)
    inst:ListenForEvent("onwakeup", function(inst) 
    	inst.components.inventoryitem.canbepickedup = false
    	inst:RemoveTag("mating")
    end)

    inst:ListenForEvent("death", function(inst, data) 
    	--If the doydoy is held drop items.
		local owner = inst.components.inventoryitem:GetGrandOwner()

		if inst.components.lootdropper and owner then
			local loots = inst.components.lootdropper:GenerateLoot()
			inst:Remove()
			for k, v in pairs(loots) do
				local loot = SpawnPrefab(v)
				owner.components.inventory:GiveItem(loot)
			end
		end
	end)
	
	MakeFeedableSmallLivestock(inst, TUNING.TOTAL_DAY_TIME, OnInventory, OnDropped)

	return inst
end

local function babyfn(Sim)
	local inst = commonpristinefn(Sim)

	inst.AnimState:SetBank("doydoy_baby")
	inst.AnimState:SetBuild("doydoy_baby_build")
	inst.AnimState:PlayAnimation("idle", true)

	inst:AddTag("baby")

	inst.sounds = babysounds
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	commonmasterfn(inst)
	
	inst.components.combat:SetHurtSound("ia/creatures/doydoy/baby/hit")
	inst:AddComponent("named")
	
	inst.components.health:SetMaxHealth(TUNING.DOYDOY_BABY_HEALTH)
	inst.components.locomotor.walkspeed = TUNING.DOYDOY_BABY_WALK_SPEED
	inst.components.locomotor.runspeed = TUNING.DOYDOY_BABY_WALK_SPEED
	inst.components.lootdropper:SetLoot(babyloot)

	inst.components.inventoryitem:ChangeImageName("doydoy_baby")

	inst.components.eater.foodprefs = babyfoodprefs

	inst:SetStateGraph("SGdoydoybaby")
	local brain = require("brains/doydoybrain")
	inst:SetBrain(brain)

	inst:AddComponent("growable")
	inst.components.growable.stages = growth_stages
	-- inst.components.growable.growonly = true
	inst.components.growable:SetStage(1)
	inst.components.growable.growoffscreen = true
	inst.components.growable:StartGrowing()

	return inst
end

local function adultfn(Sim)
	local inst = commonpristinefn(Sim)

	inst.AnimState:SetBank("doydoy")
	inst.AnimState:SetBuild("doydoy_adult_build")
	inst.AnimState:PlayAnimation("idle", true)

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	commonmasterfn(inst)
	
	inst:AddComponent("mateable")
	inst.components.mateable:SetOnMateCallback(OnMate)
	
	inst.components.combat:SetHurtSound("ia/creatures/doydoy/hit")

	inst.components.health:SetMaxHealth(TUNING.DOYDOY_HEALTH)
	inst.components.locomotor.walkspeed = TUNING.DOYDOY_WALK_SPEED
	inst.components.lootdropper:SetLoot(adultloot)

	inst.components.eater.foodprefs = adultfoodprefs
	
	inst:SetStateGraph("SGdoydoy")
	local brain = require("brains/doydoybrain")
	inst:SetBrain(brain)

	return inst
end

return  Prefab("common/monsters/doydoybaby", babyfn, assets_baby, prefabs_baby),
		Prefab("common/monsters/doydoy", adultfn, assets, prefabs)
%%+%%scripts/prefabs/doydoyegg.lua%%-%%local assets=
{
	Asset("ANIM", "anim/doydoy_nest.zip"),
}

local prefabs = 
{
	"spoiled_food",
}

local function commonfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    -- inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	inst.AnimState:SetBank("doydoy_nest")
	inst.AnimState:SetBuild("doydoy_nest")

	MakeInventoryPhysics(inst)

    inst:AddTag("cattoy")
    inst:AddTag("doydoyegg")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")
	
	MakeInvItemIA(inst)
	inst.components.inventoryitem:SetSinks(true)
	
	inst:AddComponent("edible")
	inst.components.edible.foodtype = FOODTYPE.MEAT

	inst:AddComponent("perishable")
	inst.components.perishable.onperishreplacement = "spoiled_food"

	inst:AddComponent("tradable")
    inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
	
	return inst
end


local function defaultfn()
	local inst = commonfn()

	inst.AnimState:PlayAnimation("idle_egg")

	if not TheWorld.ismastersim then
		return inst
	end
	
	inst.components.inventoryitem.imagename = "doydoyegg"

	inst.components.edible.healthvalue = TUNING.HEALING_SMALL
	inst.components.edible.hungervalue = TUNING.CALORIES_MED

	inst:AddComponent("cookable")
	inst.components.cookable.product = "doydoyegg_cooked"

	inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
	inst.components.perishable:StartPerishing()

	inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_MEDIUM

	return inst
end

local function cookedfn()
	local inst = commonfn()
	
	inst.AnimState:PlayAnimation("cooked")
	
	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("stackable")

	inst.components.edible.foodstate = "COOKED"
	inst.components.edible.healthvalue = 0
	inst.components.edible.hungervalue = TUNING.CALORIES_LARGE

	inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
	inst.components.perishable:StartPerishing()
	
	return inst
end

return Prefab( "doydoyegg", defaultfn, assets, prefabs),
	Prefab( "doydoyegg_cooked", cookedfn, assets, prefabs) 
%%+%%scripts/prefabs/doydoyfeather.lua%%-%%local assets=
{
	Asset("ANIM", "anim/feather_doydoy.zip"),
}

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    -- inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
	
	inst.AnimState:SetBank("feather_doydoy")
	inst.AnimState:SetBuild("feather_doydoy")
	inst.AnimState:PlayAnimation("idle")
	
	MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")

	inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

	inst:AddComponent("appeasement")
	inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_LARGE

	MakeInvItemIA(inst)
	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

	return inst
end

return Prefab("doydoyfeather", fn, assets)
%%+%%scripts/prefabs/doydoynest.lua%%-%%local assets =
{
	Asset("ANIM", "anim/doydoy_nest.zip"),
}

local prefabs =
{
	"doydoyegg",
	"doydoybaby",
}

local function TrackInSpawner(inst)
	if TheWorld.components.doydoyspawner then
		TheWorld.components.doydoyspawner:StartTracking(inst)
	end
end

local function StopTrackingInSpawner(inst)
	if TheWorld.components.doydoyspawner then
		TheWorld.components.doydoyspawner:StopTracking(inst)
	end
end

local function SpawnChild(inst)
    local child = SpawnAt("doydoybaby", inst)
	child.sg:GoToState("hatch")
	if inst.components.pickable then
		inst.components.pickable:MakeEmpty()
	end
	inst:Remove()
    return child
end

local function ScheduleSpawn(inst, dt)
	if inst.hatchtask then inst.hatchtask:Cancel() end
	
	dt = dt or TUNING.DOYDOY_EGG_HATCH_TIMER + math.random()*TUNING.DOYDOY_EGG_HATCH_VARIANCE
	inst.hatchtime = GetTime() + dt
	inst.hatchtask = inst:DoTaskInTime(dt, function()
		if inst:IsAsleep() then
			ScheduleSpawn(inst, TUNING.SEG_TIME)
		else
			SpawnChild(inst)
		end
	end)
end

local function onmakeempty(inst)
	inst.AnimState:PlayAnimation("idle_nest_empty")
	-- inst.components.childspawner.regening = false
	-- inst:RemoveTag('fullnest')
	inst.components.trader.enabled = true
	-- inst.components.childspawner:StopSpawning()
	if inst.hatchtask then
		inst.hatchtask:Cancel()
		inst.hatchtime = nil
	end
	 -- The doydoyspawner checks if this nest is registered before doing any math,
	 -- so putting StopTrackingInSpawner here is safe. -M
	StopTrackingInSpawner(inst)
end

local function onregrow(inst)
	inst.AnimState:PlayAnimation("idle_nest")
	-- inst.components.childspawner.regening = true
	-- inst:AddTag('fullnest')
	inst.components.trader.enabled = false
	-- inst.components.childspawner:StartSpawning(TUNING.DOYDOY_EGG_HATCH_TIMER)
	ScheduleSpawn(inst)
	TrackInSpawner(inst)
end

local function onhammered(inst)
	if inst.components.burnable and inst.components.burnable:IsBurning() then
		inst.components.burnable:Extinguish()
	end
	inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
	inst:Remove()
end

local function onhit(inst, worker)
	if not inst:HasTag("burnt") then
		if inst.components.pickable:CanBePicked() then
			inst.AnimState:PlayAnimation("hit_nest")
			inst.AnimState:PushAnimation("idle_nest")
		else
			inst.AnimState:PlayAnimation("hit_nest_empty")
			inst.AnimState:PushAnimation("idle_nest_empty")
		end
	end
end

local function itemtest(inst, item)
	return not inst.components.pickable:CanBePicked() and item.prefab == "doydoyegg"
end

local function itemget(inst, giver, item)
	inst.components.pickable:Regen()
	item:Remove()
end

local function OnSave(inst, data)
	if inst.hatchtask and inst.hatchtime then
		data.timetohatch = inst.hatchtime - GetTime()
	end
end

local function OnLoad(inst, data)
	if data.timetohatch and inst.components.pickable:CanBePicked() then
		ScheduleSpawn(inst, data.timetohatch)
	end
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetIcon( "doydoynest.tex" )

	inst.AnimState:SetBuild("doydoy_nest")
	inst.AnimState:SetBank("doydoy_nest")
	inst.AnimState:PlayAnimation("idle_nest", false)
	
	MakeObstaclePhysics(inst, 0.25)

	inst:AddTag('doydoy')
	inst:AddTag('doydoynest')
	-- inst:AddTag('fullnest')

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	inst:AddComponent("pickable")
	--inst.components.pickable.picksound = "dontstarve/wilson/harvest_berries"
	inst.components.pickable:SetUp("doydoyegg", nil)
	inst.components.pickable:SetOnPickedFn(onmakeempty)
	inst.components.pickable:SetOnRegenFn(onregrow)
	inst.components.pickable:SetMakeEmptyFn(onmakeempty)    
	
	MakeMediumBurnable(inst)
	MakeSmallPropagator(inst)
	
	-------------------
	
	--why do we even use childspawner when we could just make a task? -M
	-- inst:AddComponent("childspawner")
	-- inst.components.childspawner.childname = "doydoybaby"
	-- inst.components.childspawner.spawnoffscreen = false
	-- inst.components.childspawner:SetRegenPeriod(65000)
	-- inst.components.childspawner:StopRegen()
	-- inst.components.childspawner:SetSpawnPeriod(0)
	-- inst.components.childspawner:SetSpawnedFn(onvacate)
	-- inst.components.childspawner:SetMaxChildren(1)
	-- inst.components.childspawner:StartSpawning(TUNING.DOYDOY_EGG_HATCH_TIMER)
	-- -- inst.components.childspawner.nooffset = true
	-- inst.components.childspawner.spawnradius = 0
	
	ScheduleSpawn(inst)
	inst.OnSave = OnSave
	inst.OnLoad = OnLoad
	
	inst:AddComponent("inspectable")

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetLoot({"cutgrass", "twigs", "twigs", "doydoyfeather"})

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(3)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)		

	TrackInSpawner(inst)
	inst:ListenForEvent("onremove", StopTrackingInSpawner)

	inst:AddComponent("trader")
	inst.components.trader:SetAcceptTest(itemtest)
	inst.components.trader.onaccept = itemget
	inst.components.trader.enabled = false

	inst:ListenForEvent("onbuilt", function (inst)
		inst.components.pickable:MakeEmpty()
	end)
	
	return inst
end

return Prefab("doydoynest", fn, assets, prefabs),
		MakePlacer("doydoynest_placer", "doydoy_nest", "doydoy_nest", "idle_nest")
%%+%%scripts/prefabs/dragoonden.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/dragoon_den.zip"),
}

local prefabs = {
    "dragoon",
}

local function ongohome(inst, child)
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle")
end

local function onhammered(inst, worker)
    inst.components.lootdropper:DropLoot()
    SpawnPrefab("collapse_big").Transform:SetPosition(inst.Transform:GetWorldPosition())
    inst.SoundEmitter:PlaySound("dontstarve/common/destroy_stone")
    inst:Remove()
end

local function onhit(inst, worker)
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle")
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle")
    inst.SoundEmitter:PlaySound("ia/common/dragoon_den_place")
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 1.5)

    inst.MiniMapEntity:SetIcon("dragoonden.tex")

    inst.AnimState:SetBank("dragoon_den")
    inst.AnimState:SetBuild("dragoon_den")
    inst.AnimState:PlayAnimation("idle", true)

    inst:AddTag("structure")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("lootdropper")

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(nil)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)

--[[
    inst:AddComponent("childspawner")
    inst.components.childspawner:SetRegenPeriod(120)
    inst.components.childspawner:SetSpawnPeriod(30)
    inst.components.childspawner:SetMaxChildren(math.random(3,4))
    inst.components.childspawner:StartRegen()
    inst.components.childspawner.childname = "dragoon"
    inst.components.childspawner:StartSpawning()
    inst.components.childspawner.ongohome = ongohome
    ]]

    inst:AddComponent("inspectable")

    --inst:WatchWorldState("startdusk", function() inst.components.childspawner:StopSpawning() end)
    --inst:WatchWorldState("startday", function() inst.components.childspawner:StartSpawning() end)

    inst:ListenForEvent("onbuilt", onbuilt)

    return inst
end

return Prefab("dragoonden", fn, assets, prefabs),
        MakePlacer("dragoonden_placer", "dragoon_den", "dragoon_den", "idle")%%+%%scripts/prefabs/dragoonfire.lua%%-%%local function onupdatefueled(inst)
	if inst.components.burnable and inst.components.fueled then
		inst.components.burnable:SetFXLevel(inst.components.fueled:GetCurrentSection(), inst.components.fueled:GetSectionPercent())
	end
end

local function onfuelchange(section, oldsection, inst)
	if section <= 0 then
		inst.components.burnable:Extinguish() 
	else
		if not inst.components.burnable:IsBurning() then
			inst.components.burnable:Ignite()
		end
		inst.components.burnable:SetFXLevel(section, inst.components.fueled:GetSectionPercent())
	end
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddLight()
	inst.entity:AddNetwork()

	inst:AddTag("fire")
	inst:AddTag("NOCLICK")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("propagator")

	inst:AddComponent("burnable")
	inst.components.burnable:AddBurnFX("campfirefire", Vector3(0,0,0))
	inst:ListenForEvent("onextinguish", inst.Remove)

	inst:AddComponent("fueled")
	inst.components.fueled.maxfuel = TUNING.DRAGOONFIRE_FUEL_MAX
	inst.components.fueled.accepting = false

	inst.components.fueled:SetSections(4)
	inst.components.fueled:SetUpdateFn(onupdatefueled)
	inst.components.fueled:SetSectionCallback(onfuelchange)
	inst.components.fueled:InitializeFuelLevel(TUNING.DRAGOONFIRE_FUEL)
	  
	inst.persists = false

	return inst
end

return Prefab("dragoonfire", fn)
%%+%%scripts/prefabs/dubloon.lua%%-%%local assets=
{
  Asset("ANIM", "anim/dubloon.zip"),
}

local prefabs = {}

local function shine(inst)
	-- if inst.task then
		-- inst.task:Cancel()
		inst.task = nil
	-- end

	if inst.components.floater:IsFloating() then
		inst.AnimState:PlayAnimation("sparkle_water")
		inst.AnimState:PushAnimation("idle_water")
	else
		inst.AnimState:PlayAnimation("sparkle")
		inst.AnimState:PushAnimation("idle")
	end

	if inst.entity:IsAwake() then
		inst.task = inst:DoTaskInTime(4+math.random()*5, shine)
	end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	inst.AnimState:SetBank("dubloon")
	inst.AnimState:SetBuild("dubloon")
	inst.AnimState:PlayAnimation("idle")

	inst.AnimState:SetBloomEffectHandle( "shaders/anim.ksh" ) 

	MakeInventoryPhysics(inst)

    inst:AddTag("currency")
    inst:AddTag("molebait")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

    inst:AddComponent('edible')
    inst.components.edible.foodtype = FOODTYPE.ELEMENTAL
	inst.components.edible.hungervalue = 1

  inst:AddComponent("inspectable")

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_TINY

  inst:AddComponent("waterproofer")
  inst.components.waterproofer.effectiveness = 0

  MakeInvItemIA(inst)

  inst:AddComponent("bait")
  inst:AddComponent("tradable")

	shine(inst)

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
  MakeHauntableLaunchAndSmash(inst)

  return inst
end

return Prefab( "dubloon", fn, assets, prefabs)
%%+%%scripts/prefabs/edgefog.lua%%-%%local TEXTURE = "levels/textures/ds_fog1.tex"

local SHADER = "shaders/particle.ksh"

local COLOUR_ENVELOPE_NAME = "edgefogcolourenvelope"
local SCALE_ENVELOPE_NAME = "edgefogscaleenvelope"

local assets =
{
	Asset( "IMAGE", TEXTURE ),
	Asset( "SHADER", SHADER ),
}

local max_scale = 10

local function InitEnvelopes()
	EnvelopeManager:AddColourEnvelope(
		COLOUR_ENVELOPE_NAME,
		{	{ 0,	{ 1, 1, 1, 0 } },
			{ 0.1,	{ 1, 1, 1, 1 } },
			{ 0.75,	{ 1, 1, 1, 1 } },
			{ 1,	{ 1, 1, 1, 0 } },
		} )

	EnvelopeManager:AddVector2Envelope(
		SCALE_ENVELOPE_NAME,
		{	{ 0,	{ 6, 6 } },
			{ 1,	{ max_scale, max_scale } },
		} )
	InitEnvelopes = nil
end

local function area_emitter()
	local map = TheWorld.Map
	local w, h = map:GetSize()
	local halfw, halfh = 0.5 * w * TILE_SCALE, 0.5 * h * TILE_SCALE
	local px, py, pz = 0, 0, 0
	if TheLocalPlayer then --This is not the case if the player despawned to character selection
		px, py, pz = TheLocalPlayer.Transform:GetWorldPosition()
	end
	local distx = math.min(halfw + px, halfw - px)
	local distz = math.min(halfh + pz, halfh - pz)
	local cloud_range = TUNING.MAPWRAPPER_EDGEFOG_RANGE * TILE_SCALE
	local min_range = cloud_range + 100
	local range = 10 * TILE_SCALE

	local getx = function(distx)
		local x, z = 0, math.random(-range, range)
		if px < 0 then
			x = -halfw + math.random(0, cloud_range) - px
		else
			x = halfw - math.random(0, cloud_range) - px
		end
		return x, z
	end

	local getz = function(distz)
		local x, z = math.random(-range, range), 0
		if pz < 0 then
			z = -halfh + math.random(0, cloud_range) - pz
		else
			z = halfh - math.random(0, cloud_range) - pz
		end
		return x, z
	end

	local x, z = 0, 0
	if distx <= min_range and distz <= min_range then
		if math.random() < 0.5 then
			x, z = getx(distx)
		else
			x, z = getz(distz)
		end
	elseif distx <= min_range then
		x, z = getx(distx)
	else
		x, z = getz(distz)
	end

	--print(string.format("\nplayer (%4.2f, %4.2f), dist (%4.2f, %4.2f) (%4.2f, %4.2f)", px, pz, distx, distz, x, z))

	return x, z
end

local MAX_NUM_PARTICLES = 180
local MAX_LIFETIME = 6
local GROUND_HEIGHT = 0.4
local EMITTER_RADIUS = 25

local function fn(Sim)
	local inst = CreateEntity()
	
	inst:AddTag("FX")
    --[[Non-networked entity]]
    --inst.entity:SetCanSleep(false)
    if TheNet:GetIsClient() then
        inst.entity:AddClientSleepable()
    end
    inst.persists = false
	
	inst.entity:AddTransform()

    -----------------------------------------------------
	
    if InitEnvelopes ~= nil then
        InitEnvelopes()
    end

	
	
    local config =
    {
        texture = TEXTURE,
        shader = SHADER,
        max_num_particles = MAX_NUM_PARTICLES,
        max_lifetime = MAX_LIFETIME,
        SV =
        {
            { x = -1, y = 0, z = 1 },
            { x = 1, y = 0, z = 1 },
        },
        sort_order = 3,
        colour_envelope_name = COLOUR_ENVELOPE_NAME,
        scale_envelope_name = SCALE_ENVELOPE_NAME
    }

    local effect = inst.entity:AddVFXEffect()
    effect:InitEmitters(1)
    effect:SetRenderResources(0, config.texture, config.shader)
    effect:SetMaxNumParticles(0, config.max_num_particles)
    effect:SetMaxLifetime(0, config.max_lifetime)
    effect:SetSpawnVectors(0,
        config.SV[1].x, config.SV[1].y, config.SV[1].z,
        config.SV[2].x, config.SV[2].y, config.SV[2].z
    )
    effect:SetSortOrder(0, config.sort_order)
    effect:SetColourEnvelope(0, config.colour_envelope_name)
    effect:SetScaleEnvelope(0, config.scale_envelope_name)
    effect:SetRadius(0, EMITTER_RADIUS)

    -----------------------------------------------------

    inst:AddComponent("emitter")
    inst.components.emitter.config = config
    inst.components.emitter.max_lifetime = MAX_LIFETIME
    inst.components.emitter.ground_height = GROUND_HEIGHT
    inst.components.emitter.particles_per_tick = TheSim:GetTickTime() * 20
    inst.components.emitter.area_emitter = area_emitter
    
	inst.components.emitter:Emit()

    return inst
end

return Prefab( "edgefog", fn, assets) 
 %%+%%scripts/prefabs/elephantcactus.lua%%-%%local brain = require "brains/elephantcactusbrain"

local assets =
{
	Asset("ANIM", "anim/cactus_volcano.zip"),
}

local prefabs = 
{
	"blowdart_pipe",
	"dug_elephantcactus",
	"needlespear",
	"twigs",
}

local function makeemptyfn(inst)
	local active = SpawnPrefab("elephantcactus_active")
	active.Physics:Teleport(inst.Transform:GetWorldPosition())

	if inst.components.pickable and inst.components.pickable.withered then
		active.sg:GoToState("grow_spike")
	end

	inst:Remove()
end

local function makebarrenfn(inst)
	if inst.components.pickable and inst.components.pickable.withered then
		if not inst.components.pickable.hasbeenpicked then
			inst.AnimState:PlayAnimation("full_to_dead")
			inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/full_to_dead")
		else
			inst.AnimState:PlayAnimation("empty_to_dead")
			inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/empty_to_dead")
		end
		inst.AnimState:PushAnimation("idle_dead")
	else
		inst.AnimState:PlayAnimation("idle_dead")
	end
end

local function pickanim(inst)
	if inst.components.pickable then
		if inst.components.pickable:CanBePicked() then
			return "idle_spike"
		else
			if inst.components.pickable:IsBarren() then
				return "idle_dead"
			else
				return "idle"
			end
		end
	end

	return "idle"
end

local function shake(inst)
	if inst.components.pickable and inst.components.pickable:CanBePicked() then
		inst.AnimState:PlayAnimation("shake")
	else
		inst.AnimState:PlayAnimation("shake_empty")
	end
	inst.AnimState:PushAnimation(pickanim(inst), false)
end

local function onpickedfn(inst, picker)
	if inst.components.pickable then
		inst.AnimState:PlayAnimation("chopped")
		
		if inst.components.pickable:IsBarren() then
			inst.AnimState:PushAnimation("idle_dead")
		else
			inst.AnimState:PushAnimation("idle")
		end
	end	
	if picker.components.combat then
		picker.components.combat:GetAttacked(inst, TUNING.MARSHBUSH_DAMAGE)
		picker:PushEvent("thorns")
	end
end

local function getregentimefn(inst)
    if inst.components.pickable then
        local num_cycles_passed = math.max(0, inst.components.pickable.max_cycles - (inst.components.pickable.cycles_left or inst.components.pickable.max_cycles))
        return TUNING.BERRY_REGROW_TIME
            + TUNING.BERRY_REGROW_INCREASE * num_cycles_passed
            + TUNING.BERRY_REGROW_VARIANCE * math.random()
    else
        return TUNING.BERRY_REGROW_TIME
    end    
end

local function makefullfn(inst)
	inst.AnimState:PlayAnimation(pickanim(inst))
    
    inst:ListenForEvent("animover", function(inst)
        local active = SpawnPrefab("elephantcactus_active")
        if active then 
            active.Physics:Teleport(inst.Transform:GetWorldPosition())
            inst:Remove()
        end
    end)
end

local function dig_up(inst, chopper)
	if inst.components.pickable then
		if inst.components.pickable:CanBePicked() then
			inst.components.lootdropper:SpawnLootPrefab("needlespear")
		else
			inst.components.lootdropper:SpawnLootPrefab("twigs")
			inst.components.lootdropper:SpawnLootPrefab("twigs")
		end
	else
		inst.components.lootdropper:SpawnLootPrefab("dug_elephantcactus")
	end
	inst:Remove()
end


local function retargetfn(inst)
	local newtarget = FindEntity(inst, TUNING.ELEPHANTCACTUS_RANGE, function(guy)
			return guy.components.health and not guy.components.health:IsDead()
	end, nil, {"elephantcactus", "FX", "NOCLICK", "CLASSIFIED"})

	return newtarget
end

local function shouldKeepTarget(inst, target)
	if target and target:IsValid() and
		(target.components.health and not target.components.health:IsDead()) then
		local distsq = target:GetDistanceSqToInst(inst)
		return distsq < TUNING.ELEPHANTCACTUS_RANGE*TUNING.ELEPHANTCACTUS_RANGE
	else
		return false
	end
end

local function ontransplantfn(inst)
    inst.AnimState:PlayAnimation("idle_dead")
    inst.components.pickable:MakeBarren()
end

local function onseasonchange(inst)
    if TheWorld.state.issummer then
        local active = SpawnPrefab("elephantcactus_active")
        if active then 
            active.Physics:Teleport(inst.Transform:GetWorldPosition())
            inst:Remove()
        end
    end
end

local function onseasonchange_active(inst)
	if not inst.prevseason then
		inst.prevseason = TheWorld.state.season
		return
	end

	if TheWorld.state.isautumn and inst.prevseason == SEASONS.AUTUMN then
		local dormant = SpawnPrefab("elephantcactus")
		if dormant then 
			dormant.Physics:Teleport(inst.Transform:GetWorldPosition())
			inst:Remove()
            return
		end
	end

	inst.prevseason = TheWorld.state.season
end

local function OnLoad(inst, data)
    onseasonchange(inst)
end

local function OnLoadActive(inst, data)
	onseasonchange_active(inst)
	inst.has_spike = data.has_spike
end

local function OnSaveActive(inst, data)
	data.has_spike = inst.has_spike
end

local function OnHaunt(inst)
    if math.random() <= TUNING.HAUNT_CHANCE_ALWAYS then
        shake(inst)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_COOLDOWN_TINY
        return true
    end
    return false
end

local function fn()
	local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 1)

    inst.MiniMapEntity:SetIcon("cactus_volcano.tex")

    inst.AnimState:SetBank("cactus_volcano")
    inst.AnimState:SetBuild("cactus_volcano")
    inst.AnimState:PlayAnimation("idle_spike", true)
    inst.AnimState:SetTime(math.random()*2)

	inst:AddTag("thorny")
	inst:AddTag("elephantcactus")
	inst:AddTag("scarytoprey")

    --witherable (from witherable component) added to pristine state for optimization
    inst:AddTag("witherable")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("pickable")
	inst.components.pickable.picksound = "dontstarve/wilson/harvest_sticks"
    inst.components.pickable.onpickedfn = onpickedfn
    inst.components.pickable.makeemptyfn = makeemptyfn
    inst.components.pickable.makebarrenfn = makebarrenfn
    inst.components.pickable.makefullfn = makefullfn
    inst.components.pickable.ontransplantfn = ontransplantfn
	
	inst.components.pickable:SetUp("needlespear", TUNING.BERRY_REGROW_TIME)
	inst.components.pickable.getregentimefn = getregentimefn
	inst.components.pickable.max_cycles = TUNING.BERRYBUSH_CYCLES + math.random(2)
	inst.components.pickable.cycles_left = inst.components.pickable.max_cycles

    inst:AddComponent("witherable")
    inst.components.witherable.volcanic = true
        
    AddHauntableCustomReaction(inst, OnHaunt, false, false, true)

    inst:AddComponent("lootdropper")

    if not GetGameModeProperty("disable_transplanting") then
        inst:AddComponent("workable")
        inst.components.workable:SetWorkAction(ACTIONS.DIG)
        inst.components.workable:SetOnFinishCallback(dig_up)
        inst.components.workable:SetWorkLeft(1)
    end
	
	inst:AddComponent("inspectable")

    inst.OnLoad = OnLoad

	inst:DoTaskInTime(0, onseasonchange)

	return inst
end

local function ontimerdone(inst, data)
	if data.name == "SPIKE" then
		inst.has_spike = true
		inst:PushEvent("growspike")
	end
end

local function OnBlocked(owner, data) 
	if (data.weapon == nil or (not data.weapon:HasTag("projectile") and not data.weapon.projectile)) and
		(data.attacker and data.attacker.components.combat and data.stimuli ~= "thorns" and not data.attacker:HasTag("thorny")) and
		((data.damage and data.damage > 0) or (data.attacker.components.combat and data.attacker.components.combat.defaultdamage > 0)) then
		data.attacker.components.combat:GetAttacked(owner, TUNING.ELEPHANTCACTUS_DAMAGE/2, nil, "thorns")
		owner.SoundEmitter:PlaySound("ia/common/armour/cactus")
	end
end

local function activefn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 1)

    inst.MiniMapEntity:SetIcon("cactus_volcano.tex")

    inst.AnimState:SetBank("cactus_volcano")
    inst.AnimState:SetBuild("cactus_volcano")
    inst.AnimState:PlayAnimation("idle_spike", true)
    inst.AnimState:SetTime(math.random()*2)

	inst:AddTag("thorny")
	inst:AddTag("elephantcactus")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.combat.notags = {"elephantcactus", "armorcactus"}
        end
        return inst
    end

	inst:AddComponent("inspectable")
	
	MakeLargeFreezableCharacter(inst)

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetLoot({"needlespear"})

	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.ELEPHANTCACTUS_HEALTH)

	inst:AddComponent("combat")
    inst.components.combat:SetDefaultDamage(TUNING.ELEPHANTCACTUS_DAMAGE)
    inst.components.combat:SetAttackPeriod(1)
	inst.components.combat:SetRange(TUNING.ELEPHANTCACTUS_RANGE)
	inst.components.combat:SetRetargetFunction(1, retargetfn)
	inst.components.combat:SetKeepTargetFunction(shouldKeepTarget)
    inst.components.combat:SetAreaDamage(TUNING.ELEPHANTCACTUS_RANGE, 1.0)
	inst.components.combat:SetHurtSound("ia/creatures/volcano_cactus/hit")
    inst.components.combat.notags = {"elephantcactus", "armorcactus"}

	inst:AddComponent("timer")
	inst:ListenForEvent("timerdone", ontimerdone)

	inst:ListenForEvent("blocked", OnBlocked)
	inst:ListenForEvent("attacked", OnBlocked)

	inst.has_spike = true

	inst:SetBrain(brain)
	inst:SetStateGraph("SGelephantcactus")
	inst.sg:GoToState("grow_spike")

	inst:WatchWorldState("season", function(inst, season) onseasonchange_active(inst) end)

	inst.OnLoad = OnLoadActive
	inst.OnSave = OnSaveActive

	return inst
end

local function stumpfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("cactus_volcano.tex")

    inst.AnimState:SetBank("cactus_volcano")
    inst.AnimState:SetBuild("cactus_volcano")
    inst.AnimState:PlayAnimation("idle_underground")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
    inst:AddComponent("lootdropper")

    if not GetGameModeProperty("disable_transplanting") then
        inst:AddComponent("workable")
        inst.components.workable:SetWorkAction(ACTIONS.DIG)
        inst.components.workable:SetOnFinishCallback(dig_up)
        inst.components.workable:SetWorkLeft(1)
    end
	
	inst:AddComponent("inspectable")

    inst:WatchWorldState("season", function(inst, season) onseasonchange(inst) end)

    inst.OnLoad = OnLoad

	return inst
end

-- you can find dug_elephantcactus in plantables.lua
return Prefab("elephantcactus", fn, assets, prefabs),
	   Prefab("elephantcactus_active", activefn, assets, prefabs),
	   Prefab("elephantcactus_stump", stumpfn, assets, prefabs)
%%+%%scripts/prefabs/fabric.lua%%-%%local assets=
{
  Asset("ANIM", "anim/fabric.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("fabric")
  inst.AnimState:SetBuild("fabric")
  inst.AnimState:PlayAnimation("idle")

  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("stackable")

  inst:AddComponent("inspectable")

  MakeSmallBurnable(inst, TUNING.LARGE_BURNTIME)
  MakeSmallPropagator(inst)

  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = TUNING.MED_FUEL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

  inst:AddTag("cattoy")
  inst:AddComponent("tradable")

  MakeInvItemIA(inst)

  return inst
end

return Prefab( "fabric", fn, assets) 
%%+%%scripts/prefabs/farm_mussel.lua%%-%%require "prefabutil"

local assets = 
{
    Asset("ANIM", "anim/musselfarm.zip"),
    Asset("MINIMAP_IMAGE", "farm_mussel")
}

local prefabs =
{
    "mussel",
    "collapse_small",
}

local function NewPoint(pt)
    local theta = math.random() * 2 * PI
    local radius = 6 + math.random() * 6

    local result_offset = FindValidPositionByFan(theta, radius, 12, function(offset)
        local spawn_point = pt + offset
        if GetGroundTypeAtPosition(spawn_point) == GROUND.OCEAN_SHALLOW then
            return true
        end
        return false
    end)

    if result_offset then
        return pt + result_offset
    end
end

local function MoveLocations(inst, child)
    local pos = Vectory3(inst.Transform:GetWorldPosition())
    local spawn_point = NewPoint(pos)

    if spawn_point then
        child.Transform:SetPosition(spawn_point:Get())
    end
end

local function OnPicked(inst, picker)
    inst.AnimState:PlayAnimation("picked")
    inst.components.growable:SetStage(1)
end

local function GetStatus(inst)
    if inst.growthstage > 0 then
        return "STICK_PLANTED"
    end
end

local function MakeEmpty(inst)
    -- never called?
end
local function MakeFull(inst)
    inst.AnimState:PlayAnimation("idle_full")
end

-- Stages
local function SetHidden(inst)
    inst.components.pickable.numtoharvest = 0
    inst.components.pickable.canbepicked = false
    --inst.components.blowinwindgust:Stop()
    inst.MiniMapEntity:SetEnabled(false)
    inst.Physics:SetCollides(false)
    inst:Hide()
    inst.components.stickable:UnStuck()
end

local function SetUnderwater(inst)
    inst.AnimState:PlayAnimation("idle_underwater", true)
    inst.components.pickable.numtoharvest = 0
    inst.components.pickable.canbepicked = false
    --inst.components.blowinwindgust:STop()
    inst.AnimState:SetLayer( LAYER_BACKGROUND )
    inst.AnimState:SetSortOrder( 2 )
    inst.MiniMapEntity:SetEnabled(false)
    inst.Physics:SetCollides(false)
    inst:Show()
    inst.components.stickable:UnStuck()
end

local function SetAboveWater(inst)
    -- common
    inst.AnimState:SetLayer( LAYER_WORLD )
    inst.AnimState:SetSortOrder( 0 )
    --inst.components.blowinwidngust:Start()
    inst.MiniMapEntity:SetEnabled(true)
    inst.Physics:SetCollides(true)
    inst.components.growable:StartGrowing()
    inst:Show()
    inst.components.stickable:Stuck()
end

local function SetEmpty(inst)
    inst.AnimState:PlayAnimation("idle_empty", true)
    inst.components.pickable.numtoharvest = 0
    inst.components.pickable.canbepicked = false
    inst.components.pickable.hasbeenpicked = false

    SetAboveWater(inst)
end

local function SetSmall(inst)
    inst.AnimState:PlayAnimation("idle_small", true)
    inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_SMALL
    inst.components.pickable.canbepicked = true
    inst.components.pickable.hasbeenpicked = false

    SetAboveWater(inst)
end

local function SetMedium(inst)
    inst.AnimState:PlayAnimation("idle_small", true)
    inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_MED
    inst.components.pickable.canbepicked = true
    inst.components.pickable.hasbeenpicked = false

    SetAboveWater(inst)
end

local function SetFull(inst)
    inst.AnimState:PlayAnimation("idle_full", true)
    inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_LARGE
    inst.components.pickable.canbepicked = true
    inst.components.pickable.hasbeenpicked = false

    SetAboveWater(inst)
end

local function GrowHidden(inst)
end

local function GrowUnderwater(inst)
end

local function GrowEmpty(inst)
    inst.growthstage = 2
    inst.AnimState:PlayAnimation("empty_to_small")
    inst.AnimState:PushAnimation("idle_small", true)
end

local function GrowSmall(inst)
end

local function GrowMedium(inst)
    inst.AnimState:PlayAnimation("small_to_full")
    inst.AnimState:PushAnimation("idle_full", true)
end

local function GrowFull(inst)
end

local function GrowTime(inst)
    return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME.BASE, TUNING.MUSSEL_CATCH_TIME.RANDOM)
end

local growth_stages =
{
    {
        name = "hidden",
        time = GrowTime,
        fn = SetHidden,
        growfn = GrowHidden,
    },
    {
        name = "underwater",
        time = function(inst)
            return nil
        end,
        fn = SetUnderwater,
        growfn = GrowUnderwater,
    },
    {
        name = "empty",
        time = GrowTime,
        fn = SetEmpty,
        growfn = GrowEmpty,
    },
    {
        name = "small",
        time = GrowTime,
        fn = SetSmall,
        growfn = GrowSmall,
    },
    {
        name = "medium",
        time = GrowTime,
        fn = SetMedium,
        growfn = GrowMedium,
    },
    {
        name = "full",
        time = GrowTime,
        fn = SetFull,
        growfn = GrowFull,
    }
}

local function OnPoked(inst, worker, stick)
    inst.SoundEmitter:PlaySound("ia/common/plant_mussel")
    inst.components.growable:SetStage(3)

    if stick.components.stackable and stick.components.stackable.stacksize > 1 then
        stick = stick.components.stackable:Get()
    end

    stick:Remove()
end

local function OnGustHarvest(inst)
    if inst.components.pickable and inst.components.pickable.numtoharvest > 0 then
        for i = 1, inst.components.pickable.numtoharvest, 1 do
            inst.components.lootdropper:SpawnLootPrefab(
                inst.components.pickable.product)
        end
        OnPicked(inst, nil)
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 0.8, 1.2)
 	inst.Physics:SetCollides(false)

    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("farm_mussel.tex")
    minimap:SetEnabled(false)

    inst.AnimState:SetBank("musselfarm")
    inst.AnimState:SetBuild("musselfarm")
    inst.AnimState:PlayAnimation("idle_underwater", true)
    inst.AnimState:SetLayer( LAYER_BACKGROUND )
    inst.AnimState:SetSortOrder( 3 )
    inst.AnimState:SetRayTestOnBB(true)

    inst:AddTag("structure")
    inst:AddTag("farm_mussel")
    inst:AddTag("aquatic")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.no_wet_prefix = true
	inst.growthstage = 0
	inst.targettime = nil

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = GetStatus

    inst:AddComponent("stickable")
    inst.components.stickable:SetOnPokeCallback(OnPoked)

--	inst:AddComponent("blowinwindgust")
--	inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.MUSSELFARM_WINDBLOWN_SPEED)
--	inst.components.blowinwindgust:SetDestroyChance(TUNING.MUSSELFARM_WINDBLOWN_FALL_CHANCE)
--	inst.components.blowinwindgust:SetDestroyFn(ongustharvest)

    inst:AddComponent("pickable")
    inst.components.pickable.picksound = "dontstarve/wilson/harvest_berries"
    inst.components.pickable.canbepicked = false
    inst.components.pickable.hasbeenpicked = false
    inst.components.pickable.product = "mussel"
    inst.components.pickable.numtoharvest = 0
    inst.components.pickable.onpickedfn = OnPicked
    inst.components.pickable.makeemptyfn = MakeEmpty
    inst.components.pickable.makefullfn = MakeFull
    inst.components.pickable.makebarrenfn = MakeEmpty

    inst:AddComponent("growable")
    inst.components.growable.stages = growth_stages
    inst.components.growable:SetStage(2)
    inst.components.growable.loopstages = false

    inst:AddComponent("lootdropper")

    return inst
end

return Prefab( "farm_mussel", fn, assets, prefabs)%%+%%scripts/prefabs/fishfarm.lua%%-%%require "prefabutil"

local assets = {
	Asset("ANIM", "anim/fish_farm.zip"),
}

local prefabs = {
   "fish_farm_sign"
}

local function OnRemove(inst)
    if inst.sign then
        inst.sign:Remove()
        inst.sign = nil
    end
end

local function onhammered(inst, worker)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
	if inst.components.breeder then inst.components.breeder:Reset() end
	inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
    inst:Remove()
end

local function ResetArt(inst)    
    inst.AnimState:Hide("sign")
    inst.AnimState:Hide("fish_1")    
    inst.AnimState:Hide("fish_2")
    inst.AnimState:Hide("fish_3")
    inst.AnimState:Hide("fish_4")
    inst.AnimState:Hide("fish_5")
    inst.AnimState:Hide("fish_6")
    inst.AnimState:Hide("fish_7")
    inst.AnimState:Hide("fish_8")    
    inst.AnimState:Hide("fish_9")    
end

local function SwitchTables(fromTable, toTable)
    local randNum = math.random(#fromTable)
    local fishLayer = fromTable[randNum]
    table.remove(fromTable, randNum)
    table.insert(toTable, fishLayer)    

    return fishLayer
end

local function RefreshArt(inst)
    if inst.sign then
        inst.sign.ResetArt(inst.sign)
    end

    if inst.volume ~= inst.components.breeder.volume then
        local fishLayer = 0
       
        for i = 1, math.abs(inst.volume - inst.components.breeder.volume) do
            if inst.volume < inst.components.breeder.volume then
                if inst.volume == inst.components.breeder.max_volume -1 then
                    table.insert(inst.UsedFishStates, 9)                    
                    inst.AnimState:Show("fish_9")
                else
                    local loop = 1
                    if #inst.UsedFishStates > 0 then                    
                        loop = 2
                    end
                    for j = 1, loop do
                        inst.AnimState:Show("fish_"..tostring(SwitchTables(inst.UnusedFishStates, inst.UsedFishStates))) 
                    end
                end
                inst.volume = inst.volume + 1
            else
                if inst.volume == inst.components.breeder.max_volume then
                    table.remove(inst.UsedFishStates, #inst.UsedFishStates)
                    inst.AnimState:Hide("fish_9")
                else
                    local loop = 1
                    if #inst.UsedFishStates > 1 then                    
                        loop = 2
                    end
                    for j = 1, loop do
                        inst.AnimState:Hide("fish_"..tostring(SwitchTables(inst.UsedFishStates, inst.UnusedFishStates))) 
                    end
                end
                inst.volume = inst.volume -1
            end
        end
    end
end

local function OnSave(inst, data)
    if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end
end

local function OnLoad(inst, data)
    if data ~= nil and data.burnt and inst.components.burnable ~= nil and inst.components.burnable.onburnt ~= nil then
        inst.components.burnable.onburnt(inst)
    end
    ResetArt(inst)
    RefreshArt(inst)
end

local function SpawnSign(inst)
    local pt = Vector3(inst.Transform:GetWorldPosition())
    inst.sign = SpawnPrefab("fish_farm_sign")
    inst.sign.Transform:SetPosition(pt.x, 0, pt.z)
    inst.sign.parent = inst
    inst.sign.ResetArt(inst.sign)
end

local function onseed(inst, seed)
    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_small")
    inst.SoundEmitter:PlaySound("ia/common/pickobject_water")
end

local function onharvest(inst, harvester)
    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_small")
    inst.SoundEmitter:PlaySound("ia/common/fish_farm_harvest")
end

local function onbuilt(inst)
	inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_med")
    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_medium")
	RefreshArt(inst)
end

local VOLUME_STATUS = {
    [1] = "ONEFISH",
    [2] = "TWOFISH",
    [3] = "REDFISH",
    [4] = "BLUEFISH",
}

local function getstatus(inst)
    if inst.components.breeder.volume > 0 then
        return VOLUME_STATUS[inst.components.breeder.volume]
    else
        return inst.components.breeder.seeded and "STOCKED" or "EMPTY"
    end
end

local function placer_postinit(inst, pt)
    inst.AnimState:Hide("mouseover")
    inst.AnimState:Hide("sign")
    inst.AnimState:Hide("fish_1")    
    inst.AnimState:Hide("fish_2")
    inst.AnimState:Hide("fish_3")
    inst.AnimState:Hide("fish_4")
    inst.AnimState:Hide("fish_5")
    inst.AnimState:Hide("fish_6")
    inst.AnimState:Hide("fish_7")
    inst.AnimState:Hide("fish_8")    
    inst.AnimState:Hide("fish_9")
end

local function fn()
    local inst = CreateEntity()
    
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()
    
    inst.AnimState:SetBank("fish_farm")
    inst.AnimState:SetBuild("fish_farm")
    inst.AnimState:PlayAnimation("idle", true)
	inst.AnimState:SetLayer(LAYER_BACKGROUND)
	inst.AnimState:SetSortOrder(3)

    inst.MiniMapEntity:SetIcon("fish_farm.tex")
    
    inst.entity:SetPristine()
    
    inst:AddTag("structure")
    inst:AddTag("fishfarm")

    --breeder (from breeder component) added to pristine state for optimization
    inst:AddTag("breeder")
  
    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    inst.components.inspectable.nameoverride = "FISH_FARM"
    inst.components.inspectable.getstatus = getstatus      
        
    inst:AddComponent("breeder")    
    inst.components.breeder.onseedfn = onseed
    inst.components.breeder.onharvestfn = onharvest
    inst.components.breeder.luretime = TUNING.FISH_FARM_LURE_TEST_TIME
    inst.components.breeder.cycle_min = TUNING.FISH_FARM_CYCLE_TIME_MIN
    inst.components.breeder.cycle_max = TUNING.FISH_FARM_CYCLE_TIME_MAX
	
	inst:AddComponent("lootdropper")
	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)

    inst.volume = 0
    inst.UsedFishStates = {}
    inst.UnusedFishStates={1,2,3,4,5,6,7,8}

    inst.OnSave = OnSave
    inst.OnLoad = OnLoad
    inst.OnRemoveEntity = OnRemove

	inst:ListenForEvent("onbuilt", onbuilt)
    
	inst:ListenForEvent("vischange", RefreshArt)

    inst:DoTaskInTime(0, SpawnSign)

    inst.AnimState:Hide("mouseover")
    
    ResetArt(inst)
	RefreshArt(inst)
    
    return inst
end    

return Prefab("fish_farm", fn, assets, prefabs),
        MakePlacer("fish_farm_placer", "fish_farm", "fish_farm", "idle", nil, nil, nil, nil, nil, nil, placer_postinit)%%+%%scripts/prefabs/fishfarm_sign.lua%%-%%local assets = {
    Asset("ANIM", "anim/fish_farm_sign.zip"),   
}

local function DetermineSign(inst)
    if inst.parent then
        if inst.parent.components.breeder.seeded then
            if inst.parent.components.breeder.harvested then
                return FISH_FARM.SIGN[inst.parent.components.breeder.product]
            else
                return "buoy_sign_1"
            end
        else
            return nil
        end
    end
end

local function ResetArt(inst)    
    inst.AnimState:Hide("buoy_sign_1")    
    inst.AnimState:Hide("buoy_sign_2")
    inst.AnimState:Hide("buoy_sign_3")
    inst.AnimState:Hide("buoy_sign_4")
    inst.AnimState:Hide("buoy_sign_5") 

    local sign = DetermineSign(inst)
    if sign then
        inst.AnimState:Show(sign)   
    end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()
    
    inst.AnimState:SetBank("fish_farm_sign")
    inst.AnimState:SetBuild("fish_farm_sign")
    inst.AnimState:PlayAnimation("idle", true)  
    
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.ResetArt = ResetArt

    inst.persists = false

    return inst

end    

return Prefab("fish_farm_sign", fn, assets)%%+%%scripts/prefabs/fishinhole.lua%%-%%local assets =
{
    Asset("ANIM", "anim/fishschool.zip")
}

local prefabs =
{
    "fish_tropical",
}

local FISH_STATES =
{
    FULL = "full",
    HALF = "half",
    GONE = "gone",
}

local function SetFishState(inst, state)
    inst.fish_state = state
end

local function GetFishState(inst)
    return inst.fish_state
end

local function PlayAnimation(inst, anim, loop)
    local state = inst:GetFishState()
    anim = anim.."_"..state
    inst.AnimState:PlayAnimation(anim, loop)
end

local function PushAnimation(inst, anim, loop)
    local state = inst:GetFishState()
    anim = anim.."_"..state
    inst.AnimState:PushAnimation(anim, loop)
end

local function getactiveperiod(inst)
    local activeTime = TUNING.TOTAL_DAY_TIME * 2

    if TheWorld.state.iswinter or TheWorld.state.iswet then
        activeTime = TUNING.TOTAL_DAY_TIME
    elseif TheWorld.state.isspring or TheWorld.state.isgreen then
        activeTime = TUNING.TOTAL_DAY_TIME * 3
    end

    return activeTime
end

local function getinactiveperiod(inst)
    local inactiveTime = TUNING.TOTAL_DAY_TIME

    if TheWorld.state.iswinter or TheWorld.state.iswet then
        inactiveTime = TUNING.TOTAL_DAY_TIME * 3
    elseif TheWorld.state.isspring or TheWorld.state.isgreen then
        inactiveTime = TUNING.TOTAL_DAY_TIME * 0.5
    end

    return inactiveTime
end

local function isbeingfished(inst)
    return inst.isbeingfished
end

local function scatter(inst)
    if inst.task ~= nil then
        inst.task:Cancel()
    end

    if isbeingfished(inst) then
        inst.scatterTime = GetTime() + 2
        inst.task = inst:DoTaskInTime(2, inst.scatter, "scatter")
    else
        inst.regroupTime = getinactiveperiod(inst) + GetTime()
        PlayAnimation(inst, "idle_pst")
        local animLength = inst.AnimState:GetCurrentAnimationLength()
        inst.MiniMapEntity:SetEnabled(false)
        inst.active = false
        inst.task = inst:DoTaskInTime(getinactiveperiod(inst), inst.regroup, "regroup")
        inst.SoundEmitter:PlaySound("ia/common/fish_scatter")

        inst:DoTaskInTime(animLength, function(inst)
            inst:Hide()
        end)
    end
end

local function regroup(inst)
    if inst.task ~= nil then
        inst.task:Cancel()
    end

    inst:Show()
    inst.scatterTime = getactiveperiod(inst) + GetTime()
    PlayAnimation(inst, "idle_pre")
    PushAnimation(inst, "idle_loop", true)
    inst.MiniMapEntity:SetEnabled(true)
    inst.active = true
    inst.task = inst:DoTaskInTime(getactiveperiod(), inst.scatter, "scatter")
end

local function onlongupdate(inst, dt)
    if inst.task ~= nil then
        inst.task:Cancel()
    end
    local time = GetTime() + dt
    if inst.active then
        if time > inst.scatterTime then
            inst:scatter()
        else
            inst.task = inst:DoTaskInTime(inst.scatterTime - time, inst.scatter, "scatter")
            inst.scatterTime = inst.scatterTime - dt
        end
    else
        if time > inst.regroupTime then
            inst:regroup()
        else
            inst.task = inst:DoTaskInTime(inst.regroupTime - time, inst.regroup, "regroup")
            inst.regroupTime = inst.regroupTime - dt
        end
    end
end

local function onfishdelta(inst)
    local percent = inst.components.fishable:GetFishPercent()

    if percent >= 0.50 then
        inst:SetFishState(FISH_STATES.FULL)
    elseif percent > 0 then
        inst:SetFishState(FISH_STATES.HALF)
    else
        inst:SetFishState(FISH_STATES.GONE)
    end
    
    PushAnimation(inst, "idle_loop", true)
end

local function onsave(inst, data)
    if data == nil then
        data = {}
    end

    data.active = inst.activeTime
    data.fish_state = inst:GetFishState()
    if data.active then
        if inst.scatterTime ~= nil then
            data.timeuntilscatter = inst.scatterTime - GetTime()
            data.timeuntilregroup = nil
        end
    else
        if inst.regroupTime ~= nil then
            data.timeuntilregroup = inst.regroupTime - GetTime()
            data.timeuntilscatter = nil
        end
    end
end

local function onload(inst, data)
    if data then
        if data.fish_state then
            inst:SetFishState(data.fish_state)
        end
        if data.active then
            inst.active = true
            inst.MiniMapEntity:SetEnabled(true)
            inst.task = inst:DoTaskInTime(data.timeuntilscatter or 0, inst.scatter, "scatter")
            inst.scatterTime = GetTime() + (data.timeuntilscatter or 0)
        else
            inst.active = false
            PlayAnimation(inst, "idle_pst", false)
            inst.MiniMapEntity:SetEnabled(false)
            inst.task = inst:DoTaskInTime(data.timeuntilregroup or 0, inst.regroup, "regroup")
            inst.regroupTime = GetTime() + (data.timeuntilregroup or 0)
        end
    end
end

local function oncollide(inst, other)
    if not inst.active then return end

    if other and other.sg and other.sg:HasStateTag("running") then
        if not isbeingfished(inst) and inst:IsNear(other, 3.5) then
            scatter(inst)
        end
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddPhysics()
    inst.entity:AddNetwork()

    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("fish2.tex")

    inst.Physics:SetCylinder(4, 2)
    inst.Physics:SetCollides(false)
    inst.Physics:SetCollisionGroup(COLLISION.OBSTACLES)
    inst.Physics:CollidesWith(COLLISION.CHARACTERS)
    inst.Physics:CollidesWith(COLLISION.WAVES)
    inst.Physics:SetCollisionCallback(oncollide)

    inst.AnimState:SetBuild("fishschool")
    inst.AnimState:SetBank("fishschool")
    inst.AnimState:SetLayer( LAYER_BACKGROUND )
    inst.AnimState:SetSortOrder( 3 )
    inst.AnimState:SetRayTestOnBB(true)

    inst:AddTag("aquatic")

    inst.no_wet_prefix = true

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    inst.components.inspectable.nameoverride = "pond"

    inst:AddComponent("fishable")
    inst.components.fishable:SetRespawnTime(TUNING.FISH_SCHOOL_RESPAWN)
    inst.components.fishable:AddFish("fish_tropical")
    inst.components.fishable.OnFishDelta = onfishdelta
    local numFish = math.random(TUNING.FISH_SCHOOL_MIN, TUNING.FISH_SCHOOL_MAX)
    inst.components.fishable.maxfix = numFish
    inst.components.fishable.fishleft = numFish

    inst.regroup = regroup
    inst.scatter = scatter
    inst.GetFishState = GetFishState
    inst.SetFishState = SetFishState
    inst:SetFishState(FISH_STATES.FULL)
    PlayAnimation(inst, "idle_loop", true)

    inst.active = true
    local activeTime = getactiveperiod()
    local inactiveTime = getinactiveperiod()
    local currentTime = math.random(0, activeTime + inactiveTime)
    local timeLeft

    if currentTime >= activeTime then
        inst.active = false
        currentTime = currentTime - activeTime
        timeLeft = inactiveTime - currentTime
        inst.regroupTime = timeLeft + GetTime()
        inst.task = inst:DoTaskInTime(timeLeft, inst.regroup, "regroup")
        inst.MiniMapEntity:SetEnabled(false)
    else
        timeLeft = activeTime - currentTime
        inst.scatterTime = timeLeft + GetTime()
        inst.task = inst:DoTaskInTime(timeLeft, inst.scatter, "scatter")
    end

    inst.OnLoad = onload
    inst.OnSave = onsave
    inst.OnLongUpdate = onlongupdate

    return inst
end

return Prefab( "fishinhole", fn, assets, prefabs)
%%+%%scripts/prefabs/fish_med.lua%%-%%local dogfish_assets=
{
  Asset("ANIM", "anim/fish_dogfish.zip"),
}

local swordfish_assets=
{
  Asset("ANIM", "anim/fish_swordfish.zip"), 	
}

local spoiledfish_assets = 
{
  Asset("ANIM", "anim/spoiled_fish.zip")
}

local cooked_assets = 
{
  Asset("ANIM", "anim/fish_med_cooked.zip")
}

local raw_assets = 
{
  Asset("ANIM", "anim/fish_raw.zip")
}

local small_assets =
{
  Asset("ANIM", "anim/fish_meat_small.zip")
}

local lobster_assets =
{
  Asset("ANIM", "anim/lobster_build_color.zip"),
  Asset("ANIM", "anim/lobster.zip"),
}

local prefabs =
{
  "fish_med_cooked",
  "spoiled_fish",
  "spoiled_food",
}

SetSharedLootTable( 'spoiledfish',
  {
    {'boneshard',    1.00},
    {'boneshard',    1.00},
  })

local function stopkicking(inst)
  inst.AnimState:PlayAnimation("dead")
end


local function makefish_med(bank, build, dryablesymbol)

  local function commonfn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.entity:AddAnimState()
    inst.AnimState:SetBank(bank)
    inst.AnimState:SetBuild(build)
    inst.AnimState:PlayAnimation("dead")
    inst.build = build --This is used within SGwilson, sent from an event in fishingrod.lua

    inst:AddTag("catfood")
    inst:AddTag("fishmeat")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "dead")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("edible")
    inst.components.edible.ismeat = true
    inst.components.edible.foodtype = "MEAT"
    inst.components.edible.healthvalue = TUNING.HEALING_TINY
    inst.components.edible.hungervalue = TUNING.CALORIES_MED

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_fish"

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    inst:AddComponent("tradable")
    inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
    inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
    inst.data = {}

    inst:AddComponent("cookable")
    inst.components.cookable.product = "fish_med_cooked"

    inst:AddComponent("dryable")
    inst.components.dryable:SetProduct("meat_dried")
    inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

    inst:AddTag("spoiledbypackim")
    inst:AddTag("meat")

    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

    return inst
  end

  return commonfn
end

local function onspoiledhammered(inst, worker)
  local to_hammer = (inst.components.stackable and inst.components.stackable:Get(1)) or inst
  if to_hammer == inst then
    to_hammer.components.inventoryitem:RemoveFromOwner(true)
  end
  if to_hammer:IsInLimbo() then
    to_hammer:ReturnToScene()
  end

  to_hammer.Transform:SetPosition(inst:GetPosition():Get())
  to_hammer.components.lootdropper:DropLoot()
  SpawnPrefab("collapse_small").Transform:SetPosition(to_hammer.Transform:GetWorldPosition())
  to_hammer.SoundEmitter:PlaySound("dontstarve/common/destroy_wood")

  inst.components.workable:SetWorkLeft(1)

  to_hammer:Remove()
end

local function spoiledfn()

  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddAnimState()
  inst.AnimState:SetBank("spoiled_fish")
  inst.AnimState:SetBuild("spoiled_fish")
  inst.AnimState:PlayAnimation("idle", true)

  inst.entity:AddSoundEmitter()

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable:SetOnFinishCallback(onspoiledhammered)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"boneshard", "boneshard"})

  
  -- inst:RemoveComponent("appeasement")

  return inst

end 

local function cookedfn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddAnimState()
  inst.AnimState:SetBank("fish_med_cooked")
  inst.AnimState:SetBuild("fish_med_cooked")
  inst.AnimState:PlayAnimation("cooked", true)

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_cooked_water", "cooked")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_MED
  inst.components.edible.hungervalue = TUNING.CALORIES_MED

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food" 

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
  inst.data = {}
  inst:AddComponent("bait")

  return inst
end

local function fish_raw_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddAnimState()
  inst.AnimState:SetBank("fish_raw")
  inst.AnimState:SetBuild("fish_raw")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
  inst.data = {}

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_MED

  inst:AddComponent("cookable")
  inst.components.cookable.product = "fish_med_cooked"
  inst:AddComponent("dryable")
  inst.components.dryable:SetProduct("meat_dried")
  inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

  inst:AddComponent("bait")

  return inst
end

local function fish_raw_small_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddAnimState()
  inst.AnimState:SetBank("fish_meat_small")
  inst.AnimState:SetBuild("fish_meat_small")
  inst.AnimState:PlayAnimation("raw")

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("raw_water", "raw")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
  inst.data = {}

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL

  inst:AddComponent("cookable")
  inst.components.cookable.product = "fish_small_cooked"

  inst:AddComponent("dryable")
  inst.components.dryable:SetProduct("smallmeat_dried")
  inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

  inst:AddComponent("bait")

  return inst
end

local function fish_raw_small_cooked_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddAnimState()
  inst.AnimState:SetBank("fish_meat_small")
  inst.AnimState:SetBuild("fish_meat_small")
  inst.AnimState:PlayAnimation("cooked", true)

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_cooked_water", "cooked")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food" 

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
  inst.data = {}
  inst:AddComponent("bait")

  return inst
end

local function lobster_dead_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("lobster")
  inst.AnimState:SetBuild("lobster_build_color")
  inst.AnimState:PlayAnimation("idle_dead")

  MakeInventoryPhysics(inst)

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_dead_water", "idle_dead")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  MakeInvItemIA(inst)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL

  inst:AddComponent("cookable")
  inst.components.cookable.product = "lobster_dead_cooked"

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

  return inst
end

local function lobster_dead_cooked_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("lobster")
  inst.AnimState:SetBuild("lobster_build_color")
  inst.AnimState:PlayAnimation("idle_cooked")

  MakeInventoryPhysics(inst)

  inst:AddTag("meat")
  inst:AddTag("fishmeat")
  inst:AddTag("catfood")
  inst:AddTag("packimfood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_cooked", "idle_cooked")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  MakeInvItemIA(inst)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

  inst:AddComponent("edible")
  inst.components.edible.ismeat = true
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

  return inst
end

local rawmed = makefish_med("dogfish", "fish_dogfish", "dogfish")
local rawsword = makefish_med("swordfish", "fish_swordfish", "swordfish")

return Prefab( "solofish_dead", rawmed, dogfish_assets, prefabs), 
Prefab( "swordfish_dead", rawsword, swordfish_assets, prefabs), 
Prefab( "spoiled_fish", spoiledfn,spoiledfish_assets), 
Prefab( "fish_med", fish_raw_fn, raw_assets),
Prefab( "fish_med_cooked", cookedfn, cooked_assets),
Prefab( "fish_small", fish_raw_small_fn, small_assets),
Prefab( "fish_small_cooked", fish_raw_small_cooked_fn, small_assets),
Prefab( "lobster_dead", lobster_dead_fn, lobster_assets),
Prefab( "lobster_dead_cooked", lobster_dead_cooked_fn, lobster_assets)
%%+%%scripts/prefabs/fish_tropical.lua%%-%%local assets = {
    fish_tropical = {
        Asset("ANIM", "anim/fish2.zip"),
        Asset("ANIM", "anim/fish02.zip"),
    },
    purple_grouper = {
        Asset("ANIM", "anim/fish3.zip"),
    },
    pierrot_fish = {
        Asset("ANIM", "anim/fish4.zip"),
    },
    neon_quattro = {
        Asset("ANIM", "anim/fish5.zip"),
    },
}

local prefabs = {
    fish_tropical = {
        "fish_cooked",
        "spoiled_food",
    },
    purple_grouper = {
        "spoiled_food",
    },
    pierrot_fish = {
        "spoiled_food",
    },
    neon_quattro = {
        "spoiled_food",
    },
}

local function stopkicking(inst)
	if inst.components.floater then
		inst.components.floater:UpdateAnimations("idle_water", "dead")
	end
end

local function pristinefn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst:AddTag("meat")
    inst:AddTag("catfood")

	return inst
end

local function masterfn(inst, bank_and_build)
    inst:AddComponent("edible")
    inst.components.edible.ismeat = true
    inst.components.edible.foodtype = FOODTYPE.MEAT

--Not using the prefab name, or bools? -M
    if bank_and_build == "fish3" then
        inst.components.edible.surferdelta = TUNING.HYDRO_FOOD_BONUS_SURF
        inst.components.edible.surferduration = TUNING.FOOD_SPEED_AVERAGE
    end

    if bank_and_build == "fish4" then
        inst.components.edible.autodrydelta = TUNING.HYDRO_FOOD_BONUS_DRY
        inst.components.edible.autodryduration = TUNING.FOOD_SPEED_AVERAGE
    end
    
    if bank_and_build == "fish5" then
        inst.components.edible.autocooldelta = TUNING.HYDRO_FOOD_BONUS_COOL_RATE
    end 

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("bait")

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    MakeHauntableLaunchAndPerish(inst)

    inst:AddComponent("tradable")
    inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
    inst.data = {}
end

local function rawfn(name, bank_and_build, rod, dryable, cookable)
    local inst = pristinefn()

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "dead")

    inst.AnimState:SetBank(bank_and_build)
    inst.AnimState:SetBuild(bank_and_build)
    inst.AnimState:PlayAnimation(name == "fish_tropical" and "idle" or "dead", true)

    if dryable then
        --dryable (from dryable component) added to pristine state for optimization
        inst:AddTag("dryable")
    end

    if cookable ~= false then
        --cookable (from cookable component) added to pristine state for optimization
        inst:AddTag("cookable")
    end
	
	inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	masterfn(inst, bank_and_build)

    if dryable then
        inst:AddComponent("dryable")
        inst.components.dryable:SetProduct(dryable)
        inst.components.dryable:SetDryTime(TUNING.DRY_FAST)
    end

    if cookable ~= false then
        inst:AddComponent("cookable")
        inst.components.cookable.product = cookable or name .."_cooked"
    end
	
    inst.build = rod --This is used within SGwilson, sent from an event in fishingrod.lua

    inst.components.edible.healthvalue = TUNING.HEALING_TINY
    inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
    if name == "fish_tropical" then
        inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
    else
        inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
    end

    if name == "fish_tropical" then
        inst:DoTaskInTime(5, stopkicking)
        inst.components.inventoryitem:SetOnPickupFn(stopkicking)
        inst.OnLoad = stopkicking
    end


    return inst
end

local function cookedfn(bank_and_build, rod)
    local inst = pristinefn()
	
    inst.AnimState:SetBank(bank_and_build)
    inst.AnimState:SetBuild(bank_and_build)
    inst.AnimState:PlayAnimation("cooked")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("cooked_water", "cooked")
	
	inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	masterfn(inst, bank_and_build)

    inst.build = rod --This is used within SGwilson, sent from an event in fishingrod.lua

    inst.components.edible.healthvalue = TUNING.HEALING_TINY
    inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
    inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)


    return inst
end

local function makefish(name, bank_and_build, rod, dryable, cookable)
    local function makerawfn()
        return rawfn(name, bank_and_build, rod, dryable, cookable)
    end

    local function makecookedfn()
        return cookedfn(bank_and_build, rod)
    end

    return makerawfn, makecookedfn
end

local prefabs = {}

local function fish(name, bank_and_build, rod, dryable, cookable)
    local raw, cooked = makefish(name, bank_and_build, rod, dryable, cookable)

    table.insert(prefabs, Prefab(name, raw, assets[name], prefabs[name]))
    if cookable == nil then
        table.insert(prefabs, Prefab(name.."_cooked", cooked, assets[name], prefabs[name]))
    end
end

fish("fish_tropical", "fish2", "fish02", "smallmeat_dried", "fish_small_cooked")
fish("purple_grouper", "fish3")
fish("pierrot_fish", "fish4")
fish("neon_quattro", "fish5")

return unpack(prefabs)%%+%%scripts/prefabs/flamegeyser.lua%%-%%local assets=
{
  Asset("ANIM", "anim/geyser.zip"),
  Asset("MINIMAP_IMAGE", "geyser"),
}


local function StartBurning(inst)
  inst.Light:Enable(true)

  inst.components.geyserfx:Ignite()
  inst:AddTag("fire")
end

local function OnIgnite(inst)
  StartBurning(inst)
end

local function OnBurn(inst)
  inst.components.fueled:StartConsuming()
  inst.components.propagator:StartSpreading()
  inst.components.geyserfx:SetPercent(inst.components.fueled:GetPercent())
  inst:AddComponent("cooker")
end

local function SetIgniteTimer(inst)
  inst:DoTaskInTime(GetRandomWithVariance(TUNING.FLAMEGEYSER_REIGNITE_TIME, TUNING.FLAMEGEYSER_REIGNITE_TIME_VARIANCE), function()
      if not inst:HasTag("flooded") then
        inst.components.fueled:SetPercent(1.0)
        OnIgnite(inst)
      end 
    end)
end

local function OnErupt(inst)
  StartBurning(inst)
  inst.components.fueled:SetPercent(1.0)
  OnBurn(inst)
  ShakeAllCameras(CAMERASHAKE.FULL, .7, .02, 0.75, inst, 15)
end

local function OnExtinguish(inst, setTimer)
  inst.AnimState:ClearBloomEffectHandle()
  inst.components.fueled:StopConsuming()
  inst.components.propagator:StopSpreading()
  inst.components.geyserfx:Extinguish()
  if inst.components.cooker then 
    inst:RemoveComponent("cooker")
  end 
  if setTimer ~= false then 
    SetIgniteTimer(inst)
  end
  inst:RemoveTag("fire")
end

local function OnIdle(inst)
  inst.AnimState:PlayAnimation("idle_dormant", true)
  inst.Light:Enable(false)
  inst:StopUpdatingComponent(inst.components.geyserfx)
end

local function onSection(section, oldsection, inst)
	if section == 0 then
		OnExtinguish(inst)
	else
		local damagerange = {2,2,2,2}
		local ranges = {2,2,2,4}
		local output = {4,10,20,40}
		inst.components.propagator.damagerange = damagerange[section]
		inst.components.propagator.propagaterange = ranges[section]
		inst.components.propagator.heatoutput = output[section]
	end
end

local function onFuelUpdate(inst)
	if not inst.components.fueled:IsEmpty() then
		inst.components.geyserfx:SetPercent(inst.components.fueled:GetPercent())
	end
end

local function OnLoad(inst, data)
  if not inst.components.fueled:IsEmpty() then
    OnIgnite(inst)
  else
    SetIgniteTimer(inst)
  end
end

local heats = { 70, 85, 100, 115 }
local function GetHeatFn(inst)
  return 100 --heats[inst.components.geyserfx.level] or 20
end

local function onStartFlooded(inst)
  inst.components.fueled:SetPercent(0)
  OnExtinguish(inst, false)
end


local function onStopFlooded(inst)
  SetIgniteTimer(inst)
end 

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local light = inst.entity:AddLight()
  local sound = inst.entity:AddSoundEmitter()
  local minimap = inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()

  MakeObstaclePhysics(inst, 2.05)
  inst.Physics:SetCollides(false)

  minimap:SetIcon("geyser.tex")
  inst.AnimState:SetBank("geyser")
  inst.AnimState:SetBuild("geyser")
  inst.AnimState:PlayAnimation("idle_dormant", true)
  inst.AnimState:SetBloomEffectHandle( "shaders/anim.ksh" )

  inst.Light:EnableClientModulation(true)

	inst:AddComponent("floodable")
	inst.components.floodable:SetFX(nil,.1) --init update faster

	inst:DoTaskInTime(1, function()
		inst.components.floodable:SetFX(nil,10) --now update normal again
	end)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  inst:AddComponent("heater")
  inst.components.heater.heatfn = GetHeatFn

  inst:AddComponent("fueled")
  inst.components.fueled.maxfuel = TUNING.FLAMEGEYSER_FUEL_MAX
  inst.components.fueled.accepting = false
  inst:AddComponent("propagator")
  inst.components.propagator.damagerange = 2
  inst.components.propagator.damages = true

  inst.components.fueled:SetSections(4)
  inst.components.fueled.rate = 1
  inst.components.fueled.period = 1

  inst.components.fueled:SetUpdateFn( onFuelUpdate)
  inst.components.fueled:SetSectionCallback( onSection )

  inst.components.fueled:InitializeFuelLevel(TUNING.FLAMEGEYSER_FUEL_START)

	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

  inst:AddComponent("geyserfx")
  inst.components.geyserfx.usedayparamforsound = true
  inst.components.geyserfx.lightsound = "ia/common/flamegeyser_open"
  --inst.components.geyserfx.extinguishsound = "ia/common/flamegeyser_out"
  inst.components.geyserfx.pre =
  {
    {percent=1.0, anim="active_pre", radius=0, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=.1},
    {percent=1.0-(24/42), sound="ia/common/flamegeyser_lp", radius=1, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=1},
    {percent=0.0, sound="ia/common/flamegeyser_lp", radius=3.5, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=1},
  }
  inst.components.geyserfx.levels =
  {
    {percent=1.0, anim="active_loop", sound="ia/common/flamegeyser_lp", radius=3.5, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=1},
  }
  inst.components.geyserfx.pst =
  {
    {percent=1.0, anim="active_pst", sound="ia/common/flamegeyser_lp", radius=3.5, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=1},
    {percent=1.0-(61/96), sound="ia/common/flamegeyser_out", radius=0, intensity=.8, falloff=.33, colour = {255/255,187/255,187/255}, soundintensity=.1},
  }


  if not inst.components.fueled:IsEmpty() then
    OnIgnite(inst)
  end

  inst.OnIgnite = OnIgnite
  inst.OnErupt = OnErupt
  inst.OnBurn = OnBurn
  inst.OnIdle = OnIdle

  return inst
end

return Prefab( "flamegeyser", fn, assets)%%+%%scripts/prefabs/flood.lua%%-%%local assets =
{
	Asset("ANIM", "anim/floodtile.zip"),
}

--for networking entities sans actions (a lot less costly)
--For some reason, the basegame entityscript overrides this function.
local AddNetworkProxy = UpvalueHacker.GetUpvalue(Entity.AddNetwork, "AddNetworkProxy")
if not AddNetworkProxy then
	AddNetworkProxy = Entity.AddNetwork
	print("WARNING: IA could not find AddNetworkProxy, tides and flood are going to be very laggy!")
end

local s = .7063

local function fn()
	local inst = CreateEntity()

	AddNetworkProxy(inst.entity)

	inst.entity:AddTransform()
	inst.Transform:SetScale(s,s,s)

	--need to init this for networking
	inst.entity:AddAnimState()
	inst.AnimState:SetBuild("floodtile")
	inst.AnimState:SetBank("floodtile")

	inst.persists = false

	if not TheWorld.ismastersim then -- NETVAR
		inst:DoTaskInTime(0,function(inst)
			TheWorld.components.flooding:AddFloodTile(inst)
		end)
		inst.OnRemoveEntity = function(inst)
			TheWorld.components.flooding:RemoveFloodTile(inst)
		end
	end

	return inst
end

return Prefab( "flood", fn, assets) 

%%+%%scripts/prefabs/flotsam.lua%%-%%local assets =
{
    Asset("ANIM", "anim/flotsam_debris_armoured_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_bamboo_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_cargo_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_lograft_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_rowboat_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_surfboard_build.zip"),
    Asset("ANIM", "anim/flotsam_debris_sw.zip"),
    Asset("ANIM", "anim/flotsam_knightboat_build.zip"),

}

local anim_appends =
{
    "",
    "2",
    "3",
    "4",
    "5",
}

local function sink(inst)
    inst.SoundEmitter:PlaySound("ia/common/boat/debris_submerge")
    inst.AnimState:PushAnimation("sink"..inst.anim_append, false)
    inst:ListenForEvent("animover", inst.Remove)
end

local function fn(build)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
    MakeInventoryPhysics(inst)

    inst.SoundEmitter:PlaySound("ia/common/boat/debris_breakoff")

    inst.AnimState:SetBank("flotsam_debris_sw")
    inst.AnimState:SetBuild("flotsam_debris_"..build.."_build")
    inst.anim_append = anim_appends[math.random(#anim_appends)]
    inst.AnimState:PlayAnimation("idle"..inst.anim_append, true)

    inst:DoTaskInTime(3 + math.random() * 4, sink)

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    inst.persists = false

    inst.entity:SetPristine()

    return inst
end

return Prefab("flotsam_armoured", function() return fn("armoured") end, assets, prefabs),
Prefab("flotsam_bamboo", function() return fn("bamboo") end, assets, prefabs),
Prefab("flotsam_cargo", function() return fn("cargo") end, assets, prefabs),
Prefab("flotsam_lograft", function() return fn("lograft") end, assets, prefabs),
Prefab("flotsam_rowboat", function() return fn("rowboat") end, assets, prefabs),
Prefab("flotsam_surfboard", function() return fn("surfboard") end, assets, prefabs)%%+%%scripts/prefabs/flup.lua%%-%%local brain = require("brains/flupbrain")
require("stategraphs/SGflup")

local assets =
{
  Asset("ANIM", "anim/flup_build.zip"),
  Asset("ANIM", "anim/flup_basic.zip"),
}

local prefabs =
{
  "blowdart_flup",
  "monstermeat",
}

SetSharedLootTable( 'flup',
  {
    {'monstermeat',   1.00},
    {'blowdart_flup', 0.25},
  })

local function sleeptestfn(inst)
  return false
end

local function retargetfn(inst)
  if inst.sg:HasStateTag("ambusher") then
    --Hiding in dirt, looking to attack.
    return FindEntity(inst, 7, function(tar)
        local canTarget = inst.components.combat:CanTarget(tar)
        return canTarget
      end, nil, {"flup", "FX", "NOCLICK"})
  end
end

local function keeptargetfn(inst, target)
  local homePos = inst.components.knownlocations:GetLocation("home")

  return target
  and target.components.combat
  and target.components.health
  and not target.components.health:IsDead()
  and inst:GetPosition():Dist(target:GetPosition()) < 15
  and (homePos and homePos:Dist(target:GetPosition()) < 30)
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddPhysics()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()
  inst.entity:AddDynamicShadow()

  inst.DynamicShadow:SetSize(1.5, 0.75)
  inst.Transform:SetFourFaced()

  inst.AnimState:SetBank("flup")
  inst.AnimState:SetBuild("flup_build")
  inst.AnimState:PlayAnimation("idle")

  MakeCharacterPhysics(inst, 1, 0.3)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.FLUP_WALKSPEED
  inst.components.locomotor.runspeed = TUNING.FLUP_RUNSPEED

  inst:SetStateGraph("SGflup")
  inst:SetBrain(brain)

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.FLUP_HEALTH)

  inst:AddComponent("combat")
  inst.components.combat:SetRetargetFunction(1.5, retargetfn)
  inst.components.combat:SetKeepTargetFunction(keeptargetfn)
  inst.components.combat:SetDefaultDamage(TUNING.FLUP_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.FLUP_ATTACK_PERIOD)
  inst.components.combat:SetRange(TUNING.FLUP_JUMPATTACK_RANGE, TUNING.FLUP_HIT_RANGE)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable("flup")
  inst:AddComponent("knownlocations")
  inst:AddComponent("inspectable")

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetSleepTest(sleeptestfn)

  inst:AddTag("flup")
  inst:AddTag("monster")
  inst:AddTag("hostile")

  inst:DoTaskInTime(1*FRAMES, function() inst.components.knownlocations:RememberLocation("home", inst:GetPosition(), true) end)

  MakeTinyFreezableCharacter(inst)
  MakeSmallBurnable(inst)

  return inst
end

return Prefab("flup", fn, assets, prefabs)
%%+%%scripts/prefabs/flupspawner.lua%%-%%local assets = {}
local prefabs = {"flup"}

local function spawntestfn(inst, ground, x, y, z)
	--crude copy from watervisuals.lua
	for i = -1, 1, 1 do
		if not IsOnWater(x - 1, y, z + i, true) or not IsOnWater(x + 1, y, z + i, true) then
			return false
		end
	end
	for i = -2, 0, 1 do
		if not IsOnWater(x + i, y, z -1, true) or not IsOnWater(x + i, y, z + 1, true) then
			return false
		end
	end

	return true
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("areaspawner")
  inst.components.areaspawner:SetValidTileType(GROUND.TIDALMARSH)
  inst.components.areaspawner:SetPrefab("flup")
  inst.components.areaspawner:SetDensityInRange(40, 5)
  inst.components.areaspawner:SetMinimumSpacing(10)
  inst.components.areaspawner:SetSpawnTestFn(spawntestfn)
  inst.components.areaspawner:SetRandomTimes(TUNING.TOTAL_DAY_TIME * 3, TUNING.TOTAL_DAY_TIME)
  inst.components.areaspawner:Start()

  return inst
end

local function dense_fn()
  local inst = fn()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.components.areaspawner:SetDensityInRange(40, 10)

  return inst
end

local function sparse_fn()
  local inst = fn()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.components.areaspawner:SetDensityInRange(40, 2)

  return inst
end

return Prefab("flupspawner", fn, assets, prefabs),
Prefab("flupspawner_dense", dense_fn, assets, prefabs),
Prefab("flupspawner_sparse", sparse_fn, assets, prefabs)
%%+%%scripts/prefabs/grass_water.lua%%-%%local assets =
{
	Asset("ANIM", "anim/grass_inwater.zip"),
	Asset("ANIM", "anim/grassgreen_build.zip"),
}

local grasspart_assets =
{
    Asset("ANIM", "anim/grass.zip"),
    Asset("ANIM", "anim/grass1.zip"),
}

local prefabs =
{
    "cutgrass",
    "dug_grass",
    "disease_puff",
    "diseaseflies",
    "spoiled_food",
    "grassgekko",
    "grasspartfx",
}

local function SpawnDiseasePuff(inst)
    SpawnPrefab("disease_puff").Transform:SetPosition(inst.Transform:GetWorldPosition())
end

local function canmorph(inst)
    return inst.AnimState:IsCurrentAnimation("idle")
        and not (inst.components.diseaseable ~= nil and
                inst.components.diseaseable:IsDiseased())
end

local function triggernearbymorph(inst, quick, range)
    range = range or 1

    local x, y, z = inst.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x, y, z, range, { "renewable" }, { "INLIMBO" })
    local count = 0

    for i, v in ipairs(ents) do
        if v ~= inst and
            v.prefab == "grass" and
            v.components.timer ~= nil and
            not (v.components.timer:TimerExists("morphdelay") or
                v.components.timer:TimerExists("morphing") or
                v.components.timer:TimerExists("morphrelay")) then

            count = count + 1

            if canmorph(v) and math.random() < .75 then
                v.components.timer:StartTimer(
                    "morphing",
                    ((not quick or count > 3) and .75 + math.random() * 1.5) or
                    (.2 + math.random() * .2) * count
                )
            else
                v.components.timer:StartTimer("morphrelay", count * FRAMES)
            end
        end
    end

    if count <= 0 and range < 4 then
        triggernearbymorph(inst, quick, range * 2)
    end
end

local function dig_up(inst, worker)
    if inst.components.pickable ~= nil and inst.components.lootdropper ~= nil then
        local withered = inst.components.witherable ~= nil and inst.components.witherable:IsWithered()
        local diseased = inst.components.diseaseable ~= nil and inst.components.diseaseable:IsDiseased()

        if diseased then
            SpawnDiseasePuff(inst)
        elseif inst.components.diseaseable ~= nil and inst.components.diseaseable:IsBecomingDiseased() then
            SpawnDiseasePuff(inst)
            if worker ~= nil then
                worker:PushEvent("digdiseasing")
            end
        elseif not TheWorld.state.iswinter
            and worker ~= nil
            and worker:HasTag("player")
            and math.random() < TUNING.GRASSGEKKO_MORPH_CHANCE then
            triggernearbymorph(inst, true)
        end

        if inst.components.pickable:CanBePicked() then
            inst.components.lootdropper:SpawnLootPrefab(inst.components.pickable.product)
        end

        inst.components.lootdropper:SpawnLootPrefab(
            (withered or diseased) and
            "cutgrass" or
            "dug_grass"
        )
    end
    inst:Remove()
end

local function onregenfn(inst)
    inst.AnimState:PlayAnimation("grow")
    inst.AnimState:PushAnimation("idle", true)
	
	inst.Physics:SetCollides(true)
	inst.AnimState:SetLayer( LAYER_WORLD)
	inst.AnimState:SetSortOrder(0)
    MakeHauntablePlayAnim(inst, "rustle", nil, nil, nil, "idle", true)
end

local function makeemptyfn(inst)
    if not POPULATING and
        (   inst.components.witherable ~= nil and
            inst.components.witherable:IsWithered() or
            inst.AnimState:IsCurrentAnimation("idle_dead")
        ) then
        inst.AnimState:PlayAnimation("dead_to_empty")
        inst.AnimState:PushAnimation("picked", true)
    else
        inst.AnimState:PlayAnimation("picked", true)
	end

	inst.Physics:SetCollides(false)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )
	inst:RemoveComponent("hauntable")
end

local function makebarrenfn(inst, wasempty)
    if not POPULATING and
        (   inst.components.witherable ~= nil and
            inst.components.witherable:IsWithered()
        ) then
        inst.AnimState:PlayAnimation(wasempty and "empty_to_dead" or "full_to_dead")
        inst.AnimState:PushAnimation("idle_dead", true)
    else
        inst.AnimState:PlayAnimation("idle_dead", true)
    end

	inst.Physics:SetCollides(false)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )
	inst:RemoveComponent("hauntable")
end

local function onpickedfn(inst, picker)
    inst.SoundEmitter:PlaySound("dontstarve/wilson/pickup_reeds")
    inst.AnimState:PlayAnimation("picking")

    if inst.components.diseaseable ~= nil and inst.components.diseaseable:IsDiseased() then
        SpawnDiseasePuff(inst)
    elseif inst.components.diseaseable ~= nil and inst.components.diseaseable:IsBecomingDiseased() then
        SpawnDiseasePuff(inst)
        if picker ~= nil then
            picker:PushEvent("pickdiseasing")
        end
    elseif not TheWorld.state.iswinter
        and picker ~= nil
        and picker:HasTag("player")
        and math.random() < TUNING.GRASSGEKKO_MORPH_CHANCE then
        triggernearbymorph(inst, true)
    end

    if inst.components.pickable:IsBarren() then
        inst.AnimState:PushAnimation("empty_to_dead")
        inst.AnimState:PushAnimation("idle_dead", true)
    else
        inst.AnimState:PushAnimation("picked", true)
    end
	
	inst.Physics:SetCollides(false)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )
	inst:RemoveComponent("hauntable")
end

local function SetDiseaseBuild(inst)
    -- inst.AnimState:SetBuild("grass_diseased_build")
end

local function ondiseasedfn(inst)
    inst.components.pickable:ChangeProduct("spoiled_food")
    if POPULATING then
        SetDiseaseBuild(inst)
    elseif inst.components.pickable:CanBePicked() then
        inst.AnimState:PlayAnimation("rustle")
        inst.AnimState:PushAnimation("idle", true)
        SpawnDiseasePuff(inst)
        inst:DoTaskInTime(4 * FRAMES, SetDiseaseBuild)
    else
        if inst.components.witherable ~= nil and
            inst.components.witherable:IsWithered() or
            inst.components.pickable:IsBarren() then
            inst.AnimState:PlayAnimation("rustle_dead")
            inst.AnimState:PushAnimation("idle_dead", true)
        else
            inst.AnimState:PlayAnimation("rustle_empty")
            inst.AnimState:PushAnimation("picked", true)
        end
        inst:DoTaskInTime(2 * FRAMES, SpawnDiseasePuff)
        inst:DoTaskInTime(6 * FRAMES, SetDiseaseBuild)
    end
end

local function makediseaseable(inst)
    if inst.components.diseaseable == nil then
        inst:AddComponent("diseaseable")
        inst.components.diseaseable:SetDiseasedFn(ondiseasedfn)
    end
end

local function onmorphtimer(inst, data)
    local morphing = data.name == "morphing"
    if morphing or data.name == "morphrelay" then
        if morphing and canmorph(inst) then
            local x, y, z = inst.Transform:GetWorldPosition()
            if #TheSim:FindEntities(x, y, z, TUNING.GRASSGEKKO_DENSITY_RANGE, { "grassgekko" }) < TUNING.GRASSGEKKO_MAX_DENSITY then
                local gekko = SpawnPrefab("grassgekko")
                gekko.Transform:SetPosition(x, y, z)
                gekko.sg:GoToState("emerge")

                local partfx = SpawnPrefab("grasspartfx")
                partfx.Transform:SetPosition(x, y, z)
                partfx.Transform:SetRotation(inst.Transform:GetRotation())
                partfx.AnimState:SetMultColour(inst.AnimState:GetMultColour())

                triggernearbymorph(inst, false)
                inst:Remove()
                return
            end
        end
        inst.components.timer:StartTimer("morphdelay", GetRandomWithVariance(TUNING.GRASSGEKKO_MORPH_DELAY, TUNING.GRASSGEKKO_MORPH_DELAY_VARIANCE))
        triggernearbymorph(inst, false)
    end
end

local function makemorphable(inst)
    if inst.components.timer == nil then
        inst:AddComponent("timer")
        inst:ListenForEvent("timerdone", onmorphtimer)
    end
end

local function ontransplantfn(inst)
    inst.components.pickable:MakeBarren()
    makediseaseable(inst)
    makemorphable(inst)
    inst.components.diseaseable:RestartNearbySpread()
    inst.components.timer:StartTimer("morphdelay", GetRandomWithVariance(TUNING.GRASSGEKKO_MORPH_DELAY, TUNING.GRASSGEKKO_MORPH_DELAY_VARIANCE))
end

local function OnPreLoad(inst, data)
    if data ~= nil then
        if data.pickable ~= nil and data.pickable.transplanted then
            makediseaseable(inst)
            makemorphable(inst)
        else
            if data.diseaseable ~= nil then
                makediseaseable(inst)
            end
            if data.timer ~= nil then
                makemorphable(inst)
            end
        end
    end
end

local function grass(name, stage)
    local function fn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddSoundEmitter()
        inst.entity:AddMiniMapEntity()
        inst.entity:AddNetwork()
		
		MakeObstaclePhysics(inst, .25)

        inst.MiniMapEntity:SetIcon("grass_tropical.tex")

		inst.AnimState:SetBank("grass_inwater")
		inst.AnimState:SetBuild("grass_inwater")
        inst.AnimState:PlayAnimation("idle", true)

        -- inst:AddTag("renewable")

        --witherable (from witherable component) added to pristine state for optimization
        inst:AddTag("witherable")
		inst:AddTag("plant")


        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst.AnimState:SetTime(math.random() * 2)
        local color = 0.75 + math.random() * 0.25
        inst.AnimState:SetMultColour(color, color, color, 1)

        inst:AddComponent("pickable")
        inst.components.pickable.picksound = "dontstarve/wilson/pickup_reeds"

        inst.components.pickable:SetUp("cutgrass", TUNING.GRASS_REGROW_TIME)
        inst.components.pickable.onregenfn = onregenfn
        inst.components.pickable.onpickedfn = onpickedfn
        inst.components.pickable.makeemptyfn = makeemptyfn
        inst.components.pickable.makebarrenfn = makebarrenfn
        inst.components.pickable.max_cycles = 20
        inst.components.pickable.cycles_left = 20
        inst.components.pickable.ontransplantfn = ontransplantfn

        if stage == 1 then
            inst.components.pickable:MakeBarren()
        end

        inst:AddComponent("lootdropper")
        inst:AddComponent("inspectable")
		
        ---------------------

        -- MakeMediumBurnable(inst)
        -- MakeSmallPropagator(inst)
        MakeNoGrowInWinter(inst)
        MakeHauntablePlayAnim(inst, "rustle", nil, nil, nil, "idle", true)
		
		MakePickableBlowInWindGust(inst, TUNING.GRASS_WINDBLOWN_SPEED, TUNING.GRASS_WINDBLOWN_FALL_CHANCE)
       
	   ---------------------

        inst.OnPreLoad = OnPreLoad
        -- inst.MakeDiseaseable = makediseaseable

        return inst
    end

    return Prefab(name, fn, assets, prefabs)
end

return grass("grass_water", 0),
    grass("depleted_grass_water", 1)
%%+%%scripts/prefabs/hail.lua%%-%%local TEXTURE = resolvefilepath("images/fx/hail.tex")

local SHADER = "shaders/vfx_particle.ksh"

local COLOUR_ENVELOPE_NAME = "hailcolourenvelope"
local SCALE_ENVELOPE_NAME = "hailscaleenvelope"

local assets =
{
    Asset("IMAGE", TEXTURE),
    Asset("SHADER", SHADER),
}

local prefabs =
{
    "haildrop",
    "hail_ice",
}

--------------------------------------------------------------------------

local function IntColour(r, g, b, a)
    return { r / 255, g / 255, b / 255, a / 255 }
end

local function InitEnvelope()
    EnvelopeManager:AddColourEnvelope(
        COLOUR_ENVELOPE_NAME,
        {   { 0, IntColour(255, 255, 255, 255) },
            { 1, IntColour(255, 255, 255, 255) },
        }
    )

    local max_scale = 0.4
    EnvelopeManager:AddVector2Envelope(
        SCALE_ENVELOPE_NAME,
        {
            { 0, { max_scale, max_scale } },
            { 1, { max_scale, max_scale } },
        }
    )

    InitEnvelope = nil
    IntColour = nil
end

--------------------------------------------------------------------------

local MAX_LIFETIME = 2
local MIN_LIFETIME = 2

--------------------------------------------------------------------------

local function fn()
    local inst = CreateEntity()

    inst:AddTag("FX")
    --[[Non-networked entity]]
    inst.entity:SetCanSleep(false)
    inst.persists = false

    inst.entity:AddTransform()

    if InitEnvelope ~= nil then
        InitEnvelope()
    end

    local effect = inst.entity:AddVFXEffect()
    effect:InitEmitters(1)
    effect:SetRenderResources(0, TEXTURE, SHADER)
    effect:SetRotationStatus(0, true)
    effect:SetMaxNumParticles(0, 4800)
    effect:SetMaxLifetime(0, MAX_LIFETIME)
    effect:SetColourEnvelope(0, COLOUR_ENVELOPE_NAME)
    effect:SetScaleEnvelope(0, SCALE_ENVELOPE_NAME)
    effect:SetBlendMode(0, BLENDMODE.Premultiplied)
    effect:SetSortOrder(0, 3)
    effect:SetDragCoefficient(0, .2)
    effect:EnableDepthTest(0, true)

    -----------------------------------------------------

    local rng = math.random
    local tick_time = TheSim:GetTickTime()

    local desired_particles_per_second = 0--1000
    local desired_splashes_per_second = 0--100

    inst.particles_per_tick = desired_particles_per_second * tick_time
    inst.splashes_per_tick = desired_splashes_per_second * tick_time

    inst.num_particles_to_emit = inst.particles_per_tick
    inst.num_splashes_to_emit = 0

    local bx, by, bz = 0, 20, 0
    local emitter_shape = CreateBoxEmitter(bx, by, bz, bx + 20, by, bz + 20)

    local angle = 0
    local dx = math.cos(angle * PI / 180)
    effect:SetAcceleration(0, dx, -9.80, 1)

    local function emit_fn()
        local vy = -2 - 8 * UnitRand()
        local vz = 0
        local vx = dx
        local lifetime = MIN_LIFETIME + (MAX_LIFETIME - MIN_LIFETIME) * UnitRand()
        local px, py, pz = emitter_shape()

        effect:AddRotatingParticle(
            0,                  -- the only emitter
            lifetime,           -- lifetime
            px, py, pz,         -- position
            vx, 0.125*vy, vz,         -- velocity
            angle, 0            -- angle, angular_velocity
        )
    end

    local raindrop_offset = CreateDiscEmitter(20)

    local map = TheWorld.Map

    local function updateFunc(fastforward)
        while inst.num_particles_to_emit > 0 do
            emit_fn()
            inst.num_particles_to_emit = inst.num_particles_to_emit - 1
        end

        while inst.num_splashes_to_emit > 0 do
            local x, y, z = inst.Transform:GetWorldPosition()
            local dx, dz = raindrop_offset()

            x = x + dx
            z = z + dz

            if map:IsPassableAtPoint(x, y, z) then
                local raindrop = SpawnPrefab("haildrop")
                raindrop.Transform:SetPosition(x, y, z)

                if fastforward ~= nil then
                    raindrop.AnimState:FastForward(fastforward)
                end

            end
            inst.num_splashes_to_emit = inst.num_splashes_to_emit - 1
        end

        inst.num_particles_to_emit = inst.num_particles_to_emit + inst.particles_per_tick
        inst.num_splashes_to_emit = inst.num_splashes_to_emit + inst.splashes_per_tick
    end

    EmitterManager:AddEmitter(inst, nil, updateFunc)

    function inst:PostInit()
        local dt = 1 / 30
        local t = MAX_LIFETIME
        while t > 0 do
            t = t - dt
            updateFunc(t)
            effect:FastForward(0, dt)
        end
    end

    return inst
end

return Prefab("hail", fn, assets, prefabs)
%%+%%scripts/prefabs/haildrop.lua%%-%%local assets =
{
	Asset( "ANIM", "anim/splash_hail.zip" ),
	Asset( "ANIM", "anim/hail.zip" ),
}

local function fn()
	local inst = CreateEntity()

    inst:AddTag("FX")
    --[[Non-networked entity]]
    inst.entity:SetCanSleep(false)
    inst.persists = false

	inst.entity:AddTransform()
    inst.entity:AddAnimState()

    inst.AnimState:SetBuild("splash_hail")
    inst.AnimState:SetBank("splash_hail")
	inst.AnimState:PlayAnimation("idle")
	
	inst:ListenForEvent("animover", inst.Remove)

    return inst
end

return Prefab("haildrop", fn, assets)%%+%%scripts/prefabs/hail_ice.lua%%-%%local assets =
{
    Asset("ANIM", "anim/ice_hail.zip"),
}

local names = { "f1","f2","f3" }

local function onsave(inst, data)
    data.anim = inst.animname
end

local function onload(inst, data)
    if data and data.anim then
        inst.animname = data.anim
        inst.AnimState:PlayAnimation(inst.animname)
    end
end

local function onperish(inst)
    local owner = inst.components.inventoryitem.owner
    if owner ~= nil then
        local stacksize = inst.components.stackable:StackSize()
        if owner.components.moisture ~= nil then
            owner.components.moisture:DoDelta(2 * stacksize)
        elseif owner.components.inventoryitem ~= nil then
            owner.components.inventoryitem:AddMoisture(4 * stacksize)
        end
        inst:Remove()
    else
        inst.components.inventoryitem.canbepickedup = false
        inst.AnimState:PlayAnimation("melt")
        inst:ListenForEvent("animover", inst.Remove)
    end
end

local function onfiremelt(inst)
    inst.components.perishable.frozenfiremult = true
end

local function onstopfiremelt(inst)
    inst.components.perishable.frozenfiremult = false
end

--TODO imrpove this function
local function playfallsound(inst)
    local ice_fall_sound =
    {
        [GROUND.BEACH] = "ia/common/ice_fall/beach",
        [GROUND.JUNGLE] = "ia/common/ice_fall/jungle",
        [GROUND.TIDALMARSH] = "ia/common/ice_fall/marsh",
        [GROUND.MAGMAFIELD] = "ia/common/ice_fall/rocks",
        [GROUND.MEADOW] = "ia/common/ice_fall/grass",
        [GROUND.VOLCANO] = "ia/common/ice_fall/rocks",
        [GROUND.ASH] = "ia/common/ice_fall/rocks",
    }
	
    local tile = inst:GetCurrentTileType()
    if ice_fall_sound[tile] ~= nil then
        inst.SoundEmitter:PlaySound(ice_fall_sound[tile])
    end
end

local function onhitground_hail(inst, onwater)
    if not onwater then
        playfallsound(inst)
    else
		inst.persists = false --let the default behaviour handle this
        -- inst:Remove()
    end
end

local function onlanded_hail(inst)
    if IsOnWater(inst) then
		inst.persists = false --let the default behaviour handle this --TODO verify this works in R08_ROT_TURNOFTIDES
        -- inst:Remove()
    else
        playfallsound(inst)
    end
end

local function onlanded_haildrop(inst)
    if not IsOnWater(inst) then --TODO should be a land check
        if math.random() < TUNING.HURRICANE_HAIL_BREAK_CHANCE then
            inst.components.inventoryitem.canbepickedup = false
            inst.AnimState:PlayAnimation("break")
            inst:ListenForEvent("animover", function(inst) inst:Remove() end)
        else
			inst.components.inventoryitem.canbepickedup = true
			inst.persists = true
            -- inst.components.blowinwind:Start()
            inst:RemoveEventCallback("on_landed", onlanded_haildrop)
            -- ChangeToInventoryPhysics(inst)
            --inst.Physics:SetCollisionCallback(nil)
        end
    end
end

local function hail_startfalling(inst, x, y, z)
    -- inst.Physics:SetCollisionGroup(COLLISION.CHARACTERS)
    -- inst.Physics:ClearCollisionMask()
    -- inst.Physics:CollidesWith(COLLISION.GROUND)
    -- inst.Physics:CollidesWith(COLLISION.OBSTACLES)
    -- inst.Physics:CollidesWith(COLLISION.CHARACTERS)
	-- inst.Physics:CollidesWith(COLLISION.WAVES)
    --inst.Physics:SetCollisionCallback(function(inst, other)
    --  if other and other.components.health and other.Physics:GetCollisionGroup() == COLLISION.CHARACTERS then
    --      other.components.health:DoDelta(-TUNING.HURRICANE_HAIL_DAMAGE, false, "hail")
    --  end
    --end)
    inst.Physics:Teleport(x, 35, z)
	inst:ListenForEvent("on_landed", onlanded_haildrop)
    -- inst.components.blowinwind:Stop()
	inst.components.inventoryitem:SetLanded(false, true)
	inst.components.inventoryitem.canbepickedup = false
	inst.persists = false
end


local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("ice_hail")
    inst.AnimState:SetBuild("ice_hail")

    inst:AddTag("frozen")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)

    inst.animname = names[math.random(#names)]
    inst.AnimState:PlayAnimation(inst.animname)

    inst:AddComponent("edible")
    inst.components.edible.foodtype = "ELEMENTAL"
    inst.components.edible.healthvalue = 0
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY/8
    inst.components.edible.degrades_with_spoilage = false
    inst.components.edible.temperaturedelta = TUNING.COLD_FOOD_BONUS_TEMP
    inst.components.edible.temperatureduration = TUNING.FOOD_TEMP_BRIEF * 1.5

    inst:AddComponent("smotherer")

    inst:ListenForEvent("firemelt", onfiremelt)
    inst:ListenForEvent("stopfiremelt", onstopfiremelt)

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_ONE_DAY)
    inst.components.perishable:StartPerishing()
    inst.components.perishable:SetOnPerishFn(onperish)

    inst:AddComponent("tradable")

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnPickupFn(onstopfiremelt)
	inst.components.inventoryitem:SetSinks(true)
	inst.nosunkenprefab = true

    inst:AddComponent("repairer")
    inst.components.repairer.repairmaterial = MATERIALS.ICE
    inst.components.repairer.perishrepairpercent = .05

    -- inst:AddComponent("bait")
    -- inst:AddTag("molebait")

	inst:ListenForEvent("on_landed", onlanded_hail)

    inst.StartFalling = hail_startfalling
	
    inst.OnSave = onsave 
    inst.OnLoad = onload 

    MakeHauntableLaunchAndSmash(inst)

    return inst
end

return Prefab( "hail_ice", fn, assets)%%+%%scripts/prefabs/harpoon.lua%%-%%local assets =
{
	Asset("ANIM", "anim/swap_harpoon.zip"),
	Asset("ANIM", "anim/harpoon.zip"),
}

local prefabs = 
{
	"impact",
}

local function onfinished(inst)
	inst:Remove()
end

local function onequip(inst, owner) 
	owner.AnimState:OverrideSymbol("swap_object", "swap_harpoon", "swap_object")
	owner.AnimState:Show("ARM_carry") 
	owner.AnimState:Hide("ARM_normal") 
end

local function onunequip(inst, owner) 
	owner.AnimState:ClearOverrideSymbol("swap_object")
	owner.AnimState:Hide("ARM_carry") 
	owner.AnimState:Show("ARM_normal") 
end

local function onhit(inst, attacker, target)
	inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default)
	inst.AnimState:PlayAnimation("idle")
	
	local impactfx = SpawnPrefab("impact")
	if impactfx then
		local follower = impactfx.entity:AddFollower()
		follower:FollowSymbol(target.GUID, target.components.combat.hiteffectsymbol, 0, 0, 0 )
        if attacker then
            impactfx:FacePoint(attacker.Transform:GetWorldPosition())
        end
	end
end

local function onthrown(inst, data)
	inst.AnimState:PlayAnimation("thrown")
	inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
end


local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)
	
	inst.AnimState:SetBank("harpoon")
	inst.AnimState:SetBuild("harpoon")
	inst.AnimState:PlayAnimation("idle")
	
	inst:AddTag("thrown")
	inst:AddTag("projectile")
	
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()
	
    if not TheWorld.ismastersim then
        return inst
    end

	MakeInvItemIA(inst)
	inst:AddComponent("inspectable")

	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.HARPOON_USES)
	inst.components.finiteuses:SetUses(TUNING.HARPOON_USES)
	inst.components.finiteuses:SetOnFinished(onfinished)

	inst:AddComponent("equippable")
	inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)

	inst:AddComponent("weapon")
	inst.components.weapon:SetDamage(TUNING.HARPOON_DAMAGE)
	inst.components.weapon:SetRange(TUNING.HARPOON_RANGE, TUNING.HARPOON_RANGE+2)
	
	inst:AddComponent("projectile")
	inst.components.projectile:SetSpeed(TUNING.HARPOON_SPEED)
	inst.components.projectile:SetOnHitFn(onhit)
	-- inst.components.projectile:SetOnThrownFn(onthrown)
	inst:ListenForEvent("onthrown", onthrown)

	return inst
end

return Prefab("harpoon", fn, assets, prefabs)
%%+%%scripts/prefabs/ia_armor.lua%%-%%
local function onequip(inst, owner) 
  owner.AnimState:OverrideSymbol("swap_body", inst.overridesymbol, "swap_body")
  if inst.OnBlocked then
	inst:ListenForEvent("blocked", inst.OnBlocked, owner)
  end
  if inst.components.fueled then
	inst.components.fueled:StartConsuming()
  end
end

local function onunequip(inst, owner) 
  owner.AnimState:ClearOverrideSymbol("swap_body")
  if inst.OnBlocked then
	inst:RemoveEventCallback("blocked", inst.OnBlocked, owner)
  end
  if inst.components.fueled then
	inst.components.fueled:StopConsuming()
  end
end

local function commonfn()
  local inst = CreateEntity()

  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()
  MakeInventoryPhysics(inst)

  --inst:AddTag("wood")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")
	
  return inst
end

local function masterfn(inst)

	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)

	inst:AddComponent("equippable")
	inst.components.equippable.equipslot = EQUIPSLOTS.BODY

	inst.components.equippable:SetOnEquip( onequip )
	inst.components.equippable:SetOnUnequip( onunequip )
end

-------------------------------------------------------------

local seashell_assets = {
	Asset("ANIM", "anim/armor_seashell.zip"),
}

local function seashell_OnBlocked(owner) 
  owner.SoundEmitter:PlaySound("ia/common/armour/shell") 
end

local function seashell_fn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("armor_seashell")
	inst.AnimState:SetBuild("armor_seashell")
	inst.AnimState:PlayAnimation("anim")

	inst.foleysound = "ia/common/foley/seashell_suit"

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_seashell"

	inst.OnBlocked = seashell_OnBlocked
	
	inst:AddComponent("armor")
	inst.components.armor:InitCondition(TUNING.ARMORSEASHELL, TUNING.ARMORSEASHELL_ABSORPTION)

	inst.components.equippable.poisonblocker = true
	
	MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
	MakeSmallPropagator(inst)

	--inst:AddComponent("fuel")
	--inst.components.fuel.fuelvalue = TUNING.LARGE_FUEL
	
	return inst
end

-------------------------------------------------------------

local limestone_assets = {
	Asset("ANIM", "anim/armor_limestone.zip"),
}

local function limestone_OnBlocked(owner) 
  owner.SoundEmitter:PlaySound("ia/common/armour/limestone") 
end

local function limestone_fn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("armor_limestone")
	inst.AnimState:SetBuild("armor_limestone")
	inst.AnimState:PlayAnimation("anim")

	inst.foleysound = "ia/common/foley/limestone_suit"

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_limestone"

	inst.OnBlocked = limestone_OnBlocked
	
	inst:AddComponent("armor")
    inst.components.armor:InitCondition(TUNING.ARMORLIMESTONE, TUNING.ARMORLIMESTONE_ABSORPTION)

    inst.components.equippable.dapperness = TUNING.DAPPERNESS_SMALL
    inst.components.equippable.walkspeedmult = TUNING.ARMORLIMESTONE_SPEED_MULT
	
	return inst
end

-------------------------------------------------------------

local obsidian_assets = {
	Asset("ANIM", "anim/armor_obsidian.zip"),
}

local function obsidian_OnBlocked(owner, data) 
    owner.SoundEmitter:PlaySound("ia/common/armour/obsidian")
	
    if data.attacker ~= nil
	and not (data.attacker.components.health ~= nil
		and data.attacker.components.health:IsDead())
	and (data.weapon == nil
		or ((data.weapon.components.weapon == nil or data.weapon.components.weapon.projectile == nil)
			and data.weapon.components.projectile == nil))
	and data.attacker.components.burnable ~= nil
	and not data.redirected
	and not data.attacker:HasTag("thorny")
	and data.stimuli ~= "thorns" then
		
        data.attacker.components.burnable:Ignite()
    end
end

local function obsidian_onequip(inst, owner) 
    owner.AnimState:OverrideSymbol("swap_body", "armor_obsidian", "swap_body")

    -- inst:ListenForEvent("blocked", obsidian_OnBlocked, owner)
    inst:ListenForEvent("attacked", obsidian_OnBlocked, owner)

    if owner.components.health then
        owner.components.health.fire_damage_scale = owner.components.health.fire_damage_scale - TUNING.ARMORDRAGONFLY_FIRE_RESIST
    end
end

local function obsidian_onunequip(inst, owner) 
    owner.AnimState:ClearOverrideSymbol("swap_body")

    -- inst:RemoveEventCallback("blocked", obsidian_OnBlocked, owner)
    inst:RemoveEventCallback("attacked", obsidian_OnBlocked, owner)
    
    if owner.components.health then
        owner.components.health.fire_damage_scale = owner.components.health.fire_damage_scale + TUNING.ARMORDRAGONFLY_FIRE_RESIST
    end
end

local function sizzlesound(inst)
	inst.SoundEmitter:PlaySound("ia/common/obsidian_wetsizzles")
end

local function obsidian_fn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("armor_obsidian")
	inst.AnimState:SetBuild("armor_obsidian")
	inst.AnimState:PlayAnimation("anim")

	inst.foleysound = "ia/common/foley/obsidian_armour"

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_obsidian"
	
	inst:AddComponent("armor")
    inst.components.armor:InitCondition(TUNING.ARMORDRAGONFLY, TUNING.ARMORDRAGONFLY_ABSORPTION)
	
    inst.components.equippable:SetOnEquip( obsidian_onequip )
    inst.components.equippable:SetOnUnequip( obsidian_onunequip )
	
	inst:ListenForEvent("floater_startfloating", sizzlesound)
	
    inst:AddComponent("waterproofer")
    inst.components.waterproofer:SetEffectiveness(0)
    inst.no_wet_prefix = true
	
	return inst
end

-------------------------------------------------------------

local cactus_assets = {
	Asset("ANIM", "anim/armor_cactus.zip"),
}

local function cactus_OnBlocked(owner, data) 
	
    if data.attacker ~= nil
	and not (data.attacker.components.health ~= nil
		and data.attacker.components.health:IsDead())
	and (data.weapon == nil
		or ((data.weapon.components.weapon == nil or data.weapon.components.weapon.projectile == nil)
			and data.weapon.components.projectile == nil))
	and data.attacker.components.combat ~= nil
	and not data.redirected
	and not data.attacker:HasTag("thorny")
	and data.stimuli ~= "thorns" then
		
		owner.SoundEmitter:PlaySound("ia/common/armour/cactus")
		data.attacker.components.combat:GetAttacked(owner, TUNING.ARMORCACTUS_DMG, nil, "thorns")
    end
end

local function cactus_onequip(inst, owner) 
    owner.AnimState:OverrideSymbol("swap_body", "armor_cactus", "swap_body")
	owner:AddTag("armorcactus")

    inst:ListenForEvent("blocked", cactus_OnBlocked, owner)
    inst:ListenForEvent("attacked", cactus_OnBlocked, owner)
end

local function cactus_onunequip(inst, owner) 
    owner.AnimState:ClearOverrideSymbol("swap_body")
	owner:RemoveTag("armorcactus")

    inst:RemoveEventCallback("blocked", cactus_OnBlocked, owner)
    inst:RemoveEventCallback("attacked", cactus_OnBlocked, owner)
end

local function cactus_fn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("armor_cactus")
	inst.AnimState:SetBuild("armor_cactus")
	inst.AnimState:PlayAnimation("anim")

	inst.foleysound = "ia/common/foley/cactus_armour"

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_cactus"
	
	inst:AddComponent("armor")
	inst.components.armor:InitCondition(TUNING.ARMORCACTUS, TUNING.ARMORCACTUS_ABSORPTION)
	
    inst.components.equippable:SetOnEquip( cactus_onequip )
    inst.components.equippable:SetOnUnequip( cactus_onunequip )
	
	return inst
end

-------------------------------------------------------------

local snakeskin_assets = {
	Asset("ANIM", "anim/armor_snakeskin.zip"),
}

local function snakeskin_fn()
	local inst = commonfn()
	
    inst.AnimState:SetBank("armor_snakeskin")
    inst.AnimState:SetBuild("armor_snakeskin")
    inst.AnimState:PlayAnimation("anim")

    inst.foleysound = "ia/common/foley/snakeskin_jacket"
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_snakeskin"

    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:InitializeFuelLevel(TUNING.ARMOR_SNAKESKIN_PERISHTIME)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
    inst.components.fueled:SetDepletedFn(inst.Remove)
    
    inst:AddComponent("waterproofer")
    inst.components.waterproofer.effectiveness = TUNING.WATERPROOFNESS_LARGE
    inst.components.equippable.insulated = true
    
	inst:AddComponent("insulator")
    inst.components.insulator:SetInsulation(TUNING.INSULATION_SMALL)
	
	return inst
end

-------------------------------------------------------------

local lifejacket_assets = {
	Asset("ANIM", "anim/armor_lifejacket.zip"),
}

local function lifejacket_fn()
	local inst = commonfn()
	
    inst.AnimState:SetBank("armor_lifejacket")
    inst.AnimState:SetBuild("armor_lifejacket")
    inst.AnimState:PlayAnimation("anim")

    inst.foleysound = "ia/common/foley/life_jacket"
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_lifejacket"

    inst.components.inventoryitem.keepondeath = true
    inst.components.equippable.preventdrowning = true
    inst:ListenForEvent("preventdrowning", inst.Remove)

    MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
    MakeSmallPropagator(inst)
			
	return inst
end

-------------------------------------------------------------

local windbreaker_assets = {
	Asset("ANIM", "anim/armor_windbreaker.zip"),
}

local function windbreaker_fn()
	local inst = commonfn()
	
    inst.AnimState:SetBank("armor_windbreaker")
    inst.AnimState:SetBuild("armor_windbreaker")
    inst.AnimState:PlayAnimation("anim")

    inst.foleysound = "ia/common/foley/windbreaker"
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_windbreaker"
	
    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:InitializeFuelLevel(TUNING.WINDBREAKER_PERISHTIME)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
    inst.components.fueled:SetDepletedFn(inst.Remove)
    
    inst:AddComponent("waterproofer")
    inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_SMALL)

    inst:AddComponent("windproofer")
    inst.components.windproofer:SetEffectiveness(TUNING.WINDPROOFNESS_ABSOLUTE)

    inst.components.equippable.dapperness = TUNING.DAPPERNESS_SMALL
	
	return inst
end

-------------------------------------------------------------

local tarsuit_assets = {
	Asset("ANIM", "anim/armor_tarsuit.zip"),
}

local function tarsuit_fn()
	local inst = commonfn()
	
    inst.AnimState:SetBank("armor_tarsuit")
    inst.AnimState:SetBuild("armor_tarsuit")
    inst.AnimState:PlayAnimation("anim")

    inst.foleysound = "ia/common/foley/blubber_suit"
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_tarsuit"

    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:InitializeFuelLevel(TUNING.TARSUIT_PERISHTIME)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
    inst.components.fueled:SetDepletedFn(inst.Remove)
    
    inst:AddComponent("waterproofer")
    inst.components.waterproofer.effectiveness = TUNING.WATERPROOFNESS_ABSOLUTE
    inst.components.equippable.insulated = true
	
	return inst
end

-------------------------------------------------------------

local blubber_assets = {
	Asset("ANIM", "anim/armor_blubbersuit.zip"),
}

local function blubber_fn()
	local inst = commonfn()
	
    inst.AnimState:SetBank("armor_blubbersuit")
    inst.AnimState:SetBuild("armor_blubbersuit")
    inst.AnimState:PlayAnimation("anim")

    inst.foleysound = "ia/common/foley/blubber_suit"
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.overridesymbol = "armor_blubbersuit"

    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:InitializeFuelLevel(TUNING.BLUBBERSUIT_PERISHTIME)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
    inst.components.fueled:SetDepletedFn(inst.Remove)
    
    inst:AddComponent("waterproofer")
    inst.components.waterproofer.effectiveness = TUNING.WATERPROOFNESS_ABSOLUTE
    -- inst.components.equippable.insulated = true --no lightning resistance
	
	inst:AddComponent("insulator")
    inst.components.insulator:SetInsulation(TUNING.INSULATION_LARGE)
	
	return inst
end

-------------------------------------------------------------

return Prefab( "armorseashell", seashell_fn, seashell_assets),
Prefab( "armorlimestone", limestone_fn, limestone_assets),
Prefab( "armorobsidian", obsidian_fn, obsidian_assets),
Prefab( "armorcactus", cactus_fn, cactus_assets),
Prefab( "armor_snakeskin", snakeskin_fn, snakeskin_assets),
Prefab( "armor_lifejacket", lifejacket_fn, lifejacket_assets),
Prefab( "armor_windbreaker", windbreaker_fn, windbreaker_assets),
Prefab( "tarsuit", tarsuit_fn, tarsuit_assets),
Prefab( "blubbersuit", blubber_fn, blubber_assets) 
%%+%%scripts/prefabs/ia_birds.lua%%-%%local brain = require "brains/birdbrain"

local function onTalkParrot(inst)
	inst.SoundEmitter:PlaySound("ia/creatures/parrot/chirp", "talk") 
end
local function doneTalkParrot(inst)
	inst.SoundEmitter:KillSound("talk")
end
local function updateWaterSeagull(inst)
	if IsOnWater(inst) then
		inst.AnimState:SetBank("seagull_water")
	else
		inst.AnimState:SetBank("seagull")
	end
end
local function updateWaterCormorant(inst)
	if IsOnWater(inst) then
		inst.AnimState:SetBank("cormorant_water")
	else
		inst.AnimState:SetBank("seagull")
	end
end

local function ShouldSleep(inst)
    return DefaultSleepTest(inst) and not inst.sg:HasStateTag("flight")
end

local function OnAttacked(inst, data)
    local x, y, z = inst.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x, y, z, 30, { "bird" })
    local num_friends = 0
    local maxnum = 5
    for k, v in pairs(ents) do
        if v ~= inst then
            v:PushEvent("gohome")
            num_friends = num_friends + 1
        end

        if num_friends > maxnum then
            return
        end
    end
end

local function OnTrapped(inst, data)
    if data and data.trapper and data.trapper.settrapsymbols then
        data.trapper.settrapsymbols(inst.trappedbuild)
    end
end

local function OnPutInInventory(inst)
    --Otherwise sleeper won't work if we're in a busy state
    inst.sg:GoToState("idle")
end

local function OnDropped(inst)
	if IsOnWater(inst) then
		inst.sg:GoToState("flyaway")
	else
		if inst:HasTag("seagull") or inst:HasTag("cormorant") then
			inst.AnimState:SetBank("seagull")
		end
		inst.sg:GoToState("stunned")
	end
end

local function ChooseItem()
    local mercy_items =
    {
        "flint",
        "flint",
        "flint",
        "twigs",
        "twigs",
        "cutgrass",
    }
    return mercy_items[math.random(#mercy_items)]
end

local function ChooseSeeds()
    -- return not TheWorld.state.iswinter and "seeds" or nil
    return "seeds"
end

local function SpawnPrefabChooser(inst)
    if inst.prefab == "parrot_pirate" then
        return "dubloon"
    elseif inst.prefab == "cormorant" then
        return --loot already spawned on landing
    end

    if TheWorld.state.cycles <= 3 then
        -- The item drop is for drop-in players, players from the start of the game have to forage like normal
        return ChooseSeeds()
    end

    local x, y, z = inst.Transform:GetWorldPosition()
    local players = FindPlayersInRange(x, y, z, 20, true)

    -- Give item if only fresh players are nearby
    local oldestplayer = -1
    for i, player in ipairs(players) do
        if player.components.age ~= nil then
            local playerage = player.components.age:GetAgeInDays()
            if playerage >= 3 then
                return ChooseSeeds()
            elseif playerage > oldestplayer then
                oldestplayer = playerage
            end
        end
    end

    -- Lower chance for older players to get item
    return oldestplayer >= 0
        and math.random() < .35 - oldestplayer * .1
        and ChooseItem()
        or ChooseSeeds()
end

local function EatCormorantLoot(inst, bait)
	if bait and not inst.bufferedaction then
		inst.bufferedaction = BufferedAction(inst, bait, ACTIONS.EAT)
	end
end
local function SpawnCormorantLoot(inst)
	if not inst.bufferedaction and IsOnWater(inst)
	and math.random() <= TUNING.CROW_LEAVINGS_CHANCE then
		inst.components.periodicspawner:TrySpawn("roe")
	end
end
local function ScheduleCormorantLoot(inst)
	local pos = inst:GetPosition()
	if pos.y > 1 then
		local vx, vy, vz = inst.Physics:GetMotorVel()
		inst:DoTaskInTime(pos.y / math.abs(vy) + .1, SpawnCormorantLoot)
	end
end

--------------------------------------------------------------------------

local function makebird(name, feathername, soundbank, bank, extra_assets, commonpostfn, masterpostfn)
    local featherpostfix = feathername or name

    local assets =
    {
        Asset("ANIM", "anim/" .. (bank or "crow") .. ".zip"),
        Asset("ANIM", "anim/".. name .."_build.zip"),
        Asset("SOUND", "sound/birds.fsb"),
    }

    if extra_assets ~= nil then
        for i, v in ipairs(extra_assets) do
            table.insert(assets, Asset(v.type, v.asset))
        end
    end

    local prefabs =
    {
        "seeds",
        "smallmeat",
        "cookedsmallmeat",
        "feather_"..featherpostfix,

        --mercy items
        "flint",
        "twigs",
        "cutgrass",
    }

    local function fn()
        local inst = CreateEntity()

        --Core components
        inst.entity:AddTransform()
        inst.entity:AddPhysics()
        inst.entity:AddAnimState()
        inst.entity:AddDynamicShadow()
        inst.entity:AddSoundEmitter()
        inst.entity:AddNetwork()
        inst.entity:AddLightWatcher()

        --Initialize physics
        inst.Physics:SetCollisionGroup(COLLISION.CHARACTERS)
        inst.Physics:ClearCollisionMask()
        inst.Physics:CollidesWith(COLLISION.WORLD)
        inst.Physics:SetMass(1)
        inst.Physics:SetSphere(1)

        inst:AddTag("bird")
        inst:AddTag(name)
        inst:AddTag("smallcreature")
    	-- make birds amphibious so they can be dropped on water (they fly away anyways)
    	inst:AddTag("amphibious")

        --cookable (from cookable component) added to pristine state for optimization
        inst:AddTag("cookable")

        inst.Transform:SetTwoFaced()

        inst.AnimState:SetBank(bank or "crow")
        inst.AnimState:SetBuild(name.."_build")
        inst.AnimState:PlayAnimation("idle")

        inst.DynamicShadow:SetSize(1, .75)
        inst.DynamicShadow:Enable(false)

        MakeFeedableSmallLivestockPristine(inst)

        if commonpostfn ~= nil then commonpostfn(inst) end

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst.sounds =
        {
            takeoff = soundbank .. "takeoff",
            chirp = soundbank .. "chirp",
            flyin = "dontstarve/birds/flyin",
        }

        inst.trappedbuild = name.."_build"

        inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
        inst.components.locomotor:EnableGroundSpeedMultiplier(false)
        inst.components.locomotor:SetTriggersCreep(false)
        inst:SetStateGraph("SGbird")

        inst:AddComponent("lootdropper")
        inst.components.lootdropper:AddRandomLoot("feather_"..featherpostfix, 1)
        inst.components.lootdropper:AddRandomLoot("smallmeat", 1)
        inst.components.lootdropper.numrandomloot = 1

        inst:AddComponent("occupier")

        inst:AddComponent("eater")
        inst.components.eater:SetDiet({ FOODTYPE.SEEDS }, { FOODTYPE.SEEDS })

        inst:AddComponent("sleeper")
        inst.components.sleeper:SetSleepTest(ShouldSleep)

        MakeInvItemIA(inst, name)
        inst.components.inventoryitem.nobounce = true
        inst.components.inventoryitem.canbepickedup = false
        inst.components.inventoryitem.canbepickedupalive = true

        inst:AddComponent("cookable")
        inst.components.cookable.product = "cookedsmallmeat"

        inst:AddComponent("health")
        inst.components.health:SetMaxHealth(TUNING.BIRD_HEALTH)
        inst.components.health.murdersound = "dontstarve/wilson/hit_animal"

        inst:AddComponent("combat")
        inst.components.combat.hiteffectsymbol = "crow_body"

        inst:AddComponent("inspectable")

        if inst.prefab == "seagull" or inst.prefab == "cormorant" then
            inst.flyawaydistance = TUNING.WATERBIRD_SEE_THREAT_DISTANCE
        else
            inst.flyawaydistance = TUNING.BIRD_SEE_THREAT_DISTANCE
        end

        inst:SetBrain(brain)

        MakeSmallBurnableCharacter(inst, "crow_body")
        MakeTinyFreezableCharacter(inst, "crow_body")

        inst:AddComponent("hauntable")
        inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

        inst:AddComponent("periodicspawner")
        inst.components.periodicspawner:SetPrefab(SpawnPrefabChooser)
        inst.components.periodicspawner:SetDensityInRange(20, 2)
        inst.components.periodicspawner:SetMinimumSpacing(8)

        inst:ListenForEvent("ontrapped", OnTrapped)
        inst:ListenForEvent("attacked", OnAttacked)

        local birdspawner = TheWorld.components.birdspawner
        if birdspawner ~= nil then
            inst:ListenForEvent("onremove", birdspawner.StopTrackingFn)
            inst:ListenForEvent("enterlimbo", birdspawner.StopTrackingFn)
            birdspawner:StartTracking(inst)
        end

        MakeFeedableSmallLivestock(inst, TUNING.BIRD_PERISH_TIME, OnPutInInventory, OnDropped)

        if masterpostfn ~= nil then masterpostfn(inst) end

        return inst
    end

    return Prefab(name, fn, assets, prefabs)
end

local function parrot_pirate_common(inst)
    inst:AddComponent("talker")
    inst.components.talker.fontsize = 28
    inst.components.talker.font = TALKINGFONT
    inst.components.talker.colour = Vector3(.9, .4, .4, 1)
    inst:ListenForEvent("donetalking", doneTalkParrot)
    inst:ListenForEvent("ontalk", onTalkParrot)
end

local function parrot_pirate_master(inst)
    inst.components.inspectable.nameoverride = "PARROT"

    inst:AddComponent("named")
    inst.components.named.possiblenames = STRINGS.PARROTNAMES
    inst.components.named:PickNewName()
    inst.components.health.canmurder = false

    inst:AddComponent("sanityaura")
    inst.components.sanityaura.aura = TUNING.SANITYAURA_SMALL

    inst:AddComponent("talkingbird")
end

local function seagull_common(inst)
	inst:DoTaskInTime(0, updateWaterSeagull)
	inst:DoTaskInTime(1, updateWaterSeagull)
end

local function seagull_master(inst)
  inst.components.eater:SetOmnivore()
  
  inst:RemoveComponent("periodicspawner")
end

local function cormorant_common(inst)
	inst:DoTaskInTime(0, updateWaterCormorant)
	inst:DoTaskInTime(1, updateWaterCormorant)
	
	inst.Transform:SetScale(0.85, 0.85, 0.85)
end

local function cormorant_master(inst)
    inst.components.eater:SetOmnivore()
	inst.components.periodicspawner.onspawn = EatCormorantLoot

	inst:DoTaskInTime(0, ScheduleCormorantLoot)
end

return makebird("parrot", "robin", "ia/creatures/parrot/", nil),
makebird("parrot_pirate", "robin", "ia/creatures/parrot/", "parrot_pirate_bank", {{type = "ANIM", asset = "anim/parrot_pirate_bank.zip"}}, parrot_pirate_common, parrot_pirate_master),
makebird("toucan", "crow", "ia/creatures/toucan/"),
makebird("cormorant","crow", "ia/creatures/cormorant/", nil, {{type = "ANIM", asset = "anim/seagull.zip"}, {type = "ANIM", asset = "anim/cormorant_water.zip"}}, cormorant_common, cormorant_master),
makebird("seagull","robin_winter", "ia/creatures/seagull/", "seagull", {{type = "ANIM", asset = "anim/seagull_water.zip"}}, seagull_common, seagull_master)
%%+%%scripts/prefabs/ia_blowdart.lua%%-%%local assets =
{
  -- Asset("ANIM", "anim/blow_dart_sw.zip"),
  Asset("ANIM", "anim/blow_dart_ia.zip"),
  Asset("ANIM", "anim/swap_blowdart_flup.zip"),
}

local prefabs =
{
  "impact",
}

local function onequip(inst, owner)
  owner.AnimState:OverrideSymbol("swap_object", "swap_blowdart", "swap_blowdart")
  owner.AnimState:Show("ARM_carry")
  owner.AnimState:Hide("ARM_normal")
end

local function onunequip(inst, owner)
  owner.AnimState:ClearOverrideSymbol("swap_object")
  owner.AnimState:Hide("ARM_carry")
  owner.AnimState:Show("ARM_normal")
end

local function onhit(inst, attacker, target)
  local impactfx = SpawnPrefab("impact")
  if impactfx ~= nil then
    local follower = impactfx.entity:AddFollower()
    follower:FollowSymbol(target.GUID, target.components.combat.hiteffectsymbol, 0, 0, 0)
    if attacker ~= nil then
      impactfx:FacePoint(attacker.Transform:GetWorldPosition())
    end
  end
  inst:Remove()
end

local function onthrown(inst, data)
  inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
end

local function pristinefn(anim, tags, removephysicscolliders)
  local inst = CreateEntity()

  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("blow_dart_ia")
  inst.AnimState:SetBuild("blow_dart_ia")

  if anim ~= nil then
    inst.AnimState:PlayAnimation(anim)
  end

  inst:AddTag("blowdart")
  inst:AddTag("sharp")

  --projectile (from projectile component) added to pristine state for optimization
  inst:AddTag("projectile")

  if tags ~= nil then
    for i, v in ipairs(tags) do
      inst:AddTag(v)
    end
  end

  if removephysicscolliders then
    RemovePhysicsColliders(inst)
  end

    return inst
end

local function masterfn(inst)
  inst:AddComponent("weapon")
  inst.components.weapon:SetDamage(0)
  inst.components.weapon:SetRange(8, 10)

  inst:AddComponent("projectile")
  inst.components.projectile:SetSpeed(60)
  inst.components.projectile:SetOnHitFn(onhit)
  inst:ListenForEvent("onthrown", onthrown)
  -------

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)
  
  inst:AddComponent("stackable")

  inst:AddComponent("equippable")
  inst.components.equippable:SetOnEquip(onequip)
  inst.components.equippable:SetOnUnequip(onunequip)
  inst.components.equippable.equipstack = true

  MakeHauntableLaunch(inst)
end

local function poisonthrown(inst)
  inst.AnimState:PlayAnimation("dart_poison")
end

local function poisonattack(inst, attacker, target)
  target.SoundEmitter:PlaySound("dontstarve/wilson/blowdart_impact_sleep")
  if target.components.poisonable then
    target.components.poisonable:Poison()
  end
  if target.components.combat then
    target.components.combat:SuggestTarget(attacker)
  end
  target:PushEvent("attacked", {attacker = attacker, damage = 0, weapon = inst})
end

local function poison()
  local inst = pristinefn("idle_poison", {"poisondart"})

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_poison_water", "idle_poison")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	masterfn(inst)
  
  inst.components.weapon:SetOnAttack(poisonattack)
  inst.components.projectile:SetOnThrownFn(poisonthrown)

  return inst
end

local function flupequip(inst, owner)
  owner.AnimState:OverrideSymbol("swap_object", "swap_blowdart_flup", "swap_blowdart_flup")
  owner.AnimState:Show("ARM_carry")
  owner.AnimState:Hide("ARM_normal")
end

local function flupthrown(inst)
  inst.AnimState:PlayAnimation("dart_flup")
end

local function SetStunState(target)
	if target and target:IsValid() and target.sg and not target.sg:HasStateTag("busy") then
		target.sg:GoToState("stunned")
	end
end

local function flupattack(inst, attacker, target)
	if target and target:HasTag("bird") and target.sg and target.sg:HasState("stunned") then
		target:DoTaskInTime(.4, SetStunState)
	end
end

local function flup()
  local inst = pristinefn("idle_flup", {"flupdart"})

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_flup_water", "idle_flup")
	
	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	masterfn(inst)
  
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM
  inst.components.equippable:SetOnEquip(flupequip)
  inst.components.weapon:SetDamage(TUNING.FLUP_DART_DAMAGE)
  inst.components.projectile:SetOnThrownFn(flupthrown)
	inst.components.weapon:SetOnAttack(flupattack)
 
  return inst
end

-------------------------------------------------------------------------------
return Prefab( "blowdart_poison", poison, assets, prefabs),
Prefab( "blowdart_flup", flup, assets, prefabs)
%%+%%scripts/prefabs/ia_chests.lua%%-%%require "prefabutil"

local assets=
{
	Asset("ANIM", "anim/ui_thatchpack_1x4.zip"),

	Asset("ANIM", "anim/luggage.zip"),
	Asset("ANIM", "anim/octopus_chest.zip"),
	Asset("ANIM", "anim/kraken_chest.zip"),
	Asset("ANIM", "anim/water_chest.zip"),
}

local prefabs =
{
	"collapse_small",
}

local function onopen(inst) 
	if not inst:HasTag("burnt") then
		inst.AnimState:PlayAnimation("open")
		inst.AnimState:PushAnimation("opened", true)

		if inst.prefab == "luggagechest" then
			inst.SoundEmitter:PlaySound("ia/common/steamer_trunk/open")
		else
			inst.SoundEmitter:PlaySound("dontstarve/wilson/chest_open")
		end
	end
end

local function onclose(inst)
	if not inst:HasTag("burnt") then
		inst.AnimState:PlayAnimation("close")
		inst.AnimState:PushAnimation("closed", true)
		
		if inst.prefab == "luggagechest" then
			inst.SoundEmitter:PlaySound("ia/common/steamer_trunk/close")
		else
			inst.SoundEmitter:PlaySound("dontstarve/wilson/chest_close")
		end
	end
end

local function oncloseocto(inst)
	if not inst:HasTag("burnt") then
		inst.AnimState:PlayAnimation("close")
		inst.SoundEmitter:PlaySound("dontstarve/wilson/chest_close")

		if not inst.components.container:IsEmpty() then
			inst.AnimState:PushAnimation("closed", true)
			return
		else
		
			inst.AnimState:PushAnimation("sink", false)
			inst.components.container.canbeopened = false
			
			inst:DoTaskInTime(96*FRAMES, function (inst)
				inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_small")
			end)

			inst:ListenForEvent("animqueueover", function (inst)
				inst:Remove()
			end)
		end
	end
end 

local function onhammered(inst, worker)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
    inst.components.lootdropper:DropLoot()
    if inst.components.container ~= nil then
        inst.components.container:DropEverything()
    end
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood") --TODO water chests are rock afaik -M
    inst:Remove()
end

local function onhit(inst, worker)
	if not inst:HasTag("burnt") then
		inst.AnimState:PlayAnimation("hit")
		inst.AnimState:PushAnimation("closed", true)
		if inst.components.container ~= nil then 
			inst.components.container:DropEverything() 
			inst.components.container:Close()
		end
	end
end

local function onbuilt(inst)
	inst.AnimState:PlayAnimation("place")
	inst.AnimState:PushAnimation("closed", true)
    inst.SoundEmitter:PlaySound("dontstarve/common/chest_craft")
end

local function onsave(inst, data)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() or inst:HasTag("burnt") then
        data.burnt = true
    end
end

local joecounter = 1
local function onload(inst, data)
    if data ~= nil then
		if data.burnt and inst.components.burnable ~= nil then
			inst.components.burnable.onburnt(inst)
		end
		-- from the worldgen data
		if data.joeluggage then
			joecounter = joecounter%4
			inst:AddComponent("scenariorunner")
			inst.components.scenariorunner:SetScript("chest_luggage"..tostring(joecounter + 1))
			inst.components.scenariorunner:Run()
			joecounter = joecounter + 1
		end
    end
end


local function MakeChest(anim, override_widget, minimap, indestructible, flammable)
    return function()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddSoundEmitter()
        inst.entity:AddMiniMapEntity()
        inst.entity:AddNetwork()

		if minimap ~= false then
			inst.MiniMapEntity:SetIcon(anim ..".tex")
		end

        inst:AddTag("structure")
        inst:AddTag("chest")
		inst:AddTag("aquatic")

        inst.AnimState:SetBank(anim)
        inst.AnimState:SetBuild(anim)
		inst.AnimState:PlayAnimation("closed", true)

        MakeSnowCoveredPristine(inst)

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst:AddComponent("inspectable")
        inst:AddComponent("container")
        inst.components.container:WidgetSetup(override_widget or "treasurechest")
        inst.components.container.onopenfn = onopen
        inst.components.container.onclosefn = onclose

        if indestructible then
			MakeInventoryPhysics(inst)
			inst:AddComponent("inventoryitem")
			inst.components.inventoryitem.canbepickedup = false
			inst.components.inventoryitem.cangoincontainer = false
			inst.components.inventoryitem.nobounce = true
			inst.components.inventoryitem:SetSinks(false)
			
			inst.components.container.onclosefn = oncloseocto
		else
            inst:AddComponent("lootdropper")
            inst:AddComponent("workable")
            inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
            inst.components.workable:SetWorkLeft(2)
            inst.components.workable:SetOnFinishCallback(onhammered)
            inst.components.workable:SetOnWorkCallback(onhit)

			if flammable then
				MakeSmallBurnable(inst, nil, nil, true)
				MakeMediumPropagator(inst)
			end
        end

		--These used to be floatable, but that's no longer needed. -M

		inst:AddComponent("waterproofer")
		inst.components.waterproofer.effectiveness = 0

        inst:AddComponent("hauntable")
        inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

        inst:ListenForEvent("onbuilt", onbuilt)
        MakeSnowCovered(inst)

        inst.OnSave = onsave 
        inst.OnLoad = onload

        return inst
    end
end

return Prefab("luggagechest", MakeChest("luggage", "luggagechest"), assets, prefabs),
	Prefab("octopuschest", MakeChest("octopus_chest", "octopuschest", false, true), assets, prefabs),
	Prefab("krakenchest", MakeChest("kraken_chest", "krakenchest"), assets, prefabs),
	Prefab("waterchest", MakeChest("water_chest", "waterchest", nil, nil, true), assets, prefabs),
	MakePlacer("waterchest_placer", "water_chest", "water_chest", "closed")%%+%%scripts/prefabs/ia_hats.lua%%-%%local function MakeHat(name)
  local fname = "hat_"..name
  local symname = name.."hat"
  local prefabname = symname

  local function generic_perish(inst)
    inst:Remove()
  end
  
  local function onequip(inst, owner, symbol_override)
    local skin_build = inst:GetSkinBuild()
    if skin_build ~= nil then
      owner:PushEvent("equipskinneditem", inst:GetSkinName())
      owner.AnimState:OverrideItemSkinSymbol("swap_hat", skin_build, symbol_override or "swap_hat", inst.GUID, fname)
    else
      owner.AnimState:OverrideSymbol("swap_hat", fname, symbol_override or "swap_hat")
    end
    owner.AnimState:Show("HAT")
    owner.AnimState:Show("HAIR_HAT")
    owner.AnimState:Hide("HAIR_NOHAT")
    owner.AnimState:Hide("HAIR")

    if owner:HasTag("player") then
      owner.AnimState:Hide("HEAD")
      owner.AnimState:Show("HEAD_HAT")
    end

    if inst.components.fueled ~= nil then
      inst.components.fueled:StartConsuming()
    end
	
    if owner.components.sailor then
      if inst.onmountboat then
		if owner.components.sailor:IsSailing() then
		  inst.onmountboat(owner, {target = owner.components.sailor:GetBoat()})
		end
		inst:ListenForEvent("embarkboat", inst.onmountboat, owner)
      end
      if inst.ondismountboat then
        inst:ListenForEvent("disembarkboat", inst.ondismountboat, owner)
      end
    end
  end

  local function onunequip(inst, owner)
    local skin_build = inst:GetSkinBuild()
    if skin_build ~= nil then
      owner:PushEvent("unequipskinneditem", inst:GetSkinName())
    end

    owner.AnimState:ClearOverrideSymbol("swap_hat")
    owner.AnimState:Hide("HAT")
    owner.AnimState:Hide("HAIR_HAT")
    owner.AnimState:Show("HAIR_NOHAT")
    owner.AnimState:Show("HAIR")

    if owner:HasTag("player") then
      owner.AnimState:Show("HEAD")
      owner.AnimState:Hide("HEAD_HAT")
    end

    if inst.components.fueled ~= nil then
      inst.components.fueled:StopConsuming()
    end
	
    if owner.components.sailor then
      if inst.onmountboat then
        inst:RemoveEventCallback("embarkboat", inst.onmountboat, owner)
      end
      if inst.ondismountboat then
		if owner.components.sailor:IsSailing() then
		  inst.ondismountboat(owner, {target = owner.components.sailor:GetBoat()})
		end
        inst:RemoveEventCallback("disembarkboat", inst.ondismountboat, owner)
      end
    end
  end

  local function opentop_onequip(inst, owner)
    local skin_build = inst:GetSkinBuild()
    if skin_build ~= nil then
      owner:PushEvent("equipskinneditem", inst:GetSkinName())
      owner.AnimState:OverrideItemSkinSymbol("swap_hat", skin_build, "swap_hat", inst.GUID, fname)
    else
      owner.AnimState:OverrideSymbol("swap_hat", fname, "swap_hat")
    end

    owner.AnimState:Show("HAT")
    owner.AnimState:Hide("HAIR_HAT")
    owner.AnimState:Show("HAIR_NOHAT")
    owner.AnimState:Show("HAIR")

    owner.AnimState:Show("HEAD")
    owner.AnimState:Hide("HEAD_HAT")

    if inst.components.fueled ~= nil then
      inst.components.fueled:StartConsuming()
    end
	
    if owner.components.sailor then
      if inst.onmountboat then
		if owner.components.sailor:IsSailing() then
		  inst.onmountboat(owner, {target = owner.components.sailor:GetBoat()})
		end
		inst:ListenForEvent("embarkboat", inst.onmountboat, owner)
      end
      if inst.ondismountboat then
        inst:ListenForEvent("disembarkboat", inst.ondismountboat, owner)
      end
    end
  end

  local function simple_common(custom_init)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

	--exception for double_umbrella
    inst.AnimState:SetBank(symname == "double_umbrellahat" and "hat_double_umbrella" or symname)
    inst.AnimState:SetBuild(fname)
    inst.AnimState:PlayAnimation("anim")

    inst:AddTag("hat")

    if custom_init ~= nil then
      custom_init(inst)
    end

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")
	
	return inst
  end

  local function simple_master(inst)
    MakeInvItemIA(inst)

    inst:AddComponent("inspectable")

    inst:AddComponent("tradable")

    inst:AddComponent("equippable")
    inst.components.equippable.equipslot = EQUIPSLOTS.HEAD
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    MakeHauntableLaunch(inst)
  end
  
  --------
  
  local function ox()
    local inst = simple_common()

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end
	
	simple_master(inst)

    -- inst.components.inventoryitem.imagename = "oxhat"

    inst:AddComponent("waterproofer")
    inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_SMALLMED)

    inst:AddComponent("armor")
    inst.components.armor:InitCondition(TUNING.ARMOR_OXHAT, TUNING.ARMOR_OXHAT_ABSORPTION)

    inst.components.equippable.poisonblocker = true

    return inst
  end
  
  --------
  
  local function shark_teeth()
    local inst = simple_common()

    inst.AnimState:SetBank("hat_shark_teeth")
    -- inst.AnimState:SetBuild("hat_shark_teeth")
    -- inst.AnimState:PlayAnimation("anim")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end
	
	simple_master(inst)

    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:InitializeFuelLevel(TUNING.SHARK_HAT_PERISHTIME)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
    inst.components.fueled:SetDepletedFn(generic_perish)

    inst.components.equippable:SetOnEquip(opentop_onequip)
    -- inst.components.equippable:SetOnUnequip(shark_teeth_onunequip)

    inst.onmountboat = function(player, data)
		inst.components.equippable.dapperness = TUNING.DAPPERNESS_LARGE
	end
    inst.ondismountboat = function(player, data)
		inst.components.equippable.dapperness = 0
	end
	
	-- inst:DoTaskInTime(0.1,function()
		-- local owner = inst.components.inventoryitem.owner
		-- if owner and owner.components.sailor and owner.components.sailor:IsSailing() then
			-- inst.onmountboat(inst)
		-- end
	-- end)
	

    return inst
  end
	
	--------
	
	local function captain()
		local inst = simple_common()

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)

		-- inst.components.equippable:SetOnEquip( captain_onequip )
		-- inst.components.equippable:SetOnUnequip( captain_onunequip )
		-- inst.durabilitymultiplier = 2

		inst.onmountboat = function(player, data)
			-- if data and data.target and data.target.components.boathealth then
				-- data.target.components.boathealth.depletionmultiplier = 
					-- data.target.components.boathealth.depletionmultiplier * TUNING.CAPTAINHAT_DEPLETION_MULT
			-- end
			if player and player.components.sailor then
				player.components.sailor.durabilitymultiplier = player.components.sailor.durabilitymultiplier / TUNING.CAPTAINHAT_DEPLETION_MULT
			end
		end
		inst.ondismountboat = function(player, data)
			-- if data and data.target and data.target.components.boathealth then
				-- data.target.components.boathealth.depletionmultiplier = 
					-- data.target.components.boathealth.depletionmultiplier / TUNING.CAPTAINHAT_DEPLETION_MULT
			-- end
			if player and player.components.sailor then
				player.components.sailor.durabilitymultiplier = player.components.sailor.durabilitymultiplier * TUNING.CAPTAINHAT_DEPLETION_MULT
			end
		end

		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.CAPTAINHAT_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn(generic_perish)

		return inst
	end
	
	--------
	
    local function double_umbrella_onequip(inst, owner) 
        opentop_onequip(inst, owner)

        owner.DynamicShadow:SetSize(2.2, 1.4)
    end

    local function double_umbrella_onunequip(inst, owner) 
        onunequip(inst, owner)

        owner.DynamicShadow:SetSize(1.3, 0.6)
    end
	
	local function double_umbrella_perish(inst)
        if inst.components.equippable ~= nil and inst.components.equippable:IsEquipped() then
            local owner = inst.components.inventoryitem ~= nil and inst.components.inventoryitem.owner or nil
            if owner ~= nil then
                owner.DynamicShadow:SetSize(1.3, 0.6)
                local data =
                {
                    prefab = inst.prefab,
                    equipslot = inst.components.equippable.equipslot,
                }
                inst:Remove()--generic_perish(inst)
                owner:PushEvent("umbrellaranout", data)
                return
            end
        end
        inst:Remove()--generic_perish(inst)
    end
	
	local function double_umbrella()
		local inst = simple_common()
		
		-- inst.AnimState:SetBank("hat_double_umbrella")
		
		inst:AddTag("umbrella")
		inst:AddTag("waterproofer") --added to pristine state for optimization

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)
		
		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.DOUBLE_UMBRELLA_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn( double_umbrella_perish )

		inst.components.equippable:SetOnEquip( double_umbrella_onequip )
		inst.components.equippable:SetOnUnequip( double_umbrella_onunequip )

		inst:AddComponent("waterproofer")
		inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_ABSOLUTE)

		inst:AddComponent("insulator")
		inst.components.insulator:SetInsulation(TUNING.INSULATION_LARGE)
		inst.components.insulator:SetSummer()
		
		inst.components.equippable.insulated = true

		return inst
	end
	
	--------

	local function aerodynamic()
		local inst = simple_common()

		inst.AnimState:SetBank("hat_aerodynamic")

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)

		inst.components.equippable.dapperness = TUNING.DAPPERNESS_SMALL
		inst.components.equippable.walkspeedmult = TUNING.AERODYNAMICHAT_SPEED_MULT

		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.AERODYNAMICHAT_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn(generic_perish)

		inst:AddComponent("windproofer")
		inst.components.windproofer:SetEffectiveness(TUNING.WINDPROOFNESS_MED)

		return inst
	end
	
	--------
	
	local function gas()
		local inst = simple_common()

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)

		inst.components.equippable.poisongasblocker = true

		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.GASHAT_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn(generic_perish)

		return inst
	end
	
	--------
	
	local function snakeskin()
		local inst = simple_common()

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)

		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.SNAKESKINHAT_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn(generic_perish)

		inst:AddComponent("waterproofer")
		inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_LARGE)

		inst.components.equippable.insulated = true

		return inst
	end
	
	--------
	
	local function pirate()
		local inst = simple_common()

		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end

		simple_master(inst)

		inst.components.equippable.dapperness = TUNING.DAPPERNESS_SMALL

		inst:AddComponent("waterproofer")
		inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_SMALL)

		inst:AddComponent("fueled")
		inst.components.fueled.fueltype = "USAGE"
		inst.components.fueled:InitializeFuelLevel(TUNING.PIRATEHAT_PERISHTIME)
        inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
		inst.components.fueled:SetDepletedFn(generic_perish)

		inst.onmountboat = function(player, data)
			if not player.mapexplorerbonus then
				--Increases map exploration radius
				local radius = TUNING.MAPREVEAL_PIRATEHAT_BONUS
				local intervals = 25
				local theta = 0
				player.mapexplorerbonus = player:DoPeriodicTask(0.2, function()
					local pt = Vector3(player.Transform:GetWorldPosition())
					local offset = Vector3(radius * math.cos(theta), 0, -radius * math.sin(theta))
					theta = theta + (2 * PI/intervals)
					if player.player_classified ~= nil then
						player.player_classified.MapExplorer:RevealArea((pt + offset):Get())
						player.player_classified.MapExplorer:RevealArea((pt - offset):Get())
					end
				end)
			end
		end
		inst.ondismountboat = function(player, data)
			if player.mapexplorerbonus then
				player.mapexplorerbonus:Cancel()
				player.mapexplorerbonus = nil
			end
		end

		return inst
	end

    -------

    local function brainjelly_onequip(inst, owner, symbol_override)
        local skin_build = inst:GetSkinBuild()
        if skin_build ~= nil then
            owner:PushEvent("equipskinneditem", inst:GetSkinName())
            owner.AnimState:OverrideItemSkinSymbol("swap_hat", skin_build, symbol_override or "swap_hat", inst.GUID, fname)
        else
            owner.AnimState:OverrideSymbol("swap_hat", fname, symbol_override or "swap_hat")
        end
        owner.AnimState:Show("HAT")
        owner.AnimState:Show("HAT_HAIR")
        owner.AnimState:Hide("HAIR_NOHAT")
        owner.AnimState:Hide("HAIR")

        if owner:HasTag("player") then
            owner.AnimState:Hide("HEAD")
            owner.AnimState:Show("HEAD_HAT")
        end

        if owner.components.builder then
            owner.components.builder.jellybrainhat = true
            owner:PushEvent("unlockrecipe")
            inst.brainjelly_onbuild = function()
                inst.components.finiteuses:Use(1)
            end
            owner:ListenForEvent("builditem", inst.brainjelly_onbuild)
            owner:ListenForEvent("bufferbuild", inst.brainjelly_onbuild)
        end
    end

    local function brainjelly_onunequip(inst, owner)
        local skin_build = inst:GetSkinBuild()
        if skin_build ~= nil then
            owner:PushEvent("unequipskinneditem", inst:GetSkinName())
        end
        owner.AnimState:ClearOverrideSymbol("swap_hat")
        owner.AnimState:Hide("HAT")
        owner.AnimState:Hide("HAIR_HAT")
        owner.AnimState:Show("HAIR_NOHAT")
        owner.AnimState:Show("HAIR")

        if owner:HasTag("player") then
            owner.AnimState:Show("HEAD")
            owner.AnimState:Hide("HEAD_HAT")
        end
        if owner.components.builder then
            owner.components.builder.jellybrainhat = false
            owner:PushEvent("unlockrecipe")
            owner:RemoveEventCallback("builditem", inst.brainjelly_onbuild)
            owner:RemoveEventCallback("bufferbuild", inst.brainjelly_onbuild)
            inst.brainjelly_onbuild = nil
            --cancel any existing BUILD actions, since they might be unavaliable after jellybrainhat was set to false.
            if owner.bufferedaction and owner.bufferedaction.action == ACTIONS.BUILD then
                owner:ClearBufferedAction()
            end
        end
    end

    local function brainjelly()
        local inst = simple_common()

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        simple_master(inst)

        inst:AddComponent("finiteuses")
        inst.components.finiteuses:SetMaxUses(4)
        inst.components.finiteuses:SetPercent(1)
        inst.components.finiteuses.onfinished = function() inst:Remove() end

        inst.components.equippable:SetOnEquip(brainjelly_onequip)
        inst.components.equippable:SetOnUnequip(brainjelly_onunequip)

        return inst
    end
	
	--------
	
    local function default()
        local inst = simple_common()

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        simple_master(inst)

        return inst
    end

    local fn = nil
    local assets = { Asset("ANIM", "anim/"..fname..".zip") }
    local prefabs = nil

    if name == "captain" then
        fn = captain
    elseif name == "snakeskin" then
        fn = snakeskin
    elseif name == "pirate" then
        fn = pirate
    elseif name == "gas" then
        fn = gas
    elseif name == "aerodynamic" then
        fn = aerodynamic
    elseif name == "double_umbrella" then
        fn = double_umbrella
    elseif name == "shark_teeth" then
        fn = shark_teeth
    elseif name == "brainjelly" then
        fn = brainjelly
    elseif name == "ox" then
        fn = ox
    end

    return Prefab(prefabname, fn or default, assets, prefabs)
end


return 
MakeHat("captain"), 
MakeHat("snakeskin"),
MakeHat("pirate"),
MakeHat("gas"),
MakeHat("aerodynamic"),
MakeHat("double_umbrella"),
MakeHat("shark_teeth"),
MakeHat("brainjelly"),
-- MakeHat("woodlegs"),
MakeHat("ox")
%%+%%scripts/prefabs/ia_marsh_plant.lua%%-%%local assets =
{
    Asset("ANIM", "anim/tidal_plant.zip"),
    Asset("ANIM", "anim/marsh_plant_tropical.zip"),
}

local function fn(bank, build)
  return function()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank(bank)
    inst.AnimState:SetBuild(build)
    inst.AnimState:PlayAnimation("idle", true)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    MakeMediumBurnable(inst)
    MakeSmallPropagator(inst)
    MakeHauntableIgnite(inst)

    inst:AddComponent("inspectable")

    return inst
  end
end

return Prefab("tidal_plant", fn("tidal_plant", "tidal_plant"), assets),
Prefab("marsh_plant_tropical", fn("marsh_plant_tropical", "marsh_plant_tropical"), assets)%%+%%scripts/prefabs/ia_monsterwarningsounds.lua%%-%%local easing = require("easing")

local MAX_SOUND_RANGE = 30 --max distance for sound to be heard at min volume
local RANGE_BUFFER = 10 --buffer for sound to "bleed" over the monster's range

local monster_params =
{
    twister =
    {
        range = 40, --twisterspawner.lua::HASSLER_SPAWN_DIST
        levels =
        {
            {
                sound = "ia/creatures/twister/distant",
                distance = 25,
            },
            {
                sound = "ia/creatures/twister/distant",
                distance = 20,
            },
            {
                sound = "ia/creatures/twister/distant",
                distance = 15,
            },
            {
                sound = "ia/creatures/twister/distant",
                distance = 5,
            },
        }
    },
}

local function PlayWarningSound(proxy, sound, range, theta, radius)
    local inst = CreateEntity()

    --[[Non-networked entity]]

    inst.entity:AddTransform()
    inst.entity:AddSoundEmitter()
    inst.entity:SetParent(TheFocalPoint.entity)

    --Sound starts fading when source is out of range
    --At 2x range + RANGE_BUFFER, sound is offset by MAX_SOUND_RANGE
    local distsq = TheFocalPoint:GetDistanceSqToInst(proxy)
    if distsq > range * range then
        radius = easing.inQuad(math.sqrt(distsq) - range, radius, MAX_SOUND_RANGE - radius, range + RANGE_BUFFER)
    end

    inst.Transform:SetPosition(radius * math.cos(theta), 0, radius * math.sin(theta))
    inst.SoundEmitter:PlaySound(sound)

    inst:Remove()
end

local function OnRandDirty(inst)
    if inst._params == nil or inst._level == nil or inst._rand:value() <= 0 then
        return
    end

    --Delay one frame so that we are positioned properly before starting the effect
    --or in case we are about to be removed
    local leveldata = inst._params.levels[inst._level]
    inst:DoTaskInTime(0, PlayWarningSound, leveldata.sound, inst._params.range, inst._rand:value() / 255 * 2 * PI, leveldata.distance)
    inst._params = nil
    inst._level = nil
end

local function makewarning(params, level)
    return function()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddNetwork()

        inst:AddTag("FX")

        inst._rand = net_byte(inst.GUID, "_rand", "randdirty")

        --Dedicated server does not need to spawn the local fx
        if not TheNet:IsDedicated() then
            inst._params = params
            inst._level = level
            inst:ListenForEvent("randdirty", OnRandDirty)
        end

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst.entity:SetCanSleep(false)
        inst.persists = false

        inst._rand:set(math.random(255))
        inst:DoTaskInTime(1, inst.Remove)

        return inst
    end
end

local t = {}
for monster, params in pairs(monster_params) do
    for level = 1, #params.levels do
        table.insert(t, Prefab(monster.."warning_lvl"..level, makewarning(params, level)))
    end
end
return unpack(t)
%%+%%scripts/prefabs/ia_placeholder.lua%%-%%local assets = {
  Asset("ANIM", "anim/dubloon.zip"),
}

local function basic()
    local inst = CreateEntity()
    inst.entity:AddTransform()

    function inst:OnLoad(data)
        inst.data = data
    end

    function inst:OnSave(data)
        if inst.data then
            for k, v in pairs(inst.data) do
        	   data[k] = v
            end
        end
    end

    return inst
end

local function item()
    local inst = basic()

    inst.entity:AddNetwork()
    inst.entity:AddAnimState()
    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("dubloon")
    inst.AnimState:SetBuild("dubloon")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeInvItemIA(inst, "dubloon")

    inst:AddComponent("inspectable")
    inst.components.inspectable.descriptionfn = function(inst, viewer)
        return GetString(viewer, "ANNOUNCE_UNIMPLEMENTED")
    end

    return inst
end

return
Prefab("beachresurrector", basic),
Prefab("butterfly_areaspawner", basic),
Prefab("buriedtreasure", basic),
Prefab("quackenbeak", item, assets),
Prefab("volcanostaff", item, assets)
%%+%%scripts/prefabs/ia_plantables.lua%%-%%require "prefabutil"

local function make_plantable(data)
  local assets =
  {
    Asset("ANIM", "anim/"..(data.build or data.name)..".zip"),
  }

  local function ondeploy(inst, pt, deployer)
    local tree = SpawnPrefab(data.name)
    if tree ~= nil then
      tree.Transform:SetPosition(pt:Get())
      inst.components.stackable:Get():Remove()
      if tree.components.pickable then 
        tree.components.pickable:OnTransplant()
      elseif tree.components.hackable then 
        tree.components.hackable:OnTransplant()
      end 
      if deployer ~= nil and deployer.SoundEmitter ~= nil then
        deployer.SoundEmitter:PlaySound("dontstarve/common/plant")
      end
    end
  end

  local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    --inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
	
	inst:AddTag("deployedplant")

    if data.volcanic then inst:AddTag("volcanicplant") end
    if data.noburn then inst:AddTag("fire_proof") end

    inst.AnimState:SetBank(data.bank or data.name)
    inst.AnimState:SetBuild(data.build or data.name)
    inst.AnimState:PlayAnimation("dropped")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("dropped_water", "dropped")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

    inst:AddComponent("inspectable")
    inst.components.inspectable.nameoverride = data.inspectoverride or "dug_"..data.name
    MakeInvItemIA(inst)

    inst:AddComponent("fuel")
    inst.components.fuel.fuelvalue = TUNING.LARGE_FUEL

    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

    if data.noburn then
      MakeHauntableLaunch(inst)
    else
      MakeMediumBurnable(inst, TUNING.LARGE_BURNTIME)
      MakeSmallPropagator(inst)

      MakeHauntableLaunchAndIgnite(inst)
    end

    inst:AddComponent("deployable")
    inst.components.deployable.ondeploy = ondeploy
    inst.components.deployable:SetDeployMode(DEPLOYMODE.PLANT)
        if data.deployatrange then
            inst.components.deployable.deployatrange = true
        end
        if data.mediumspacing then
            inst.components.deployable:SetDeploySpacing(DEPLOYSPACING.MEDIUM)
        end
	
    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.WOOD
    inst.components.edible.woodiness = 10

    ---------------------
    return inst
  end

  return Prefab("dug_"..data.name, fn, assets)
end

-- Note: using separate function just to avoid naming inconsistencies caused by Klei's naming inconsistencies -M
local function make_waterplantable(data)
  local assets =
  {
	Asset("ANIM", "anim/"..(data.build or data.name)..".zip"),
	Asset("ANIM", "anim/"..data.pbuild..".zip"),
  }

  local function ondeploy(inst, pt, deployer)
	local tree = SpawnAt(data.tree, pt)
	if tree ~= nil then
		if inst.components.stackable then
			inst.components.stackable:Get():Remove()
		else
			inst:Remove()
		end
		if tree.components.pickable then 
			tree.components.pickable:OnTransplant()
		elseif tree.components.growable and data.stage then 
			tree.components.growable:SetStage(data.stage)
		end 
		if deployer ~= nil and deployer.SoundEmitter ~= nil and data.sound then
			deployer.SoundEmitter:PlaySound(data.sound)
		end
	end
  end

  local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	--inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	if data.isplant then
		inst:AddTag("deployedplant")
	end

	inst.AnimState:SetBank(data.build or data.name)
	inst.AnimState:SetBuild(data.build or data.name)
	inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
	  return inst
	end
	
	inst:AddComponent("inspectable")
	-- inst.components.inspectable.nameoverride = data.inspectoverride or "dug_"..data.name
	MakeInvItemIA(inst)
	
	if not data.nostack then
		inst:AddComponent("stackable")
		inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM --For some reason, they're small -M
	end
	if data.perishable then
		inst:AddComponent("perishable")
		inst.components.perishable:SetPerishTime(TUNING.PERISH_PRESERVED)
		inst.components.perishable:StartPerishing()
		inst.components.perishable.onperishreplacement = "spoiled_food"
		inst:AddTag("show_spoilage")
	end
	
	-- No idea why they are tradable -M
	-- inst:AddComponent("tradable")
	
	MakeHauntableLaunch(inst)
	
	inst:AddComponent("deployable")
	inst.components.deployable.ondeploy = ondeploy
	inst.components.deployable:SetDeployMode(DEPLOYMODE.PLANT)
	inst.components.deployable.candeployonland = false
	inst.components.deployable.candeployonshallowocean = true
	if data.canonbuildable then
		inst.components.deployable.candeployonbuildableocean = true
	end
    if data.spacing then
		inst.components.deployable:SetDeploySpacing(DEPLOYSPACING.MEDIUM)
    end
	

	---------------------
	return inst
  end

  return Prefab(data.name, fn, assets)
end

local plantables =
{
  {
    name="bambootree",
    build = "bambootree_build",
  },
  {
    name="bush_vine",
  },
  {
    name="coffeebush",
    anim="idle_dead",
    noburn=true,
	volcanic = true,
	deployatrange = true,
  },
  {
    name="elephantcactus",
    bank = "cactus_volcano",
    build = "cactus_volcano",
    anim="idle_dead",
    noburn=true,
	volcanic = true,
	deployatrange = true,
  },
}

--separate function because there's just too many inconsistencies
local waterplantables =
{
  {
    name = "seaweed_stalk",
    build = "seaweed_seed",
    pbuild = "seaweed_seed",
	panim = "placer",
	tree = "seaweed_planted",
	isplant = true,
  },
  {
    name = "mussel_bed",
    build = "musselfarm_seed",
    pbuild = "musselfarm",
	panim = "idle_underwater",
	tree = "mussel_farm",
	nostack = true,
	stage = 2,
	sound = "ia/common/musselbed_plant",
  },
  {
    name = "nubbin",
    build = "nubbin",
    pbuild = "coral_rock",
	panim = "low1",
	tree = "rock_coral",
	stage = 1,
	sound = "ia/creatures/seacreature_movement/splash_medium",
	perishable = true,
	canonbuildable = true,
	spacing = true,
  },
}

local prefabs = {}
for i, v in ipairs(plantables) do
  table.insert(prefabs, make_plantable(v))
  table.insert(prefabs, MakePlacer("dug_"..v.name.."_placer", v.bank or v.name, v.build or v.name, v.anim or "idle"))
end
for i, v in ipairs(waterplantables) do
  table.insert(prefabs, make_waterplantable(v))
  table.insert(prefabs, MakePlacer(v.name.."_placer", v.pbuild or v.build, v.pbuild or v.build, v.panim))
end

return unpack(prefabs)
%%+%%scripts/prefabs/ia_preparedfoods.lua%%-%%local assets =
{
    Asset("ANIM", "anim/cook_pot_food_sw.zip"),
}

local prefabs =
{
    "spoiled_food",
}

local function MakePreparedFood(data)
    local foodassets = assets
    local spicename = data.spice ~= nil and string.lower(data.spice) or nil
    if spicename ~= nil then
        foodassets = shallowcopy(assets)
        table.insert(foodassets, Asset("ANIM", "anim/spices.zip"))
        table.insert(foodassets, Asset("ANIM", "anim/plate_food.zip"))
        table.insert(foodassets, Asset("INV_IMAGE", spicename.."_over"))
    end

    local foodprefabs = prefabs
    if data.prefabs ~= nil then
        foodprefabs = shallowcopy(prefabs)
        for i, v in ipairs(data.prefabs) do
            if not table.contains(foodprefabs, v) then
                table.insert(foodprefabs, v)
            end
        end
    end

    local function DisplayNameFn(inst)
        return subfmt(STRINGS.NAMES[data.spice.."_FOOD"], { food = STRINGS.NAMES[string.upper(data.basename)] })
    end

    local function fn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddNetwork()

        MakeInventoryPhysics(inst)

        if spicename ~= nil then
            inst.AnimState:SetBuild("plate_food")
            inst.AnimState:SetBank("plate_food")
			inst.AnimState:PlayAnimation("idle")
            inst.AnimState:OverrideSymbol("swap_garnish", "spices", spicename)

            inst:AddTag("spicedfood")

            inst.inv_image_bg = { image = (data.basename or data.name)..".tex" }
            inst.inv_image_bg.atlas = GetInventoryItemAtlas(inst.inv_image_bg.image)

			inst.AnimState:OverrideSymbol("swap_food", data.basename or data.name, data.basename or data.name)

			MakeInventoryFloatable(inst)
        else
			inst.AnimState:SetBuild("cook_pot_food_sw")
			inst.AnimState:SetBank("food_floating")
			inst.AnimState:PlayAnimation(data.name, false)

			MakeInventoryFloatable(inst)
			inst.components.floater:UpdateAnimations(data.name.."_water", data.name)
        end

        inst:AddTag("preparedfood")
        if data.tags then
            for i,v in pairs(data.tags) do
                inst:AddTag(v)
            end
        end

        if data.basename ~= nil then
            inst:SetPrefabNameOverride(data.basename)
            if data.spice ~= nil then
                inst.displaynamefn = DisplayNameFn
            end
        end

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst:AddComponent("edible")
        inst.components.edible.healthvalue = data.health
        inst.components.edible.hungervalue = data.hunger
        inst.components.edible.foodtype = data.foodtype or FOODTYPE.GENERIC
        inst.components.edible.sanityvalue = data.sanity or 0
        inst.components.edible.temperaturedelta = data.temperature or 0
        inst.components.edible.temperatureduration = data.temperatureduration or 0
        inst.components.edible.nochill = data.nochill or nil
        inst.components.edible.spice = data.spice
        inst.components.edible:SetOnEatenFn(data.oneatenfn)

        inst.components.edible.naughtyvalue = data.naughtiness or 0
        inst.components.edible.caffeinedelta = data.caffeinedelta or 0
        inst.components.edible.caffeineduration = data.caffeineduration or 0

        if data.boost_surf then
            inst.components.edible.surferdelta = TUNING.HYDRO_FOOD_BONUS_SURF
            inst.components.edible.surferduration = TUNING.FOOD_SPEED_AVERAGE       
        end
        if data.boost_dry then
            inst.components.edible.autodrydelta = TUNING.HYDRO_FOOD_BONUS_DRY
            inst.components.edible.autodryduration = TUNING.FOOD_SPEED_AVERAGE
        end
        if data.boost_cool then
            inst.components.edible.autocooldelta = TUNING.HYDRO_FOOD_BONUS_COOL_RATE
        end

        inst:AddComponent("inspectable")
        inst.wet_prefix = data.wet_prefix
        
        MakeInvItemIA(inst)

        if spicename ~= nil then
            inst.components.inventoryitem:ChangeImageName(spicename.."_over")
        elseif data.basename ~= nil then
            inst.components.inventoryitem:ChangeImageName(data.basename)
        end

        inst:AddComponent("stackable")
        inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

		if data.perishtime ~= nil and data.perishtime > 0 then
			inst:AddComponent("perishable")
			inst.components.perishable:SetPerishTime(data.perishtime)
			inst.components.perishable:StartPerishing()
			inst.components.perishable.onperishreplacement = "spoiled_food"
		end
		
        MakeSmallBurnable(inst)
        MakeSmallPropagator(inst)
        MakeHauntableLaunchAndPerish(inst)
        -- AddHauntableCustomReaction(inst, function(inst, haunter)
            --#HAUNTFIX
            --if math.random() <= TUNING.HAUNT_CHANCE_SUPERRARE then
                --if inst.components.burnable and not inst.components.burnable:IsBurning() then
                    --inst.components.burnable:Ignite()
                    --inst.components.hauntable.hauntvalue = TUNING.HAUNT_MEDIUM
                    --inst.components.hauntable.cooldown_on_successful_haunt = false
                    --return true
                --end
            --end
            -- return false
        -- end, true, false, true)
        ---------------------        

        inst:AddComponent("bait")

        ------------------------------------------------
        inst:AddComponent("tradable")
        
        ------------------------------------------------  

        return inst
    end

    return Prefab(data.name, fn, foodassets, foodprefabs)
end

----------------------------------------------------------------------------------------

local function ApplyGourmetBonus(edible, key)
	if edible and edible[key] then
		if edible[key] < 0 then
			edible[key] = edible[key] * (1 - TUNING.WARLY_IA_GOURMET_BONUS)
		else
			edible[key] = edible[key] * (1 + TUNING.WARLY_IA_GOURMET_BONUS)
		end
	end
end

local function MakeGourmetFood(name)
	local needtocopyassets = true
	if Prefabs[name] ~= nil then --might not be registered yet
		needtocopyassets = nil
	end
    local function fn()
		local inst = Prefabs[name].fn()
		
		if needtocopyassets then
			Prefabs[name .."_gourmet"].assets = Prefabs[name].assets
			Prefabs[name .."_gourmet"].deps = Prefabs[name].deps
			needtocopyassets = nil
		end
		
		inst:AddTag("gourmetfood") --this is not pristine anymore, but it should not hurt networking too much
		
        if not TheWorld.ismastersim then
            return inst
        end
		
		-- inst.nameoverride = name
		if inst.components.inspectable ~= nil then
			inst.components.inspectable.nameoverride = name
		end
		if inst.components.inventoryitem ~= nil then
			inst.components.inventoryitem.imagename = inst.components.inventoryitem.imagename or name
		end
		if inst.components.perishable ~= nil then
			inst.components.perishable:SetPerishTime( inst.components.perishable.perishtime * TUNING.WARLY_IA_GOURMET_PERISHTIME_MULT )
		end
		
		ApplyGourmetBonus(inst.components.edible, "healthvalue")
		ApplyGourmetBonus(inst.components.edible, "hungervalue")
		ApplyGourmetBonus(inst.components.edible, "sanityvalue")
		-- ApplyGourmetBonus(inst.components.edible, "temperaturedelta")
		ApplyGourmetBonus(inst.components.edible, "temperatureduration")
		-- ApplyGourmetBonus(inst.components.edible, "naughtyvalue")
		-- ApplyGourmetBonus(inst.components.edible, "caffeinedelta")
		ApplyGourmetBonus(inst.components.edible, "caffeineduration")
		-- ApplyGourmetBonus(inst.components.edible, "surferdelta")
		ApplyGourmetBonus(inst.components.edible, "surferduration")
		-- ApplyGourmetBonus(inst.components.edible, "autodrydelta")
		ApplyGourmetBonus(inst.components.edible, "autodryduration")
		ApplyGourmetBonus(inst.components.edible, "autocooldelta")

        return inst
    end

    return Prefab(name .."_gourmet", fn, Prefabs[name] and Prefabs[name].assets, Prefabs[name] and Prefabs[name].deps)
end

local prefs = {}

for k,v in pairs(IA_PREPAREDFOODS) do
    table.insert(prefs, MakePreparedFood(v))
end

local cooking = require("cooking")
for cooker, recipes in pairs(cooking.recipes) do
	if cooker ~= "portablespicer" then
		for name, data in pairs(recipes) do
			if name ~= "wetgoop" then --explicitly exclude the failed cooking
				table.insert(prefs, MakeGourmetFood(name))
				STRINGS.NAMES[string.upper(name) .."_GOURMET"] = STRINGS.GOURMETPREFIX .. (STRINGS.NAMES[string.upper(name)] or STRINGS.GOURMETGENERIC)
			end
		end
	end
end

return unpack(prefs)
%%+%%scripts/prefabs/ia_spear.lua%%-%%
local poison_assets = {
	Asset("ANIM", "anim/spear_poison.zip"),
	Asset("ANIM", "anim/swap_spear_poison.zip"),
}
local obsidian_assets = {
	Asset("ANIM", "anim/spear_obsidian.zip"),
	Asset("ANIM", "anim/swap_spear_obsidian.zip"),
}
local needle_assets = {
	Asset("ANIM", "anim/swap_cactus_spike.zip"),
	Asset("ANIM", "anim/cactus_spike.zip"),
}
local pegleg_assets = {
	Asset("ANIM", "anim/swap_peg_leg.zip"),
	Asset("ANIM", "anim/peg_leg.zip"),
}

local function onunequip(inst, owner)
	owner.AnimState:Hide("ARM_carry")
	owner.AnimState:Show("ARM_normal")
	local skin_build = inst:GetSkinBuild()
	if skin_build ~= nil then
		owner:PushEvent("unequipskinneditem", inst:GetSkinName())
	end
end

local function commonfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst:AddTag("sharp")
	inst:AddTag("pointy")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	return inst
end

local function masterfn(inst)
	inst:AddComponent("weapon")
	inst.components.weapon:SetDamage(TUNING.SPEAR_DAMAGE)

	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.SPEAR_USES)
	inst.components.finiteuses:SetUses(TUNING.SPEAR_USES)

	inst.components.finiteuses:SetOnFinished(inst.Remove)

	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)

	inst:AddComponent("equippable")
	-- inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)
	

	MakeHauntableLaunch(inst)
end



local function poisonattack(inst, attacker, target, projectile)
	if target.components.poisonable then
	--TODO unless attack gets blocked?
		target.components.poisonable:Poison()
	end
	-- if target.components.combat then
		-- target.components.combat:SuggestTarget(attacker)
	-- end
	-- this was commented out as the attack with the spear will do an attacked event. The poison itself doesn't need a second one pushed
	--target:PushEvent("attacked", {attacker = attacker, damage = 0, projectile = projectile})
end

local function onequip_poison(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_spear_poison", "swap_spear")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function poison_fn()
	local inst = commonfn()
	
	inst.AnimState:SetBuild("spear_poison")
	inst.AnimState:SetBank("spear_poison")
	inst.AnimState:PlayAnimation("idle")
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.components.weapon:SetOnAttack(poisonattack)
	inst.components.equippable:SetOnEquip(onequip_poison)
	
	return inst
end


local function onequip_obsidian(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_spear_obsidian", "swap_spear")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function obsidian_fn()
	local inst = commonfn()
	inst.entity:AddSoundEmitter()

	inst.AnimState:SetBuild("spear_obsidian")
	inst.AnimState:SetBank("spear_obsidian")
	inst.AnimState:PlayAnimation("idle")

    MakeObsidianToolPristine(inst)
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
	inst.components.weapon:SetDamage(TUNING.OBSIDIAN_SPEAR_DAMAGE)
	inst.components.weapon.attackwear = 1 / TUNING.OBSIDIANTOOLFACTOR
	inst.components.equippable:SetOnEquip( onequip_obsidian )

	inst:AddComponent("waterproofer")
	inst.components.waterproofer:SetEffectiveness(0)
	
	MakeObsidianTool(inst, "spear")
	inst.components.obsidiantool.maxcharge = TUNING.OBSIDIAN_WEAPON_MAXCHARGES
	inst.components.obsidiantool.cooldowntime = TUNING.TOTAL_DAY_TIME / TUNING.OBSIDIAN_WEAPON_MAXCHARGES

	return inst
end


local function onequip_needle(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_cactus_spike", "swap_cactus_spike")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function needle_fn()
	local inst = commonfn()

	inst.AnimState:SetBuild("cactus_spike")
	inst.AnimState:SetBank("cactus_spike")
	inst.AnimState:PlayAnimation("idle")
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)

	inst.components.weapon:SetDamage(TUNING.NEEDLESPEAR_DAMAGE)
	inst.components.finiteuses:SetMaxUses(TUNING.NEEDLESPEAR_USES)
	inst.components.finiteuses:SetUses(TUNING.NEEDLESPEAR_USES)

	inst.components.equippable:SetOnEquip( onequip_needle )

	return inst
end


local function onequip_pegleg(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_peg_leg", "swap_object")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function pegleg_fn()
	local inst = commonfn()

	inst.AnimState:SetBuild("peg_leg")
	inst.AnimState:SetBank("peg_leg")
	inst.AnimState:PlayAnimation("idle")

	inst:AddTag("pegleg")

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)

	inst.components.weapon:SetDamage(TUNING.PEG_LEG_DAMAGE)
	inst.components.finiteuses:SetMaxUses(TUNING.PEG_LEG_USES)
	inst.components.finiteuses:SetUses(TUNING.PEG_LEG_USES)

	inst.components.equippable:SetOnEquip( onequip_pegleg )

	return inst
end


return Prefab("spear_poison", poison_fn, poison_assets),
Prefab("spear_obsidian", obsidian_fn, obsidian_assets),
Prefab("needlespear", needle_fn, needle_assets),
Prefab("peg_leg", pegleg_fn, pegleg_assets)%%+%%scripts/prefabs/ia_trinkets.lua%%-%%
local oldPickRandomTrinket = PickRandomTrinket
function PickRandomTrinket()
	if math.random() < 11 / (NUM_TRINKETS + 11) then
		return "trinket_ia_".. math.random(13,23)
	else
		return oldPickRandomTrinket()
	end
end

local assets =
{
    Asset("ANIM", "anim/trinkets_ia.zip"),
}

local TRADEFOR =
{
    -- [1] = {"rewardprefab"},
}

local function MakeTrinket(num, prefix, tuning)
    local prefabs = TRADEFOR[num]

    local function fn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddSoundEmitter()
        inst.entity:AddNetwork()

        MakeInventoryPhysics(inst)

        inst.AnimState:SetBank("trinkets_ia")
        inst.AnimState:SetBuild("trinkets_ia")
        inst.AnimState:PlayAnimation(tostring(num))

        inst:AddTag("molebait")
        inst:AddTag("cattoy")

		MakeInventoryFloatable(inst)
		inst.components.floater:UpdateAnimations(tostring(num).."_water", tostring(num))

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst:AddComponent("appeasement")
        inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_LARGE

        inst:AddComponent("inspectable")
        inst:AddComponent("stackable")
        inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

        MakeInvItemIA(inst)
        inst:AddComponent("tradable")
        inst.components.tradable.goldvalue = TUNING.GOLD_VALUES[tuning][num] or 3
        inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES[tuning][num] or 3
        inst.components.tradable.tradefor = TRADEFOR[num]
        
		-- if num >= HALLOWEDNIGHTS_TINKET_START and num <= HALLOWEDNIGHTS_TINKET_END then
	        -- if IsSpecialEventActive(SPECIAL_EVENTS.HALLOWED_NIGHTS) then
				-- inst.components.tradable.halloweencandyvalue = 5
			-- end
		-- end
		inst.components.tradable.rocktribute = math.ceil(inst.components.tradable.goldvalue / 3)

        MakeHauntableLaunchAndSmash(inst)

        inst:AddComponent("bait")

        return inst
    end

    return Prefab(prefix .. tostring(num), fn, assets, prefabs)
end

local ret = {}
for k = 13, 23 do
    table.insert(ret, MakeTrinket(k, "trinket_ia_", "IA_TRINKETS"))
end
for k = 1, 5 do
    table.insert(ret, MakeTrinket(k, "sunken_boat_trinket_", "SUNKEN_BOAT_TRINKETS"))
end

return unpack(ret)
%%+%%scripts/prefabs/ia_veggies.lua%%-%%local assets_seeds =
{
  Asset("ANIM", "anim/seeds.zip"),
}

local function OnDeploy(inst, pt)--, deployer, rot)
    local plant = SpawnPrefab("plant_normal_ground")
    plant.components.crop:StartGrowing(inst.components.plantable.product, inst.components.plantable.growtime)
    plant.Transform:SetPosition(pt.x, 0, pt.z)
    plant.SoundEmitter:PlaySound("dontstarve/wilson/plant_seeds")
    inst:Remove()
end

local function MakeVeggie(name, has_seeds)

  local assets =
  {
    Asset("ANIM", "anim/"..name..".zip"),
  }

  local assets_cooked =
  {
    Asset("ANIM", "anim/"..name..".zip"),
  }

  local prefabs =
  {
    name.."_cooked",
    "spoiled_food",
  }

  if has_seeds then
    table.insert(prefabs, name.."_seeds")
  end

  local function fn_seeds()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("seeds")
    inst.AnimState:SetBuild("seeds")
    inst.AnimState:SetRayTestOnBB(true)

	inst:AddTag("deployedplant")

    --cookable (from cookable component) added to pristine state for optimization
    inst:AddTag("cookable")

	inst.overridedeployplacername = "seeds_placer"

	MakeInventoryFloatable(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.SEEDS

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("tradable")
    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)

    inst.AnimState:PlayAnimation("idle")
    inst.components.edible.healthvalue = TUNING.HEALING_TINY/2
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERSLOW)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("cookable")
    inst.components.cookable.product = "seeds_cooked"

    inst:AddComponent("bait")
    inst:AddComponent("plantable")
    inst.components.plantable.growtime = TUNING.SEEDS_GROW_TIME
    inst.components.plantable.product = name

	inst:AddComponent("deployable")
	inst.components.deployable:SetDeployMode(DEPLOYMODE.PLANT)
	inst.components.deployable.restrictedtag = "plantkin"
	inst.components.deployable.ondeploy = OnDeploy

    MakeHauntableLaunchAndPerish(inst)

    return inst
  end

  local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank(name)
    inst.AnimState:SetBuild(name)
    inst.AnimState:PlayAnimation("idle")

    --cookable (from cookable component) added to pristine state for optimization
    inst:AddTag("cookable")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("edible")
    inst.components.edible.healthvalue = IA_VEGGIES[name].health
    inst.components.edible.hungervalue = IA_VEGGIES[name].hunger
    inst.components.edible.sanityvalue = IA_VEGGIES[name].sanity or 0      
    inst.components.edible.foodtype = FOODTYPE.VEGGIE

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(IA_VEGGIES[name].perishtime)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("stackable")
    if name ~= "pumpkin" and
    name ~= "eggplant" and
    name ~= "durian" and 
    name ~= "watermelon" then
      inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM
    end

    if name == "watermelon" then
      inst.components.edible.temperaturedelta = TUNING.COLD_FOOD_BONUS_TEMP
      inst.components.edible.temperatureduration = TUNING.FOOD_TEMP_BRIEF
    end

    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst, name)

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    ---------------------        

    inst:AddComponent("bait")

    ------------------------------------------------
    inst:AddComponent("tradable")

    ------------------------------------------------  

    inst:AddComponent("cookable")
    inst.components.cookable.product = name.."_cooked"

    MakeHauntableLaunchAndPerish(inst)

    return inst
  end

  local function fn_cooked()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank(name)
    inst.AnimState:SetBuild(name)
    inst.AnimState:PlayAnimation("cooked")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("perishable")
    inst.components.perishable:SetPerishTime(IA_VEGGIES[name].cooked_perishtime)
    inst.components.perishable:StartPerishing()
    inst.components.perishable.onperishreplacement = "spoiled_food"

    inst:AddComponent("edible")
    inst.components.edible.healthvalue = IA_VEGGIES[name].cooked_health
    inst.components.edible.hungervalue = IA_VEGGIES[name].cooked_hunger
    inst.components.edible.sanityvalue = IA_VEGGIES[name].cooked_sanity or 0
    inst.components.edible.foodtype = FOODTYPE.VEGGIE

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst, name.."_cooked")

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    ---------------------        

    inst:AddComponent("bait")

    ------------------------------------------------
    inst:AddComponent("tradable")

    MakeHauntableLaunchAndPerish(inst)

    return inst
  end

  local base = Prefab(name, fn, assets, prefabs)
  local cooked = Prefab(name.."_cooked", fn_cooked, assets_cooked)
  local seeds = has_seeds and Prefab(name.."_seeds", fn_seeds, assets_seeds) or nil

  return base, cooked, seeds
end

local prefs = {}
for veggiename,veggiedata in pairs(IA_VEGGIES) do
  local veg, cooked, seeds = MakeVeggie(veggiename, veggiename ~= "berries" and veggiename ~= "cave_banana" and veggiename ~= "cactus_meat" and veggiename ~= "berries_juicy")
  table.insert(prefs, veg)
  table.insert(prefs, cooked)
  if seeds then
    table.insert(prefs, seeds)
  end
end

return unpack(prefs)%%+%%scripts/prefabs/ia_walls.lua%%-%%require "prefabutil"

local function OnIsPathFindingDirty(inst)
    if inst._ispathfinding:value() then
        if inst._pfpos == nil then
            inst._pfpos = inst:GetPosition()
            TheWorld.Pathfinder:AddWall(inst._pfpos:Get())
        end
    elseif inst._pfpos ~= nil then
        TheWorld.Pathfinder:RemoveWall(inst._pfpos:Get())
        inst._pfpos = nil
    end
end

local function InitializePathFinding(inst)
    inst:ListenForEvent("onispathfindingdirty", OnIsPathFindingDirty)
    OnIsPathFindingDirty(inst)
end

local function makeobstacle(inst)
    inst.Physics:SetActive(true)
    inst._ispathfinding:set(true)
end

local function clearobstacle(inst)
    inst.Physics:SetActive(false)
    inst._ispathfinding:set(false)
end

local anims =
{
    { threshold = 0, anim = "broken" },
    { threshold = 0.4, anim = "onequarter" },
    { threshold = 0.5, anim = "half" },
    { threshold = 0.99, anim = "threequarter" },
    { threshold = 1, anim = { "fullA", "fullB", "fullC" } },
}

local function resolveanimtoplay(inst, percent)
	local animname
    for i, v in ipairs(anims) do
        if percent <= v.threshold then
            if type(v.anim) == "table" then
                -- get a stable animation, by basing it on world position
                local x, y, z = inst.Transform:GetWorldPosition()
                local x = math.floor(x)
                local z = math.floor(z)
                local q1 = #v.anim + 1
                local q2 = #v.anim + 4
                local t = ( ((x%q1)*(x+3)%q2) + ((z%q1)*(z+3)%q2) )% #v.anim + 1
                animname = v.anim[t]
				break
            else
                animname = v.anim
				break
            end
        end
    end
	
    if animname and inst:HasTag("aquatic") then
        animname = "water_" .. animname
    end
	
	return animname
end

local function onhealthchange(inst, old_percent, new_percent)
    local anim_to_play = resolveanimtoplay(inst, new_percent)
    if new_percent > 0 then
        if old_percent <= 0 then
            makeobstacle(inst)
        end
        inst.AnimState:PlayAnimation(anim_to_play.."_hit")
        inst.AnimState:PushAnimation(anim_to_play, false)
    else
        if old_percent > 0 then
            clearobstacle(inst)
        end
        inst.AnimState:PlayAnimation(anim_to_play)
    end
end

local function keeptargetfn()
    return false
end

local function onload(inst)
    if inst.components.health:IsDead() then
        clearobstacle(inst)
    end
end

local function onremove(inst)
    inst._ispathfinding:set_local(false)
    OnIsPathFindingDirty(inst)
end

local function checkmaterialfn(inst, item)
    return not item:HasTag("wallbuilder") or item.prefab == inst.prefab .."_item"
end

function MakeWallType(data)
    local assets =
    {
        Asset("ANIM", "anim/wall.zip"),
        Asset("ANIM", "anim/wall_water.zip"),
        Asset("ANIM", "anim/wall_"..data.name..".zip"),
    }

    local prefabs =
    {
        "collapse_small",
        -- "brokenwall_"..data.name, --screw that, only used by ruins anyways
    }

    local function ondeploywall(inst, pt, deployer)
        --inst.SoundEmitter:PlaySound("dontstarve/creatures/spider/spider_egg_sack")
        local wall = SpawnPrefab("wall_"..data.name) 
        if wall ~= nil then 
            local x = math.floor(pt.x) + .5
            local z = math.floor(pt.z) + .5
            wall.Physics:SetCollides(false)
            wall.Physics:Teleport(x, 0, z)
            wall.Physics:SetCollides(true)
            inst.components.stackable:Get():Remove()
            
            if data.buildsound ~= nil then
                wall.SoundEmitter:PlaySound(data.buildsound)
            end
        end
    end

    local function onhammered(inst, worker)
        if data.maxloots ~= nil and data.loot ~= nil then
            local num_loots = math.max(1, math.floor(data.maxloots * inst.components.health:GetPercent()))
            for i = 1, num_loots do
                inst.components.lootdropper:SpawnLootPrefab(data.loot)
            end
        end

        local fx = SpawnPrefab("collapse_small")
        fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
        if data.material ~= nil then
            fx:SetMaterial(data.material)
        end

        inst:Remove()
    end
	
	-- local function ongusthammerfn(inst)
	    -- --onhammered(inst, nil)
	    -- inst.components.health:DoDelta(-data.windblown_damage, false, "wind")
	-- end

    local function itemfn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddNetwork()

        MakeInventoryPhysics(inst)

        inst:AddTag("wallbuilder")

        inst.AnimState:SetBank("wall")
        inst.AnimState:SetBuild("wall_"..data.name)
        inst.AnimState:PlayAnimation("idle")

		MakeInventoryFloatable(inst)
		inst.components.floater:UpdateAnimations("idle_water", "idle")

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst:AddComponent("stackable")
        inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

        inst:AddComponent("inspectable")
        inst:AddComponent("inventoryitem")

        inst:AddComponent("repairer")

        inst.components.repairer.repairmaterial = data.material
        inst.components.repairer.healthrepairvalue = data.maxhealth / 6

        -- if data.flammable then
            -- MakeSmallBurnable(inst, TUNING.MED_BURNTIME)
            -- MakeSmallPropagator(inst)

            -- inst:AddComponent("fuel")
            -- inst.components.fuel.fuelvalue = TUNING.SMALL_FUEL
        -- end

        inst:AddComponent("deployable")
        inst.components.deployable.ondeploy = ondeploywall
        inst.components.deployable:SetDeployMode(DEPLOYMODE.WALL)
		if data.waterwall then
			inst.components.deployable.candeployonland = false
			inst.components.deployable.candeployonbuildableocean = true
			inst.components.deployable.candeployonunbuildableocean = true
		end
		
        MakeHauntableLaunch(inst)

        return inst
    end

    local function onhit(inst)
		if data.destroysound ~= nil then
			inst.SoundEmitter:PlaySound(data.destroysound)
		elseif data.material ~= nil then
            inst.SoundEmitter:PlaySound("dontstarve/common/destroy_"..data.material)
        end

        local healthpercent = inst.components.health:GetPercent()
        if healthpercent > 0 then
            local anim_to_play = resolveanimtoplay(inst, healthpercent)
            inst.AnimState:PlayAnimation(anim_to_play.."_hit")
            inst.AnimState:PushAnimation(anim_to_play, inst:HasTag("aquatic"))
        end
    end

    local function onrepaired(inst)
        if data.buildsound ~= nil then
            inst.SoundEmitter:PlaySound(data.buildsound)
        end
        makeobstacle(inst)
    end

    local function fn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddSoundEmitter()
        inst.entity:AddNetwork()

        inst.Transform:SetEightFaced()

        MakeObstaclePhysics(inst, .5)
        inst.Physics:SetDontRemoveOnSleep(true)

        --inst.Transform:SetScale(1.3,1.3,1.3)

        inst:AddTag("wall")
        inst:AddTag("noauradamage")
        inst:AddTag("nointerpolate")

        inst.AnimState:SetBank(data.waterwall and "wall_water" or "wall")
        inst.AnimState:SetBuild("wall_"..data.name)
        inst.AnimState:PlayAnimation(data.waterwall and "water_half" or "half")

        for i, v in ipairs(data.tags) do
            inst:AddTag(v)
        end
		if data.waterwall then
			inst:AddTag("aquatic")
		end

        MakeSnowCoveredPristine(inst)

        inst._pfpos = nil
        inst._ispathfinding = net_bool(inst.GUID, "_ispathfinding", "onispathfindingdirty")
        makeobstacle(inst)
        --Delay this because makeobstacle sets pathfinding on by default
        --but we don't to handle it until after our position is set
        inst:DoTaskInTime(0, InitializePathFinding)

        inst.OnRemoveEntity = onremove

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

		if data.waterwall then
			inst:AddComponent("waveobstacle")
		end
		
        inst:AddComponent("inspectable")
        inst:AddComponent("lootdropper")

        inst:AddComponent("repairable")
        inst.components.repairable.repairmaterial = data.material
        inst.components.repairable.onrepaired = onrepaired
        inst.components.repairable.checkmaterialfn = checkmaterialfn

        inst:AddComponent("combat")
        inst.components.combat:SetKeepTargetFunction(keeptargetfn)
        inst.components.combat.onhitfn = onhit

        inst:AddComponent("health")
        inst.components.health:SetMaxHealth(data.maxhealth)
        inst.components.health:SetCurrentHealth(data.maxhealth * .5)
        inst.components.health.ondelta = onhealthchange
        inst.components.health.nofadeout = true
        inst.components.health.canheal = false

        -- if data.flammable then
            -- MakeMediumBurnable(inst)
            -- MakeLargePropagator(inst)
            -- inst.components.burnable.flammability = .5
        -- else
            inst.components.health.fire_damage_scale = 0
        -- end

        inst:AddComponent("workable")
        inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
        inst.components.workable:SetWorkLeft(3)
        inst.components.workable:SetOnFinishCallback(onhammered)
        inst.components.workable:SetOnWorkCallback(onhit) 

		-- if data.windblown_speed and data.windblown_fall_chance and data.windblown_damage then
		    -- inst:AddComponent("blowinwindgust")
		    -- inst.components.blowinwindgust:SetWindSpeedThreshold(data.windblown_speed)
		    -- inst.components.blowinwindgust:SetDestroyChance(data.windblown_fall_chance)
		    -- inst.components.blowinwindgust:SetDestroyFn(ongusthammerfn)
		    -- inst.components.blowinwindgust:Start()
		-- end
		
        MakeHauntableWork(inst)

        inst.OnLoad = onload

        MakeSnowCovered(inst)

        return inst
    end

    return Prefab("wall_"..data.name, fn, assets, prefabs),
        Prefab("wall_"..data.name.."_item", itemfn, assets, { "wall_"..data.name, "wall_"..data.name.."_item_placer" }),
        MakePlacer("wall_"..data.name.."_item_placer", "wall", "wall_"..data.name, "half", false, false, true, nil, nil, "eight")
end

local wallprefabs = {}

local walldata =
{
	{name = "limestone", material = MATERIALS.LIMESTONE, tags={"stone"}, loot = "coral", maxloots = 2, maxhealth=TUNING.LIMESTONEWALL_HEALTH, buildsound="dontstarve/common/place_structure_stone", destroysound="dontstarve/common/destroy_stone"},
	{name = "enforcedlimestone", material = MATERIALS.LIMESTONE, tags={"stone"}, loot = "coral", maxloots = 1, maxhealth=TUNING.ENFORCEDLIMESTONEWALL_HEALTH, buildsound="ia/creatures/seacreature_movement/water_emerge_lrg", destroysound="dontstarve/common/destroy_stone", waterwall = true},
}

for i, v in ipairs(walldata) do
    local wall, item, placer = MakeWallType(v)
    table.insert(wallprefabs, wall)
    table.insert(wallprefabs, item)
    table.insert(wallprefabs, placer)
end

return unpack(wallprefabs)
%%+%%scripts/prefabs/icemaker.lua%%-%%require "prefabutil"

local assets = {
	Asset("ANIM", "anim/icemachine.zip"),
}

local prefabs = {
	"collapse_small",
	"ice",
}

local MACHINESTATES = {
	ON = "_on",
	OFF = "_off",
}

local function spawnice(inst)
	inst:RemoveEventCallback("animover", spawnice)

    local ice = SpawnPrefab("ice")
    local pt = inst:GetPosition() + Vector3(0, 2, 0)
    ice.Transform:SetPosition(pt:Get())

    local angle = math.random() * 2 * PI
    local sp = 3 + math.random()
    ice.Physics:SetVel(sp * math.cos(angle), math.random() * 2 + 8, sp * math.sin(angle))
	ice.components.inventoryitem:SetLanded(false, true)

    --Machine should only ever be on after spawning an ice
	inst.components.fueled:StartConsuming()
	inst.AnimState:PlayAnimation("idle"..inst.machinestate, true)
end

local function onhammered(inst, worked)
	inst.components.lootdropper:DropLoot()
	local fx = SpawnPrefab("collapse_small")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
	fx:SetMaterial("metal")
	inst:Remove()
end

local function fueltaskfn(inst)
	inst.AnimState:PlayAnimation("use")
	inst.SoundEmitter:PlaySound("ia/common/icemachine_start")
	inst.components.fueled:StopConsuming() --temp pause fuel so we don't run out in the animation.
	inst:ListenForEvent("animover", spawnice)
end

local function OnAddFuel(inst)
	inst.SoundEmitter:PlaySound("dontstarve_DLC001/common/machine_fuel")
	inst.components.fueled:StartConsuming()
end

local function OnUpdateFueled(inst, dt)
	--TODO: summer season rate adjustment?
	inst.components.fueled.rate = 1
end

local function onhit(inst, worker)
	inst.AnimState:PlayAnimation("hit"..inst.machinestate)
	inst.AnimState:PushAnimation("idle"..inst.machinestate, true)
	inst:RemoveEventCallback("animover", spawnice)
	if inst.machinestate == MACHINESTATES.ON then
		inst.components.fueled:StartConsuming() --resume fuel consumption incase you were interrupted from fueltaskfn
	end
end

local function OnFuelSectionChange(newsection, oldsection, inst, doer)
	if newsection == 0 and oldsection > 0 then
		inst.machinestate = MACHINESTATES.OFF
		inst.AnimState:PlayAnimation("turn"..inst.machinestate)
		inst.AnimState:PushAnimation("idle"..inst.machinestate, true)
		inst.SoundEmitter:KillSound("loop")
		if inst.fueltask ~= nil then
			inst.fueltask:Cancel()
			inst.fueltask = nil
		end
	elseif newsection > 0 and oldsection == 0 then
		inst.machinestate = MACHINESTATES.ON
		inst.AnimState:PlayAnimation("turn"..inst.machinestate)
		inst.AnimState:PushAnimation("idle"..inst.machinestate, true)
		if not inst.SoundEmitter:PlayingSound("loop") then
			inst.SoundEmitter:PlaySound("ia/common/icemachine_lp", "loop")
		end
		if inst.fueltask == nil then
			inst.fueltask = inst:DoPeriodicTask(TUNING.ICEMAKER_SPAWN_TIME, fueltaskfn)
		end
	end
end


local SECTION_STATUS = {
    [0] = "OUT",
    [1] = "VERYLOW",
    [2] = "LOW",
    [3] = "NORMAL",
    [4] = "HIGH",
}

local function getstatus(inst)
    return SECTION_STATUS[inst.components.fueled:GetCurrentSection()]
end

local function onbuilt(inst)
	inst.AnimState:PlayAnimation("place")
	inst.AnimState:PushAnimation("idle"..inst.machinestate)
	inst.SoundEmitter:PlaySound("ia/common/icemaker_place")
end

local function onStartFlooded(inst)
	if inst.components.fueled then 
		inst.components.fueled.accepting = false
	end 
end 

local function onStopFlooded(inst)
	if inst.components.fueled then 
		inst.components.fueled.accepting = true
	end 
end 

local function fn(Sim)
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddMiniMapEntity()
	inst.entity:AddNetwork()

	inst.MiniMapEntity:SetIcon("icemachine.tex")

	inst.AnimState:SetBank("icemachine")
	inst.AnimState:SetBuild("icemachine")
	inst.AnimState:PushAnimation("idle"..MACHINESTATES.ON)

	MakeObstaclePhysics(inst, .4)

    inst:AddTag("structure")

	inst:AddComponent("floodable")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("lootdropper")

	inst:AddComponent("fueled")
	inst.components.fueled:SetTakeFuelFn(OnAddFuel)
	inst.components.fueled.accepting = true
	inst.components.fueled:SetSections(4)
	inst.components.fueled:SetSectionCallback(OnFuelSectionChange)
	inst.components.fueled:SetUpdateFn(OnUpdateFueled)
	inst.components.fueled.maxfuel = TUNING.ICEMAKER_FUEL_MAX
	inst.components.fueled:InitializeFuelLevel(TUNING.ICEMAKER_FUEL_MAX/2)
	inst.components.fueled:StartConsuming()

	inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = getstatus

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

	inst.machinestate = MACHINESTATES.ON
	inst:ListenForEvent("onbuilt", onbuilt)

	return inst
end

return Prefab("icemaker", fn, assets, prefabs),
		MakePlacer("icemaker_placer", "icemachine", "icemachine", "idle_off")
%%+%%scripts/prefabs/inventorywaterygrave.lua%%-%%local assets =
{
	Asset("ANIM", "anim/graves_water.zip"),
    Asset("ANIM", "anim/graves_water_crate.zip"),
}

local prefabs =
{
    "seaweed",
    "coral",
    "pirateghost"
}

for k= 1,NUM_TRINKETS do
    table.insert(prefabs, "trinket_"..tostring(k) )
end
for k= 13,23 do
    table.insert(prefabs, "trinket_ia_"..tostring(k) )
end

local anims =
{
    {idle = "idle1", pst = "fishing_pst1"},
    {idle = "idle2", pst = "fishing_pst2"},
    {idle = "idle3", pst = "fishing_pst3"},
    {idle = "idle4", pst = "fishing_pst4"},
    {idle = "idle5", pst = "fishing_pst5"},
}

local function ReturnChildren(inst)
    local toremove = {}
    for k, v in pairs(inst.components.childspawner.childrenoutside) do
        table.insert(toremove, v)
    end
    for i, v in ipairs(toremove) do
        if v:IsAsleep() then
            v:PushEvent("detachchild")
            v:Remove()
        else
            v.components.health:Kill()
        end
    end
end

local function spawnghost(inst, chance)
    if inst.ghost == nil and math.random() <= (chance or 1) then
        inst.ghost = SpawnPrefab("ghost")
        if inst.ghost ~= nil then
            local x, y, z = inst.Transform:GetWorldPosition()
            inst.ghost.Transform:SetPosition(x - .3, y, z - .3)
            inst:ListenForEvent("onremove", function() inst.ghost = nil end, inst.ghost)
            return true
        end
    end
    return false
end

--these things are common between waterygrave and inventorywaterygrave
local function onretrieve(inst, worker)
    -- inst:RemoveComponent("workable")

	if worker then
		if worker.components.sanity then
			worker.components.sanity:DoDelta(-TUNING.SANITY_SMALL)
		end

        inst.SoundEmitter:PlaySound("ia/common/loot_reveal")

		--[[if worker.components.inventory then
			local srcpos = Vector3(TheSim:GetScreenPos(worker.Transform:GetWorldPosition()))
			for i, prefab in ipairs(loot) do
				worker.components.inventory:GiveItem(prefab, nil, srcpos)
			end
		else
			local x, y, z = worker.Transform:GetWorldPosition()
			for i, prefab in ipairs(loot) do
				prefab.Transform:SetPosition(x, 0, z)

				local angle = math.random()*2*PI
				local speed = 1
				speed = speed * math.random()
				prefab.Physics:SetVel(speed*math.cos(angle), GetRandomWithVariance(16, 4), speed*math.sin(angle))

				if prefab.components.inventoryitem then
					prefab.components.inventoryitem:SetLanded(false, true)
				end
			end
		end]]
    end
    inst:Remove()
end

local function onfinishcallback(inst, worker)
	local pt = worker and worker:GetPosition() or nil

	if spawnghost(inst, .1) then
		if IsSpecialEventActive(SPECIAL_EVENTS.HALLOWED_NIGHTS) then
			inst.components.lootdropper:SpawnLootPrefab("halloween_ornament_1", pt) -- ghost
		end
	else -- no ghost
		inst.components.lootdropper:SpawnLootPrefab("seaweed", pt)
        if math.random() < 0.75 then
			inst.components.lootdropper:SpawnLootPrefab("coral", pt)
        end
        if math.random() < 0.5 then
			local item = PickRandomTrinket()
			if item ~= nil then
				inst.components.lootdropper:SpawnLootPrefab(item, pt)
			end
		end

		if IsSpecialEventActive(SPECIAL_EVENTS.HALLOWED_NIGHTS) then
			local ornament = math.random(NUM_HALLOWEEN_ORNAMENTS * 4)
			if ornament <= NUM_HALLOWEEN_ORNAMENTS then
				inst.components.lootdropper:SpawnLootPrefab("halloween_ornament_"..tostring(ornament), pt)
			end
			-- if TheWorld.components.specialeventsetup ~= nil then
				-- if math.random() < TheWorld.components.specialeventsetup.halloween_bat_grave_spawn_chance then
					-- local num_bats = 3
					-- for i = 1, num_bats do
						-- inst:DoTaskInTime(0.2 * i + math.random() * 0.3, function()
							-- local bat = SpawnPrefab("bat")
							-- local pos = FindNearbyLand(inst:GetPosition(), 3)
							-- bat.Transform:SetPosition(pos:Get())
							-- bat:PushEvent("fly_back")
						-- end)
					-- end

					-- TheWorld.components.specialeventsetup.halloween_bat_grave_spawn_chance = 0
				-- else
					-- TheWorld.components.specialeventsetup.halloween_bat_grave_spawn_chance = TheWorld.components.specialeventsetup.halloween_bat_grave_spawn_chance + 0.1 + (math.random() * 0.1)
				-- end
			-- end
		end
    end

    onretrieve(inst, worker)
end

local function oninvfinishcallback(inst, worker)
    local loot = {}
    if inst.sunkeninventory ~= nil then
        for k,v in pairs(inst.sunkeninventory) do
            local pref = SpawnPrefab(v.prefab)
            pref:SetPersistData(v.data, {})
            table.insert(loot, pref)
        end
    end
    onretrieve(inst, worker, loot)
end

local function onfullmoon(inst, isfullmoon)
    if isfullmoon then
        inst.components.childspawner:StartSpawning()
        inst.components.childspawner:StopRegen()
    else
        inst.components.childspawner:StopSpawning()
        inst.components.childspawner:StartRegen()
        ReturnChildren(inst)
    end
end

local function oninit(inst)
    inst:WatchWorldState("isfullmoon", onfullmoon)
    onfullmoon(inst, TheWorld.state.isfullmoon)
end

local function oninvsave(inst, data)
    data.sunkeninventory = inst.sunkeninventory
end

local function oninvload(inst, data)
    if data then
        inst.sunkeninventory = data.sunkeninventory
    end
end

local function commonfn(Sim)
    local inst = CreateEntity()

	inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()
    inst.entity:AddSoundEmitter()

    MakeObstaclePhysics(inst, 0.2)

    inst:AddTag("fishable") --Does NOT have the fishable component, but can be fished anyways.

    inst.anim = math.random(1, #anims)

    inst.AnimState:SetBank("graves_water")
    inst.AnimState:SetBuild("graves_water")
    inst.AnimState:PlayAnimation(anims[inst.anim].idle, true)
    --inst.AnimState:SetLayer(LAYER_WORLD_BACKGROUND)

	return inst
end

local function masterfn(inst)
    inst:AddComponent("inspectable")

    inst:AddComponent("lootdropper")

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.FISH)
    inst.components.workable:SetWorkLeft(1)

    inst:ListenForEvent("retrieve", function(inst)
        inst.AnimState:PlayAnimation(anims[inst.anim].pst, false)
        inst:ListenForEvent("animover", function(inst) inst:Hide() end)
    end)

end

local function gravefn()
    local inst = commonfn()

    inst:AddTag("waterygrave")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	masterfn(inst)

    inst.components.workable:SetOnFinishCallback(onfinishcallback)

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_SMALL)
    -- inst.components.hauntable:SetOnHauntFn(OnHaunt)

    inst:AddComponent("childspawner")
    inst.components.childspawner.childname = "pirateghost"
    inst.components.childspawner:SetMaxChildren(1)
    inst.components.childspawner:SetSpawnPeriod(10, 3)

    inst:DoTaskInTime(0, oninit)

    return inst
end

local function invgravefn(Sim)
    local inst = commonfn(Sim)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	masterfn(inst)

    inst.components.workable:SetOnFinishCallback(oninvfinishcallback)

    inst.sunkeninventory = {}

    inst.OnSave = oninvsave
    inst.OnLoad = oninvload

    return inst
end

return Prefab( "waterygrave", gravefn, assets, prefabs ),
    Prefab( "inventorywaterygrave", invgravefn, assets )
%%+%%scripts/prefabs/inv_bamboo.lua%%-%%local assets=
{
  Asset("ANIM", "anim/bamboo.zip"),
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)


  inst.AnimState:SetBank("bamboo")
  inst.AnimState:SetBuild("bamboo")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  --inst:AddComponent("edible")
  --inst.components.edible.foodtype = "WOOD"
  --inst.components.edible.woodiness = 10

  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = TUNING.MED_FUEL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

  MakeSmallBurnable(inst, TUNING.MED_BURNTIME)
  MakeSmallPropagator(inst)

  inst:AddComponent("inspectable")
  MakeInvItemIA(inst)

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "bamboo", fn, assets)

%%+%%scripts/prefabs/inv_vine.lua%%-%%local assets=
{
  Asset("ANIM", "anim/vine.zip"),
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("vine")
  inst.AnimState:SetBuild("vine")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)
  
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  --inst:AddComponent("edible")
  --inst.components.edible.foodtype = "WOOD"
  --inst.components.edible.woodiness = 10


  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = TUNING.MED_FUEL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL


  MakeSmallBurnable(inst, TUNING.MED_BURNTIME)
  MakeSmallPropagator(inst)

  ---------------------       

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst, "vine")

  -- inst:AddComponent("repairer")
  -- inst.components.repairer.repairmaterial = "wood"
  --inst.components.repairer.healthrepairvalue = TUNING.REPAIR_LOGS_HEALTH

  --inst:ListenForEvent("burnt", function(inst) inst.entity:Retire() end)

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "vine", fn, assets) 

%%+%%scripts/prefabs/jellyfish.lua%%-%%local assets =
{
  Asset('ANIM', 'anim/jellyfish.zip'),
  Asset("ANIM", "anim/meat_rack_food_sw.zip"),
}

local prefabs = 
{
  'jellyfish_planted',
}

local function playshockanim(inst)
  if inst:HasTag('aquatic') then
    inst.AnimState:PlayAnimation('idle_water_shock')
    inst.AnimState:PushAnimation('idle_water', true)
    inst.SoundEmitter:PlaySound("ia/creatures/jellyfish/electric_water")
  else
    inst.AnimState:PlayAnimation('idle_ground_shock')
    inst.AnimState:PushAnimation('idle_ground', true)
    inst.SoundEmitter:PlaySound("ia/creatures/jellyfish/electric_water")
  end
end

local function playdeadanim(inst)
  inst.AnimState:PlayAnimation('idle_ground', true)
end

local function removeifdropped(inst)
	if not inst.components.inventoryitem:IsHeld() then
		local replacement = SpawnPrefab('jellyfish_planted')
		replacement.Transform:SetPosition(inst.Transform:GetWorldPosition())
		inst:Remove()
	end
end

local function ondropped(inst)
	if inst.components.inventoryitem:IsHeld() then return end --KLEI'S FLOATER IMPLEMENTATION SUCKS -M
  if IsOnWater(inst) then
	inst:DoTaskInTime(0, removeifdropped) --KLEI'S BACKPACK IMPLEMENTATION SUCKS -M
  else
    local replacement = SpawnPrefab("jellyfish_dead")
    replacement.Transform:SetPosition(inst.Transform:GetWorldPosition())
    replacement.AnimState:PlayAnimation('death_ground', true)
    replacement:DoTaskInTime(2.5, playdeadanim)
    replacement.shocktask = replacement:DoPeriodicTask(math.random() * 10 + 5, playshockanim)
    replacement:AddTag('stinger')
    inst:Remove()
  end
end

local function ondroppeddead(inst)
  inst:AddTag('stinger')
  inst.shocktask = inst:DoPeriodicTask(math.random() * 10 + 5, playshockanim)
  inst.AnimState:PlayAnimation('idle_ground', true)
end

local function onpickup(inst, guy)
  if inst:HasTag('stinger') and guy.components.combat and guy.components.inventory then
    if not guy.components.inventory:IsInsulated() then
      guy.components.health:DoDelta(-TUNING.JELLYFISH_DAMAGE, nil, inst.prefab, nil, inst)
      guy.sg:GoToState('electrocute')
    end

    inst:RemoveTag('stinger')
  end

  if inst.shocktask then
    inst.shocktask:Cancel()
    inst.shocktask = nil
  end
end

local function commonfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	inst.AnimState:SetBank("jellyfish")
	inst.AnimState:SetBuild("jellyfish")

	inst.AnimState:SetRayTestOnBB(true)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )

	MakeInventoryPhysics(inst)

	return inst
end

local function masterfn(inst)

  MakeInvItemIA(inst)
  
  inst:AddComponent("inspectable")

  inst:AddComponent('tradable')
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

  return inst
end

local function default()
  local inst = commonfn()
  inst.AnimState:PlayAnimation('idle_ground', true)
  inst:AddTag('show_spoilage')
  inst:AddTag("small_livestock") -- "hungry" instead of "stale"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_ground")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  masterfn(inst)

    inst:AddComponent('perishable')
    inst.components.perishable:SetPerishTime(TUNING.PERISH_ONE_DAY * 1.5)
    inst.components.perishable.onperishreplacement = 'jellyfish_dead'
    inst.components.perishable:StartPerishing()

  inst.components.inventoryitem:SetOnDroppedFn(ondropped)
  inst.components.inventoryitem:SetOnPickupFn(onpickup)

	inst:ListenForEvent("on_landed", ondropped)

  inst:AddComponent('cookable')
  inst.components.cookable.product = 'jellyfish_cooked'

  inst:AddComponent('health')
  inst.components.health.murdersound = 'ia/creatures/jellyfish/death_murder'

  inst:AddComponent('lootdropper')
  inst.components.lootdropper:SetLoot({'jellyfish_dead'})

  return inst
end

local function dead()
  local inst = commonfn()

  inst.AnimState:PlayAnimation('idle_ground')

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_ground")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  masterfn(inst)

    inst:AddComponent('edible')
    inst.components.edible.foodtype = FOODTYPE.MEAT
    inst.components.edible.foodstate = 'COOKED'

    inst:AddComponent('perishable')
    inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
    inst.components.perishable.onperishreplacement = 'spoiled_food'
    inst.components.perishable:StartPerishing()

  inst.components.inventoryitem:SetOnDroppedFn(ondroppeddead)
  inst.components.inventoryitem:SetOnPickupFn(onpickup)

  inst:AddComponent('cookable')
  inst.components.cookable.product = 'jellyfish_cooked'

  inst:AddComponent('dryable')
  inst.components.dryable:SetProduct("jellyjerky")
  inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

  inst:AddComponent('stackable')
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end

local function cooked()
  local inst = commonfn()

  inst.AnimState:PlayAnimation('cooked')

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end
  
  masterfn(inst)

    inst:AddComponent('edible')
    inst.components.edible.foodtype = FOODTYPE.MEAT
    inst.components.edible.foodstate = 'COOKED'
    inst.components.edible.hungervalue = TUNING.CALORIES_MEDSMALL

    inst:AddComponent('perishable')
    inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
    inst.components.perishable.onperishreplacement = 'spoiled_food'
    inst.components.perishable:StartPerishing()

  inst:AddComponent('stackable')
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end

local function dried()
  local inst = commonfn()
  inst:AddTag('show_spoilage')

  inst.AnimState:SetBank('meat_rack_food')
  inst.AnimState:SetBuild('meat_rack_food_sw')
  inst.AnimState:PlayAnimation('idle_dried_jellyjerky')

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_dried_jellywater", "idle_dried_jellyjerky")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  masterfn(inst)

    inst:AddComponent('edible')
    inst.components.edible.foodtype = FOODTYPE.MEAT
    inst.components.edible.foodstate = 'DRIED'
    inst.components.edible.hungervalue = TUNING.CALORIES_MEDSMALL

    inst:AddComponent('perishable')
    inst.components.perishable:SetPerishTime(TUNING.PERISH_PRESERVED)
    inst.components.perishable.onperishreplacement = 'spoiled_food'
    inst.components.perishable:StartPerishing()

  inst:AddComponent('stackable')
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end

return Prefab( 'jellyfish', default, assets),
Prefab( 'jellyfish_dead', dead, assets),
Prefab( 'jellyfish_cooked', cooked, assets),
Prefab( 'jellyjerky', dried, assets)%%+%%scripts/prefabs/jellyfish_planted.lua%%-%%local assets = {
    Asset("Anim", "anim/jellyfish.zip")
}

local prefabs = {
    "jellyfish_dead"
}

local function onworked(inst, worker)
    --stupid DST change, explosives do a "work" check before an attack check, this is reversed in SW
    if not worker.components.explosive then
        if worker.components.inventory then
            local toGive = SpawnPrefab("jellyfish")
            worker.components.inventory:GiveItem(toGive, nil, inst:GetPosition())
            worker.SoundEmitter:PlaySound("ia/common/bugnet_inwater")
        end
        inst:Remove()
    end
end

local function onattacked(inst, data)
    if data.attacker.components.health then
        if (data.weapon == nil or (not (data.weapon.components.projectile) and not (data.weapon.components.weapon and data.weapon.components.weapon:CanRangedAttack()))) and
        (data.attacker:HasTag("player") and not data.attacker.components.inventory:IsInsulated()) then
            data.attacker.components.health:DoDelta(-TUNING.JELLYFISH_DAMAGE, nil, inst.prefab, nil, inst)
            data.attacker.sg:GoToState("electrocute")
        end
    end
end

local brain = require "brains/jellyfishbrain"
local function fn()
	local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	inst.AnimState:SetBank("jellyfish")
	inst.AnimState:SetBuild("jellyfish")
    inst.AnimState:PlayAnimation("idle", true)

    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)
	
    MakeCharacterPhysics(inst, 1, 0.5)
    inst.Transform:SetFourFaced()
    
    inst:AddTag("aquatic")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = TUNING.JELLYFISH_WALKSPEED

    inst:SetStateGraph("SGjellyfish")
    inst:SetBrain(brain)

    inst:AddComponent("combat")
    inst.components.combat:SetHurtSound("ia/creatures/jellyfish/hit")
    inst:ListenForEvent("attacked", onattacked)

    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.JELLYFISH_HEALTH)

    MakeMediumFreezableCharacter(inst, "jelly")

    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetLoot({"jellyfish_dead"})

    inst:AddComponent("inspectable")
    inst:AddComponent("knownlocations")

    inst:AddComponent("sleeper")
    inst.components.sleeper.onlysleepsfromitems = true

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.NET)
    inst.components.workable:SetWorkLeft(1)
    inst.components.workable:SetOnFinishCallback(onworked)

    return inst
end

return Prefab("jellyfish_planted", fn, assets, prefabs)%%+%%scripts/prefabs/jellyfish_spawner.lua%%-%%local prefabs = {
	"jellyfish_planted",
}

local function onspawned(inst, child)
	local pos = child:GetPosition()
	local offset = FindWaterOffset(pos, 2*math.pi*math.random(), 30*math.random(), 4)
	if offset then
		child.Transform:SetPosition((offset + pos):Get())
	end
	SpawnAt("splash_water_drop", child)
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
    --[[Non-networked entity]]

    inst:AddTag("CLASSIFIED")

    inst:AddComponent("childspawner")
    inst.components.childspawner.childname = "jellyfish_planted"
    inst.components.childspawner.spawnoffscreen = true
    inst.components.childspawner:SetRegenPeriod(60)
    inst.components.childspawner:SetSpawnPeriod(.1)
    inst.components.childspawner:SetMaxChildren(5)
    inst.components.childspawner:SetSpawnedFn(onspawned)
	inst.components.childspawner:StartSpawning()

    return inst
end

return Prefab( "jellyfish_spawner", fn, nil, prefabs)
%%+%%scripts/prefabs/jungletrees.lua%%-%%local assets =
{
  Asset("ANIM", "anim/tree_jungle_build.zip"),
  Asset("ANIM", "anim/tree_jungle_normal.zip"),
  Asset("ANIM", "anim/tree_jungle_short.zip"),
  Asset("ANIM", "anim/tree_jungle_tall.zip"),
  Asset("ANIM", "anim/cavein_dust_fx.zip"),
  Asset("SOUND", "sound/forest.fsb"),
}

local prefabs =
{
  "log",
  "jungletreeseed",
  "charcoal",
  -- "treeguard",
  "jungle_chop",
  "jungle_fall",
  "snake",
  "snake_poison",
  "cave_banana",
  "bird_egg",
}

local builds =
{
  normal = {
    file="tree_jungle_build",
    prefab_name="jungletree",
    regrowth_product="jungletree_short",
    regrowth_tuning=TUNING.EVERGREEN_REGROWTH,
    normal_loot = {"log", "log", "jungletreeseed"},
    short_loot = {"log"},
    tall_loot = {"log", "log", "log", "jungletreeseed", "jungletreeseed"},

    leif="leif",
  },
  --[[
	sparse = {
		file="evergreen_new_2",
		prefab_name="evergreen_sparse",
		normal_loot = {"log","log"},
		short_loot = {"log"},
		tall_loot = {"log", "log","log"},
		drop_pinecones=false,
		leif="leif_sparse",
	},
	]]
}

local function makeanims(stage)
  return {
    idle="idle_"..stage,
    sway1="sway1_loop_"..stage,
    sway2="sway2_loop_"..stage,
    chop="chop_"..stage,
    fallleft="fallleft_"..stage,
    fallright="fallright_"..stage,
    stump="stump_"..stage,
    burning="burning_loop_"..stage,
    burnt="burnt_"..stage,
    chop_burnt="chop_burnt_"..stage,
    idle_chop_burnt="idle_chop_burnt_"..stage,
    blown1="blown_loop_"..stage.."1",
    blown2="blown_loop_"..stage.."2",
    blown_pre="blown_pre_"..stage,
    blown_pst="blown_pst_"..stage
  }
end

local short_anims = makeanims("short")
local tall_anims = makeanims("tall")
local normal_anims = makeanims("normal")
local old_anims =
{
  idle="idle_old",
  sway1="idle_old",
  sway2="idle_old",
  chop="chop_old",
  fallleft="chop_old",
  fallright="chop_old",
  stump="stump_old",
  burning="idle_olds",
  burnt="burnt_tall",
  chop_burnt="chop_burnt_tall",
  idle_chop_burnt="idle_chop_burnt_tall",
  blown="blown_loop",
  blown_pre="blown_pre",
  blown_pst="blown_pst"
}

local function dig_up_stump(inst, chopper)
  inst.components.lootdropper:SpawnLootPrefab("log")
  inst:Remove()
end

local function chop_down_burnt_tree(inst, chopper)
  inst:RemoveComponent("workable")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeCrumble")
  inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  inst.AnimState:PlayAnimation(inst.anims.chop_burnt)
  RemovePhysicsColliders(inst)
  inst:ListenForEvent("animover", function() inst:Remove() end)
  inst.components.lootdropper:SpawnLootPrefab("charcoal")
  inst.components.lootdropper:DropLoot()
  if inst.pineconetask then
    inst.pineconetask:Cancel()
    inst.pineconetask = nil
  end
end

local function GetBuild(inst)
  local build = builds[inst.build]
  if build == nil then
    return builds["normal"]
  end
  return build
end

local burnt_highlight_override = {.5,.5,.5}
local function OnBurnt(inst, imm)

  local function changes()
    if inst.components.burnable then
      inst.components.burnable:Extinguish()
    end
    inst:RemoveComponent("burnable")
    inst:RemoveComponent("propagator")
    inst:RemoveComponent("growable")
    inst:RemoveComponent("blowinwindgust")
    inst:RemoveComponent("hauntable")
    inst:RemoveTag("shelter")
    inst:RemoveTag("fire")
    inst:RemoveTag("gustable")

    MakeHauntableWork(inst)

    inst.components.lootdropper:SetLoot({})

    if inst.components.workable then
      inst.components.workable:SetWorkLeft(1)
      inst.components.workable:SetOnWorkCallback(nil)
      inst.components.workable:SetOnFinishCallback(chop_down_burnt_tree)
    end
  end

  if imm then
    changes()
  else
    inst:DoTaskInTime( 0.5, changes)
  end
  inst.AnimState:PlayAnimation(inst.anims.burnt, true)
  inst:AddTag("burnt")

	inst.MiniMapEntity:SetIcon("jungletree_burnt.tex")

  inst.highlight_override = burnt_highlight_override
end

local function PushSway(inst)
  if math.random() > .5 then
    inst.AnimState:PushAnimation(inst.anims.sway1, true)
  else
    inst.AnimState:PushAnimation(inst.anims.sway2, true)
  end
end

local function Sway(inst)
  if math.random() > .5 then
    inst.AnimState:PlayAnimation(inst.anims.sway1, true)
  else
    inst.AnimState:PlayAnimation(inst.anims.sway2, true)
  end
  inst.AnimState:SetTime(math.random()*2)
end

local function SetShort(inst)
  inst.anims = short_anims

  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.JUNGLETREE_CHOPS_SMALL)
  end

  inst.components.lootdropper:SetLoot(GetBuild(inst).short_loot)

  if math.random() < 0.5 then
    for i = 1, TUNING.SNAKE_JUNGLETREE_AMOUNT_SMALL do
      if math.random() < 0.5 and TheWorld.state.cycles >= TUNING.SNAKE_POISON_START_DAY then
        inst.components.lootdropper:AddChanceLoot("snake_poison", TUNING.SNAKE_JUNGLETREE_POISON_CHANCE)
      else
        inst.components.lootdropper:AddChanceLoot("snake", TUNING.SNAKE_JUNGLETREE_CHANCE)
      end
    end
  end

  Sway(inst)
end

local function GrowShort(inst)
  inst.AnimState:PlayAnimation("grow_tall_to_short")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrowFromWilt")
  PushSway(inst)
end

local function SetNormal(inst)
  inst.anims = normal_anims

  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.JUNGLETREE_CHOPS_NORMAL)
  end

  inst.components.lootdropper:SetLoot(GetBuild(inst).normal_loot)

  if math.random() < 0.5 then
    for i = 1, TUNING.SNAKE_JUNGLETREE_AMOUNT_MED do
      if math.random() < 0.5 and TheWorld.state.cycles >= TUNING.SNAKE_POISON_START_DAY then
        inst.components.lootdropper:AddChanceLoot("snake_poison", TUNING.SNAKE_JUNGLETREE_POISON_CHANCE)
      else
        inst.components.lootdropper:AddChanceLoot("snake", TUNING.SNAKE_JUNGLETREE_CHANCE)
      end
    end
  else
    inst.components.lootdropper:AddChanceLoot("bird_egg", 1.0)
  end

  Sway(inst)
end

local function GrowNormal(inst)
  inst.AnimState:PlayAnimation("grow_short_to_normal")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function SetTall(inst)
  inst.anims = tall_anims
  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.JUNGLETREE_CHOPS_TALL)
  end
  inst.components.lootdropper:SetLoot(GetBuild(inst).tall_loot)

  if math.random() < 0.5 then
    for i = 1, TUNING.SNAKE_JUNGLETREE_AMOUNT_TALL do
      if math.random() < 0.5 and TheWorld.state.cycles >= TUNING.SNAKE_POISON_START_DAY then
        inst.components.lootdropper:AddChanceLoot("snake_poison", TUNING.SNAKE_JUNGLETREE_POISON_CHANCE)
      else
        inst.components.lootdropper:AddChanceLoot("snake", TUNING.SNAKE_JUNGLETREE_CHANCE)
      end
    end
  else
    if math.random() < 0.5 then
      inst.components.lootdropper:AddChanceLoot("bird_egg", 1.0)
    else
      inst.components.lootdropper:AddChanceLoot("cave_banana", 1.0)
    end
  end

  Sway(inst)
end

local function GrowTall(inst)
  inst.AnimState:PlayAnimation("grow_normal_to_tall")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function inspect_tree(inst)
  if inst:HasTag("burnt") then
    return "BURNT"
  elseif inst:HasTag("stump") then
    return "CHOPPED"
  end
end

local growth_stages =
{
  {name="short", time = function(inst) return GetRandomWithVariance(TUNING.JUNGLETREE_GROW_TIME[1].base, TUNING.JUNGLETREE_GROW_TIME[1].random) end, fn = function(inst) SetShort(inst) end,  growfn = function(inst) GrowShort(inst) end , leifscale=.7 },
  {name="normal", time = function(inst) return GetRandomWithVariance(TUNING.JUNGLETREE_GROW_TIME[2].base, TUNING.JUNGLETREE_GROW_TIME[2].random) end, fn = function(inst) SetNormal(inst) end, growfn = function(inst) GrowNormal(inst) end, leifscale=1 },
  {name="tall", time = function(inst) return GetRandomWithVariance(TUNING.JUNGLETREE_GROW_TIME[3].base, TUNING.JUNGLETREE_GROW_TIME[3].random) end, fn = function(inst) SetTall(inst) end, growfn = function(inst) GrowTall(inst) end, leifscale=1.25 },
  --{name="old", time = function(inst) return GetRandomWithVariance(TUNING.EVERGREEN_GROW_TIME[4].base, TUNING.EVERGREEN_GROW_TIME[4].random) end, fn = function(inst) SetOld(inst) end, growfn = function(inst) GrowOld(inst) end },
}


local function chop_tree(inst, chopper, chops)

  if chopper and chopper:HasTag("beaver") then
    inst.SoundEmitter:PlaySound("dontstarve/characters/woodie/beaver_chop_tree")
  else
    inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  end

  local fx = SpawnPrefab("jungle_chop")
  local x, y, z= inst.Transform:GetWorldPosition()
  fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

  inst.AnimState:PlayAnimation(inst.anims.chop)
  inst.AnimState:PushAnimation(inst.anims.sway1, true)

  --tell any nearby leifs to wake up
  local pt = Vector3(inst.Transform:GetWorldPosition())
  local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, TUNING.PALMTREEGUARD_REAWAKEN_RADIUS, {"treeguard"})
  for k,v in pairs(ents) do
    if v.components.sleeper and v.components.sleeper:IsAsleep() then
      v:DoTaskInTime(math.random(), function() v.components.sleeper:WakeUp() end)
    end
    v.components.combat:SuggestTarget(chopper)
  end
end

local function chop_down_tree(inst, chopper)
  inst:RemoveComponent("burnable")
  MakeSmallBurnable(inst)
  inst:RemoveComponent("propagator")
  MakeSmallPropagator(inst)
  inst:RemoveComponent("workable")
  inst:RemoveTag("shelter")
  inst:RemoveComponent("blowinwindgust")
  inst:RemoveTag("gustable")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treefall")
  local pt = Vector3(inst.Transform:GetWorldPosition())
  local hispos = Vector3(chopper.Transform:GetWorldPosition())

  local he_right = (hispos - pt):Dot(TheCamera:GetRightVec()) > 0

  if he_right then
    inst.AnimState:PlayAnimation(inst.anims.fallleft)
    inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
  else
    inst.AnimState:PlayAnimation(inst.anims.fallright)
    inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
  end

  local fx = SpawnPrefab("jungle_fall")
  local x, y, z= inst.Transform:GetWorldPosition()
  fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

  -- make snakes attack
  local snakes = TheSim:FindEntities(x,y,z, 2, {"snake"})
  for k, v in pairs(snakes) do
    if v.components.combat then
      v.components.combat:SetTarget(chopper)
    end
  end

  inst:DoTaskInTime(.4, function()
      ShakeAllCameras(CAMERASHAKE.FULL, .25, .03,
        inst.components.growable ~= nil and
        inst.components.growable.stage > 2 and .5 or .25,
        inst, 6)
    end)

  inst:RemoveComponent("hauntable")
  MakeHauntableIgnite(inst)

  RemovePhysicsColliders(inst)
  inst.AnimState:PushAnimation(inst.anims.stump)

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetOnFinishCallback(dig_up_stump)
  inst.components.workable:SetWorkLeft(1)

  inst:AddTag("stump")
  if inst.components.growable then
    inst.components.growable:StopGrowing()
  end

    inst.MiniMapEntity:SetIcon("jungletree_stump.tex")

  inst:AddTag("NOCLICK")
  inst:DoTaskInTime(2, function() inst:RemoveTag("NOCLICK") end)
end

local function chop_down_tree_leif(inst, chopper)
  chop_down_tree(inst, chopper)
end

local function tree_burnt(inst)
  OnBurnt(inst)
  inst.pineconetask = inst:DoTaskInTime(10,
    function()
      local pt = Vector3(inst.Transform:GetWorldPosition())
      if math.random(0, 1) == 1 then
        pt = pt + TheCamera:GetRightVec()
      else
        pt = pt - TheCamera:GetRightVec()
      end
      inst.components.lootdropper:DropLoot(pt)
      inst.pineconetask = nil
    end)
end

local function onhauntjungletree(inst, haunter)
  -- if math.random() <= TUNING.HAUNT_CHANCE_SUPERRARE and
  -- find_leif_spawn_target(inst) and
  -- not (inst:HasTag("burnt") or inst:HasTag("stump")) then

    -- inst.leifscale = GetGrowthStages(inst)[inst.components.growable.stage].leifscale or 1
    -- spawn_leif(inst)

    -- inst.components.hauntable.hauntvalue = TUNING.HAUNT_HUGE
    -- inst.components.hauntable.cooldown_on_successful_haunt = false
    -- return true
  -- end
  if inst.components.workable ~= nil and math.random() <= TUNING.HAUNT_CHANCE_OFTEN then
        inst.components.workable:WorkedBy(haunter, 1)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    end
    return false
end

local function handler_growfromseed (inst)
  inst.components.growable:SetStage(1)
  inst.AnimState:PlayAnimation("grow_seed_to_short")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function onsave(inst, data)
  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end

  if inst:HasTag("stump") then
    data.stump = true
  end

  if inst.build ~= "normal" then
    data.build = inst.build
  end
end

local function onload(inst, data)
  if data then
    if not data.build or builds[data.build] == nil then
      inst.build = "normal"
    else
      inst.build = data.build
    end

    if data.burnt then
      inst:AddTag("fire") -- Add the fire tag here: OnEntityWake will handle it actually doing burnt logic
    elseif data.stump then
      inst:RemoveComponent("burnable")
      MakeSmallBurnable(inst)
      inst:RemoveComponent("workable")
      inst:RemoveComponent("propagator")
      MakeSmallPropagator(inst)
      inst:RemoveComponent("growable")
      inst:RemoveComponent("hauntable")
      MakeHauntableIgnite(inst)
      RemovePhysicsColliders(inst)
      inst.AnimState:PlayAnimation(inst.anims.stump)
      inst:AddTag("stump")
      inst:RemoveTag("shelter")
      inst:RemoveTag("gustable")
      inst:RemoveComponent("blowinwindgust")
      inst:AddComponent("workable")
      inst.components.workable:SetWorkAction(ACTIONS.DIG)
      inst.components.workable:SetOnFinishCallback(dig_up_stump)
      inst.components.workable:SetWorkLeft(1)
    end
  end
end

local function OnEntitySleep(inst)
  local fire = false
  if inst:HasTag("fire") then
    fire = true
  end
  inst:RemoveComponent("burnable")
  inst:RemoveComponent("propagator")
  inst:RemoveComponent("inspectable")
  if fire then
    inst:AddTag("fire")
  end
end

local function OnEntityWake(inst)

  if not inst:HasTag("burnt") and not inst:HasTag("fire") then
    if not inst.components.burnable then
      if inst:HasTag("stump") then
        MakeSmallBurnable(inst)
      else
        MakeLargeBurnable(inst)
        inst.components.burnable:SetFXLevel(5)
        inst.components.burnable:SetOnBurntFn(tree_burnt)
      end
    end

    if not inst.components.propagator then
      if inst:HasTag("stump") then
        MakeSmallPropagator(inst)
      else
        MakeLargePropagator(inst)
      end
    end
  elseif not inst:HasTag("burnt") and inst:HasTag("fire") then
    OnBurnt(inst, true)
  end

  if not inst.components.inspectable then
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_tree
  end
end


local function makefn(build, stage, data)

  local function fn()
    local l_stage = stage
    if l_stage == 0 then
      l_stage = math.random(1,3)
    end

    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()

    local sound = inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .25)

    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("jungletree.tex")

    minimap:SetPriority(-1)

    inst:AddTag("tree")
	inst:AddTag("plant")
    inst:AddTag("workable")
    inst:AddTag("shelter")
    inst:AddTag("gustable")

    inst.build = build
    inst.AnimState:SetBuild(GetBuild(inst).file)
    inst.AnimState:SetBank("jungletree")

    inst:SetPrefabName( GetBuild(inst).prefab_name )
    inst:AddTag(GetBuild(inst).prefab_name)

    MakeSnowCoveredPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    local color = 0.5 + math.random() * 0.5
    inst.AnimState:SetMultColour(color, color, color, 1)

    MakeLargeBurnable(inst)
    inst.components.burnable:SetFXLevel(5)
    inst.components.burnable:SetOnBurntFn(tree_burnt)

    MakeLargePropagator(inst)

    -------------------
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_tree
    -------------------
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.CHOP)
    inst.components.workable:SetOnWorkCallback(chop_tree)
    inst.components.workable:SetOnFinishCallback(chop_down_tree_leif)

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetOnHauntFn(onhauntjungletree)

    -------------------
    inst:AddComponent("lootdropper")
    ---------------------
    inst:AddComponent("growable")
    inst.components.growable.stages = growth_stages
    inst.components.growable:SetStage(l_stage)
    inst.components.growable.loopstages = true
    inst.components.growable.springgrowth = true
    inst.components.growable:StartGrowing()

    inst.growfromseed = handler_growfromseed

--    inst:AddComponent("plantregrowth")
--    inst.components.plantregrowth:SetRegrowthRate(GetBuild(inst).regrowth_tuning.OFFSPRING_TIME)
--    inst.components.plantregrowth:SetProduct(GetBuild(inst).regrowth_product)
--    inst.components.plantregrowth:SetSearchTag(GetBuild(inst).prefab_name)

	MakeTreeBlowInWindGust(inst, TUNING.JUNGLETREE_WINDBLOWN_SPEED, TUNING.JUNGLETREE_WINDBLOWN_FALL_CHANCE)
	inst.PushSway = PushSway

    ---------------------
    --PushSway(inst)
    inst.AnimState:SetTime(math.random()*2)

    ---------------------

    inst.OnSave = onsave
    inst.OnLoad = onload

    MakeSnowCovered(inst, .01)
    ---------------------

    if data =="burnt"  then
      OnBurnt(inst)
    end

    if data =="stump"  then
      inst:RemoveComponent("burnable")
      MakeSmallBurnable(inst)
      inst:RemoveComponent("workable")
      inst:RemoveComponent("propagator")
      MakeSmallPropagator(inst)
      inst:RemoveComponent("growable")
      inst:RemoveComponent("blowinwindgust")
      inst:RemoveTag("gustable")
      RemovePhysicsColliders(inst)
      inst.AnimState:PlayAnimation(inst.anims.stump)
      inst:AddTag("stump")
      inst:AddComponent("workable")
      inst.components.workable:SetWorkAction(ACTIONS.DIG)
      inst.components.workable:SetOnFinishCallback(dig_up_stump)
      inst.components.workable:SetWorkLeft(1)
    end

    inst.OnEntitySleep = OnEntitySleep
    inst.OnEntityWake = OnEntityWake

    return inst
  end
  return fn
end

local function tree(name, build, stage, data)
  return Prefab(name, makefn(build, stage, data), assets, prefabs)
end

return tree("jungletree", "normal", 0),
tree("jungletree_normal", "normal", 2),
tree("jungletree_tall", "normal", 3),
tree("jungletree_short", "normal", 1),
tree("jungletree_burnt", "normal", 0, "burnt"),
tree("jungletree_stump", "normal", 0, "stump")
%%+%%scripts/prefabs/jungletreeseed.lua%%-%%require "prefabutil"
local assets =
{
  Asset("ANIM", "anim/jungletreeseed.zip"),
}

local function plant(inst, growtime)
	local sapling = SpawnPrefab("jungletreeseed_sapling")
	sapling:StartGrowing(growtime)
	sapling.Transform:SetPosition(inst.Transform:GetWorldPosition())
	sapling.SoundEmitter:PlaySound("dontstarve/wilson/plant_tree")
	inst:Remove()
end

local function ondeploy (inst, pt) 
  inst = inst.components.stackable:Get()
  inst.Transform:SetPosition(pt:Get() )
  local timeToGrow = GetRandomWithVariance(TUNING.JUNGLETREESEED_GROWTIME.base, TUNING.JUNGLETREESEED_GROWTIME.random)
  plant(inst, timeToGrow)

  --tell any nearby leifs to chill out
  local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, TUNING.LEIF_PINECONE_CHILL_RADIUS, {"leif"})

  local played_sound = false
  for k,v in pairs(ents) do

    local chill_chance = TUNING.LEIF_PINECONE_CHILL_CHANCE_FAR
    if distsq(pt, Vector3(v.Transform:GetWorldPosition())) < TUNING.LEIF_PINECONE_CHILL_CLOSE_RADIUS*TUNING.LEIF_PINECONE_CHILL_CLOSE_RADIUS then
      chill_chance = TUNING.LEIF_PINECONE_CHILL_CHANCE_CLOSE
    end

    if math.random() < chill_chance then
      if v.components.sleeper then
        v.components.sleeper:GoToSleep(1000)
      end
    else
      if not played_sound then
        v.SoundEmitter:PlaySound("dontstarve/creatures/leif/taunt_VO")
        played_sound = true
      end
    end

  end

end

-- local notags = {'NOBLOCK', 'player', 'FX'}
-- local function test_ground(inst, pt)
  -- local tiletype = GetGroundTypeAtPosition(pt)
  -- local ground_OK = tiletype ~= GROUND.ROCKY and tiletype ~= GROUND.ROAD and tiletype ~= GROUND.IMPASSABLE and tiletype ~= GROUND.MAGMAFIELD and
  -- tiletype ~= GROUND.UNDERROCK and tiletype ~= GROUND.WOODFLOOR and tiletype ~= GROUND.BEACH and 
  -- tiletype ~= GROUND.CARPET and tiletype ~= GROUND.CHECKER and tiletype < GROUND.UNDERGROUND and
  -- tiletype ~= GROUND.ASH and tiletype ~= GROUND.VOLCANO and tiletype ~= GROUND.VOLCANO_ROCK and tiletype ~= GROUND.BRICK_GLOW and
  -- inst:IsPosSurroundedByLand(pt.x, pt.y, pt.z, 1)

  -- if ground_OK then
    -- local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, 4, nil, notags) -- or we could include a flag to the search?
    -- local min_spacing = inst.components.deployable.min_spacing or 2

    -- for k, v in pairs(ents) do
      -- if v ~= inst and v:IsValid() and v.entity:IsVisible() and not v.components.placer and v.parent == nil then
        -- if distsq( Vector3(v.Transform:GetWorldPosition()), pt) < min_spacing*min_spacing then
          -- return false
        -- end
      -- end
    -- end
    -- return true
  -- end
  -- return false
-- end

-- backwards-compatibility
local function OnLoad(inst, data)
    if data ~= nil and data.growtime ~= nil then
        plant(inst, data.growtime)
    end
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("jungletreeseed")
  inst.AnimState:SetBuild("jungletreeseed")
  inst.AnimState:PlayAnimation("idle")

	inst:AddTag("deployedplant")
  inst:AddTag("cattoy")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  --inst:AddComponent("edible")
  --inst.components.edible.foodtype = "WOOD"
  --inst.components.edible.woodiness = 2

  inst:AddComponent("tradable")

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = TUNING.SMALL_FUEL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

  MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
  MakeSmallPropagator(inst)
  MakeHauntableLaunchAndPerish(inst)

  MakeInvItemIA(inst)
	inst.components.inventoryitem:SetSinks(true)

  inst:AddComponent("deployable")
  inst.components.deployable:SetDeployMode(DEPLOYMODE.PLANT)
  inst.components.deployable.ondeploy = ondeploy

  inst.OnLoad = OnLoad
  
  return inst
end


local function growtree(inst)
    local tree = SpawnPrefab("jungletree_short")
    if tree then
        tree.Transform:SetPosition(inst.Transform:GetWorldPosition())
        tree:growfromseed()
        inst:Remove()
    end
end

local function stopgrowing(inst)
    inst.components.timer:StopTimer("grow")
end

local function startgrowing(inst, growtime)
    if not inst.components.timer:TimerExists("grow") then
        growtime = growtime or GetRandomWithVariance(TUNING.JUNGLETREESEED_GROWTIME.base, TUNING.JUNGLETREESEED_GROWTIME.random)
        inst.components.timer:StartTimer("grow", growtime)
    end
end

local function ontimerdone(inst, data)
    if data.name == "grow" then
        growtree(inst)
    end
end

local function digup(inst, digger)
    inst.components.lootdropper:DropLoot()
    inst:Remove()
end

local function saplingfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst.AnimState:SetBank("jungletreeseed")
	inst.AnimState:SetBuild("jungletreeseed")
	inst.AnimState:PlayAnimation("idle_planted")

	-- inst:AddTag("jungletree")
	-- inst:AddTag("isgrowing")
	inst:AddTag("plant")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.StartGrowing = startgrowing

	inst:AddComponent("timer")
	inst:ListenForEvent("timerdone", ontimerdone)
	startgrowing(inst)

	inst:AddComponent("inspectable")

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetLoot({"twigs"})

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.DIG)
	inst.components.workable:SetOnFinishCallback(digup)
	inst.components.workable:SetWorkLeft(1)

	MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
	inst:ListenForEvent("onignite", stopgrowing)
	inst:ListenForEvent("onextinguish", startgrowing)
	MakeSmallPropagator(inst)

	MakeHauntableIgnite(inst)

	return inst
end


return Prefab( "jungletreeseed", fn, assets),
Prefab( "jungletreeseed_sapling", saplingfn, assets),
MakePlacer( "jungletreeseed_placer", "jungletreeseed", "jungletreeseed", "idle_planted" ) 


%%+%%scripts/prefabs/knightboat.lua%%-%%local assets =
{
    Asset("ANIM", "anim/knightboat.zip"),
	Asset("ANIM", "anim/knightboat_death.zip"),
    Asset("ANIM", "anim/knightboat_build.zip"),
}

local prefabs =
{
	"gears",
    "knightboat_cannonshot",
}

SetSharedLootTable("knightboat",
{
    {"gears",  1.00},
    {"gears",  0.66},
    {"gears",  0.33},
})

local SLEEP_DIST_FROMHOME = 1
local SLEEP_DIST_FROMTHREAT = 20
local MAX_CHASEAWAY_DIST = 40
local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 40

local function Retarget(inst)
    local notags = {"FX", "NOCLICK","INLIMBO", "CLASSIFIED", "chess"}
    local yestags = {"character", "monster"}
    local newtarget = FindEntity(inst, 25, function(guy)
            return inst.components.combat:CanTarget(guy)
    end, nil, notags, yestags)
    return newtarget
end

local function KeepTarget(inst, target)
    local selfpos = inst:GetPosition()
    local targetPos = target:GetPosition()
    return distsq(selfpos, targetPos) < MAX_CHASEAWAY_DIST*MAX_CHASEAWAY_DIST
end

local function OnAttacked(inst, data)
    local attacker = data and data.attacker
    if attacker and attacker:HasTag("chess") then return end
    inst.components.combat:SetTarget(attacker)
    inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("chess") end, MAX_TARGET_SHARES)
end

local function OnAttack(inst, data)
    local numshots = 3
    if data.target then
        for i = 0, numshots - 1 do
            local offset = Vector3(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
            inst:DoTaskInTime(FRAMES * 10 * i, function()
                inst.components.thrower:Throw(data.target:GetPosition() + offset)
            end)
        end
    end
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	inst.Transform:SetFourFaced()

	MakeCharacterPhysics(inst, 50, 1)

	inst:AddTag("monster")
    inst:AddTag("hostile")
    inst:AddTag("chess")
    inst:AddTag("knight")
    inst:AddTag("aquatic")

	inst.AnimState:SetBank("knightboat")
	inst.AnimState:SetBuild("knightboat_build")
	inst.AnimState:PlayAnimation("idle_loop")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("inspectable")

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = 4
    inst.components.locomotor.runspeed = 8

    inst:AddComponent("combat")
    inst.components.combat.hiteffectsymbol = "spring"
    inst.components.combat:SetKeepTargetFunction(KeepTarget)
    inst.components.combat:SetRetargetFunction(3, Retarget)
    inst.components.combat:SetDefaultDamage(0)
    inst.components.combat:SetAttackPeriod(6)
    inst.components.combat:SetRange(20, 25)
    inst.components.combat:SetHurtSound("ia/creatures/knight_steamboat/hit")

    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.KNIGHTBOAT_HEALTH)

    inst:AddComponent("thrower")
    inst.components.thrower.throwable_prefab = "knightboat_cannonshot"
    
    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetChanceLootTable("knightboat")

    inst:AddComponent("rowboatwakespawner")

    inst:AddComponent("knownlocations")
    inst:DoTaskInTime(1*FRAMES, function() inst.components.knownlocations:RememberLocation("home", inst:GetPosition(), true) end)

    inst:AddComponent("sleeper")
    inst.components.sleeper.onlysleepsfromitems = true 
    inst.components.sleeper:SetResistance(3)

    inst:SetStateGraph("SGknightboat")
    local brain = require "brains/knightboatbrain"
    inst:SetBrain(brain)

    -- MakeMediumBurnableCharacter(inst, "spring")
    MakeMediumFreezableCharacter(inst, "spring")
    
    inst:ListenForEvent("attacked", OnAttacked)
    inst:ListenForEvent("onattackother", OnAttack)

	return inst
end

return Prefab("knightboat", fn, assets, prefabs)
%%+%%scripts/prefabs/knightboat_cannon.lua%%-%%local assets=
{
	Asset("ANIM", "anim/coconut_cannon.zip"),
}

local prefabs = 
{
	"impact",
	"explode_small",
	"bombsplash",
}

local function onthrown(inst, thrower, pt, time_to_target)
    inst.Physics:SetFriction(.2)
	inst.Transform:SetFourFaced()
	inst:FacePoint(pt:Get())
    inst.AnimState:PlayAnimation("throw", true)

    local shadow = SpawnPrefab("warningshadow")
    shadow.Transform:SetPosition(pt:Get())
    shadow:shrink(time_to_target, 2, 0.5)

    local smoke =  SpawnPrefab("collapse_small")
    local x, y, z = inst.Transform:GetWorldPosition()
    y = y + 1

	inst.UpdateTask = inst:DoPeriodicTask(FRAMES, function()
		local pos = inst:GetPosition()
		if pos.y <= 0.3 then
		    local ents = TheSim:FindEntities(pos.x, 0, pos.z, TUNING.KNIGHTBOAT_RADIUS, nil, {"FX", "DECOR", "INLIMBO", "CLASSIFIED"})

		    for k,v in pairs(ents) do
	            if v.components.combat and v ~= inst then --For now I want knight boats to kill eachother
	                v.components.combat:GetAttacked(thrower, TUNING.KNIGHTBOAT_DAMAGE)
	            end
		    end
			inst.SoundEmitter:PlaySound("ia/common/cannon_hit")

			if inst:GetIsOnWater() then
				local splash = SpawnPrefab("bombsplash")
				splash.Transform:SetPosition(pos.x, pos.y, pos.z)

				inst.SoundEmitter:PlaySound("ia/common/cannon_impact")
				inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large")

			else
				inst.SoundEmitter:PlaySound("dontstarve/common/blackpowder_explo")
				local explode = SpawnPrefab("explode_small")
				explode.Transform:SetPosition(pos.x, pos.y, pos.z)
			end

			inst:Remove()
		end
	end)
end

local function onremove(inst)
	if inst.UpdateTask then
		inst.UpdateTask:Cancel()
	end
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)
	
	inst.AnimState:SetBank("coconut_cannon")
	inst.AnimState:SetBuild("coconut_cannon")
	inst.AnimState:PlayAnimation("throw", true)

	inst:AddTag("thrown")
	inst:AddTag("projectile")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("throwable")
	inst.components.throwable.onthrown = onthrown
	inst.components.throwable.random_angle = 0
	inst.components.throwable.max_y = 50

	inst.persists = false

    inst.OnRemoveEntity = onremove

	return inst
end

return Prefab( "knightboat_cannonshot", fn, assets, prefabs)%%+%%scripts/prefabs/lavaerupt.lua%%-%%local erupt_assets =
{
	Asset("ANIM", "anim/lava_erupt.zip"),
}

local bubble_assets =
{
	Asset("ANIM", "anim/lava_erupt.zip"),
	Asset("ANIM", "anim/lava_bubbling.zip"),
}

local function OnEntitySleep(inst)
	inst:Remove()
end

local function commonfn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst:AddTag("FX")

	return inst	
end

local function masterfn(inst)
	inst.persists = false

	inst.OnEntitySleep = OnEntitySleep

	inst:ListenForEvent("animover", function(inst) inst:Remove() end)

	return inst	
end

local function eruptfn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("lava_erupt")
	inst.AnimState:SetBuild("lava_erupt")
	inst.AnimState:PlayAnimation("idle")
	inst.SoundEmitter:PlaySound("ia/common/volcano/rock_launch")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst = masterfn(inst)

	return inst
end

local function bubblefn()
	local inst = commonfn()
	
	inst.AnimState:SetBank("lava_bubbling")
	inst.AnimState:SetBuild("lava_erupt")
	inst.AnimState:PlayAnimation("idle")
	inst.SoundEmitter:PlaySound("ia/amb/volcano/lava_bubbling")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst = masterfn(inst)

	return inst
end

return Prefab("lava_erupt", eruptfn, erupt_assets),
		Prefab("lava_bubbling", bubblefn, bubble_assets)%%+%%scripts/prefabs/leif_palm.lua%%-%%local brain = require "brains/treeguardbrain"

local assets =
{
  Asset("ANIM", "anim/treeguard_walking.zip"),
  Asset("ANIM", "anim/treeguard_actions.zip"),
  Asset("ANIM", "anim/treeguard_attacks.zip"),
  Asset("ANIM", "anim/treeguard_idles.zip"),
  Asset("ANIM", "anim/treeguard_build.zip"),
}

local prefabs =
{
  "meat",
  "log",
  "character_fire",
  "livinglog",
  "treeguard_coconut",
}

SetSharedLootTable( 'leif_palm',
  {
    {"livinglog",   1.0},
    {"livinglog",   1.0},
    {"livinglog",   1.0},
    {"livinglog",   1.0},
    {"livinglog",   1.0},
    {"livinglog",   1.0},
    {"monstermeat", 1.0},
    {"coconut",     1.0},
    {"coconut",     1.0},
  })

local function OnLoad(inst, data)
  if data and data.hibernate then
    inst.components.sleeper.hibernate = true
  end
  if data and data.sleep_time then
    inst.components.sleeper.testtime = data.sleep_time
  end
  if data and data.sleeping then
    inst.components.sleeper:GoToSleep()
  end
end

local function OnSave(inst, data)
  if inst.components.sleeper:IsAsleep() then
    data.sleeping = true
    data.sleep_time = inst.components.sleeper.testtime
  end

  if inst.components.sleeper:IsHibernating() then
    data.hibernate = true
  end
end

local function CalcSanityAura(inst, observer)

  if inst.components.combat.target then
    return -TUNING.SANITYAURA_LARGE
  else
    return -TUNING.SANITYAURA_MED
  end

  return 0
end

local function OnBurnt(inst)
  if inst.components.propagator and inst.components.health and not inst.components.health:IsDead() then
    inst.components.propagator.acceptsheat = true
  end
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
end

local function OnAttack(inst, data)
  local numshots = 3
  if data.target and data.target:IsValid() then
	-- local x, y, z = inst.Transform:GetWorldPosition()
    for i = 0, numshots - 1 do
      local offset = Vector3(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
		inst.components.thrower:Throw(data.target:GetPosition() + offset)
		-- local projectile = SpawnPrefab("treeguard_coconut")
		-- projectile.Transform:SetPosition(x, y, z)
		-- projectile.components.complexprojectile:Launch(data.target:GetPosition() + offset, inst)
    end
  end
end

local function SetRangeMode(inst)
  if inst.combatmode == "RANGE" then
    return
  end

  inst.combatmode = "RANGE"
  inst.components.combat:SetDefaultDamage(0)
  inst.components.combat:SetAttackPeriod(6)
  inst.components.combat:SetRange(20, 25)
  inst:ListenForEvent("onattackother", OnAttack)
end

local function SetMeleeMode(inst)
  if inst.combatmode == "MELEE" then
    return
  end

  inst.combatmode = "MELEE"
  inst.components.combat:SetDefaultDamage(TUNING.PALMTREEGUARD_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.PALMTREEGUARD_ATTACK_PERIOD)
  inst.components.combat:SetRange(20, 3)
  inst:RemoveEventCallback("onattackother", OnAttack)
end

local function fn(Sim)

  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()

  shadow:SetSize( 4, 1.5 )
  inst.Transform:SetFourFaced()

  inst.entity:AddNetwork()

  MakeCharacterPhysics(inst, 1000, .5)

  inst:AddTag("monster")
  inst:AddTag("hostile")
  inst:AddTag("leif")
  inst:AddTag("palmtree")
  inst:AddTag("tree")
  inst:AddTag("largecreature")
  inst:AddTag("epic")

  inst.AnimState:SetBank("treeguard")
  inst.AnimState:SetBuild("treeguard_build")
  inst.AnimState:PlayAnimation("idle_loop", true)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.walkspeed = 1.5

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aurafn = CalcSanityAura

  MakeLargeBurnableCharacter(inst, "marker")
  inst.components.burnable.flammability = TUNING.PALMTREEGUARD_FLAMMABILITY
  inst.components.burnable:SetOnBurntFn(OnBurnt)
  inst.components.propagator.acceptsheat = true

  MakeHugeFreezableCharacter(inst, "marker")

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.PALMTREEGUARD_HEALTH)

  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "marker"
  inst.components.combat:SetDefaultDamage(TUNING.PALMTREEGUARD_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.PALMTREEGUARD_ATTACK_PERIOD)
  inst.components.combat:SetRange(20, 25)
  inst.components.combat.playerdamagepercent = TUNING.PALMTREEGUARD_DAMAGE_PLAYER_PERCENT
  
    inst:AddComponent("thrower")
    inst.components.thrower.throwable_prefab = "treeguard_coconut"

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetResistance(3)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('leif_palm')

  inst:AddComponent("inspectable")
  inst.components.inspectable:RecordViews()

  inst:SetStateGraph("SGtreeguard")
  inst:SetBrain(brain)

  inst.OnLoad = OnLoad
  inst.OnSave = OnSave

  inst.SetRange = SetRangeMode
  inst.SetMelee = SetMeleeMode

  inst:ListenForEvent("attacked", OnAttacked)

  return inst
end

return Prefab( "leif_palm", fn, assets, prefabs)
%%+%%scripts/prefabs/limestonenugget.lua%%-%%local assets =
{
    Asset("ANIM", "anim/limestone.zip")
}

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
	inst.entity:AddNetwork()
    
    inst.AnimState:SetBank("limestone")
    inst.AnimState:SetBuild("limestone")
    inst.AnimState:PlayAnimation("idle")

    MakeInventoryPhysics(inst)

    inst:AddTag("molebait")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.ELEMENTAL
    inst.components.edible.hungervalue = 1
    inst:AddComponent("tradable")
    inst:AddComponent("bait")

	if IA_CONFIG.limestonerepair then
		inst:AddComponent("repairer")
		inst.components.repairer.repairmaterial = MATERIALS.LIMESTONE
		inst.components.repairer.workrepairvalue = TUNING.REPAIR_LIMESTONE_WORK
		inst.components.repairer.healthrepairvalue = TUNING.REPAIR_LIMESTONE_HEALTH
	end
	
	MakeHauntableLaunch(inst)

    return inst
end

return Prefab("limestonenugget", fn, assets)%%+%%scripts/prefabs/limpets.lua%%-%%local assets=
{
  Asset("ANIM", "anim/limpets.zip"),
}


local prefabs =
{
  "limpets_cooked",
}    

local function pristinefn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.AnimState:SetBank("limpets")
  inst.AnimState:SetBuild("limpets")
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst:AddTag("smallmeat")
  inst:AddTag("packimfood")
  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.forcequickeat = true

    return inst
end

local function masterfn(inst)
  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_TINY

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("bait")

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("tradable")
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
end

local function defaultfn()
  local inst = pristinefn()
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	masterfn(inst)

  inst.components.edible.healthvalue = 0
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.edible.sanityvalue = -TUNING.SANITY_SMALL


  inst:AddComponent("cookable")
  inst.components.cookable.product = "limpets_cooked"
  --inst:AddComponent("dryable")
  --inst.components.dryable:SetProduct("smallmeat_dried")
  --inst.components.dryable:SetDryTime(TUNING.DRY_FAST)
  return inst
end

local function cookedfn()
  local inst = pristinefn()
  inst.AnimState:PlayAnimation("cooked")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("cooked_water", "cooked")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	masterfn(inst)

  inst.components.inventoryitem.imagename = "limpets_cooked"
  
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)

  return inst
end

return Prefab("limpets", defaultfn, assets, prefabs),
Prefab("limpets_cooked", cookedfn, assets) 
%%+%%scripts/prefabs/livingjungletree.lua%%-%%local assets =
{
  Asset("ANIM", "anim/living_jungle_tree.zip"),
}

local prefabs =
{
  "livinglog",
}

local function chop_down_burnt_tree(inst, chopper)
  inst:RemoveComponent("workable")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeCrumble")          
  if not (chopper ~= nil and chopper:HasTag("playerghost")) then
    inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  end      
  inst.AnimState:PlayAnimation("chop_burnt_tall")
  RemovePhysicsColliders(inst)
  inst:ListenForEvent("animover", function() inst:Remove() end)
  inst.components.lootdropper:SpawnLootPrefab("charcoal")
  inst.components.lootdropper:DropLoot()
end

local function Extinguish(inst)
	if inst.components.burnable then
		inst.components.burnable:Extinguish()
	end
	inst:RemoveComponent("burnable")
	inst:RemoveComponent("propagator")
	inst:RemoveComponent("hauntable")
	MakeHauntableWork(inst)

	inst.components.lootdropper:SetLoot({})

	if inst.components.workable then
		inst.components.workable:SetWorkLeft(1)
		inst.components.workable:SetOnWorkCallback(nil)
		inst.components.workable:SetOnFinishCallback(chop_down_burnt_tree)
	end
end

local function OnBurnt(inst)
	inst:DoTaskInTime(.5, Extinguish)

  inst.AnimState:PlayAnimation("burnt_tall", true)

  inst.SoundEmitter:PlaySound("ia/common/living_jungle_tree/burn")

  inst.AnimState:SetRayTestOnBB(true);
  inst:AddTag("burnt")
end

local function ondug(inst)
	inst.components.lootdropper:SpawnLootPrefab("livinglog")
	inst:Remove()
end

local function makestump(inst, instant)
  inst:RemoveComponent("workable")
  inst:RemoveComponent("hauntable")
  MakeHauntableWork(inst)
  RemovePhysicsColliders(inst)
  if instant then
    inst.AnimState:PlayAnimation("stump")
  else
    inst.AnimState:PushAnimation("stump")	
  end
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetOnFinishCallback(ondug)
  inst.components.workable:SetWorkLeft(1)    
  inst:AddTag("stump")
end

local function onworked(inst, chopper, workleft)
    if not (chopper ~= nil and chopper:HasTag("playerghost")) then
        inst.SoundEmitter:PlaySound(
            chopper ~= nil and chopper:HasTag("beaver") and
            "dontstarve/characters/woodie/beaver_chop_tree" or
            "dontstarve/wilson/use_axe_tree"
        )
    end
	inst.SoundEmitter:PlaySound("ia/common/living_jungle_tree/hit")
	inst.AnimState:PlayAnimation("chop")
	inst.AnimState:PushAnimation("idle", true)
end

local function ShakeCamera(inst)
	ShakeAllCameras(CAMERASHAKE.FULL, .25, .03, 0.5, inst, 6)
end

local function onworkfinish(inst, chopper)
  inst.SoundEmitter:PlaySound("dontstarve/forest/treefall")
  local pt = Vector3(inst.Transform:GetWorldPosition())
  local hispos = Vector3(chopper.Transform:GetWorldPosition())
  local he_right = (hispos - pt):Dot(TheCamera:GetRightVec()) > 0

  inst.SoundEmitter:PlaySound("ia/common/living_jungle_tree/death")

  if he_right then
    inst.AnimState:PlayAnimation("fallleft")
    inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
  else
    inst.AnimState:PlayAnimation("fallright")
    inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
  end

	inst:DoTaskInTime(.4, ShakeCamera)

  makestump(inst)
end

local function onsave(inst, data)
  if inst:HasTag("stump") then
    data.stump = true
  end

  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end
end

local function onload(inst, data)
  if data and data.stump then
    makestump(inst, true)
  end

  if data and data.burnt then
    OnBurnt(inst)
  end
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()        
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon("livingjungletree.tex")

  inst:AddTag("tree")
	inst:AddTag("plant")
  inst:AddTag("workable")

  MakeObstaclePhysics(inst, .66)

  inst.AnimState:SetBank("living_jungle_tree")
  inst.AnimState:SetBuild("living_jungle_tree")
  inst.AnimState:PlayAnimation("idle", true)
  
  MakeSnowCoveredPristine(inst)
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"livinglog", "livinglog"})

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.CHOP)
  inst.components.workable:SetWorkLeft(TUNING.LIVINGJUNGLETREE_WORK)
  inst.components.workable:SetOnWorkCallback(onworked)
  inst.components.workable:SetOnFinishCallback(onworkfinish)

  MakeLargeBurnable(inst)
  inst.components.burnable:SetFXLevel(5)
  inst.components.burnable:SetOnBurntFn(OnBurnt)
  MakeLargePropagator(inst)
  MakeHauntableWorkAndIgnite(inst)

  MakeSnowCovered(inst, .01)

  inst.OnSave = onsave
  inst.OnLoad = onload

  return inst
end

return Prefab("livingjungletree", fn, assets, prefabs)
%%+%%scripts/prefabs/lobster.lua%%-%%local assets = {
    Asset("ANIM", "anim/lobster_build.zip"),
    Asset("ANIM", "anim/lobster_build_color.zip"),
    Asset("ANIM", "anim/lobster.zip"),
}

local prefabs = {
    "lobster_dead",
}

local brain = require "brains/lobsterbrain"

local function StartDay(inst)
    if inst:IsAsleep() and inst.components.homeseeker then
        inst.components.homeseeker:GoHome(true)
    end
end

local function OnCookedFn(inst)
    inst.SoundEmitter:PlaySound("ia/creatures/lobster/death")
end

local function OnAttacked(inst, data)
    local x,y,z = inst.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x,y,z, 30, {'lobster'}, {"INLIMBO"})
    
    local num_friends = 0
    local maxnum = 5
    for k,v in pairs(ents) do
        v:PushEvent("gohome")
        num_friends = num_friends + 1
        
        if num_friends > maxnum then
            break
        end
    end
end

local function CanBeAttacked(inst)
    return not IsOnWater(inst)
end

local function onpickup(inst)
    inst.components.timer:StopTimer("dryout")
end

local function onnolongerlanded(inst)
	inst:RemoveTag("aquatic")
	inst:RemoveTag("fireimmune")
	inst:RemoveTag("noattack")
end

local function onlanded(inst)
	if IsOnWater(inst) then
        inst:AddTag("aquatic")
        inst:AddTag("fireimmune")
        inst:AddTag("noattack")
	else
		onnolongerlanded(inst)
	end
end

local function ondrop(inst)
    local onwater = IsOnWater(inst)

    --See where it is dropped
    --Start "death" logic if dropped on ground
    --Release if dropped in water.

    if not onwater then
        inst.AnimState:SetMultColour(1, 1, 1, 1)
        inst.AnimState:SetBuild("lobster_build_color")
        inst.sg:GoToState("stunned")
        inst.components.timer:StartTimer("dryout", 15)
        inst:RemoveTag("fireimmune")
    else
        --Play splash
        SpawnPrefab("splash_water_drop").Transform:SetPosition(inst:GetPosition():Get())
        inst.AnimState:SetMultColour(1, 1, 1, .30)
        inst.AnimState:SetBuild("lobster_build")
        inst.sg:GoToState("idle")
        inst:AddTag("fireimmune")
    end
end

local function ontimerdone(inst, data)
    if data.name and data.name == "dryout" then
		-- TODO this causes the lobster to seemingly duplicate for a moment, try locking the loot on the pos?
        inst.components.health:Kill()
    end
end

local function onload(inst)
    if IsOnWater(inst) then
        inst:AddTag("aquatic")
        inst:AddTag("fireimmune")
        inst:AddTag("noattack")
    end
end

local function ShouldSleep(inst)
    return NocturnalSleepTest(inst) and inst:GetIsOnWater()
end

local function ShouldWake(inst)
    return NocturnalWakeTest(inst) or not inst:GetIsOnWater()
end

local function onsleep(inst)
    if not IsOnWater(inst) then
        inst.components.health:Kill()
    end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddPhysics()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst.Transform:SetFourFaced()

    MakeUnderwaterCharacterPhysics(inst, 1, 0.5)
    MakePoisonableCharacter(inst)

    inst.AnimState:SetBank("lobster")
    inst.AnimState:SetBuild("lobster_build")
    inst.AnimState:PlayAnimation("idle")
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)
    
    inst.AnimState:SetMultColour(1, 1, 1, .30)

    inst:AddTag("animal")
    inst:AddTag("prey")
    inst:AddTag("lobster")
    inst:AddTag("smallcreature")
    inst:AddTag("canbetrapped")
    inst:AddTag("packimfood")
    inst:AddTag("fireimmune")
    inst:AddTag("catfood")
    inst:AddTag("aquatic")

    --cookable (from cookable component) added to pristine state for optimization
    inst:AddTag("cookable")

    MakeFeedableSmallLivestockPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        function inst.OnEntityReplicated(inst)
            inst.replica.combat.canbeattackedfn = CanBeAttacked
        end
        return inst
    end

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = TUNING.LOBSTER_WALK_SPEED
    inst.components.locomotor.runspeed = TUNING.LOBSTER_RUN_SPEED
    inst:SetStateGraph("SGlobster")

    inst:SetBrain(brain)
    
    inst:AddComponent("eater")
    inst.components.eater:SetDiet({FOODTYPE.MEAT}, {FOODTYPE.MEAT})

    MakeInvItemIA(inst)
    inst.components.inventoryitem.nobounce = true
    inst.components.inventoryitem.canbepickedup = false
    inst.components.inventoryitem.canbepickedupalive = true
	inst.components.inventoryitem:SetSinks(false)
    inst.components.inventoryitem:SetOnPickupFn(onpickup)

    inst:AddComponent("tradable")
    inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
    inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

    inst:AddComponent("cookable")
    inst.components.cookable.product = "lobster_dead_cooked"
    inst.components.cookable:SetOnCookedFn(OnCookedFn)
    
    inst:AddComponent("knownlocations")

    inst:AddComponent("combat")
    inst.components.combat.hiteffectsymbol = "chest"
    inst.replica.combat.canbeattackedfn = CanBeAttacked

    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.LOBSTER_HEALTH)
    inst.components.health.murdersound = "ia/creatures/lobster/death"
    
    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetLoot({"lobster_dead"})
    
    inst:AddComponent("inspectable")

    inst:AddComponent("sleeper")
    inst.components.sleeper:SetNocturnal(true)
    inst.components.sleeper:SetWakeTest(ShouldWake)
    inst.components.sleeper:SetSleepTest(ShouldSleep)

    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_MEDIUM
    
    inst:AddComponent("timer")
    inst:ListenForEvent("timerdone", ontimerdone)

    MakeFeedableSmallLivestock(inst, TUNING.LOBSTER_PERISH_TIME, nil, ondrop)
    MakeSmallBurnableCharacter(inst, "chest")
    MakeTinyFreezableCharacter(inst, "chest")

    inst.no_wet_prefix = true
	inst:ListenForEvent("on_landed", onlanded)
	inst:ListenForEvent("on_no_longer_landed", onnolongerlanded)
    inst:ListenForEvent("attacked", OnAttacked)
    inst.OnLoad = onload

    inst:WatchWorldState("isday", function() StartDay(inst) end)
    inst:ListenForEvent("gotosleep", onsleep)

    return inst
end

return Prefab("lobster", fn, assets, prefabs)
%%+%%scripts/prefabs/lobsterhole.lua%%-%%local assets =
{
	Asset("ANIM", "anim/lobster_home.zip"),
}

local prefabs = 
{
	"lobster",
}

local function startspawning(inst)
	if inst.components.spawner and not TheWorld.state.isspring then
		if not inst.components.spawner:IsSpawnPending() then
			inst.components.spawner:SpawnWithDelay(10 + math.random(15))
		end
	end
end

local function stopspawning(inst)
	if inst.components.spawner then
		inst.components.spawner:CancelSpawning()
	end
end

local function onoccupied(inst)
	if not TheWorld.state.isday and not TheWorld.state.isspring then
		startspawning(inst)
	end
end

local function SetSpringMode(inst, force)
    if not inst.spring or force then
        stopspawning(inst)
        inst.springtask = nil
        inst.spring = true
    end
end

local function SetNormalMode(inst, force)
	if inst.spring or force then
        --inst.AnimState:PlayAnimation("idle")
        if not TheWorld.state.isday and inst.components.spawner and not inst.components.spawner:IsSpawnPending() then
            startspawning(inst)
        end
        inst.normaltask = nil
        inst.spring = false
	end
end

local function OnWake(inst)
    if inst.spring and inst.components.spawner and inst.components.spawner:IsOccupied() then
        if inst.components.spawner:IsSpawnPending() then
            stopspawning(inst)
        end
        if inst.springtask then
            inst.springtask:Cancel()
            inst.springtask = nil
        end
    end
end

local function fn(Sim)
	local inst = CreateEntity()

	inst.entity:AddTransform()
    inst.entity:AddNetwork()
    inst.entity:AddAnimState()
	inst.entity:AddMiniMapEntity()


	inst.AnimState:SetBank("lobster_home")
	inst.AnimState:SetBuild("lobster_home")
	inst.AnimState:PlayAnimation("idle", true)
	inst.AnimState:SetLayer(LAYER_BACKGROUND)
	inst.AnimState:SetSortOrder(3)

	inst.MiniMapEntity:SetIcon("lobster.tex")

	inst.no_wet_prefix = true

    inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
        return inst
    end
	
	inst:AddComponent("spawner")
    inst.components.spawner:SetQueueSpawning(false)
	inst.components.spawner:Configure("lobster", TUNING.LOBSTER_RESPAWN_TIME)
	
	inst.components.spawner:SetOnOccupiedFn(onoccupied)
	inst.components.spawner:SetOnVacateFn(stopspawning)

	inst:WatchWorldState("phase", function()
        if TheWorld.state.isday then
            stopspawning(inst)
        elseif TheWorld.state.isdusk then
            startspawning(inst)
        end
    end)
	inst.spring = TheWorld.state.isspring
	if inst.spring then
		inst:DoTaskInTime(.1, function(inst) SetSpringMode(inst, true) end)
	else
		inst:DoTaskInTime(.1, function(inst) SetNormalMode(inst, true) end)
	end

    inst:WatchWorldState("israining", function(world, data)
        if TheWorld.state.isspring and not inst.spring then
            inst.springtask = inst:DoTaskInTime(math.random(3, 20), SetSpringMode)
        end
    end)

    inst:WatchWorldState("season", function(world, data)
        if not TheWorld.state.isspring and inst.spring then
            inst.normaltask = inst:DoTaskInTime(math.random(TUNING.MIN_LOBSTER_HOME_TRANSITION_TIME, TUNING.MAX_LOBSTER_HOME_TRANSITION_TIME), SetNormalMode)
        end
    end)


	inst.OnEntityWake = OnWake
	
	inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = function(inst)
		if TheWorld.state.isspring then
			return "SPRING"
		end
	end
	
	return inst
end

return Prefab("lobsterhole", fn, assets, prefabs) 
%%+%%scripts/prefabs/machete.lua%%-%%local assets = {
    machete = {
        Asset("ANIM", "anim/machete.zip"),
        Asset("ANIM", "anim/swap_machete.zip"),
    },
    machete_obsidian = {
        Asset("ANIM", "anim/machete_obsidian.zip"),
        Asset("ANIM", "anim/swap_machete_obsidian.zip"),
    },
    machete_golden = {
        Asset("ANIM", "anim/goldenmachete.zip"),
        Asset("ANIM", "anim/swap_goldenmachete.zip"),
    },
}

local function onfinished(inst)
    inst:Remove()
end

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_object", "swap_machete", "swap_machete")
    owner.AnimState:Show("ARM_carry")
    owner.AnimState:Hide("ARM_normal")
end

local function onunequip(inst, owner)
    owner.AnimState:Hide("ARM_carry")
    owner.AnimState:Show("ARM_normal")
end

local function pristinefn()
    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("machete")
    inst.AnimState:SetBuild("machete")
    inst.AnimState:PlayAnimation("idle")

    inst:AddTag("sharp")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	return inst
end

local function masterfn(inst)

    MakeInvItemIA(inst)

    inst:AddComponent("weapon")
    inst.components.weapon:SetDamage(TUNING.MACHETE_DAMAGE)

    -----
    inst:AddComponent("tool")
    inst.components.tool:SetAction(ACTIONS.HACK)
    -------
    inst:AddComponent("finiteuses")
    inst.components.finiteuses:SetMaxUses(TUNING.MACHETE_USES)
    inst.components.finiteuses:SetUses(TUNING.MACHETE_USES)
    inst.components.finiteuses:SetOnFinished( onfinished)
    inst.components.finiteuses:SetConsumption(ACTIONS.HACK, 1)
    -------
    inst:AddComponent("equippable")

    inst:AddComponent("inspectable")

    inst.components.equippable:SetOnEquip( onequip )

    inst.components.equippable:SetOnUnequip( onunequip)

    MakeHauntableLaunch(inst)

    return inst
end

local function normal()
    local inst = pristinefn()

    inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	
    return inst
end

local function onequipgold(inst, owner)
    owner.AnimState:OverrideSymbol("swap_object", "swap_goldenmachete", "swap_goldenmachete")
    owner.SoundEmitter:PlaySound("dontstarve/wilson/equip_item_gold")
    owner.AnimState:Show("ARM_carry")
    owner.AnimState:Hide("ARM_normal")
end

local function golden()
    local inst = pristinefn()

    inst.AnimState:SetBuild("goldenmachete")

    inst.entity:SetPristine()
	
    if not TheWorld.ismastersim then
        return inst
    end
	
	masterfn(inst)

    inst.components.finiteuses:SetConsumption(ACTIONS.HACK, 1 / TUNING.GOLDENTOOLFACTOR)
    inst.components.weapon.attackwear = 1 / TUNING.GOLDENTOOLFACTOR
    inst.components.equippable:SetOnEquip(onequipgold)

    return inst
end

local function onequipobsidian(inst, owner)
    owner.AnimState:OverrideSymbol("swap_object", "swap_machete_obsidian", "swap_machete")
    owner.AnimState:Show("ARM_carry")
    owner.AnimState:Hide("ARM_normal")
end

local function obsidian()
    local inst = pristinefn()

    inst.AnimState:SetBuild("machete_obsidian")
    inst.AnimState:SetBank("machete_obsidian")

    MakeObsidianToolPristine(inst)

    inst.entity:SetPristine()
	
    if not TheWorld.ismastersim then
        return inst
    end
	
	masterfn(inst)

    inst:AddComponent("waterproofer")
    inst.components.waterproofer:SetEffectiveness(0)

    MakeObsidianTool(inst, "machete")

    inst.components.tool:SetAction(ACTIONS.HACK, TUNING.OBSIDIANTOOL_WORK)

    inst.components.finiteuses:SetConsumption(ACTIONS.HACK, 1 / TUNING.OBSIDIANTOOLFACTOR)
    inst.components.weapon.attackwear = 1 / TUNING.OBSIDIANTOOLFACTOR
    inst.components.equippable:SetOnEquip(onequipobsidian)

    return inst
end

return Prefab("machete", normal, assets.machete),
    Prefab("goldenmachete", golden, assets.machete_golden),
    Prefab("obsidianmachete", obsidian, assets.machete_obsidian)%%+%%scripts/prefabs/magic_seal.lua%%-%%local assets=
{
	Asset("ANIM", "anim/seal_of_approval.zip"),
}

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("seal_of_approval")
    inst.AnimState:SetBuild("seal_of_approval")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    return inst
end

return Prefab("magic_seal", fn, assets)%%+%%scripts/prefabs/magma_rocks.lua%%-%%local assets =
{
  Asset("ANIM", "anim/rock_magma_gold.zip"),
  Asset("ANIM", "anim/rock_magma.zip"),
  Asset("MINIMAP_IMAGE", "rockmagma"),
}

local prefabs =
{
  "rocks",
  "nitre",
  "flint",
  "goldnugget",
  "redgem",
  "bluegem",
  "flamegeyser"
}

local loot_table =
{
  ["rocks"] = 0.75,
  ["flint"] = 0.25,
  ["nitre"] = 0.25,
  ["redgem"] = 0.0025,
  ["bluegem"] = 0.005,
}

local function GetLoot(loot_table, num)

  local total = 0
  for k,v in pairs(loot_table) do
    total = total + v
  end

  local loot = {}

  for i = 1, num do
    local rand = math.random() * total
    for k,v in pairs(loot_table) do
      rand = rand - v
      if rand <= 0 then
        table.insert(loot, k)
        break
      end
    end
  end

  return loot
end

local STAGES =
{
  {
    animation = "low",
    work = 2,
    stage_initfn = function(inst)
      --if math.random() < TUNING.FLAMEGEYSER_SPAWN_CHANCE then
      --	inst.components.workable:SetOnWorkCallback(onworkedgeyser)
      --end
    end
  },
  {
    animation = "med",
    work = 4,
  },
  {
    animation = "full",
    work = 6,
  },
}


local function SetStage(inst, stage)
  inst.stage = stage
  inst.AnimState:PlayAnimation(STAGES[inst.stage].animation)
  --inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  if STAGES[inst.stage].stage_initfn ~= nil then
    STAGES[inst.stage].stage_initfn(inst)
  end
end

local function onworked(inst, worker, workleft)

  inst.SoundEmitter:PlaySound("ia/common/dig_rockpile")

  local nextStage = 3 
  if workleft <= 0 then 
    nextStage = 0
  elseif workleft <= 2 then 
    nextStage = 1
  elseif workleft <= 4 then 
    nextStage = 2
  end 

  local numDrops = inst.stage - nextStage

  local doGeyser = nextStage == 0 and math.random() < TUNING.FLAMEGEYSER_SPAWN_CHANCE

  if doGeyser then 
    local geyser = SpawnPrefab("flamegeyser")
    geyser.Transform:SetPosition(inst:GetPosition():Get())
    geyser:OnErupt()
  end 

  for i = 1, numDrops do 
    local loot = GetLoot(inst.loot, math.random(2,3))
    if doGeyser then 
      inst.components.lootdropper:ExplodeLoot(nil, 6 + (math.random() * 8), loot)
    else 
      inst.components.lootdropper:DropLoot(nil, loot)
    end 
  end 

  if nextStage ~= inst.stage then 
    if nextStage == 0 then
      if not doGeyser and inst.components.growable then
        inst.components.growable:SetStage(1)
      else
        inst:Remove()
      end
    else
      SetStage(inst, nextStage)
    end
  end 
end

local function SetEmpty(inst)
  local days = TheWorld.state.autumnlength + TheWorld.state.winterlength + TheWorld.state.springlength + TheWorld.state.summerlength
  inst.components.growable:StartGrowing(days * TUNING.TOTAL_DAY_TIME)
  inst.Physics:SetCollides(false)
  inst:AddTag("NOCLICK")
  inst:Hide()
  inst.MiniMapEntity:SetEnabled(false)
end

local function SetFull(inst)
  SetStage(inst, 3)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)
  inst.components.growable:StopGrowing()
  inst.Physics:SetCollides(true)
  inst:RemoveTag("NOCLICK")
  inst:Show()
  inst.MiniMapEntity:SetEnabled(true)
end

local grow_stages =
{
  {name="empty", fn=SetEmpty},
  {name="full", fn=SetFull},
}

local function SetRegen(inst)
  inst:AddComponent("growable")
  inst.components.growable.stages = grow_stages
  inst.components.growable:SetStage(2)
  inst.components.growable.loopstages = false
  inst.components.growable.growonly = false
  inst.components.growable.springgrowth = false
  inst.components.growable.growoffscreen = true
end

local function OnSave(inst, data)
  data.stage = inst.stage
end

local function OnLoad(inst, data)
  if data and data.stage then
    SetStage(inst, data.stage)
    inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)
  end
  if data and data.regen and data.regen == true then
    SetRegen(inst)
  end
end

local function commonfn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()

  MakeObstaclePhysics(inst, 1)

  inst.MiniMapEntity:SetIcon( "rock_magma.tex" )

  inst.AnimState:SetBank("rock_magma")
  inst.AnimState:SetBuild("rock_magma")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  inst.components.inspectable.nameoverride = "magmarock"

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetOnWorkCallback(onworked)

  inst:AddComponent("lootdropper")
  inst.loot = loot_table

  inst.stage = 3
  SetStage(inst, inst.stage)

  inst.displaynamefn = function(inst) return STRINGS.NAMES["MAGMAROCK"] end

  inst.OnLoad = OnLoad
  inst.OnSave = OnSave

  return inst
end

local function full_fn()
  local inst = commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 3
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

local function med_fn()
  local inst = commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 2
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

local function low_fn()
  local inst = commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 1
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

----------GOLD ROCKS------------

local gold_loot_table =
{
  ["rocks"] = 0.75,
  ["flint"] = 0.25,
  ["goldnugget"] = 0.25,
  ["redgem"] = 0.0025,
  ["bluegem"] = 0.005,
}

local function gold_commonfn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()

  MakeObstaclePhysics(inst, 1)

  inst.MiniMapEntity:SetIcon( "rock_magma_gold.tex" )

  inst.AnimState:SetBank("rock_magma_gold")
  inst.AnimState:SetBuild("rock_magma_gold")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetWorkLeft(6)
  inst.components.workable:SetOnWorkCallback(onworked)

  inst:AddComponent("lootdropper")
  inst.loot = gold_loot_table

  inst.components.inspectable.nameoverride = "magmarock_gold"
  inst.displaynamefn = function(inst) return STRINGS.NAMES["MAGMAROCK_GOLD"] end

  inst.stage = 3
  SetStage(inst, inst.stage)

  inst.OnLoad = OnLoad
  inst.OnSave = OnSave

  return inst
end

local function gold_full_fn()
  local inst = gold_commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 3
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

local function gold_med_fn()
  local inst = gold_commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 2
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

local function gold_low_fn()
  local inst = gold_commonfn()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst.stage = 1
  SetStage(inst, inst.stage)
  inst.components.workable:SetWorkLeft(STAGES[inst.stage].work)

  return inst
end

return Prefab("magmarock_gold", gold_full_fn, assets, prefabs),
Prefab("magmarock_gold_full", gold_full_fn, assets, prefabs),
Prefab("magmarock_gold_med", gold_med_fn, assets, prefabs),
Prefab("magmarock_gold_low", gold_low_fn, assets, prefabs),
Prefab("magmarock", full_fn, assets, prefabs),
Prefab("magmarock_full", full_fn, assets, prefabs),
Prefab("magmarock_med", med_fn, assets, prefabs),
Prefab("magmarock_low", low_fn, assets, prefabs)%%+%%scripts/prefabs/mangrove.lua%%-%%local assets =
{
	Asset("ANIM", "anim/tree_mangrove_build.zip"),
	Asset("ANIM", "anim/tree_mangrove_normal.zip"),
	Asset("ANIM", "anim/tree_mangrove_short.zip"),
	Asset("ANIM", "anim/tree_mangrove_tall.zip"),
	-- Asset("ANIM", "anim/dust_fx.zip"),
	-- Asset("SOUND", "sound/forest.fsb"),
	-- Asset("MINIMAP_IMAGE", "mangrove"),
}

local prefabs =
{
	"log",
	"twigs",
	"charcoal",
	-- "treeguard",
	"mangrove_chop",
	"mangrove_fall"
}

local builds =
{
	normal = {
		file="tree_mangrove_build",
		prefab_name="mangrovetree",
		-- regrowth_product="jungletree_short",
		-- regrowth_tuning=TUNING.EVERGREEN_REGROWTH,
		normal_loot = {"log", "twigs", "twigs"},
		short_loot = {"log", "twigs"},
		tall_loot = {"log", "log", "twigs", "twigs", "twigs"},

		-- leif="poisonmangrove",
	}
}

local function makeanims(stage)
	return {
		idle="idle_"..stage,
		sway1="sway1_loop_"..stage,
		sway2="sway2_loop_"..stage,
		chop="chop_"..stage,
		fallleft="fallleft_"..stage,
		fallright="fallright_"..stage,
		stump="stump_"..stage,
		burning="burning_loop_"..stage,
		burnt="burnt_"..stage,
		chop_burnt="chop_burnt_"..stage,
		idle_chop_burnt="idle_chop_burnt_"..stage,
		blown1="blown_loop_"..stage.."1",
		blown2="blown_loop_"..stage.."2",
		blown_pre="blown_pre_"..stage,
		blown_pst="blown_pst_"..stage,
	}
end

local short_anims = makeanims("short")
local tall_anims = makeanims("tall")
local normal_anims = makeanims("normal")
local grow_stump_anims =
{
	"grow_stump_short_to_short",
	"grow_stump_short_to_short",
	"grow_stump_normal_to_short",
	"grow_stump_tall_to_short"
}

local make_tree
local make_stump

local function chop_down_burnt_tree(inst, chopper)
	inst:RemoveComponent("workable")
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeCrumble")
	inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
	inst.AnimState:PlayAnimation(inst.anims.chop_burnt)
	RemovePhysicsColliders(inst)
	inst:ListenForEvent("animover", function() inst:Remove() end)
	inst.components.lootdropper:SpawnLootPrefab("charcoal")
	inst.components.lootdropper:DropLoot()
	if inst.pineconetask then
		inst.pineconetask:Cancel()
		inst.pineconetask = nil
	end
end

local function GetBuild(inst)
	local build = builds[inst.build]
	if build == nil then
		return builds["normal"]
	end
	return build
end

local burnt_highlight_override = {.5,.5,.5}
local function OnBurnt(inst, imm)

	local function changes()
		if inst.components.burnable then
			inst.components.burnable:Extinguish()
		end
		inst:RemoveComponent("burnable")
		inst:RemoveComponent("propagator")
		inst:RemoveComponent("growable")
		inst:RemoveComponent("blowinwindgust")
		inst:RemoveTag("shelter")
		inst:RemoveTag("dragonflybait_lowprio")
		inst:RemoveTag("fire")
		--inst:RemoveTag("gustable")
		
		inst.components.lootdropper:SetLoot({})

		if inst.components.workable then
			inst.components.workable:SetWorkLeft(1)
			inst.components.workable:SetOnWorkCallback(nil)
			inst.components.workable:SetOnFinishCallback(chop_down_burnt_tree)
		end
	end

	if imm then
		changes()
	else
		inst:DoTaskInTime( 0.5, changes)
	end
	inst.AnimState:PlayAnimation(inst.anims.burnt, true)
	--inst.AnimState:SetRayTestOnBB(true);
	inst:AddTag("burnt")

	inst.MiniMapEntity:SetIcon("mangrovetree_burnt.tex")

	inst.highlight_override = burnt_highlight_override
end

local function PushSway(inst)
	if math.random() > .5 then
		inst.AnimState:PushAnimation(inst.anims.sway1, true)
	else
		inst.AnimState:PushAnimation(inst.anims.sway2, true)
	end
end

local function Sway(inst)
	if math.random() > .5 then
		inst.AnimState:PlayAnimation(inst.anims.sway1, true)
	else
		inst.AnimState:PlayAnimation(inst.anims.sway2, true)
	end
	inst.AnimState:SetTime(math.random()*2)
end

local function SetShort(inst)
	inst.anims = short_anims

	if inst.components.workable then
		inst.components.workable:SetWorkLeft(TUNING.MANGROVETREE_CHOPS_SMALL)
	end
	-- if inst:HasTag("shelter") then inst:RemoveTag("shelter") end

	inst.components.lootdropper:SetLoot(GetBuild(inst).short_loot)

	Sway(inst)
end

local function GrowShort(inst)
	if inst:HasTag("stump") then
		inst.AnimState:PlayAnimation(inst.anim_grow_stump)
	else
		inst.AnimState:PlayAnimation("grow_tall_to_short")
	end
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrowFromWilt")
	PushSway(inst)
end

local function SetNormal(inst)
	inst.anims = normal_anims

	if inst.components.workable then
		inst.components.workable:SetWorkLeft(TUNING.MANGROVETREE_CHOPS_NORMAL)
	end
	-- if inst:HasTag("shelter") then inst:RemoveTag("shelter") end

	inst.components.lootdropper:SetLoot(GetBuild(inst).normal_loot)

	Sway(inst)
end

local function GrowNormal(inst)
	inst.AnimState:PlayAnimation("grow_short_to_normal")
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
	PushSway(inst)
end

local function SetTall(inst)
	inst.anims = tall_anims
	if inst.components.workable then
		inst.components.workable:SetWorkLeft(TUNING.MANGROVETREE_CHOPS_TALL)
	end
	-- inst:AddTag("shelter")
	inst.components.lootdropper:SetLoot(GetBuild(inst).tall_loot)

	Sway(inst)
end

local function GrowTall(inst)
	inst.AnimState:PlayAnimation("grow_normal_to_tall")
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
	PushSway(inst)
end

local function SetStump(inst)
	if inst.anims == nil then
		inst.anims = normal_anims
	end
end

local function GrowStump(inst)
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
end

local function inspect_tree(inst)
	if inst:HasTag("burnt") then
		return "BURNT"
	elseif inst:HasTag("stump") then
		return "CHOPPED"
	end
end

local growth_stages =
{
	{name="stump", time = function(inst) return GetRandomWithVariance(TUNING.MANGROVETREE_GROW_TIME[4].base, TUNING.MANGROVETREE_GROW_TIME[4].random) end, fn = function(inst) SetStump(inst) end, growfn = function(inst) GrowStump(inst) end, leifscale=1 },
	{name="short", time = function(inst) return GetRandomWithVariance(TUNING.MANGROVETREE_GROW_TIME[1].base, TUNING.MANGROVETREE_GROW_TIME[1].random) end, fn = function(inst) SetShort(inst) end,  growfn = function(inst) GrowShort(inst) end , leifscale=.7 },
	{name="normal", time = function(inst) return GetRandomWithVariance(TUNING.MANGROVETREE_GROW_TIME[2].base, TUNING.MANGROVETREE_GROW_TIME[2].random) end, fn = function(inst) SetNormal(inst) end, growfn = function(inst) GrowNormal(inst) end, leifscale=1 },
	{name="tall", time = function(inst) return GetRandomWithVariance(TUNING.MANGROVETREE_GROW_TIME[3].base, TUNING.MANGROVETREE_GROW_TIME[3].random) end, fn = function(inst) SetTall(inst) end, growfn = function(inst) GrowTall(inst) end, leifscale=1.25 },	
}

local function growthfn(inst, last, current)
	--print("grow", last, current)
	if last == 1 then
		make_tree(inst)
	end
	if current == 4 then
		inst.components.growable:SetStage(1)
		inst.components.growable:StartGrowing()
	end
	inst.anim_grow_stump = grow_stump_anims[current]
end

local function chop_tree(inst, chopper, chops)

	if chopper and chopper:HasTag("beaver") then
		inst.SoundEmitter:PlaySound("dontstarve/characters/woodie/beaver_chop_tree")
	else
		inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
	end

	local fx = SpawnPrefab("mangrove_chop")
	local x, y, z= inst.Transform:GetWorldPosition()
	fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

	inst.AnimState:PlayAnimation(inst.anims.chop)
	inst.AnimState:PushAnimation(inst.anims.sway1, true)

	--tell any nearby leifs to wake up
	local pt = Vector3(inst.Transform:GetWorldPosition())
	local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, TUNING.PALMTREEGUARD_REAWAKEN_RADIUS, {"treeguard"})
	for k,v in pairs(ents) do
		if v.components.sleeper and v.components.sleeper:IsAsleep() then
			v:DoTaskInTime(math.random(), function() v.components.sleeper:WakeUp() end)
		end
		v.components.combat:SuggestTarget(chopper)
	end
end

local function chop_down_tree(inst, chopper)
	
	
	inst.SoundEmitter:PlaySound("dontstarve/forest/treefall")
	local pt = Vector3(inst.Transform:GetWorldPosition())
	local hispos = Vector3(chopper.Transform:GetWorldPosition())

	local he_right = (hispos - pt):Dot(TheCamera:GetRightVec()) > 0
	if he_right then
		inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
	else
		inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
	end

	make_stump(inst)

	if he_right then
		inst.AnimState:PlayAnimation(inst.anims.fallleft)
	else
		inst.AnimState:PlayAnimation(inst.anims.fallright)
	end
	

	local fx = SpawnPrefab("mangrove_fall")
	local x, y, z= inst.Transform:GetWorldPosition()
	fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

	-- make snakes attack
	--[[local x,y,z = inst.Transform:GetWorldPosition()
	local snakes = TheSim:FindEntities(x,y,z, 2, {"snake"})
	for k, v in pairs(snakes) do
		if v.components.combat then
			v.components.combat:SetTarget(chopper)
		end
	end]]

	inst:DoTaskInTime(.4, function()
		ShakeAllCameras(CAMERASHAKE.FULL,	0.25, 0.03,
		(inst.components.growable and inst.components.growable.stage > 2) and .5 or .25,
		inst, 6)
	end)

	--RemovePhysicsColliders(inst)
	inst.AnimState:PushAnimation(inst.anims.stump)

	inst:AddTag("NOCLICK")
	inst:DoTaskInTime(2, function() inst:RemoveTag("NOCLICK") end)
end

local function chop_down_tree_leif(inst, chopper)
	chop_down_tree(inst, chopper)
end

local function tree_burnt(inst)
	OnBurnt(inst)
	inst.pineconetask = inst:DoTaskInTime(10,
		function()
			local pt = Vector3(inst.Transform:GetWorldPosition())
			if math.random(0, 1) == 1 then
				pt = pt + TheCamera:GetRightVec()
			else
				pt = pt - TheCamera:GetRightVec()
			end
			inst.components.lootdropper:DropLoot(pt)
			inst.pineconetask = nil
		end)
end

local function onsave(inst, data)
	if inst:HasTag("burnt") or inst:HasTag("fire") then
		data.burnt = true
	end

	if inst:HasTag("stump") then
		data.stump = true
	end

	if inst.build ~= "normal" then
		data.build = inst.build
	end
end

local function onload(inst, data)
	if data then
		if not data.build or builds[data.build] == nil then
			inst.build = "normal"
		else
			inst.build = data.build
		end

		if data.burnt then
			inst:AddTag("fire") -- Add the fire tag here: OnEntityWake will handle it actually doing burnt logic
		elseif data.stump then
			make_stump(inst)
			inst.AnimState:PlayAnimation(inst.anims.stump)
		end
	end
end

local function OnEntitySleep(inst)
	local fire = false
	if inst:HasTag("fire") then
		fire = true
	end
	inst:RemoveComponent("burnable")
	inst:RemoveComponent("propagator")
	inst:RemoveComponent("inspectable")
	if fire then
		inst:AddTag("fire")
	end
end

local function OnEntityWake(inst)

	if not inst:HasTag("burnt") and not inst:HasTag("fire") then
		if not inst.components.burnable then
			if inst:HasTag("stump") then
				MakeSmallBurnable(inst)
			else
				MakeLargeBurnable(inst)
				inst.components.burnable:SetFXLevel(5)
				inst.components.burnable:SetOnBurntFn(tree_burnt)
			end
		end

		if not inst.components.propagator then
			if inst:HasTag("stump") then
				MakeSmallPropagator(inst)
			else
				MakeLargePropagator(inst)
			end
		end
	elseif not inst:HasTag("burnt") and inst:HasTag("fire") then
		OnBurnt(inst, true)
	end

	if not inst.components.inspectable then
		inst:AddComponent("inspectable")
		inst.components.inspectable.getstatus = inspect_tree
	end
end

make_tree = function(inst)
	inst:AddTag("tree")
	inst:AddTag("plant")
	inst:AddTag("workable")
	inst:AddTag("shelter")
	inst:RemoveTag("stump")

	-------------------
	inst:RemoveComponent("burnable")
	MakeLargeBurnable(inst)
	inst.components.burnable:SetFXLevel(5)
	inst.components.burnable:SetOnBurntFn(tree_burnt)

	inst:RemoveComponent("propagator")
	MakeLargePropagator(inst)

	-------------------
	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.CHOP)
	inst.components.workable:SetOnWorkCallback(chop_tree)
	inst.components.workable:SetOnFinishCallback(chop_down_tree_leif)

	MakeHauntableWork(inst, TUNING.HAUNT_CHANCE_OFTEN)
	
	MakeTreeBlowInWindGust(inst, TUNING.MANGROVETREE_WINDBLOWN_SPEED, TUNING.MANGROVETREE_WINDBLOWN_FALL_CHANCE)
	inst.PushSway = PushSway

	-- inst:AddComponent("waveobstacle")
	-- inst.components.waveobstacle:SetOnDestroyFn(OnGustFall)
	-- inst.components.waveobstacle:SetDestroyChance(0.1)
end

make_stump = function(inst)
	inst:AddTag("stump")
	inst:RemoveTag("tree")
	inst:RemoveTag("workable")
	inst:RemoveTag("shelter")

	inst.components.growable:SetStage(1)

	inst:RemoveComponent("burnable")
	MakeSmallBurnable(inst)
	inst:RemoveComponent("workable")
	inst:RemoveComponent("propagator")
	MakeSmallPropagator(inst)
	inst:RemoveComponent("blowinwindgust")
	inst:RemoveComponent("waveobstacle")

	--RemovePhysicsColliders(inst)
	inst.AnimState:PlayAnimation(inst.anims.stump, true)
end

local function makefn(build, stage, data)

	local function fn(Sim)
		local l_stage = stage
		if l_stage == 0 then
			l_stage = math.random(2,4)
		end

		local inst = CreateEntity()
		local trans = inst.entity:AddTransform()
		inst.entity:AddAnimState()

		local sound = inst.entity:AddSoundEmitter()
		inst.entity:AddNetwork()

		MakeObstaclePhysics(inst, 0.9)

		local minimap = inst.entity:AddMiniMapEntity()
		minimap:SetIcon("mangrove.tex")

		minimap:SetPriority(-1)

		inst.build = build
		inst.AnimState:SetBuild(GetBuild(inst).file)
		inst.AnimState:SetBank("tree_mangrove")
		--local color = 0.5 + math.random() * 0.5
		--inst.AnimState:SetMultColour(color, color, color, 1)
		
		inst:SetPrefabName( GetBuild(inst).prefab_name )
		inst:AddTag(GetBuild(inst).prefab_name)

		inst.anim_grow_stump = grow_stump_anims[l_stage]

		MakeSnowCoveredPristine(inst)
		
		inst.entity:SetPristine()

		if not TheWorld.ismastersim then
		  return inst
		end
		
		-------------------
		inst:AddComponent("inspectable")
		inst.components.inspectable.getstatus = inspect_tree

		-------------------
		inst:AddComponent("lootdropper")
		---------------------
		inst:AddComponent("growable")
		inst.components.growable.stages = growth_stages
		inst.components.growable:SetStage(l_stage)
		inst.components.growable.loopstages = false
		inst.components.growable.springgrowth = true
		inst.components.growable:SetOnGrowthFn(growthfn)
		inst.components.growable:StartGrowing()

		---------------------
		inst.AnimState:SetTime(math.random()*2)

		---------------------

		inst.OnSave = onsave
		inst.OnLoad = onload

		MakeSnowCovered(inst, .01)
		---------------------


		if data =="burnt"  then
			OnBurnt(inst)
		elseif data =="stump" or l_stage == 1 then
			make_stump(inst)
		else
			make_tree(inst)
		end

		inst.OnEntitySleep = OnEntitySleep
		inst.OnEntityWake = OnEntityWake


		return inst
	end
	return fn
end

local function tree(name, build, stage, data)
	return Prefab("forest/objects/trees/"..name, makefn(build, stage, data), assets, prefabs)
end

return tree("mangrovetree", "normal", 0),
		tree("mangrovetree_normal", "normal", 2),
		tree("mangrovetree_tall", "normal", 3),
		tree("mangrovetree_short", "normal", 1),
		tree("mangrovetree_burnt", "normal", 0, "burnt"),
		tree("mangrovetree_stump", "normal", 0, "stump")
%%+%%scripts/prefabs/mermfisher.lua%%-%%require "brains/mermfisherbrain"
require "stategraphs/SGmerm"

local assets=
{
  Asset("ANIM", "anim/merm_fisherman_build.zip"),
  Asset("ANIM", "anim/ds_pig_basic.zip"),
  Asset("ANIM", "anim/ds_pig_actions.zip"),
  Asset("ANIM", "anim/ds_pig_attacks.zip"),
  Asset("ANIM", "anim/merm_fishing.zip"),
  Asset("SOUND", "sound/merm.fsb"),
}

local prefabs =
{
  "fish_tropical",
}

local loot =
{
  "fish_tropical",
}

local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 40

local function ontalk(inst, script)
  inst.SoundEmitter:PlaySound("dontstarve/creatures/merm/idle")
end

local function ShouldSleep(inst)
  return TheWorld.state.isday
  and not (inst.components.combat and inst.components.combat.target)
  and not (inst.components.homeseeker and inst.components.homeseeker:HasHome() )
  and not (inst.components.burnable and inst.components.burnable:IsBurning() )
  and not (inst.components.freezable and inst.components.freezable:IsFrozen() )
end

local function ShouldWake(inst)
  return not TheWorld.state.isday
  or (inst.components.combat and inst.components.combat.target)
  or (inst.components.homeseeker and inst.components.homeseeker:HasHome() )
  or (inst.components.burnable and inst.components.burnable:IsBurning() )
  or (inst.components.freezable and inst.components.freezable:IsFrozen() )
end

local NO_TAGS = {"FX", "NOCLICK", "DECOR", "INLIMBO"}
local HOUSE_TAGS = {"mermhouse"} --TODO add this tag to mermhouse prefab

local function OnAttacked(inst, data)
  local attacker = data and data.attacker
  if attacker then
    inst.components.combat:SetTarget(attacker)

    local pt = inst:GetPosition()
    local homes = TheSim:FindEntities(pt.x, pt.y, pt.z, 20, HOUSE_TAGS, NO_TAGS)

    for k,v in pairs(homes) do
      if v and v.components.childspawner then
        v.components.childspawner:ReleaseAllChildren(attacker)
      end
    end

    inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, 
      function(dude) return dude:HasTag("merm")
		and dude.components.combat
		and dude.components.combat.defaultdamage > 0
      end, MAX_TARGET_SHARES)
  end
end

local function retargetfn(inst, target)
  local tar = FindEntity(inst, 8, nil, nil, {"merm"}, {"player", "monster", "character"})

  if tar and tar:IsValid() and inst.components.combat:CanTarget(tar) then
    return tar
  end
end

local function keeptargetfn(inst, target)
  return inst.components.combat:CanTarget(target) and target:GetPosition():Dist(inst:GetPosition()) < 12
end

local function ontimerdone(inst, data)
  if data.name == "fish" then
    inst.CanFish = true
  end
end

local function oncollect(inst)
  inst.CanFish = false

  if inst.components.timer:TimerExists("fish") then
    inst.components.timer:StopTimer("fish")
  end

  inst.components.timer:StartTimer("fish", TUNING.SEG_TIME * 2)
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()
  shadow:SetSize( 1.5, .75 )
  inst.Transform:SetFourFaced()

  inst.entity:AddNetwork()

  MakeCharacterPhysics(inst, 50, .5)

  inst.AnimState:SetBank("pigman")
  inst.AnimState:SetBuild("merm_fisherman_build")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor")
  inst.components.locomotor.runspeed = TUNING.MERM_RUN_SPEED
  inst.components.locomotor.walkspeed = TUNING.MERM_WALK_SPEED

  inst:SetStateGraph("SGmerm")
  inst.AnimState:Hide("hat")

  inst:AddTag("character")
  inst:AddTag("merm")
  inst:AddTag("mermfisher")
  inst:AddTag("wet")

  local brain = require "brains/mermfisherbrain"
  inst:SetBrain(brain)

  inst:AddComponent("eater")
  inst.components.eater:SetVegetarian()

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetWakeTest(ShouldWake)
  inst.components.sleeper:SetSleepTest(ShouldSleep)

  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "pig_torso"
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(keeptargetfn)

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.MERM_FISHER_HEALTH)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot(loot)

  inst:AddComponent("inventory")

  inst:AddComponent("inspectable")
  inst:AddComponent("knownlocations")

  inst:AddComponent("talker")
  inst.components.talker.ontalk = ontalk
  inst.components.talker.fontsize = 35
  inst.components.talker.font = TALKINGFONT
  inst.components.talker.offset = Vector3(0,-400,0)

  inst:AddComponent("fishingrod")
  inst.components.fishingrod:SetWaitTimes(TUNING.BIG_FISHING_ROD_MIN_WAIT_TIME, TUNING.BIG_FISHING_ROD_MAX_WAIT_TIME)
  inst.components.fishingrod:SetStrainTimes(0, 5)
  inst.components.fishingrod.basenibbletime = TUNING.BIG_FISHING_ROD_BASE_NIBBLE_TIME
  inst.components.fishingrod.nibbletimevariance = TUNING.BIG_FISHING_ROD_NIBBLE_TIME_VARIANCE
  inst.components.fishingrod.nibblestealchance = 0

  inst:AddComponent("timer")
  inst:ListenForEvent("timerdone", ontimerdone)

  inst:ListenForEvent("fishingcollect", oncollect)

  inst:AddComponent("named")
  inst.components.named.possiblenames = STRINGS.MERMNAMES
  inst.components.named:PickNewName()

  inst.CanFish = true

  MakeMediumBurnableCharacter(inst, "pig_torso")
  MakeMediumFreezableCharacter(inst, "pig_torso")

  inst:ListenForEvent("attacked", OnAttacked)

  return inst
end

return Prefab("mermfisher", fn, assets, prefabs)
%%+%%scripts/prefabs/mermhouse_fisher.lua%%-%%local assets =
{
  Asset("ANIM", "anim/merm_fisherman_house.zip"),
}

local prefabs =
{
  "mermfisher",
  "collapse_big",
}

local loot =
{
  "boards",
  "rocks",
  "fish_tropical",
}

local function onhammered(inst, worker)
  if inst:HasTag("fire") and inst.components.burnable then
    inst.components.burnable:Extinguish()
  end
  inst:RemoveComponent("childspawner")
  inst.components.lootdropper:DropLoot()
	local fx = SpawnPrefab("collapse_big")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
  inst:Remove()
end

local function onhit(inst, worker)
  if not inst:HasTag("burnt") then
    if inst.components.childspawner then
      inst.components.childspawner:ReleaseAllChildren(worker)
    end
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle")
  end
end

local function StartSpawning(inst)
  if not inst:HasTag("burnt") then
    if inst.components.childspawner and TheWorld.state.iswinter then
      inst.components.childspawner:StartSpawning()
    end
  end
end

local function StopSpawning(inst)
  if not inst:HasTag("burnt") then
    if inst.components.childspawner then
      inst.components.childspawner:StopSpawning()
    end
  end
end

local function OnSpawned(inst, child)
  if not inst:HasTag("burnt") then
    inst.SoundEmitter:PlaySound("dontstarve/common/pighouse_door")
    if TheWorld.state.isday and inst.components.childspawner and inst.components.childspawner:CountChildrenOutside() >= 1 and not child.components.combat.target then
      StopSpawning(inst)
    end
  end
end

local function OnGoHome(inst, child)
  if not inst:HasTag("burnt") then
    inst.SoundEmitter:PlaySound("dontstarve/common/pighouse_door")
    if inst.components.childspawner and inst.components.childspawner:CountChildrenOutside() < 1 then
      StartSpawning(inst)
    end
  end
end

local function onsave(inst, data)
  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end
end

local function onload(inst, data)
  if data and data.burnt then
    inst.components.burnable.onburnt(inst)
  end
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon( "mermhouse_fisher.tex" )

  MakeObstaclePhysics(inst, 1)

  inst.AnimState:SetBank("merm_fisherman_house")
  inst.AnimState:SetBuild("merm_fisherman_house")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("structure")

  MakeSnowCoveredPristine(inst)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot(loot)

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(2)
  inst.components.workable:SetOnFinishCallback(onhammered)
  inst.components.workable:SetOnWorkCallback(onhit)

  inst:AddComponent("childspawner")
  inst.components.childspawner.childname = "mermfisher"
  inst.components.childspawner:SetSpawnedFn(OnSpawned)
  inst.components.childspawner:SetGoHomeFn(OnGoHome)
  inst.components.childspawner:SetRegenPeriod(TUNING.TOTAL_DAY_TIME*4)
  inst.components.childspawner:SetSpawnPeriod(10)
  inst.components.childspawner:SetMaxChildren(2)

  inst:AddComponent("inspectable")

  inst:ListenForEvent("dusktime", function()
      if not inst:HasTag("burnt") then
        if TheWorld.state.iswinter then
          inst.components.childspawner:ReleaseAllChildren()
        end
        StartSpawning(inst)
      end
    end, TheWorld)

  inst:ListenForEvent("daytime", function() StopSpawning(inst) end , TheWorld)

  inst:ListenForEvent("onignite", function(inst)
      if inst.components.childspawner then
        inst.components.childspawner:ReleaseAllChildren()
      end
    end)

  inst:ListenForEvent("burntup", function(inst)
      inst.AnimState:PlayAnimation("burnt")
    end)

  MakeMediumBurnable(inst, nil, nil, true)
  MakeLargePropagator(inst)
  MakeSnowCovered(inst, .01)
  StartSpawning(inst)

  return inst
end

return Prefab( "mermhouse_fisher", fn, assets, prefabs)%%+%%scripts/prefabs/messagebottle.lua%%-%%local assets =
{
  Asset("ANIM", "anim/messagebottle.zip"),

}

local function revealTreasure(inst)
  if inst.treasure and inst.treasure:IsValid() then
    inst.treasure:Reveal(inst)
    inst.treasure:RevealFog(inst)
  end
end

local function showOnMinimap(treasure, reader)
  if treasure and treasure:IsValid() then
    treasure:FocusMinimap(treasure)
  end
end

local function readfn(inst, reader)

  print("Read Message Bottle", tostring(inst.treasure), tostring(inst.treasureguid))

  if (not inst.treasure and inst.treasureguid) or (not SaveGameIndex:IsModeShipwrecked() 
    or TheWorld:HasTag("volcano") ) then

    reader.components.talker:Say(GetString(reader, "ANNOUNCE_OTHER_WORLD_TREASURE"))
    return true
  end

  local message
  if inst.treasure then
    --message = GetString(reader, "ANNOUNCE_TREASURE")
    revealTreasure(inst)
    inst.treasure:DoTaskInTime(0, function() showOnMinimap(inst.treasure, reader) end)
  else
    --reader.components.talker:Say(GetString(reader, messages[inst.message]))
    message = GetString(reader, "ANNOUNCE_MESSAGEBOTTLE", inst.message)
  end

  if inst.debugmsg then
    print(inst.debugmsg)
    reader.components.talker:Say(inst.debugmsg)
  elseif message then
    reader.components.talker:Say(message)
  end

  inst.components.inventoryitem:RemoveFromOwner(true)
  inst:Remove()

  reader:DoTaskInTime(3*FRAMES, function() reader.components.inventory:GiveItem(SpawnPrefab("messagebottleempty")) end)
  -- reader.components.inventory:GiveItem(SpawnPrefab("messagebottleempty"))

  return true
end

local function OnSave_message(inst, data)
	local refs = {}
	if inst.treasure then
		data.treasure = inst.treasure.GUID
		table.insert(refs, inst.treasure.GUID)
	elseif inst.treasureguid then
		data.treasure = inst.treasureguid
		table.insert(refs, inst.treasureguid)
	end
	data.message = inst.message
	return refs
end

local function OnLoadPostPass_message(inst, ents, data)
	-- inst.components.inventoryitem:OnHitGround() --this now handles hitting water or land 
	if data then
		if data.treasure then
			if ents[data.treasure] then
				inst.treasure = ents[data.treasure].entity
			end
			inst.treasureguid = data.treasure
		end
		inst.message = data.message
	end
end


local function clientcommonfn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("messagebottle")
  inst.AnimState:SetBuild("messagebottle")

	MakeInventoryFloatable(inst)

    return inst
end

local function mastercommonfn(inst)
  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("waterproofer")
  inst.components.waterproofer:SetEffectiveness(0)

  inst.no_wet_prefix = true
end

local function messagebottlefn()
  local inst = clientcommonfn()
  local minimap = inst.entity:AddMiniMapEntity()

  -- inst.AnimState:PlayAnimation("idle", true)
  inst:AddTag("messagebottle")
  inst:AddTag("nosteal")

  minimap:SetIcon("messagebottle.tex")

	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	mastercommonfn(inst)

	--TODO remove this once readable
    inst.components.inspectable.descriptionfn = function(inst, viewer)
        return GetString(viewer, "ANNOUNCE_UNIMPLEMENTED")
    end

	--This won't do, only Wickerbottom and Maxwell can read.
	-- inst:AddComponent("book")
	-- inst.components.book.onread = readfn

  inst.treasure = nil
  inst.treasureguid = nil

	inst.OnSave = OnSave_message
	inst.OnLoadPostPass = OnLoadPostPass_message

  return inst
end

local function emptybottlefn(Sim)
  local inst = clientcommonfn()

	inst.components.floater:UpdateAnimations("idle_water_empty", "idle_empty")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	mastercommonfn(inst)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end

return Prefab("messagebottle", messagebottlefn, assets),
Prefab("messagebottleempty", emptybottlefn, assets)
%%+%%scripts/prefabs/mosquitosack_yellow.lua%%-%%local assets =
{
    Asset("ANIM", "anim/bladder_yellow.zip"),
}

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()
    
    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("bladder")
    inst.AnimState:SetBuild("bladder_yellow")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeSmallBurnable(inst, TUNING.TINY_BURNTIME)
    MakeSmallPropagator(inst)
    MakeHauntableLaunchAndIgnite(inst)

    ---------------------       

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    inst:AddComponent("stackable")

    inst:AddComponent("fillable")
    inst.components.fillable.filledprefab = "waterballoon"

    inst:AddComponent("healer")
    inst.components.healer:SetHealthAmount(TUNING.HEALING_MED)

    return inst
end

return Prefab("mosquitosack_yellow", fn, assets)%%+%%scripts/prefabs/mosquito_poison.lua%%-%%local assets=
{
	Asset("ANIM", "anim/mosquito.zip"),
	Asset("ANIM", "anim/mosquito_yellow_build.zip"),
}

local prefabs = 
{
	"mosquitosack_yellow",
}

local brain = require("brains/mosquitobrain")

local sounds =
{
	takeoff = "dontstarve/creatures/mosquito/mosquito_takeoff",
	attack = "dontstarve/creatures/mosquito/mosquito_attack",
	buzz = "dontstarve/creatures/mosquito/mosquito_fly_LP",
	hit = "dontstarve/creatures/mosquito/mosquito_hurt",
	death = "dontstarve/creatures/mosquito/mosquito_death",
	explode = "dontstarve/creatures/mosquito/mosquito_explo",
}

SetSharedLootTable("poisonmosquito",
{
	{"mosquitosack_yellow", .5},
	{"venomgland", .25},
})

local SHARE_TARGET_DIST = 30
local MAX_TARGET_SHARES = 10


local function StopTrackingInSpawner(inst)
	if TheWorld and TheWorld.components.floodmosquitospawner then
		TheWorld.components.floodmosquitospawner:StopTracking(inst)
	end
end


local function OnWorked(inst, worker)
    local owner = inst.components.homeseeker ~= nil and inst.components.homeseeker.home or nil
    if owner ~= nil and owner.components.childspawner ~= nil then
        owner.components.childspawner:OnChildKilled(inst)
    end
    if worker.components.inventory ~= nil then
        worker.components.inventory:GiveItem(inst, nil, inst:GetPosition())
    end
end

local function StartBuzz(inst)
    if not inst.components.inventoryitem:IsHeld() then
        inst.SoundEmitter:PlaySound(inst.sounds.buzz, "buzz")
    end
end

local function StopBuzz(inst)
    inst.SoundEmitter:KillSound("buzz")
end

local function OnDropped(inst)
    inst.sg:GoToState("idle")
	if TheWorld and TheWorld.components.floodmosquitospawner then
		TheWorld.components.floodmosquitospawner:StartTracking(inst)
	end
    if inst.components.workable ~= nil then
        inst.components.workable:SetWorkLeft(1)
    end
    if inst.brain ~= nil then
        inst.brain:Start()
    end
    if inst.sg ~= nil then
        inst.sg:Start()
    end
    if inst.components.stackable ~= nil and inst.components.stackable:IsStack() then
        local x, y, z = inst.Transform:GetWorldPosition()
        while inst.components.stackable:IsStack() do
            local item = inst.components.stackable:Get()
            if item ~= nil then
                if item.components.inventoryitem ~= nil then
                    item.components.inventoryitem:OnDropped()
                end
                item.Physics:Teleport(x, y, z)
            end
        end
    end
end

local function OnPickedUp(inst)
	inst.SoundEmitter:KillSound("buzz")
end

local function KillerRetarget(inst)
    return FindEntity(inst, SpringCombatMod(20),
        function(guy)
            return inst.components.combat:CanTarget(guy)
        end,
        { "_combat", "_health" },
        { "insect", "INLIMBO" },
        { "character", "animal", "monster" })
end

local function SwapBelly(inst, size)
    for i = 1, 4 do
        if i == size then
            inst.AnimState:Show("body_"..tostring(i))
        else
            inst.AnimState:Hide("body_"..tostring(i))
        end
    end
end

local function TakeDrink(inst, data)
	inst.drinks = inst.drinks + 1
	if inst.drinks > inst.maxdrinks then
		inst.toofat = true
		inst.components.health:Kill()
	else
		SwapBelly(inst, inst.drinks)
	end
end

local function ShareTargetFn(dude)
    return dude:HasTag("mosquito") and not dude.components.health:IsDead()
end

local function OnAttacked(inst, data)
    inst.components.combat:SetTarget(data.attacker)
    inst.components.combat:ShareTarget(data.attacker, SpringCombatMod(SHARE_TARGET_DIST), ShareTargetFn, MAX_TARGET_SHARES)
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddLightWatcher()
	inst.entity:AddDynamicShadow()
	inst.entity:AddNetwork()
	
	MakeFlyingCharacterPhysics(inst, 1, .5)

	inst.DynamicShadow:SetSize(.8, .5)
	inst.Transform:SetFourFaced()
	local s = 1.18
	inst.Transform:SetScale(s,s,s)

	inst:AddTag("mosquito")
	inst:AddTag("insect")
	inst:AddTag("flying")
	inst:AddTag("smallcreature")
    inst:AddTag("cattoyairborne")

	inst.AnimState:SetBank("mosquito")
	inst.AnimState:SetBuild("mosquito_yellow_build")
	inst.AnimState:PlayAnimation("idle")
	inst.AnimState:SetRayTestOnBB(true)

    MakeFeedableSmallLivestockPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:SetBrain(brain)

	inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
	inst.components.locomotor:EnableGroundSpeedMultiplier(false)
	inst.components.locomotor:SetTriggersCreep(false)
	inst.components.locomotor.walkspeed = TUNING.MOSQUITO_WALKSPEED
	inst.components.locomotor.runspeed = TUNING.MOSQUITO_RUNSPEED
	inst:SetStateGraph("SGmosquito")

	inst.sounds = sounds

	inst.OnEntityWake = StartBuzz
	inst.OnEntitySleep = StopBuzz   


	inst:AddComponent("inventoryitem")
	inst.components.inventoryitem.imagename = "mosquito_yellow"

	inst:AddComponent("stackable")
    inst.components.inventoryitem.canbepickedup = false
    inst.components.inventoryitem.canbepickedupalive = true

	---------------------

	inst:AddComponent("lootdropper")

    inst.components.lootdropper:SetChanceLootTable("poisonmosquito")

	inst:AddComponent("tradable")

	 ------------------
	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.NET)
	inst.components.workable:SetWorkLeft(1)
	inst.components.workable:SetOnFinishCallback(OnWorked)

	MakeSmallBurnableCharacter(inst, "body", Vector3(0, -1, 1))
	MakeTinyFreezableCharacter(inst, "body", Vector3(0, -1, 1))

	------------------
	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.MOSQUITO_HEALTH)

	------------------
	inst:AddComponent("combat")
	inst.components.combat.hiteffectsymbol = "body"
    inst.components.combat:SetDefaultDamage(TUNING.MOSQUITO_DAMAGE)
    inst.components.combat:SetRange(TUNING.MOSQUITO_ATTACK_RANGE)
    inst.components.combat:SetAttackPeriod(TUNING.MOSQUITO_ATTACK_PERIOD)
    inst.components.combat:SetRetargetFunction(2, KillerRetarget)
    inst.components.combat:SetPlayerStunlock(PLAYERSTUNLOCK.RARELY)

    MakePoisonousEntity(inst)

	inst.drinks = 1
	inst.maxdrinks = TUNING.MOSQUITO_MAX_DRINKS
	inst:ListenForEvent("onattackother", TakeDrink)
	SwapBelly(inst, 1)

    MakeHauntablePanic(inst)
    AddHauntableCustomReaction(inst, function(inst, haunter)
        if math.random() <= TUNING.HAUNT_CHANCE_OCCASIONAL then
            inst.sg:GoToState("splat")
            inst.components.hauntable.hauntvalue = TUNING.HAUNT_MEDIUM
            return true
        end
        return false
    end, true, false, true)

	------------------
	inst:AddComponent("sleeper")

	------------------
	inst:AddComponent("knownlocations")

	------------------
	inst:AddComponent("inspectable")

	inst:ListenForEvent("attacked", OnAttacked)

    MakeFeedableSmallLivestock(inst, TUNING.TOTAL_DAY_TIME * 2, OnPickedUp, OnDropped)

	inst:ListenForEvent("onremove", StopTrackingInSpawner)
	if TheWorld and TheWorld.components.floodmosquitospawner then
        inst.components.inventoryitem:SetOnPickupFn(TheWorld.components.floodmosquitospawner.StopTrackingFn)
		TheWorld.components.floodmosquitospawner:StartTracking(inst)
	end

	return inst
end

return Prefab("mosquito_poison", fn, assets, prefabs)%%+%%scripts/prefabs/mussel.lua%%-%%local assets=
{
  Asset("ANIM", "anim/mussel.zip"),
}

local prefabs =
{
  "mussel_cooked",
  "spoiled_food",
}


local function commonclient()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("mussel")
  inst.AnimState:SetBuild("mussel")
  inst.AnimState:SetRayTestOnBB(true)

  inst:AddTag("packimfood")

	-- MakeInventoryFloatable(inst)

  return inst
end

local function commonmaster(inst)
  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)
	inst.components.inventoryitem:SetSinks(true)

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"
end

local function raw()
  local inst = commonclient()
  inst.no_wet_prefix = true
  inst.AnimState:PlayAnimation("idle")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	commonmaster(inst)

  inst.components.inventoryitem.imagename = "mussel"

  inst.components.edible.healthvalue = 0
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
  inst.components.edible.sanityvalue = -TUNING.SANITY_SMALL

  inst:AddComponent("cookable")
  inst.components.cookable.product = "mussel_cooked"

  inst:AddTag("aquatic")
  inst:AddComponent("bait")

  return inst
end

local function cooked()
  local inst = commonclient()
  inst.AnimState:PlayAnimation("cooked")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	commonmaster(inst)

  inst.components.inventoryitem.imagename = "mussel_cooked"

  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
  return inst
end

return Prefab( "mussel", raw, assets, prefabs),
Prefab("mussel_cooked", cooked, assets)
%%+%%scripts/prefabs/mussel_farm.lua%%-%%require "prefabutil"

local assets =
{
  Asset("ANIM", "anim/musselfarm.zip"),
}

local prefabs = 
{
  "mussel",
  "collapse_small",
}


local function getnewpoint(pt)

  local theta = math.random() * 2 * PI
  local radius = 6+math.random()*6

  local result_offset = FindValidPositionByFan(theta, radius, 12, function(offset)
      local spawn_point = pt + offset
      if GetGroundTypeAtPosition(spawn_point) == GROUND.OCEAN_SHALLOW then
        return true
      end
      return false
    end)

  if result_offset then
    return pt+result_offset
  end
end

local function movetonewhome(inst, child)
  local pos = Vector3(inst.Transform:GetWorldPosition())
  local spawn_point = getnewpoint(pos)

  if spawn_point then
    child.Transform:SetPosition(spawn_point:Get())
  end
end

local function onpickedfn(inst, picker)

  inst.AnimState:PlayAnimation("picked")


  inst.pickedanimdone = function(inst)
    inst.components.growable:SetStage(1)
    inst:RemoveEventCallback("animover", inst.pickedanimdone)
  end

  inst:ListenForEvent("animover", inst.pickedanimdone)
end

-- for inspect string
local function getstatus(inst)
  if inst.growthstage > 0 then 
    return "STICKPLANTED"
  end
end

local function makeemptyfn(inst)
  -- never called?
end

local function makefullfn(inst)
  inst.AnimState:PlayAnimation("idle_full")
end

-- stage 1
local function SetHidden(inst)
  inst.components.pickable.numtoharvest = 0
  inst.components.pickable.canbepicked = false
  inst.components.blowinwindgust:Stop()
  inst.MiniMapEntity:SetEnabled(false)
  inst.Physics:SetCollides(false)
  inst:Hide()
  inst.components.stickable:UnStuck()
end

-- stage 2
local function SetUnderwater(inst)
  inst.AnimState:PlayAnimation("idle_underwater", true)
  inst.components.pickable.numtoharvest = 0
  inst.components.pickable.canbepicked = false
  inst.components.blowinwindgust:Stop()
  inst.AnimState:SetLayer(LAYER_BACKGROUND)
  inst.AnimState:SetSortOrder(2)
  inst.MiniMapEntity:SetEnabled(false)
  inst.Physics:SetCollides(false)
  inst:Show()
  inst.components.stickable:UnStuck()
end

local function SetAboveWater(inst)
  -- common
  inst.AnimState:SetLayer(LAYER_WORLD)
  inst.AnimState:SetSortOrder(0)
  inst.components.blowinwindgust:Start()
  inst.MiniMapEntity:SetEnabled(true)
  inst.Physics:SetCollides(true)
  inst.components.growable:StartGrowing()
  inst:Show()
  inst.components.stickable:Stuck()
end

-- stage 3
local function SetEmpty(inst)
  inst.AnimState:PlayAnimation("idle_empty", true)
  inst.components.pickable.numtoharvest = 0
  inst.components.pickable.canbepicked = false
  inst.components.pickable.hasbeenpicked = false

  SetAboveWater(inst)
end

-- stage 4
local function SetSmall(inst)
  inst.AnimState:PlayAnimation("idle_small", true)
  inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_SMALL
  inst.components.pickable.canbepicked = true
  inst.components.pickable.hasbeenpicked = false

  SetAboveWater(inst)
end

-- stage 5
local function SetMedium(inst)
  -- there's no real animation for this stage
  inst.AnimState:PlayAnimation("idle_small", true)
  inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_MED
  inst.components.pickable.canbepicked = true
  inst.components.pickable.hasbeenpicked = false

  SetAboveWater(inst)
end

-- stage 6
local function SetLarge(inst)
  inst.AnimState:PlayAnimation("idle_full", true)
  inst.components.pickable.numtoharvest = TUNING.MUSSEL_CATCH_LARGE
  inst.components.pickable.canbepicked = true
  inst.components.pickable.hasbeenpicked = false

  SetAboveWater(inst)
end



local function GrowHidden(inst)

end

local function GrowUnderwater(inst)

end

local function GrowEmpty(inst)
  inst.growthstage = 2
  inst.AnimState:PlayAnimation("empty_to_small")
  inst.AnimState:PushAnimation("idle_small", true)
end

local function GrowSmall(inst)
  --inst.AnimState:PlayAnimation("empty_to_small")
  --inst.AnimState:PushAnimation("idle_small", true)
end

local function GrowMedium(inst)
  inst.AnimState:PlayAnimation("small_to_full")
  inst.AnimState:PushAnimation("idle_full", true)
end

local function GrowLarge(inst)

end


local growth_stages =
{
  {
    name = "hidden",
    time = function(inst) 
      return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME[1].base, TUNING.MUSSEL_CATCH_TIME[1].random)
    end,
    fn = SetHidden,
    growfn = GrowHidden,
  },
  {
    name = "underwater", -- waiting to be stuck
    time = function(inst) 
      return nil -- this stage doesn't grow automatically
    end,
    fn = SetUnderwater,
    growfn = GrowUnderwater,
  },
  {
    name = "empty", -- the stick is in now
    time = function(inst) 
      return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME[2].base, TUNING.MUSSEL_CATCH_TIME[2].random)
    end,
    fn = SetEmpty,
    growfn = GrowEmpty,
  },
  {
    name = "small",
    time = function(inst) 
      return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME[3].base, TUNING.MUSSEL_CATCH_TIME[3].random)
    end,
    fn = SetSmall,
    growfn = GrowSmall,
  },
  {
    name = "medium",
    time = function(inst) 
      return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME[4].base, TUNING.MUSSEL_CATCH_TIME[4].random)
    end,
    fn = SetMedium,
    growfn = GrowMedium,
  },
  {
    name = "large",
    time = function(inst) 
      return GetRandomWithVariance(TUNING.MUSSEL_CATCH_TIME[5].base, TUNING.MUSSEL_CATCH_TIME[5].random)
    end,
    fn = SetLarge,
    growfn = GrowLarge,
  },
}


local function onpoked(inst, worker, stick)
  inst.SoundEmitter:PlaySound("ia/common/plant_mussel")
  inst.components.growable:SetStage(3)

  if stick.components.stackable and stick.components.stackable.stacksize > 1 then
    stick = stick.components.stackable:Get()
  end

  stick:Remove()
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()

  MakeObstaclePhysics(inst, 0.8, 1.2)
  inst.Physics:SetCollides(false)

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon("mussel_farm.tex")
  minimap:SetEnabled(false) --Not enabled until poked 

  inst:AddTag("structure")
  inst:AddTag("mussel_farm")
  inst:AddTag("aquatic")

  inst.AnimState:SetBank("musselFarm")
  inst.AnimState:SetBuild("musselFarm")
  inst.AnimState:PlayAnimation("idle_underwater", true)
  inst.AnimState:SetLayer(LAYER_BACKGROUND)
  inst.AnimState:SetSortOrder(2)
  inst.AnimState:SetRayTestOnBB(true)

  inst.no_wet_prefix = true

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.growthstage = 0
  inst.targettime = nil

  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = getstatus

  inst:AddComponent("stickable")
  inst.components.stickable:SetOnPokeCallback(onpoked)

	MakePickableBlowInWindGust(inst, TUNING.MUSSELFARM_WINDBLOWN_SPEED, TUNING.MUSSELFARM_WINDBLOWN_FALL_CHANCE)
	inst.components.blowinwindgust:SetGustStartFn(nil)
	
  inst:AddComponent("pickable")
  inst.components.pickable.picksound = "dontstarve/wilson/harvest_berries"
  inst.components.pickable.canbepicked = false
  inst.components.pickable.hasbeenpicked = false
  inst.components.pickable.product = "mussel"
  inst.components.pickable.numtoharvest = 0
  inst.components.pickable.onpickedfn = onpickedfn
  inst.components.pickable.makeemptyfn = makeemptyfn
  inst.components.pickable.makebarrenfn = makeemptyfn
  inst.components.pickable.makefullfn = makefullfn

  inst:AddComponent("growable")
  inst.components.growable.stages = growth_stages
  inst.components.growable:SetStage(2)
  inst.components.growable.loopstages = false

  inst:AddComponent("lootdropper")

  return inst
end    

return Prefab( "mussel_farm", fn, assets, prefabs )
%%+%%scripts/prefabs/mussel_stick.lua%%-%%local assets =
{
  Asset("ANIM", "anim/musselfarm_stick.zip"),
}

local prefabs =
{
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.no_wet_prefix = true

  inst.AnimState:SetBuild("musselFarm_stick")
  inst.AnimState:SetBank("musselFarm_stick")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst:AddComponent("sticker")
  inst:AddComponent("inspectable")

  inst:AddComponent("stackable")

  MakeInvItemIA(inst)

  return inst
end

return Prefab( "mussel_stick", fn, assets, prefabs) 

%%+%%scripts/prefabs/mysterymeat.lua%%-%%local assets=
{
  Asset("ANIM", "anim/mystery_meat.zip"),
}

local function impact(inst)
	inst.SoundEmitter:PlaySound("ia/common/mysterymeat_impactland")
end

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst:AddTag("kittenchow")

  inst.AnimState:SetBank("mysterymeat")
  inst.AnimState:SetBuild("mystery_meat")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	inst:ListenForEvent("floater_startfloating", impact)

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_LARGE

  inst:AddComponent("edible")
  inst.components.edible.healthvalue = TUNING.SPOILED_HEALTH
  inst.components.edible.hungervalue = TUNING.SPOILED_HUNGER
  inst.components.edible.foodtype = "MEAT"

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end

return Prefab( "mysterymeat", fn, assets)
%%+%%scripts/prefabs/obsidian.lua%%-%%local assets=
{
  Asset("ANIM", "anim/obsidian.zip"),
}

local function hitwater(inst)
	inst.SoundEmitter:PlaySound("ia/common/obsidian_wetsizzles")
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)


  inst.AnimState:SetRayTestOnBB(true);
  inst.AnimState:SetBank("obsidian")
  inst.AnimState:SetBuild("obsidian")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("molebait")
  
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.HEAVY, TUNING.WINDBLOWN_SCALE_MAX.HEAVY)

	inst:ListenForEvent("floater_startfloating", hitwater)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  inst:AddComponent("waterproofer")
  inst.components.waterproofer:SetEffectiveness(0)
  inst.no_wet_prefix = true

  MakeInvItemIA(inst)

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_LARGE

    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.ELEMENTAL
    inst.components.edible.hungervalue = 3
    inst:AddComponent("tradable")
    inst:AddComponent("bait")

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "obsidian", fn, assets)
%%+%%scripts/prefabs/obsidianaxe.lua%%-%%local assets = {
    Asset("ANIM", "anim/axe_obsidian.zip"),
    Asset("ANIM", "anim/swap_axe_obsidian.zip"),
}

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_object", "swap_axe_obsidian", "swap_axe")
    owner.AnimState:Show("ARM_carry")
    owner.AnimState:Hide("ARM_normal")
end

local function onunequip(inst, owner)
    owner.AnimState:Hide("ARM_carry")
    owner.AnimState:Show("ARM_normal")
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("axe_obsidian")
    inst.AnimState:SetBuild("axe_obsidian")
    inst.AnimState:PlayAnimation("idle")

    inst:AddTag("sharp")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    MakeObsidianToolPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeInvItemIA(inst)
    -----
    inst:AddComponent("tool")
    inst.components.tool:SetAction(ACTIONS.CHOP, TUNING.OBSIDIANTOOL_WORK)

    if TheNet:GetServerGameMode() ~= "quagmire" then
        -------
        inst:AddComponent("finiteuses")
        inst.components.finiteuses:SetMaxUses(TUNING.AXE_USES)
        inst.components.finiteuses:SetUses(TUNING.AXE_USES)
        inst.components.finiteuses:SetOnFinished(inst.Remove)
        inst.components.finiteuses:SetConsumption(ACTIONS.CHOP, 1 / TUNING.OBSIDIANTOOLFACTOR)

        -------
        inst:AddComponent("weapon")
        inst.components.weapon:SetDamage(TUNING.AXE_DAMAGE)
        inst.components.weapon.attackwear = 1 / TUNING.OBSIDIANTOOLFACTOR
    end

    inst:AddComponent("inspectable")

    inst:AddComponent("equippable")

    inst.components.equippable:SetOnEquip(onequip)

    inst.components.equippable:SetOnUnequip(onunequip)

    MakeHauntableLaunch(inst)

    inst:AddComponent("waterproofer")
    inst.components.waterproofer:SetEffectiveness(0)

    MakeObsidianTool(inst, "axe")

    return inst
end

return Prefab("obsidianaxe", fn, assets)
%%+%%scripts/prefabs/obsidianfirefire.lua%%-%%local assets = {
    Asset("ANIM", "anim/campfire_fire.zip"),
}

local heats = {70, 85, 100, 115}

local function GetHeatFn(inst)
    return heats[inst.components.firefx.level] or 20
end

local firelevels =
{
    {anim="level1", sound="dontstarve/common/campfire", radius=TUNING.OBSIDIANLIGHT_RADIUS_1, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.1},
    {anim="level2", sound="dontstarve/common/campfire", radius=TUNING.OBSIDIANLIGHT_RADIUS_2, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.3},
    {anim="level3", sound="dontstarve/common/campfire", radius=TUNING.OBSIDIANLIGHT_RADIUS_3, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=.6},
    {anim="level4", sound="dontstarve/common/campfire", radius=TUNING.OBSIDIANLIGHT_RADIUS_4, intensity=.8, falloff=.33, colour = {255/255,255/255,192/255}, soundintensity=1},
}

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("campfire_fire")
    inst.AnimState:SetBuild("campfire_fire")
    inst.AnimState:SetBloomEffectHandle("shaders/anim.ksh")
    inst.AnimState:SetRayTestOnBB(true)
    inst.AnimState:SetFinalOffset(-1)

    inst:AddTag("FX")

    --HASHEATER (from heater component) added to pristine state for optimization
    inst:AddTag("HASHEATER")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("heater")
    inst.components.heater.heatfn = GetHeatFn

    inst:AddComponent("firefx")
    inst.components.firefx.levels = firelevels
    inst.components.firefx:SetLevel(1)
    inst.components.firefx.usedayparamforsound = true
    
    return inst
end

return Prefab("obsidianfirefire", fn, assets) 
%%+%%scripts/prefabs/obsidianfirepit.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/firepit.zip"),
    Asset("ANIM", "anim/firepit_obsidian.zip"),
}

local prefabs = {
    "obsidianfirefire",
    "collapse_small",
}    

local function onhammered(inst, worker)
    inst.components.lootdropper:DropLoot()
    SpawnPrefab("ash").Transform:SetPosition(inst.Transform:GetWorldPosition())
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("stone")
    inst:Remove()
end

local function onhit(inst, worker)
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle")
end

local function onextinguish(inst)
    if inst.components.fueled then
        inst.components.fueled:InitializeFuelLevel(0)
    end
end

local function ontakefuel(inst)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function updatefuelrate(inst)
	if IsInIAClimate(inst) then
		inst.components.fueled.rate = 1
			+ TUNING.OBSIDIANFIREPIT_RAIN_RATE * TheWorld.state.islandprecipitationrate
			+ (inst:HasTag("flooded") and TUNING.OBSIDIANFIREPIT_FLOOD_RATE or 0)
	else
		inst.components.fueled.rate = 1
			+ TUNING.OBSIDIANFIREPIT_RAIN_RATE * TheWorld.state.precipitationrate
	end
end

local function onupdatefueled(inst)
    if inst.components.burnable and inst.components.fueled then
        updatefuelrate(inst)
        inst.components.burnable:SetFXLevel(inst.components.fueled:GetCurrentSection(), inst.components.fueled:GetSectionPercent())
    end
end

local function onfuelchange(newsection, oldsection, inst, doer)
    if newsection <= 0 then
        inst.components.burnable:Extinguish()
    else
        if not inst.components.burnable:IsBurning() then
            inst.components.burnable:Ignite(nil, nil, doer)
        end
        inst.components.burnable:SetFXLevel(newsection, inst.components.fueled:GetSectionPercent())
    end
end

local SECTION_STATUS = {
    [0] = "OUT",
    [1] = "EMBERS",
    [2] = "LOW",
    [3] = "NORMAL",
    [4] = "HIGH",
}

local function getstatus(inst)
    return SECTION_STATUS[inst.components.fueled:GetCurrentSection()]
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle", false)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function OnHaunt(inst, haunter)
    if math.random() <= TUNING.HAUNT_CHANCE_RARE and
        inst.components.fueled ~= nil and
        not inst.components.fueled:IsEmpty() then
        inst.components.fueled:DoDelta(TUNING.MED_FUEL)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    --#HAUNTFIX
    --elseif math.random() <= TUNING.HAUNT_CHANCE_HALF and
        --inst.components.workable ~= nil and
        --inst.components.workable:CanBeWorked() then
        --inst.components.workable:WorkedBy(haunter, 1)
        --inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        --return true
    end
    return false
end

local function OnInit(inst)
    if inst.components.burnable ~= nil then
        inst.components.burnable:FixFX()
    end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()
  
    MakeObstaclePhysics(inst, .3)

    inst.MiniMapEntity:SetIcon("firepit.png")
    inst.MiniMapEntity:SetPriority(1)

    inst.AnimState:SetBank("firepit_obsidian")
    inst.AnimState:SetBuild("firepit_obsidian")
    inst.AnimState:PlayAnimation("idle", false)

    inst:AddTag("campfire")
    inst:AddTag("structure")
    inst:AddTag("wildfireprotected")

    --cooker (from cooker component) added to pristine state for optimization
    inst:AddTag("cooker")
    
	inst:AddComponent("floodable")
	
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end

    -----------------------
    inst:AddComponent("burnable")
    inst.components.burnable:AddBurnFX("obsidianfirefire", Vector3(0, .4, 0))
    inst:ListenForEvent("onextinguish", onextinguish)
    
    -------------------------
    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)    

    -------------------------
    inst:AddComponent("cooker")
    -------------------------
    inst:AddComponent("fueled")
    inst.components.fueled.maxfuel = TUNING.OBSIDIANFIREPIT_FUEL_MAX
    inst.components.fueled.accepting = true
    
    inst.components.fueled:SetSections(4)
    inst.components.fueled.bonusmult = TUNING.OBSIDIANFIREPIT_BONUS_MULT
    inst.components.fueled.ontakefuelfn = ontakefuel
    inst.components.fueled:SetUpdateFn(updatefuelrate)
    inst.components.fueled:SetSectionCallback(onfuelchange)
    inst.components.fueled:InitializeFuelLevel(TUNING.OBSIDIANFIREPIT_FUEL_START)

    -----------------------------

    --[[
    inst:AddComponent("blowinwindgust")
    inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.OBSIDIANFIRE_WINDBLOWN_SPEED)
    inst.components.blowinwindgust:SetGustStartFn(function(inst, windspeed)
        if inst and inst.components.burnable and inst.components.burnable:IsBurning() and math.random() < TUNING.OBSIDIANFIRE_BLOWOUT_CHANCE then
            inst.components.burnable:Extinguish()
        end
    end)
    inst.components.blowinwindgust:Start()
    --]]

	inst.components.floodable:SetFX(nil,.5) --update faster

    -----------------------------

    inst:AddComponent("hauntable")
    inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_HUGE
    inst.components.hauntable:SetOnHauntFn(OnHaunt)
    
    -----------------------------
    
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus
    
    inst:ListenForEvent("onbuilt", onbuilt)

    inst:DoTaskInTime(0, OnInit)
    
    return inst
end

return Prefab("obsidianfirepit", fn, assets, prefabs),
        MakePlacer("obsidianfirepit_placer", "firepit", "firepit", "preview" ) 
%%+%%scripts/prefabs/obsidiantoollight.lua%%-%%local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddLight()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    inst.Light:SetFalloff(0.5)
    inst.Light:SetIntensity(0.75)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false

    return inst
end
   
return Prefab("obsidiantoollight", fn)%%+%%scripts/prefabs/obsidian_workbench.lua%%-%%local assets = {
    Asset("ANIM", "anim/workbench_obsidian.zip"),
}

local MAXHITS = 10  -- make this an even number

local function turnlightoff(inst, light)
    if light then
        light:Enable(false)
    end
end

--light, rad, intensity, falloff, colour, time, callback
local function OnTurnOn(inst)
    inst.components.prototyper.on = true  -- prototyper doesn't set this until after this function is called!!
    inst.AnimState:PlayAnimation("proximity_pre")
    inst.AnimState:PushAnimation("proximity_loop", true)
    inst.SoundEmitter:PlaySound("ia/common/obsidian_workbench_LP", "loop")
end

local function OnTurnOff(inst)
    inst.components.prototyper.on = false  -- prototyper doesn't set this until after this function is called
    inst.AnimState:PlayAnimation("proximity_pst")
    inst.AnimState:PushAnimation("idle", true)
    inst.SoundEmitter:KillSound("loop")
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetPriority( 5 )
    inst.MiniMapEntity:SetIcon("obsidian_workbench.tex")
    inst.Transform:SetScale(1, 1, 1)

    MakeObstaclePhysics(inst, 2, 1.2)

    inst.AnimState:SetBank("workbench_obsidian")
    inst.AnimState:SetBuild("workbench_obsidian")
    inst.AnimState:PlayAnimation("idle")

    inst:AddTag("prototyper")
    inst:AddTag("altar")
    inst:AddTag("structure")
    inst:AddTag("stone")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    inst:AddComponent("prototyper")
    inst.components.prototyper.onturnon = OnTurnOn
    inst.components.prototyper.onturnoff = OnTurnOff
    inst.components.prototyper.trees = TUNING.PROTOTYPER_TREES.OBSIDIAN_BENCH

    inst.components.prototyper.onactivate = function()
        inst.AnimState:PlayAnimation("use")
        inst.AnimState:PushAnimation("proximity_loop", true)
    end

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

    return inst
end

return Prefab("obsidian_workbench", fn, assets)
%%+%%scripts/prefabs/oceanfog.lua%%-%%local TEXTURE = "levels/textures/ds_fog1.tex"

local SHADER = "shaders/vfx_particle.ksh"

local OCEAN_COLOUR_ENVELOPE_NAME = "oceanfogcolourenvelope"
local VOLCANO_COLOUR_ENVELOPE_NAME = "volcanofogcolourenvelope"
local SCALE_ENVELOPE_NAME = "oceanfogscaleenvelope"

local assets = {
    Asset("IMAGE", TEXTURE),
    Asset("SHADER", SHADER),
}

local function IntColour(r, g, b, a)
    return {r / 255.0, g / 255.0, b / 255.0, a / 255.0}
end

local function InitEnvelope()
    EnvelopeManager:AddColourEnvelope(OCEAN_COLOUR_ENVELOPE_NAME, {
        {0, IntColour(255, 255, 255, 0)},
        {0.1, IntColour(255, 255, 255, 61)},
        {0.75, IntColour(255, 255, 255, 61)},
        {1, IntColour(255, 255, 255, 0)}})

    EnvelopeManager:AddColourEnvelope(VOLCANO_COLOUR_ENVELOPE_NAME, {
        {0, IntColour(255, 255, 255, 0)},
        {0.1, IntColour(255, 255, 255, 30)},
        {0.75, IntColour(255, 255, 255, 30)},
        {1, IntColour(255, 255, 255, 0)}})

    local min_scale = 6
    local max_scale = 10
	EnvelopeManager:AddVector2Envelope(SCALE_ENVELOPE_NAME, {
			{0,	{min_scale, min_scale}},
			{1,	{max_scale, max_scale}}})
    InitEnvelope = nil
    IntColour = nil
end

local MAX_LIFETIME = 15
local MAX_NUM_PARTICLES = 16 * MAX_LIFETIME
local GROUND_HEIGHT = 0.4
local EMITTER_RADIUS = 50

local function emit_fn(effect, radius)
	local vx, vy, vz = 0.01 * UnitRand(), 0, 0.01 * UnitRand()
	local lifetime = MAX_LIFETIME * (0.9 + UnitRand() * 0.1)
	local px, py, pz = radius * UnitRand(), GROUND_HEIGHT, radius * UnitRand()

    effect:AddParticle(
        0,
        lifetime,           -- lifetime
        px, py, pz,         -- position
        vx, vy, vz          -- velocity
    )
end

local function InitParticles(inst)
    --Dedicated server does not need to spawn local particle fx
    if TheNet:IsDedicated() then
        return
    elseif InitEnvelope ~= nil then
        InitEnvelope()
    end

    local effect = inst.entity:AddVFXEffect()
    effect:InitEmitters(1)
    effect:SetRenderResources(0, softresolvefilepath(TEXTURE), SHADER)
    effect:SetMaxNumParticles(0, MAX_NUM_PARTICLES)
    effect:SetMaxLifetime(0, MAX_LIFETIME)
    effect:SetSpawnVectors(0, -1, 0, 1, 1, 0, 1)
    effect:SetSortOrder(0, 3)
    effect:SetScaleEnvelope(0, SCALE_ENVELOPE_NAME)
    effect:SetRadius(0, EMITTER_RADIUS)

	inst.num_particles_to_emit = 0
end

local function commonfn(Sim)
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddNetwork()

	inst:AddTag("FX")
	inst:AddTag("NOCLICK")

    InitParticles(inst)

    return inst
end

local function oceanfn()
	local inst = commonfn()

    inst.entity:SetPristine()

    if TheNet:IsDedicated() then
    	return inst
    end

	inst.VFXEffect:SetColourEnvelope(0, OCEAN_COLOUR_ENVELOPE_NAME)
	inst.particles_per_tick = 8 * TheSim:GetTickTime()

	inst.daysegs = 16

	inst:ListenForEvent("clocksegschanged", function(world, data)
		inst.daysegs = data.day
	end, TheWorld)
	
	EmitterManager:AddEmitter(inst, nil, function()
		if TheWorld.state.isday then
			local t = inst.daysegs * TheWorld.state.timeinphase
			if t >= 0 and t <= 2 then
		        while inst.num_particles_to_emit > 1 do
		            emit_fn(inst.VFXEffect, EMITTER_RADIUS)
		            inst.num_particles_to_emit = inst.num_particles_to_emit - 1
		        end
		        inst.num_particles_to_emit = inst.num_particles_to_emit + inst.particles_per_tick
		    end
	    end
	end)

	return inst
end

local function gravefn(Sim)
	local inst = commonfn()

	inst._radius = net_float(inst.GUID, "radius", "onvfxradiusdirty")

    inst.entity:SetPristine()

    if TheWorld.ismastersim then
		inst:AddComponent("scenariorunner")
		inst.components.scenariorunner:SetScript("fog_shipgrave")

		inst.SetRadius = function(inst, radius)
			inst._radius:set(radius)
		end

		inst.OnSave = function(inst, data)
			data.radius = inst._radius:value()
		end

		inst.OnLoad = function(inst, data)
			if data and data.radius then
				inst:SetRadius(data.radius)
			end
		end
    end

    if TheNet:IsDedicated() then
    	return inst
    end

    inst:ListenForEvent("onvfxradiusdirty", function(inst)
    	inst.radius = inst._radius:value()
    	inst.VFXEffect:SetRadius(0, inst.radius)
    end)

	inst.VFXEffect:SetColourEnvelope(0, OCEAN_COLOUR_ENVELOPE_NAME)
	inst.particles_per_tick = 1 * TheSim:GetTickTime()

	inst.radius = 2

	inst.VFXEffect:SetRadius(0, inst.radius)
	
	EmitterManager:AddEmitter(inst, nil, function()
        while inst.num_particles_to_emit > 1 do
            emit_fn(inst.VFXEffect, inst.radius)
            inst.num_particles_to_emit = inst.num_particles_to_emit - 1
        end
        inst.num_particles_to_emit = inst.num_particles_to_emit + inst.particles_per_tick
	end)

	return inst
end

local function volcanofn()
	local inst = commonfn()

    inst.entity:SetPristine()
	
    if TheNet:IsDedicated() then
    	return inst
    end

	inst.VFXEffect:SetColourEnvelope(0, VOLCANO_COLOUR_ENVELOPE_NAME)
	inst.particles_per_tick = 1 * TheSim:GetTickTime()
	
	EmitterManager:AddEmitter(inst, nil, function()
        while inst.num_particles_to_emit > 1 do
            emit_fn(inst.VFXEffect, EMITTER_RADIUS)
            inst.num_particles_to_emit = inst.num_particles_to_emit - 1
        end
        inst.num_particles_to_emit = inst.num_particles_to_emit + inst.particles_per_tick
	end)

	return inst
end

return Prefab("oceanfog", oceanfn, assets),
		Prefab("shipgravefog", gravefn, assets),
		Prefab("volcanofog", volcanofn, assets)%%+%%scripts/prefabs/octopusking.lua%%-%%local assets=
{
	Asset("ANIM", "anim/octopus.zip"),
	-- Asset("MINIMAP_IMAGE", "octopus"),
}


local prefabs = 
{
	"dubloon",
	"octopuschest",
	"seaweed",
	"seashell",
	"coral",
	"shark_fin",
	"blubber",
	"sail_palmleaf",
	"sail_cloth",
	"trawlnet",
	"seatrap",
	--"telescope",
	"boat_lantern",
	"piratehat",
	"boatcannon",
}

-- only accept 1 trinket per day and pull up a chest that has multiple  dubloons + items (that we set per trinket)
-- only accept 1 seafood meal per day and pull up a chest with 1 dubloon + rando cheap items that come from a loot list
-- only accept 1 seafood crockpot meal per day and pull up a chest that has 1 dubloon + items (that we set per dish)

local function StartTrading(inst)
	if not inst.components.trader.enabled then
		inst.components.trader:Enable()
		inst.AnimState:PlayAnimation("sleep_pst")
		inst.AnimState:PushAnimation("idle", true)

        inst:RemoveEventCallback("animover", inst.sleepfn)
        inst.sleepfn = nil
	end
end

local function FinishedTrading(inst)
	inst.components.trader:Disable()
	inst.AnimState:PlayAnimation("sleep_pre")

	if inst.sleepfn then
		inst:RemoveEventCallback("animover", inst.sleepfn)
        inst.sleepfn = nil
	end
	
	inst.sleepfn = function(inst)
		inst.AnimState:PlayAnimation("sleep_loop")
		inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/sleep")
	end
    
    inst:ListenForEvent("animover", inst.sleepfn)
end

-- chest style
local function OnGetItemFromPlayer(inst, giver, item)
	
	local istrinket = item:HasTag("trinket") or string.sub(item.prefab, 1, 7) == "trinket" -- cache this, the item is destroyed by the time the reward is created.
	local itemprefab = string.sub(item.prefab, -8) == "_gourmet" and string.sub(item.prefab, 1, -9) or item.prefab
	local tradefor = item.components.tradable.tradefor
	inst.components.trader:Disable()

	inst.AnimState:PlayAnimation("happy")
	inst.AnimState:PushAnimation("grabchest")
	inst.AnimState:PushAnimation("idle", true)
	inst:DoTaskInTime(13*FRAMES, function(inst)	inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/happy") end)
	inst:DoTaskInTime(53*FRAMES, function(inst)	inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/tenticle_out_water") end)
	inst:DoTaskInTime(71*FRAMES, function(inst)	inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/tenticle_in_water") end)
	inst:DoTaskInTime(78*FRAMES, function(inst)	inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_small") end)
	inst:DoTaskInTime(109*FRAMES, function(inst)

		inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/tenticle_out_water")
		
		-- put things in a chest and throw that
		local angle
		local spawnangle
		local sp = math.random()*3+2
		local x, y, z = inst.Transform:GetWorldPosition()
		
		if giver ~= nil and giver:IsValid() then
			angle = (210 - math.random()*60 - giver:GetAngleToPoint(x, 0, z))*DEGREES
			spawnangle = (130 - giver:GetAngleToPoint(x, 0, z))*DEGREES
		else
			local down = TheCamera:GetDownVec()
			angle = math.atan2(down.z, down.x) + (math.random()*60-30)*DEGREES
			spawnangle = math.atan2(down.z, down.x) + -50*DEGREES
			giver = nil
		end
		
		local chest = SpawnPrefab("octopuschest")
		local pt = Vector3(inst.Transform:GetWorldPosition()) + Vector3(2*math.cos(spawnangle), 2, 2*math.sin(spawnangle))
		chest.Transform:SetPosition(pt:Get())
		chest.Physics:SetVel(sp*math.cos(angle), math.random()*2+9, sp*math.sin(angle))
		if chest.components.inventoryitem then
			chest.components.inventoryitem:SetLanded(false, true)
		end
		chest.AnimState:PlayAnimation("air_loop", true)

		chest:ListenForEvent("on_landed", function()
			chest.AnimState:PlayAnimation("land")
			chest.AnimState:PushAnimation("closed", true)
		end)

		if not istrinket then
            local single = SpawnPrefab("dubloon")
            chest.components.container:GiveItem(single, nil, nil, true, false)

            if OCTOPUSKING_LOOT.chestloot[itemprefab] then
                local goodreward = SpawnPrefab(OCTOPUSKING_LOOT.chestloot[itemprefab])
                chest.components.container:GiveItem(goodreward, nil, nil, true, false)
            else
                local dubloonvalue = math.min(item.components.tradable.dubloonvalue or 0, 2)
                for i = 1, dubloonvalue do
                    local loot = SpawnPrefab(OCTOPUSKING_LOOT.randomchestloot[math.random(1, #OCTOPUSKING_LOOT.randomchestloot)])
                    chest.components.container:GiveItem(loot, nil, nil, true, false)
                end
            end
		else
			-- trinkets give out dubloons only
			for i = 1, (item.components.tradable.dubloonvalue or item.components.tradable.goldvalue * 3) do
				local loot = SpawnPrefab("dubloon")
				chest.components.container:GiveItem(loot, nil, nil, true, false)
			end
		end
		if tradefor ~= nil then
			for _, v in pairs(tradefor) do
				local item = SpawnPrefab(v)
				if item ~= nil then
					chest.components.container:GiveItem(item, nil, nil, true, false)
				end
			end
		end
	end)
	
	inst.happy = true
	if inst.endhappytask then
		inst.endhappytask:Cancel()
	end
	inst.endhappytask = inst:DoTaskInTime(5, function(inst)
		inst.happy = false
		inst.endhappytask = nil

		FinishedTrading(inst)
	end)
end

local function OnRefuseItem(inst, giver, item)
    inst.SoundEmitter:PlaySound("ia/creatures/octopus_king/reject")
    inst.AnimState:PlayAnimation("unimpressed")
    inst.AnimState:PushAnimation("idle", true)
    inst.happy = false
end

local function OnLoad(inst,data)
    if not inst.components.trader.enabled then
        FinishedTrading(inst)
    end
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddDynamicShadow()
    inst.entity:AddNetwork()
	inst.entity:AddMiniMapEntity()
    
	inst.MiniMapEntity:SetIcon("octopus.tex")
	inst.MiniMapEntity:SetPriority(1)
	
	inst.DynamicShadow:SetSize(10, 5)
	
	MakeObstaclePhysics(inst, 2, .9)
	
	inst:AddTag("king")
	inst.AnimState:SetBank("octopus")
	inst.AnimState:SetBuild("octopus")
	inst.AnimState:PlayAnimation("idle", true)

    inst:AddTag("trader")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
	inst:AddComponent("inspectable")

	inst:AddComponent("trader")

	inst.components.trader:SetAcceptTest(function(inst, item)
		local itemprefab = string.sub(item.prefab, -8) == "_gourmet" and string.sub(item.prefab, 1, -9) or item.prefab
		return (item.components.tradable.dubloonvalue and item.components.tradable.dubloonvalue > 0) or OCTOPUSKING_LOOT.chestloot[itemprefab] ~= nil or string.sub(itemprefab, 1, 7) == "trinket"
	end)

	inst.components.trader.onaccept = OnGetItemFromPlayer
	inst.components.trader.onrefuse = OnRefuseItem
	
	inst.OnLoad = OnLoad

    inst:WatchWorldState("startnight", function(inst)
        FinishedTrading(inst)
    end)

    inst:WatchWorldState("startday", function(inst)
        StartTrading(inst)
    end)
	
	inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)
    inst.components.hauntable:SetOnHauntFn(function(inst, haunter)
        if inst.components.trader and inst.components.trader.enabled then
            OnRefuseItem(inst)
            return true
        end
        return false
    end)
	
	return inst
end

return Prefab( "octopusking", fn, assets, prefabs) 
%%+%%scripts/prefabs/ox.lua%%-%%local brain = require "brains/oxbrain"
require "stategraphs/SGox"

local assets=
{
  Asset("ANIM", "anim/ox_basic.zip"),
  Asset("ANIM", "anim/ox_actions.zip"),
  Asset("ANIM", "anim/ox_build.zip"),
  -- Asset("ANIM", "anim/ox_shaved_build.zip"),

  Asset("ANIM", "anim/ox_basic_water.zip"),
  Asset("ANIM", "anim/ox_actions_water.zip"),

  Asset("ANIM", "anim/ox_heat_build.zip"),
  Asset("SOUND", "sound/beefalo.fsb"),
}

local prefabs =
{
  "meat",
  "poop",
  "ox_horn",
}

SetSharedLootTable( 'ox',
  {
    {'meat',            1.00},
    {'meat',            1.00},
    {'meat',            1.00},
    {'meat',            1.00},
    {'ox_horn',            0.33},
  })

local sounds = 
{
  angry = "ia/creatures/OX/angry",
  curious = "ia/creatures/OX/curious",

  attack_whoosh = "ia/creatures/OX/attack_whoosh",
  chew = "ia/creatures/OX/chew",
  grunt = "ia/creatures/OX/bellow",
  hairgrow_pop = "ia/creatures/OX/hairgrow_pop",
  hairgrow_vocal = "ia/creatures/OX/hairgrow_vocal",
  sleep = "ia/creatures/OX/sleep",
  tail_swish = "ia/creatures/OX/tail_swish",
  walk_land = "ia/creatures/OX/walk_land",
  walk_water = "ia/creatures/OX/walk_water",

  death = "ia/creatures/OX/death",
  mating_call = "ia/creatures/OX/mating_call",

  emerge = "ia/creatures/seacreature_movement/water_emerge_med",
  submerge = "ia/creatures/seacreature_movement/water_submerge_med",
}

local function OnEnterMood(inst)
  if inst.components.beard and inst.components.beard.bits > 0 then
    inst.AnimState:SetBuild("ox_heat_build")
    inst.AnimState:SetBank("ox")
    inst:AddTag("scarytoprey")
  end
end

local function OnLeaveMood(inst)
  if inst.components.beard and inst.components.beard.bits > 0 then
    inst.AnimState:SetBuild("ox_build")
    inst.AnimState:SetBank("ox")
    inst:RemoveTag("scarytoprey")
  end
end

local function Retarget(inst)
	local herd = inst.components.herdmember and inst.components.herdmember:GetHerd()
	if herd and herd.components.mood and herd.components.mood:IsInMood() then
		return FindEntity(
                inst,
                TUNING.OX_TARGET_DIST,
                function(guy)
                    return inst.components.combat:CanTarget(guy)
                        and (guy.components.rider == nil
                            or guy.components.rider:GetMount() == nil
                            or not guy.components.rider:GetMount():HasTag("beefalo"))
                end,
                { "_combat" }, --See entityreplica.lua (re: "_combat" tag)
                { "ox", "wall", "aquatic", "INLIMBO" } --according to SW, ox never attack aquatic life?
            )
	end
end

local function KeepTarget(inst, target)
	local herd = inst.components.herdmember and inst.components.herdmember:GetHerd()
	return herd and herd.components.mood and herd.components.mood:IsInMood()
		or inst:IsNear(herd, TUNING.OX_CHASE_DIST)
end

local function OnNewTarget(inst, data)
	if data and data.target and data.target == inst.components.follower.leader then
		inst.components.follower:SetLeader(nil)
	end
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, 30,function(dude)
      return dude:HasTag("ox") and not dude:HasTag("player") and not dude.components.health:IsDead()
    end, 5)
end

local function GetStatus(inst)
	return (inst.components.follower.leader ~= nil and "FOLLOWER")
		or (inst.components.beard ~= nil and inst.components.beard.bits == 0 and "NAKED")
		or (inst.components.domesticatable ~= nil and
			inst.components.domesticatable:IsDomesticated() and
			(inst.tendency == TENDENCY.DEFAULT and "DOMESTICATED" or inst.tendency))
		or nil
end

local function OnWaterChange(inst, onwater)
  if onwater then
    inst.sg:GoToState("submerge")
  else
    inst.sg:GoToState("emerge")
  end
end

local function OnPooped(inst, poop)
  local heading_angle = -(inst.Transform:GetRotation()) + 180

  local pos = Vector3(inst.Transform:GetWorldPosition())
  pos.x = pos.x + (math.cos(heading_angle*DEGREES))
  pos.y = pos.y + 0.9
  pos.z = pos.z + (math.sin(heading_angle*DEGREES))
  poop.Transform:SetPosition(pos.x, pos.y, pos.z)

  if poop.components.inventoryitem then 
    poop.components.inventoryitem:SetLanded(false, true)
  end
end

local function OnEntityWake(inst)
  inst.components.tiletracker:Start()
end

local function OnEntitySleep(inst)
  inst.components.tiletracker:Stop()
end

local function CustomOnHaunt(inst)
	inst.components.periodicspawner:TrySpawn()
	return true
end

local function fn()
	local inst = CreateEntity()
	
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddDynamicShadow()
	inst.entity:AddNetwork()
	
	MakeAmphibiousCharacterPhysics(inst, 100, .8)
	
    inst.DynamicShadow:SetSize(6, 2)
	inst.Transform:SetSixFaced()

	inst.AnimState:SetBank("ox")
	inst.AnimState:SetBuild("ox_build")
	inst.AnimState:PlayAnimation("idle_loop", true)

	inst:AddTag("ox")
	inst:AddTag("animal")
	inst:AddTag("largecreature")
	--herdmember (from herdmember component) added to pristine state for optimization
	inst:AddTag("herdmember")
	
	inst.sounds = sounds
	inst.walksound = sounds.walk_land
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end

  inst:AddComponent("eater")
  inst.components.eater:SetVegetarian()

  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "beefalo_body"
  inst.components.combat:SetDefaultDamage(TUNING.OX_DAMAGE)
  inst.components.combat:SetRetargetFunction(1, Retarget)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.OX_HEALTH)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('ox')    

  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = GetStatus

  inst:AddComponent("knownlocations")
  inst:AddComponent("herdmember")
  inst.components.herdmember.herdprefab = "oxherd"

  -- inst:ListenForEvent("entermood", OnEnterMood)
  -- inst:ListenForEvent("leavemood", OnLeaveMood)

  inst:AddComponent("leader")
  inst:AddComponent("follower")
  inst.components.follower.maxfollowtime = TUNING.OX_FOLLOW_TIME
  inst.components.follower.canaccepttarget = false
  inst:ListenForEvent("newcombattarget", OnNewTarget)
  inst:ListenForEvent("attacked", OnAttacked)

  inst:AddComponent("periodicspawner")
  inst.components.periodicspawner:SetPrefab("poop")
  inst.components.periodicspawner:SetRandomTimes(TUNING.OX_POOP_PERIOD_MIN, TUNING.OX_POOP_PERIOD_MAX)
  inst.components.periodicspawner:SetDensityInRange(20, 2)
  inst.components.periodicspawner:SetMinimumSpacing(8)
  inst.components.periodicspawner:SetOnSpawnFn(OnPooped)
  inst.components.periodicspawner:Start()

  MakeLargeBurnableCharacter(inst, "swap_fire")
  MakeLargeFreezableCharacter(inst, "beefalo_body")

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.walkspeed = TUNING.OX_WALK_SPEED
  inst.components.locomotor.runspeed = TUNING.OX_RUN_SPEED

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetResistance(3)

  inst:AddComponent("tiletracker")
  inst.components.tiletracker:SetOnWaterChangeFn(OnWaterChange)

	MakeHauntablePanic(inst)
	AddHauntableCustomReaction(inst, CustomOnHaunt, true, false, true)

  inst:SetBrain(brain)
  inst:SetStateGraph("SGox")

  inst.OnEntityWake = OnEntityWake
  inst.OnEntitySleep = OnEntitySleep

  return inst
end

return Prefab( "ox", fn, assets, prefabs) 
%%+%%scripts/prefabs/oxherd.lua%%-%%local assets =
{
  --Asset("ANIM", "anim/arrow_indicator.zip"),
}

local prefabs = 
{
  -- "babyox",
  "ox",
}

local function InMood(inst)
  if inst.components.periodicspawner then
    inst.components.periodicspawner:Start()
  end
  if inst.components.herd then
    for k,v in pairs(inst.components.herd.members) do
      k:PushEvent("entermood")
    end
  end
end

local function LeaveMood(inst)
  if inst.components.periodicspawner then
    inst.components.periodicspawner:Stop()
  end
  if inst.components.herd then
    for k,v in pairs(inst.components.herd.members) do
      k:PushEvent("leavemood")
    end
  end
  inst.components.mood:CheckForMoodChange()
end

local function AddMember(inst, member)
	if inst.components.mood then
		member:PushEvent(inst.components.mood:IsInMood() and "entermood" or "leavemood")
	end
end

local function CanSpawn(inst)
  return inst.components.herd and not inst.components.herd:IsFull()
end

local function OnSpawned(inst, newent)
  if inst.components.herd then
    inst.components.herd:AddMember(newent)
  end
end

local function OnEmpty(inst)
  inst:Remove()
end

-- local function OnFull(inst)
  --TODO: mark some ox for death
-- end

local function OnInit(inst)
    inst.components.mood:ValidateMood()
end

local function fn(Sim)
	local inst = CreateEntity()
	
	inst.entity:AddTransform()
    --[[Non-networked entity]]

	-- inst.entity:AddAnimState()
  --inst.AnimState:SetBank("arrow_indicator")
  --inst.AnimState:SetBuild("arrow_indicator")
  --inst.AnimState:PlayAnimation("arrow_loop", true)

	inst:AddTag("herd")
	--V2C: Don't use CLASSIFIED because herds use FindEntities on "herd" tag
	inst:AddTag("NOBLOCK")
	inst:AddTag("NOCLICK")

	inst:AddComponent("herd")
	if inst:HasTag("migratory") then
		inst.components.herd:SetMemberTag("ox_migratory") 
	else
		inst.components.herd:SetMemberTag("ox")
	end
	inst.components.herd:SetGatherRange(TUNING.OXHERD_RANGE)
  inst.components.herd:SetUpdateRange(20)
  inst.components.herd:SetOnEmptyFn(OnEmpty)
  -- inst.components.herd:SetOnFullFn(OnFull)
  inst.components.herd:SetAddMemberFn(AddMember)

  inst:AddComponent("mood")
  inst.components.mood:SetMoodTimeInDays(TUNING.OX_MATING_SEASON_LENGTH, TUNING.OX_MATING_SEASON_WAIT)
  inst.components.mood:SetMoodSeason(SEASONS.AUTUMN) --SEASONS.MILD
  inst.components.mood:SetInMoodFn(InMood)
  inst.components.mood:SetLeaveMoodFn(LeaveMood)
  inst.components.mood:CheckForMoodChange()
  inst:DoTaskInTime(0, OnInit)

  inst:AddComponent("periodicspawner")
  inst.components.periodicspawner:SetRandomTimes(TUNING.OX_MATING_SEASON_BABYDELAY, TUNING.OX_MATING_SEASON_BABYDELAY_VARIANCE)
  inst.components.periodicspawner:SetPrefab("ox")
  inst.components.periodicspawner:SetOnSpawnFn(OnSpawned)
  inst.components.periodicspawner:SetSpawnTestFn(CanSpawn)
  inst.components.periodicspawner:SetDensityInRange(20, 6)
  inst.components.periodicspawner:SetOnlySpawnOffscreen(true)

  return inst
end

return Prefab( "oxherd", fn, assets, prefabs) 
%%+%%scripts/prefabs/ox_flute.lua%%-%%local assets=
{
  Asset("ANIM", "anim/ox_flute.zip"),
}

local function onfinished(inst)
  inst:Remove()
end

local function OnPlayed(inst, musician, instrument)
  TheWorld:PushEvent("ms_forceprecipitation")
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst:AddTag("flute")

  inst.AnimState:SetBank("ox_flute")
  inst.AnimState:SetBuild("ox_flute")
  inst.AnimState:PlayAnimation("idle")

  inst.flutebuild = "ox_flute"
  inst.flutesymbol = "ox_flute01"

  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end
  
  inst:AddComponent("inspectable")
  inst:AddComponent("instrument")
  inst.components.instrument.onplayed = OnPlayed
  inst.components.instrument.sound_noloop = "ia/common/ox_flute"    

  inst:AddComponent("tool")
  inst.components.tool:SetAction(ACTIONS.PLAY)

  inst:AddComponent("finiteuses")
  inst.components.finiteuses:SetMaxUses(TUNING.OX_FLUTE_USES)
  inst.components.finiteuses:SetUses(TUNING.OX_FLUTE_USES)
  inst.components.finiteuses:SetOnFinished( onfinished)
  inst.components.finiteuses:SetConsumption(ACTIONS.PLAY, 1)

  MakeInvItemIA(inst, "ox_flute")

  return inst
end

return Prefab( "ox_flute", fn, assets) 
%%+%%scripts/prefabs/ox_horn.lua%%-%%local assets=
{
  Asset("ANIM", "anim/ox_horn.zip"),
}

local function onfinished(inst)
  inst:Remove()
end

local function HearPanFlute(inst, musician, instrument)
  TheWorld:PushEvent("ms_forceprecipitation")
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("ox_horn")
  inst.AnimState:SetBuild("ox_horn")
  inst.AnimState:PlayAnimation("idle")

  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  return inst
end

return Prefab( "ox_horn", fn, assets) %%+%%scripts/prefabs/packim.lua%%-%%local assets =
{
    Asset("ANIM", "anim/ui_chester_shadow_3x4.zip"),
    Asset("ANIM", "anim/ui_chest_3x3.zip"),

    Asset("ANIM", "anim/packim.zip"),
    Asset("ANIM", "anim/packim_build.zip"),
    Asset("ANIM", "anim/packim_fat_build.zip"),
    Asset("ANIM", "anim/packim_fire_build.zip"),

    Asset("MINIMAP_IMAGE", "packim"),
    Asset("MINIMAP_IMAGE", "packim_fat"),
    Asset("MINIMAP_IMAGE", "packim_fire"),
}

local prefabs =
{
    "packim_fishbone",
    "die_fx",
    "chesterlight",
    "sparklefx",
    "firestaff",
    "feathers_packim",
    "feathers_packim_fat",
    "feathers_packim_fire",
}

local brain = require "brains/packimbrain"

local normalsounds =
{
    close = "ia/creatures/packim/close",
    death = "ia/creatures/packim/death",
    hurt = "ia/creatures/packim/hurt",
    land = "ia/creatures/packim/land",
    open = "ia/creatures/packim/open",
    swallow = "ia/creatures/packim/swallow",
    transform = "ia/creatures/packim/transform",
    trasnform_stretch = "ia/creatures/packim/transform_stretch",
    transform_pop = "ia/creatures/packim/transformation_pop",
    fly = "ia/creatures/packim/fly",
    fly_sleep = "ia/creatures/packim/fly_sleep",
    sleep = "ia/creatures/packim/sleep",
    bounce = "ia/creatures/packim/fly_bounce",

    -- only fat packim
    fat_death_spin = "ia/creatures/packim/fat/death_spin",
    fat_land_empty = "ia/creatures/packim/fat/land_empty",
    fat_land_full = "ia/creatures/packim/fat/land_full",
}

local fatsounds = 
{
    close = "ia/creatures/packim/fat/close",
    death = "ia/creatures/packim/fat/death",
    hurt = "ia/creatures/packim/fat/hurt",
    land = "ia/creatures/packim/land",
    open = "ia/creatures/packim/fat/open",
    swallow = "ia/creatures/packim/fat/swallow",
    transform = "ia/creatures/packim/transform",
    trasnform_stretch = "ia/creatures/packim/trasnform_stretch",
    transform_pop = "ia/creatures/packim/trasformation_pop",
    fly = "ia/creatures/packim/fly",
    fly_sleep = "ia/creatures/packim/fly_sleep",
    sleep = "ia/creatures/packim/sleep",
    bounce = "ia/creatures/packim/fly_bounce",
    
    -- only fat packim
    fat_death_spin = "ia/creatures/packim/fat/death_spin",
    fat_land_empty = "ia/creatures/packim/fat/land_empty",
    fat_land_full = "ia/creatures/packim/fat/land_full",
}

local WAKE_TO_FOLLOW_DISTANCE = 14
local SLEEP_NEAR_LEADER_DISTANCE = 7

local function ShouldWakeUp(inst)
    return DefaultWakeTest(inst) or not inst.components.follower:IsNearLeader(WAKE_TO_FOLLOW_DISTANCE)
end

local function ShouldSleep(inst)
    return DefaultSleepTest(inst) and not inst.sg:HasStateTag("open") and inst.components.follower:IsNearLeader(SLEEP_NEAR_LEADER_DISTANCE) and not TheWorld.state.isfullmoon
end

local function ShouldKeepTarget(inst, target)
    return false -- packim can't attack, and won't sleep if he has a target
end


local function OnOpen(inst)
    if not inst.components.health:IsDead() then
        inst.sg:GoToState("open")
    end
end

local function OnClose(inst)
    if not inst.components.health:IsDead() then
        inst.sg:GoToState("close")
    end
end

-- eye bone was killed/destroyed
local function OnStopFollowing(inst)
    inst:RemoveTag("companion")
end

local function OnStartFollowing(inst)
    inst:AddTag("companion")
end

local function RetargetFn(inst) 
    local notags = {"FX", "NOCLICK","INLIMBO", "abigail", "player"}
    local yestags = {"monster"}
    if not inst.last_fire_time or (inst.fire_interval and (GetTime() - inst.last_fire_time) > inst.fire_interval) then      
        return FindEntity(inst, TUNING.PIG_TARGET_DIST,
            function(guy)
                if not guy.LightWatcher or guy.LightWatcher:IsInLight() then
                    return guy.components.health and not guy.components.health:IsDead() and inst.components.combat:CanTarget(guy) 
                end
            end, yestags, notags)
    end
    return nil
end

local function KeepTargetFn(inst, target)
    if not inst.last_fire_time or (inst.fire_interval and (GetTime() - inst.last_fire_time) > inst.fire_interval) then
        --give up on dead guys, or guys in the dark, or werepigs
        return inst.components.combat:CanTarget(target)
        and (not target.LightWatcher or target.LightWatcher:IsInLight())
        and not (target.sg and target.sg:HasStateTag("transform") )
    end
    return false
end

local function tryeatcontents(inst)
    local dideat = false
    local dideatfire = false
    local container = inst.components.container

    if inst.PackimState == "FIRE" then
        for i = 1, container:GetNumSlots() do
            local item = container:GetItemInSlot(i)
            if item and not item:HasTag("irreplaceable") then 
                local replacement = nil 
                if item.components.cookable then 
                    replacement = item.components.cookable:Cook(inst, inst)
                elseif item.components.burnable then 
                    replacement = SpawnPrefab("ash")
                end  
                if replacement then 
                    local stacksize = 1 
                    if item.components.stackable then 
                        stacksize = item.components.stackable:StackSize()
                    end
                    if replacement.components.stackable then 
                        replacement.components.stackable:SetStackSize(stacksize)
                    end 
                    container:RemoveItemBySlot(i)
                    item:Remove()
                    container:GiveItem(replacement, i)
                end 
            end 
        end 
        return false 
    end 

    local loot = {}
    for i = 1, container:GetNumSlots() do
        local item = container:GetItemInSlot(i)
		if item then 
            if item:HasTag("packimfood") then
                dideat = true
                item = container:RemoveItemBySlot(i)
                if item.components.edible then
                    local cals = item.components.edible:GetHunger()
                    if item.components.stackable then
                        cals = cals * item.components.stackable:StackSize()
                    end
                    inst.components.hunger:DoDelta(cals)
                    
                end
                item:Remove()
            elseif item:HasTag("spoiledbypackim") then
                dideat = true
                item = container:RemoveItemBySlot(i)
                if item.components.perishable and item.components.perishable.onperishreplacement then
                    local stack = 1 
                    if item.components.stackable then 
                        stack = item.components.stackable:StackSize()
                    end  
                    for i = 1, stack do 
                        table.insert(loot, item.components.perishable.onperishreplacement)
                    end 
                end
                if item.components.edible then
                    local cals = item.components.edible:GetHunger()
                    if item.components.stackable then
                        cals = cals * item.components.stackable:StackSize()
                    end
                    inst.components.hunger:DoDelta(cals)
                end
                item:Remove()
            end
        end
    end
    if #loot > 0 then
        inst.components.lootdropper:SetLoot(loot)

        inst:DoTaskInTime(60 * FRAMES, function(inst)
            inst.components.lootdropper:DropLoot()
            inst.components.lootdropper:SetLoot({})
        end)
    end

    return dideat
end

local function MorphFatPackim(inst, noconsume)
    local container = inst.components.container
    inst.forceclosed = true
    container:Close()
    inst.forceclosed = false

    local old_SetNumSlots = container.SetNumSlots
    function container:SetNumSlots(numslots)
        self.numslots = numslots
    end

    inst.components.container:WidgetSetup("fat_packim")

    container.SetNumSlots = old_SetNumSlots

    inst.PackimState = "FAT"
    inst._isfatpackim:set(true)

    inst.AnimState:SetBuild("packim_fat_build")
    inst.MiniMapEntity:SetIcon("packim_fat.tex")
    inst.components.maprevealable:SetIcon("packim_fat.tex")

    inst:RemoveTag("fireimmune")

    inst.sounds = fatsounds

    local fx = SpawnPrefab("feathers_packim_fat")
    fx.Transform:SetPosition(inst:GetPosition():Get())
end

local function WeaponDropped(inst)
    inst:Remove()
end

local function MorphFirePackim(inst, noconsume)
    local container = inst.components.container
    inst.forceclosed = true
    container:Close()
    inst.forceclosed = false

    if not noconsume then
        local container = inst.components.container
        for i = 1, container:GetNumSlots() do
            container:RemoveItem(container:GetItemInSlot(i)):Remove()
        end
    end

    local old_SetNumSlots = container.SetNumSlots
    function container:SetNumSlots(numslots)
        self.numslots = numslots
    end

    inst.components.container:WidgetSetup("packim")

    container.SetNumSlots = old_SetNumSlots

    inst.PackimState = "FIRE"
    inst._isfatpackim:set(false)

    inst.AnimState:SetBuild("packim_fire_build")
    inst.MiniMapEntity:SetIcon("packim_fire.tex")
    inst.components.maprevealable:SetIcon("packim_fire.tex")

    local weapon = SpawnPrefab("firestaff")
    inst.components.inventory:Equip(weapon)
    weapon:RemoveComponent("finiteuses")
    weapon.persists = false
    weapon.components.inventoryitem:SetOnDroppedFn(WeaponDropped)

    inst:AddTag("fireimmune")

    inst.sounds = normalsounds

    local fx = SpawnPrefab("feathers_packim_fire")
    fx.Transform:SetPosition(inst:GetPosition():Get())
end

local MorphPackim

local function MorphNormalPackim(inst, noconsume)
    local container = inst.components.container
    inst.forceclosed = true
    inst.components.container:Close()
    inst.forceclosed = false

    --Handle things being in the extra slots!
    local oldnumslots = container:GetNumSlots()
    local newnumslots = 9

    local overflowitems = {}

    if oldnumslots > newnumslots then
        local diff = oldnumslots - newnumslots
        for i = newnumslots + 1, oldnumslots, 1 do
            overflowitems[#overflowitems + 1] = container:RemoveItemBySlot(i)
        end
    end

    local old_SetNumSlots = container.SetNumSlots
    function container:SetNumSlots(numslots)
        self.numslots = numslots
    end

    inst.components.container:WidgetSetup("packim")

    container.SetNumSlots = old_SetNumSlots

    for i = 1,  #overflowitems, 1  do
        local item = overflowitems[i]
        overflowitems[i] = nil
        container:GiveItem(item, nil, nil, true)
    end

    inst.PackimState = "NORMAL"
    inst._isfatpackim:set(false)
    inst.components.hunger.current = 0

    inst.AnimState:SetBuild("packim_build")
    inst.MiniMapEntity:SetIcon("packim.tex")
    inst.components.maprevealable:SetIcon("packim.tex")

    inst:RemoveTag("fireimmune")

    inst.sounds = normalsounds

    local fx = SpawnPrefab("feathers_packim")
    fx.Transform:SetPosition(inst:GetPosition():Get())
end

local function CanMorph(inst, dideat)
    local canFat = false
    local canFire = true

    if inst.PackimState ~= "NORMAL" then
        return false, false
    end

    if dideat and inst.PackimState == "NORMAL" then
        if inst.components.hunger.current > TUNING.PACKIM_TRANSFORM_HUNGER then
            canFat = true
        end
    end

    local container = inst.components.container

    for i = 1, container:GetNumSlots() do
        local item = container:GetItemInSlot(i)
        if item == nil then
            return canFat, false
        end

        canFire = canFire and item.prefab == "obsidian"

        if not canFire then
            return canFat, false
        end
    end

    return canFat, canFire
end

local function CheckForMorph(inst)
    local dideat = tryeatcontents(inst)

    if inst.forceclosed then return end

    inst.canFat, inst.canFire = CanMorph(inst, dideat)

    if inst.canFat or inst.canFire then
        inst.sg:GoToState("transform", true)
    elseif dideat then
        inst.sg:GoToState("swallow")
    end
end

local function DoMorph(inst, fn, noconsume)
    fn(inst, noconsume)
end

function MorphPackim(inst, noconsume)
    if inst.canFat then 
        MorphFatPackim(inst, noconsume) 
    elseif inst.canFire then
        MorphFirePackim(inst, noconsume)
    else
        MorphNormalPackim(inst, noconsume)
    end
    inst.canFat = false
    inst.canFire = false
end

local function OnStarve(inst)
    if inst.PackimState == "FAT" then
        inst.sg:GoToState("transform")
    end
end

local function OnPoisoned(inst)
    inst:AddTag("spoiler")
end

local function OnPoisonDone(inst)
    inst:RemoveTag("spoiler")
end

local function OnSave(inst, data)
    data.PackimState = inst.PackimState
end

local function OnPreLoad(inst, data)
    if data == nil then
        return
    elseif data.PackimState == "FAT" then
        MorphFatPackim(inst, true)
    elseif data.PackimState == "FIRE" then
        MorphFirePackim(inst, true)
    end
end

local function OnIsFatPackimDirty(inst)
    if inst._isfatpackim:value() ~= inst._clientfatmorphed then
        inst._clientfatmorphed = inst._isfatpackim:value()

        inst.replica.container:WidgetSetup(inst._clientfatmorphed and "fat_packim" or nil)
    end
end

local function OnHaunt(inst)
    if math.random() <= TUNING.HAUNT_CHANCE_ALWAYS then
        inst.components.hauntable.panic = true
        inst.components.hauntable.panictimer = TUNING.HAUNT_PANIC_TIME_SMALL
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    end
    return false
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddDynamicShadow()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()
    inst.entity:AddLightWatcher()

    MakeAmphibiousCharacterPhysics(inst, 75, .5) 

    inst:AddTag("companion")
    inst:AddTag("character")
    inst:AddTag("scarytoprey")
    inst:AddTag("packim")
    inst:AddTag("cattoy")
    inst:AddTag("notraptrigger")
    inst:AddTag("noauradamage")

    inst.MiniMapEntity:SetIcon("packim.tex")
    inst.MiniMapEntity:SetCanUseCache(false)

    inst.AnimState:SetBank("packim")
    inst.AnimState:SetBuild("packim_build")

    inst.DynamicShadow:SetSize(1.5, .6)

    inst.Transform:SetSixFaced()

    inst._isfatpackim = net_bool(inst.GUID, "_isfatpackim", "onisfatpackimdirty")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        inst._clientfatmorphed = false
        inst:ListenForEvent("onisfatpackimdirty", OnIsFatPackimDirty)
        return inst
    end

    ------------------------------------------
    inst:AddComponent("maprevealable")
    inst.components.maprevealable:SetIconPrefab("globalmapiconunderfog")

    inst:AddComponent("combat")
    inst.components.combat.hiteffectsymbol = "chester_body"
    inst.components.combat:SetDefaultDamage(TUNING.PACKIM_DAMAGE)
    inst.components.combat:SetAttackPeriod(TUNING.PACKIM_ATTACK_PERIOD)
    inst.components.combat:SetKeepTargetFunction(KeepTargetFn)
    inst.components.combat:SetRetargetFunction(3, RetargetFn)
    inst.components.combat:SetTarget(nil)

    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.CHESTER_HEALTH)
    inst.components.health:StartRegen(TUNING.CHESTER_HEALTH_REGEN_AMOUNT, TUNING.CHESTER_HEALTH_REGEN_PERIOD)

    MakePoisonableCharacter(inst)
    inst.components.poisonable:SetOnPoisonedFn(OnPoisoned)
    inst.components.poisonable:SetOnPoisonDoneFn(OnPoisonDone)

    inst:AddComponent("inspectable")
    inst.components.inspectable:RecordViews()

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = TUNING.PACKIM_WALKSPEED

    inst:AddComponent("follower")
    inst:ListenForEvent("stopfollowing", OnStopFollowing)
    inst:ListenForEvent("startfollowing", OnStartFollowing)

    inst:AddComponent("knownlocations")

    MakeSmallBurnableCharacter(inst, "PACKIM_BODY", Vector3(100, 50, 0.5))

    inst:AddComponent("inventory")
    inst.components.inventory.maxslots = 0

    inst:AddComponent("container")
    inst.components.container:WidgetSetup("packim")
    inst.components.container.onopenfn = OnOpen
    inst.components.container.onclosefn = OnClose

    --we do this for stuff that does if inst.components.inventory or inst.components.container
    inst.components.inventory.GetItemSlot = function(self, ...) inst.components.container:GetItemSlot(...) end
    inst.components.inventory.GiveItem = function(self, ...) inst.components.container:GiveItem(...) end
    inst.components.inventory.DropItem = function(self, ...) inst.components.container:DropItem(...) end
    inst.components.inventory.RemoveItem = function(self, ...) inst.components.container:RemoveItem(...) end

    inst:AddComponent("sleeper")
    inst.components.sleeper:SetResistance(3)
    inst.components.sleeper.testperiod = GetRandomWithVariance(6, 2)
    inst.components.sleeper:SetSleepTest(ShouldSleep)
    inst.components.sleeper:SetWakeTest(ShouldWakeUp)

    MakeHauntableDropFirstItem(inst)
    AddHauntableCustomReaction(inst, OnHaunt, false, false, true)

    inst:AddComponent("lootdropper")

    inst:AddComponent("hunger")
    inst.components.hunger:SetMax(TUNING.PACKIM_MAX_HUNGER)
    inst.components.hunger:SetKillRate(0)
    inst.components.hunger.current = 0
    inst.components.hunger:SetRate(TUNING.PACKIM_HUNGER_DRAIN)
    inst:ListenForEvent("startstarving", OnStarve)

    inst.sounds = normalsounds

    inst:SetStateGraph("SGpackim")
    inst.sg:GoToState("idle")

    inst:SetBrain(brain)

    inst.PackimState = "NORMAL"
    inst.MorphPackim = MorphPackim
    inst.CheckForMorph = CheckForMorph
    inst:ListenForEvent("onclose", CheckForMorph)

    inst.OnSave = OnSave
    inst.OnPreLoad = OnPreLoad

    return inst
end

return Prefab("packim", fn, assets, prefabs)%%+%%scripts/prefabs/packim_fishbone.lua%%-%%local assets=
{
    Asset("ANIM", "anim/packim_fishbone.zip"),
}

local SPAWN_DIST = 30

local function PackimDead(inst)
	if inst.components.floater then
		inst.components.floater:UpdateAnimations("dead_water", "dead")
	end
	inst.components.inventoryitem:ChangeImageName("packim_fishbone_dead")
end

local function PackimLive(inst)
	if inst.components.floater then
		inst.components.floater:UpdateAnimations("idle_water", "idle_loop")
	end
	inst.components.inventoryitem:ChangeImageName("packim_fishbone")
end

local function NoHoles(pt)
    return not TheWorld.Map:IsPointNearHole(pt)
end

local function GetSpawnPoint(pt)
	local offset = FindWalkableOffset(pt, math.random() * 2 * PI, SPAWN_DIST, 12, true, true, NoHoles)
    if offset ~= nil then
        offset.x = offset.x + pt.x
        offset.z = offset.z + pt.z
        return offset
    end
end

local function SpawnPackim(inst)
    local pt = inst:GetPosition()
    local spawn_pt = GetSpawnPoint(pt)
    if spawn_pt ~= nil then
        local packim = SpawnPrefab("packim")
        if packim ~= nil then
            packim.Physics:Teleport(spawn_pt:Get())
            packim:FacePoint(pt:Get())

            return packim
        end
    -- else
        -- this is not fatal, they can try again in a new location by picking up the bone again
    end
end

local StartRespawn --initialised later

local function StopRespawn(inst)
    if inst.respawntask then
        inst.respawntask:Cancel()
        inst.respawntask = nil
        inst.respawntime = nil
    end
end

local function RebindPackim(inst, packim)
    packim = packim or TheSim:FindFirstEntityWithTag("packim")
    if packim then
		PackimLive(inst)
		inst:ListenForEvent("death", function() StartRespawn(inst, TUNING.PACKIM_RESPAWN_TIME) end, packim)

        if packim.components.follower.leader ~= inst then
            packim.components.follower:SetLeader(inst)
        end
        return true
    end
end

local function RespawnPackim(inst)
    StopRespawn(inst)
    RebindPackim(inst, TheSim:FindFirstEntityWithTag("packim") or SpawnPackim(inst))
end

function StartRespawn(inst, time)
    StopRespawn(inst)

    local time = time or 0
    inst.respawntask = inst:DoTaskInTime(time, RespawnPackim)
    inst.respawntime = GetTime() + time
    if time > 0 then
        PackimDead(inst)
    end
end

local function FixPackim(inst)
	inst.fixtask = nil
	--take an existing FAT BIRD if there is one
	if not RebindPackim(inst) then
        PackimDead(inst)

		if inst.components.inventoryitem.owner then
            local time_remaining = inst.respawntime ~= nil and math.max(0, inst.respawntime - GetTime()) or 0
			StartRespawn(inst, time_remaining)
		end
	end
end

local function OnPutInInventory(inst)
	if not inst.fixtask then
		inst.fixtask = inst:DoTaskInTime(1, FixPackim)
	end
end

local function OnSave(inst, data)
    if inst.respawntime ~= nil then
        local time = GetTime()
        if inst.respawntime > time then
            data.respawntimeremaining = inst.respawntime - time
        end
    end
end

local function OnLoad(inst, data)
    if data == nil then
        return
    end

    if data.respawntimeremaining ~= nil then
        inst.respawntime = data.respawntimeremaining + GetTime()
        if data.respawntimeremaining > 0 then
            PackimDead(inst, true)
        end
    end
end

local function GetStatus(inst)
    return inst.respawntask ~= nil and "WAITING" or nil
end

--idle_water
--dead_water

local function fn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
	inst.entity:AddNetwork()
		
    MakeInventoryPhysics(inst)

    inst:AddTag("packim_fishbone") -- This tag is used to check explicitly for packim_fishbone
    inst:AddTag("irreplaceable")
	inst:AddTag("nonpotatable")

    inst.AnimState:SetBank("fishbone")
    inst.AnimState:SetBuild("packim_fishbone")
    inst.AnimState:PlayAnimation("idle_loop", true)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_loop")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnPutInInventoryFn(OnPutInInventory)
    inst.components.inventoryitem:ChangeImageName("packim_fishbone_dead")
	

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = GetStatus
    inst.components.inspectable:RecordViews()

    inst:AddComponent("leader")

    MakeHauntableLaunch(inst)

    inst.OnLoad = OnLoad
    inst.OnSave = OnSave

	inst.fixtask = inst:DoTaskInTime(1, FixPackim)

    return inst
end

return Prefab("packim_fishbone", fn, assets)
%%+%%scripts/prefabs/palmleaf.lua%%-%%local assets =
{
  Asset("ANIM", "anim/palmleaf.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("palmleaf")
  inst.AnimState:SetBuild("palmleaf")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "ROUGHAGE"
  inst.components.edible.woodiness = 1

  inst:AddTag("cattoy")
  inst:AddComponent("tradable")

  inst:AddComponent("inspectable")

  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = TUNING.SMALL_FUEL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

  MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
  MakeSmallPropagator(inst)

  MakeInvItemIA(inst)

  return inst
end

return Prefab( "palmleaf", fn, assets) 

%%+%%scripts/prefabs/palmleafhut.lua%%-%%require "prefabutil"

local assets =
{
  Asset("ANIM", "anim/palmleaf_hut.zip"),
  Asset("ANIM", "anim/palmleaf_hut_shdw.zip"),
}

local prefabs =
{
  "palmleaf_hut_shadow",
}

local function onhammered(inst, worker)
  if inst:HasTag("fire") and inst.components.burnable then
    inst.components.burnable:Extinguish()
  end
  inst.components.lootdropper:DropLoot()
  local fx = SpawnPrefab("collapse_big")
  fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
  fx:SetMaterial("wood")
  inst:Remove()
end

local function onhit(inst, worker)
  if not inst:HasTag("burnt") then
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle", true)

    if inst.shadow then
      inst.shadow.AnimState:PlayAnimation("hit")
      inst.shadow.AnimState:PushAnimation("idle", true)
    end
  end
end

local function onbuilt(inst)
  inst.AnimState:PlayAnimation("place")
  inst.AnimState:PushAnimation("idle", true)

  if inst.shadow then
    inst.shadow.AnimState:PlayAnimation("place")
    inst.shadow.AnimState:PushAnimation("idle", true)
  end

  inst.SoundEmitter:PlaySound("ia/common/palmleafhut_jumpup")
  inst:DoTaskInTime(23*FRAMES, function() inst.SoundEmitter:PlaySound("ia/common/palmleafhut_land") end)
end

local function onsave(inst, data)
  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end
end

local function onload(inst, data)
  if data and data.burnt then
    inst.components.burnable.onburnt(inst)
  end
end

local function onremove(inst)
  if inst.shadow then
    inst.shadow:Remove()
  end
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()

  inst:AddTag("shelter")
  inst:AddTag("dryshelter")

  inst:AddTag("structure")
  inst.AnimState:SetBank("hut")
  inst.AnimState:SetBuild("palmleaf_hut")
  inst.AnimState:PlayAnimation("idle", true)

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon( "palmleaf_hut.tex" )

  MakeSnowCoveredPristine(inst)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("lootdropper")
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(4)
  inst.components.workable:SetOnFinishCallback(onhammered)
  inst.components.workable:SetOnWorkCallback(onhit)

  inst.shadow = SpawnPrefab("palmleaf_hut_shadow")
  inst:DoTaskInTime(0, function()
      inst.shadow.Transform:SetPosition(inst:GetPosition():Get())
    end)

  MakeSnowCovered(inst, .01)
  inst:ListenForEvent( "onbuilt", onbuilt)

  MakeLargeBurnable(inst, nil, nil, true)
  MakeLargePropagator(inst)

  inst.OnSave = onsave 
  inst.OnLoad = onload

  inst.OnRemoveEntity = onremove

  return inst
end

local function shadowfn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("palmleaf_hut_shdw")
  inst.AnimState:SetBuild("palmleaf_hut_shdw")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("NOCLICK")
  inst:AddTag("FX")

  inst.persists = false

  return inst
end

return Prefab( "palmleaf_hut", fn, assets, prefabs),
MakePlacer( "palmleaf_hut_placer", "hut", "palmleaf_hut", "idle" ),
Prefab("palmleaf_hut_shadow", shadowfn, assets)%%+%%scripts/prefabs/palmleaf_umbrella.lua%%-%%local assets=
{
  Asset("ANIM", "anim/swap_parasol_palmleaf.zip"),
  Asset("ANIM", "anim/parasol_palmleaf.zip"),
}

--in DST, this is handled by the world component "weather"
-- local function UpdateSound(inst)
  -- local equipper = inst.components.equippable:IsEquipped() and inst.components.inventoryitem:GetGrandOwner()
  -- local soundShouldPlay = TheWorld.state.israining and equipper and not equipper.sg:HasStateTag("rowing")
  -- if soundShouldPlay ~= inst.SoundEmitter:PlayingSound("umbrellarainsound") then
    -- if soundShouldPlay then
      -- inst.SoundEmitter:PlaySound("dontstarve/rain/rain_on_umbrella", "umbrellarainsound") 
    -- else
      -- inst.SoundEmitter:KillSound("umbrellarainsound")
    -- end
  -- end
-- end  

local function onfinished(inst)
  inst:Remove()
end

local function onperish(inst)
  if inst.components.inventoryitem and inst.components.inventoryitem:IsHeld() then
    local owner = inst.components.inventoryitem.owner
    inst:Remove()

    if owner then
      owner:PushEvent("umbrellaranout")
    end
  else
    inst:Remove()
  end
end    


local function common_fn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()

  MakeInventoryPhysics(inst)

  inst:AddTag("nopunch")
  inst:AddTag("umbrella")

  MakeSnowCoveredPristine(inst)
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    return inst
end

local function master_fn(inst)
  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("waterproofer")
  inst:AddComponent("inspectable")
  inst:AddComponent("equippable")

  inst:AddComponent("insulator")
  inst.components.insulator:SetSummer()

  -- inst:ListenForEvent("rainstop", function() UpdateSound(inst) end, TheWorld) 
  -- inst:ListenForEvent("rainstart", function() UpdateSound(inst) end, TheWorld) 

  -- inst:ListenForEvent("startrowing", function() UpdateSound(inst) end)
  -- inst:ListenForEvent("stoprowing", function() UpdateSound(inst) end)
end

local function onequip_palmleaf(inst, owner) 
  owner.AnimState:OverrideSymbol("swap_object", "swap_parasol_palmleaf", "swap_parasol_palmleaf")
  owner.AnimState:Show("ARM_carry")
  owner.AnimState:Hide("ARM_normal")
  -- UpdateSound(inst)

  owner.DynamicShadow:SetSize(1.7, 1)
end

local function onunequip_palmleaf(inst, owner) 
  owner.AnimState:Hide("ARM_carry") 
  owner.AnimState:Show("ARM_normal") 
  -- UpdateSound(inst)

  owner.DynamicShadow:SetSize(1.3, 0.6)
end

local function palmleaf()
  local inst = common_fn()

  inst.AnimState:SetBank("parasol_palmleaf")
  inst.AnimState:SetBuild("parasol_palmleaf")
  inst.AnimState:PlayAnimation("idle")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	master_fn(inst)

  MakeInvItemIA(inst)

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.GRASS_UMBRELLA_PERISHTIME)
  inst.components.perishable:StartPerishing()
  inst.components.perishable:SetOnPerishFn(onperish)
  inst:AddTag("show_spoilage")

  inst.components.waterproofer:SetEffectiveness(TUNING.WATERPROOFNESS_MED)

  inst.components.equippable:SetOnEquip( onequip_palmleaf )
  inst.components.equippable:SetOnUnequip( onunequip_palmleaf )

  inst.components.insulator:SetInsulation(TUNING.INSULATION_MED)

  inst.components.equippable.dapperness = TUNING.DAPPERNESS_SMALL

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.WRATH_SMALL

  MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
  MakeSmallPropagator(inst)

  return inst
end

return Prefab( "palmleaf_umbrella", palmleaf, assets)
%%+%%scripts/prefabs/palmtrees.lua%%-%%local assets =
{
  Asset("ANIM", "anim/palmtree_build.zip"),
  Asset("ANIM", "anim/palmtree_normal.zip"),
  Asset("ANIM", "anim/palmtree_short.zip"),
  Asset("ANIM", "anim/palmtree_tall.zip"),
  Asset("ANIM", "anim/cavein_dust_fx.zip"),
  Asset("SOUND", "sound/forest.fsb"),
}

local prefabs =
{
  "log",
  "coconut",
  "charcoal",
  "leif_palm",
  "pine_needles_chop",
  "palmleaf"
}

SetSharedLootTable('palmtree_short',  {{"log", 1.0}, {"palmleaf", 1.0}})
SetSharedLootTable('palmtree_normal', {{"log", 1.0},{"log", 1.0}, {"palmleaf", 1.0}})
SetSharedLootTable('palmtree_tall',  {{"log", 1.0}, {"log", 1.0}, {"coconut", 1.0}, {"coconut", 0.33},{"palmleaf", 1.0}})

local builds =
{
  normal = {
    file="palmtree_build",
    prefab_name="palmtree",
    regrowth_product="palmtree_short",
    regrowth_tuning=TUNING.EVERGREEN_REGROWTH,
    normal_loot = 'palmtree_normal',
    short_loot = 'palmtree_short',
    tall_loot = 'palmtree_tall',
    leif="leif_palm",
  },
}

local function makeanims(stage)
  return {
    idle="idle_"..stage,
    sway1="sway1_loop_"..stage,
    sway2="sway2_loop_"..stage,
    chop="chop_"..stage,
    fallleft="fallleft_"..stage,
    fallright="fallright_"..stage,
    stump="stump_"..stage,
    burning="burning_loop_"..stage,
    burnt="burnt_"..stage,
    chop_burnt="chop_burnt_"..stage,
    idle_chop_burnt="idle_chop_burnt_"..stage,
    blown1="blown_loop_"..stage.."1",
    blown2="blown_loop_"..stage.."2",
    blown_pre="blown_pre_"..stage,
    blown_pst="blown_pst_"..stage
  }
end

local short_anims = makeanims("short")
local tall_anims = makeanims("tall")
local normal_anims = makeanims("normal")
local old_anims =
{
  idle="idle_old",
  sway1="idle_old",
  sway2="idle_old",
  chop="chop_old",
  fallleft="chop_old",
  fallright="chop_old",
  stump="stump_old",
  burning="idle_olds",
  burnt="burnt_tall",
  chop_burnt="chop_burnt_tall",
  idle_chop_burnt="idle_chop_burnt_tall",
}

local function dig_up_stump(inst, chopper)
  inst:Remove()
  inst.components.lootdropper:SpawnLootPrefab("log")
end

local function chop_down_burnt_tree(inst, chopper)
  inst:RemoveComponent("workable")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeCrumble")
  inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  inst.AnimState:PlayAnimation(inst.anims.chop_burnt)
  RemovePhysicsColliders(inst)
  inst:ListenForEvent("animover", function() inst:Remove() end)
  inst.components.lootdropper:SpawnLootPrefab("charcoal")
  inst.components.lootdropper:DropLoot()
  if inst.pineconetask then
    inst.pineconetask:Cancel()
    inst.pineconetask = nil
  end
end

local function GetBuild(inst)
  local build = builds[inst.build]
  if build == nil then
    return builds["normal"]
  end
  return build
end

local burnt_highlight_override = {.5,.5,.5}
local function OnBurnt(inst, imm)

  local function changes()
    if inst.components.burnable then
      inst.components.burnable:Extinguish()
    end
    inst:RemoveComponent("burnable")
    inst:RemoveComponent("propagator")
    inst:RemoveComponent("growable")
    inst:RemoveComponent("blowinwindgust")
    inst:RemoveTag("shelter")
    inst:RemoveTag("dragonflybait_lowprio")
    inst:RemoveTag("fire")
    inst:RemoveTag("gustable")

    MakeHauntableWork(inst)

    inst.components.lootdropper:SetChanceLootTable(nil)

    if inst.components.workable then
      inst.components.workable:SetWorkLeft(1)
      inst.components.workable:SetOnWorkCallback(nil)
      inst.components.workable:SetOnFinishCallback(chop_down_burnt_tree)
    end
  end

  if imm then
    changes()
  else
    inst:DoTaskInTime( 0.5, changes)
  end
  inst.AnimState:PlayAnimation(inst.anims.burnt, true)
  inst:AddTag("burnt")

	inst.MiniMapEntity:SetIcon("palmtree_burnt.tex")

  inst.highlight_override = burnt_highlight_override
end

local function PushSway(inst)
  if math.random() > .5 then
    inst.AnimState:PushAnimation(inst.anims.sway1, true)
  else
    inst.AnimState:PushAnimation(inst.anims.sway2, true)
  end
end

local function Sway(inst)
  if math.random() > .5 then
    inst.AnimState:PlayAnimation(inst.anims.sway1, true)
  else
    inst.AnimState:PlayAnimation(inst.anims.sway2, true)
  end
  inst.AnimState:SetTime(math.random()*2)
end

local function SetShort(inst)
  inst.anims = short_anims

  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.PALMTREE_CHOPS_SMALL)
  end

  inst.components.lootdropper:SetChanceLootTable(GetBuild(inst).short_loot)
  Sway(inst)
end

local function GrowShort(inst)
  inst.AnimState:PlayAnimation("grow_tall_to_short")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrowFromWilt")
  PushSway(inst)
end

local function SetNormal(inst)
  inst.anims = normal_anims

  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.PALMTREE_CHOPS_NORMAL)
  end

  inst.components.lootdropper:SetChanceLootTable(GetBuild(inst).normal_loot)
  Sway(inst)
end

local function GrowNormal(inst)
  inst.AnimState:PlayAnimation("grow_short_to_normal")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function SetTall(inst)
  inst.anims = tall_anims
  if inst.components.workable then
    inst.components.workable:SetWorkLeft(TUNING.PALMTREE_CHOPS_TALL)
  end

  inst.components.lootdropper:SetChanceLootTable(GetBuild(inst).tall_loot)

  Sway(inst)
end

local function GrowTall(inst)
  inst.AnimState:PlayAnimation("grow_normal_to_tall")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function inspect_tree(inst)
  if inst:HasTag("burnt") then
    return "BURNT"
  elseif inst:HasTag("stump") then
    return "CHOPPED"
  end
end

local growth_stages =
{
  {name="short", time = function(inst) return GetRandomWithVariance(TUNING.PALMTREE_GROW_TIME[1].base, TUNING.PALMTREE_GROW_TIME[1].random) end, fn = function(inst) SetShort(inst) end,  growfn = function(inst) GrowShort(inst) end , leifscale=.7 },
  {name="normal", time = function(inst) return GetRandomWithVariance(TUNING.PALMTREE_GROW_TIME[2].base, TUNING.PALMTREE_GROW_TIME[2].random) end, fn = function(inst) SetNormal(inst) end, growfn = function(inst) GrowNormal(inst) end, leifscale=1 },
  {name="tall", time = function(inst) return GetRandomWithVariance(TUNING.PALMTREE_GROW_TIME[3].base, TUNING.PALMTREE_GROW_TIME[3].random) end, fn = function(inst) SetTall(inst) end, growfn = function(inst) GrowTall(inst) end, leifscale=1.25 },
}

local function grounddetection_update(inst)
  local pt = Point(inst.Transform:GetWorldPosition())

  if pt.y < 2 then
    inst.fell = true
    inst.Physics:SetMotorVel(0,0,0)
  end

  if pt.y <= 0.2 then
    if inst.shadow then
      inst.shadow:Remove()
    end

    local ents = TheSim:FindEntities(pt.x, 0, pt.z, 2, nil, {'smashable'})

    for k,v in pairs(ents) do
      if v and v.components.combat and v ~= inst then  -- quakes shouldn't break the set dressing
        v.components.combat:GetAttacked(inst, 20, nil)
      end
    end

    inst.Physics:SetDamping(0.9)	   	

    if inst.updatetask then
      inst.updatetask:Cancel()
      inst.updatetask = nil
    end
  end

  -- Failsafe: if the entity has been alive for at least 1 second, hasn't changed height significantly since last tick, and isn't near the ground, remove it and its shadow
  if inst.last_y and pt.y > 2 and inst.last_y > 2 and (inst.last_y - pt.y  < 1) and inst:GetTimeAlive() > 1 and not inst.fell then
    inst:Remove()
  end
  inst.last_y = pt.y
end

local function chop_tree(inst, chopper, chops)

  if chopper and chopper:HasTag("beaver") then
    inst.SoundEmitter:PlaySound("dontstarve/characters/woodie/beaver_chop_tree")
  else
    inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
  end

  local fx = SpawnPrefab("pine_needles_chop")
  local x, y, z= inst.Transform:GetWorldPosition()
  fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

  inst.AnimState:PlayAnimation(inst.anims.chop)
  inst.AnimState:PushAnimation(inst.anims.sway1, true)

  --tell any nearby leifs to wake up
  local pt = Vector3(inst.Transform:GetWorldPosition())
  local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, TUNING.PALMTREEGUARD_REAWAKEN_RADIUS, {"leif"})
  for k,v in pairs(ents) do
    if v.components.sleeper and v.components.sleeper:IsAsleep() then
      v:DoTaskInTime(math.random(), function() v.components.sleeper:WakeUp() end)
    end
    v.components.combat:SuggestTarget(chopper)
  end

  if inst.components.growable and inst.components.growable.stage == 3 then
    if math.random() <= TUNING.PALMTREE_COCONUT_CHANCE then
      local coconut = SpawnPrefab("coconut")
      local rad = chopper:GetPosition():Dist(inst:GetPosition())
      local vec = (chopper:GetPosition() - inst:GetPosition()):Normalize()
      local offset = Vector3(vec.x * rad, 4, vec.z * rad)

      coconut.Transform:SetPosition((inst:GetPosition() + offset):Get())
      coconut.updatetask = coconut:DoPeriodicTask(0.1, grounddetection_update, 0.05)
    end
  end
end

local function make_stump(inst)
    inst:RemoveComponent("burnable")
    MakeSmallBurnable(inst)
    inst:RemoveComponent("propagator")
    MakeSmallPropagator(inst)
    inst:RemoveComponent("workable")
    inst:RemoveTag("shelter")
	inst:RemoveComponent("blowinwindgust")
	inst:RemoveTag("gustable")
    inst:RemoveComponent("hauntable")
    MakeHauntableIgnite(inst)

    RemovePhysicsColliders(inst)

    inst:AddTag("stump")
    if inst.components.growable ~= nil then
        inst.components.growable:StopGrowing()
    end

    inst.MiniMapEntity:SetIcon("palmtree_stump.tex")

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.DIG)
    inst.components.workable:SetOnFinishCallback(dig_up_stump)
    inst.components.workable:SetWorkLeft(1)

	--TODO regrow chopped trees
    -- if inst.components.timer and not inst.components.timer:TimerExists("decay") then
        -- inst.components.timer:StartTimer("decay", GetRandomWithVariance(GetBuild(inst).regrowth_tuning.DEAD_DECAY_TIME, GetBuild(inst).regrowth_tuning.DEAD_DECAY_TIME*0.5))
    -- end
end

local function find_leif_spawn_target(item)
    return not item.noleif
end

local function spawn_leif(target)
    --assert(GetBuild(target).leif ~= nil)
    local leif = SpawnPrefab(GetBuild(target).leif)
    leif.AnimState:SetMultColour(target.AnimState:GetMultColour())
	
    local x, y, z = target.Transform:GetWorldPosition()
    target:Remove()

    leif.Transform:SetPosition(x, y, z)
    leif.sg:GoToState("spawn")
	
	return leif
end

local function chop_down_tree(inst, chopper)
  inst.SoundEmitter:PlaySound("dontstarve/forest/treefall")
  local pt = Vector3(inst.Transform:GetWorldPosition())
  local hispos = Vector3(chopper.Transform:GetWorldPosition())

  local he_right = (hispos - pt):Dot(TheCamera:GetRightVec()) > 0

  if he_right then
    inst.AnimState:PlayAnimation(inst.anims.fallleft)
    inst.components.lootdropper:DropLoot(pt - TheCamera:GetRightVec())
  else
    inst.AnimState:PlayAnimation(inst.anims.fallright)
    inst.components.lootdropper:DropLoot(pt + TheCamera:GetRightVec())
  end

  -- local fx = SpawnPrefab("pine_needles_chop")
  -- local x, y, z= inst.Transform:GetWorldPosition()
  -- fx.Transform:SetPosition(x,y + 2 + math.random()*2,z)

  inst:DoTaskInTime(.4, function()
      ShakeAllCameras(CAMERASHAKE.FULL, .25, .03,
        inst.components.growable ~= nil and
        inst.components.growable.stage > 2 and .5 or .25,
        inst, 6)
    end)

  make_stump(inst)
  inst.AnimState:PushAnimation(inst.anims.stump)

  inst:AddTag("NOCLICK")
  inst:DoTaskInTime(2, function() inst:RemoveTag("NOCLICK") end)
end

local function chop_down_tree_leif(inst, chopper)
  chop_down_tree(inst, chopper)

  local days_survived = TheWorld.state.cycles
  if days_survived >= TUNING.PALMTREEGUARD_MIN_DAY then
    if math.random() <= TUNING.PALMTREEGUARD_PERCENT_CHANCE then

      local numleifs = 3
      if days_survived > 30 then
        numleifs = math.random(3,4)
      elseif days_survived > 80 then
        numleifs = math.random(4,5)
      end

      local notags = {"FX", "NOCLICK","INLIMBO", "stump", "burnt"}
      local yestags = {"palmtree"}

      for k = 1,numleifs do
        local target = FindEntity(inst, TUNING.PALMTREEGUARD_MAXSPAWNDIST, find_leif_spawn_target, yestags, notags)

        if target  then
          target.noleif = true
          target.leifscale = growth_stages[target.components.growable.stage].leifscale or 1
          target:DoTaskInTime(1 + math.random()*3, function()
              if target and not target:HasTag("stump") and not target:HasTag("burnt") and
              target.components.growable and target.components.growable.stage <= 3 then
                local target = target
                if builds[target.build] and builds[target.build].leif then
                  local leif = spawn_leif(target)
                  if leif then
                    leif.components.combat:SuggestTarget(chopper)
                  end
                end
              end
          end)
        end
      end
    end
  end
end

local function tree_burnt(inst)
  OnBurnt(inst)
  inst.pineconetask = inst:DoTaskInTime(10,
    function()
      local pt = Vector3(inst.Transform:GetWorldPosition())
      if math.random(0, 1) == 1 then
        pt = pt + TheCamera:GetRightVec()
      else
        pt = pt - TheCamera:GetRightVec()
      end
      inst.components.lootdropper:DropLoot(pt)
      inst.pineconetask = nil
    end)
end

local function onhauntwork(inst, haunter)
    if inst.components.workable ~= nil and math.random() <= TUNING.HAUNT_CHANCE_OFTEN then
        inst.components.workable:WorkedBy(haunter, 1)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    end
    return false
end

local function onhauntpalmtree(inst, haunter)
  if math.random() <= TUNING.HAUNT_CHANCE_SUPERRARE and
  find_leif_spawn_target(inst) and
  not (inst:HasTag("burnt") or inst:HasTag("stump")) then

    spawn_leif(inst)

    inst.components.hauntable.hauntvalue = TUNING.HAUNT_HUGE
    inst.components.hauntable.cooldown_on_successful_haunt = false
    return true
  end
  return onhauntwork(inst, haunter)
end

local function handler_growfromseed (inst)
  inst.components.growable:SetStage(1)
  inst.AnimState:PlayAnimation("grow_seed_to_short")
  inst.SoundEmitter:PlaySound("dontstarve/forest/treeGrow")
  PushSway(inst)
end

local function onsave(inst, data)
  if inst:HasTag("burnt") or inst:HasTag("fire") then
    data.burnt = true
  end

  if inst:HasTag("stump") then
    data.stump = true
  end

  if inst.build ~= "normal" then
    data.build = inst.build
  end
end

local function onload(inst, data)
  if data then
    if not data.build or builds[data.build] == nil then
      inst.build = "normal"
    else
      inst.build = data.build
    end

    if data.burnt then
      inst:AddTag("fire") -- Add the fire tag here: OnEntityWake will handle it actually doing burnt logic
    elseif data.stump then
      make_stump(inst)
      inst.AnimState:PlayAnimation(inst.anims.stump)
    end
  end
end

local function OnEntitySleep(inst)
  local fire = false
  if inst:HasTag("fire") then
    fire = true
  end
  inst:RemoveComponent("burnable")
  inst:RemoveComponent("propagator")
  inst:RemoveComponent("inspectable")
  if fire then
    inst:AddTag("fire")
  end
end

local function OnEntityWake(inst)

  if not inst:HasTag("burnt") and not inst:HasTag("fire") then
    if not inst.components.burnable then
      if inst:HasTag("stump") then
        MakeSmallBurnable(inst)
      else
        MakeLargeBurnable(inst)
        inst.components.burnable:SetFXLevel(5)
        inst.components.burnable:SetOnBurntFn(tree_burnt)
      end
    end

    if not inst.components.propagator then
      if inst:HasTag("stump") then
        MakeSmallPropagator(inst)
      else
        MakeLargePropagator(inst)
      end
    end
  elseif not inst:HasTag("burnt") and inst:HasTag("fire") then
    OnBurnt(inst, true)
  end

  if not inst.components.inspectable then
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_tree
  end
end


local function makefn(build, stage, data)

  local function fn(Sim)
    local l_stage = stage
    if l_stage == 0 then
      l_stage = math.random(1,3)
    end

    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()

    local sound = inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .25)

    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("palmtree.tex")

    minimap:SetPriority(-1)

    inst:AddTag("tree")
	inst:AddTag("plant")
    inst:AddTag("workable")
    inst:AddTag("shelter")
    inst:AddTag("gustable")

    inst.build = build
    inst.AnimState:SetBuild(GetBuild(inst).file)
    inst.AnimState:SetBank("palmtree")

    inst:SetPrefabName( GetBuild(inst).prefab_name )

    MakeSnowCoveredPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    local color = 0.5 + math.random() * 0.5
    inst.AnimState:SetMultColour(color, color, color, 1)

    -------------------
    MakeLargeBurnable(inst)
    inst.components.burnable:SetFXLevel(5)
    inst.components.burnable:SetOnBurntFn(tree_burnt)

    MakeLargePropagator(inst)

    -------------------

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_tree

    -------------------

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.CHOP)
    inst.components.workable:SetOnWorkCallback(chop_tree)
    inst.components.workable:SetOnFinishCallback(chop_down_tree_leif)

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetOnHauntFn(onhauntpalmtree)

    -------------------

    inst:AddComponent("lootdropper")

    ---------------------

    inst:AddComponent("growable")
    inst.components.growable.stages = growth_stages
    inst.components.growable:SetStage(l_stage)
    inst.components.growable.loopstages = true
    inst.components.growable.springgrowth = true
    inst.components.growable:StartGrowing()

    inst.growfromseed = handler_growfromseed

--    inst:AddComponent("plantregrowth")
--    inst.components.plantregrowth:SetRegrowthRate(GetBuild(inst).regrowth_tuning.OFFSPRING_TIME)
--    inst.components.plantregrowth:SetProduct(GetBuild(inst).regrowth_product)
--    inst.components.plantregrowth:SetSearchTag(GetBuild(inst).prefab_name)

	MakeTreeBlowInWindGust(inst, TUNING.PALMTREE_WINDBLOWN_SPEED, TUNING.PALMTREE_WINDBLOWN_FALL_CHANCE)
	inst.PushSway = PushSway
	
    ---------------------

    inst.AnimState:SetTime(math.random()*2)

    ---------------------

    inst.OnSave = onsave
    inst.OnLoad = onload

    MakeSnowCovered(inst, .01)

    ---------------------

    if data =="burnt"  then
      OnBurnt(inst)
    end

    if data =="stump"  then
      inst:RemoveComponent("burnable")
      MakeSmallBurnable(inst)
      inst:RemoveComponent("workable")
      inst:RemoveComponent("propagator")
      MakeSmallPropagator(inst)
      inst:RemoveComponent("growable")
      inst:RemoveComponent("blowinwindgust")
      inst:RemoveTag("gustable")
      RemovePhysicsColliders(inst)
      inst.AnimState:PlayAnimation(inst.anims.stump)
      inst:AddTag("stump")
      inst:AddComponent("workable")
      inst.components.workable:SetWorkAction(ACTIONS.DIG)
      inst.components.workable:SetOnFinishCallback(dig_up_stump)
      inst.components.workable:SetWorkLeft(1)
    end

    inst.OnEntitySleep = OnEntitySleep
    inst.OnEntityWake = OnEntityWake

    return inst
  end
  return fn
end

local function tree(name, build, stage, data)
  return Prefab(name, makefn(build, stage, data), assets, prefabs)
end

return tree("palmtree", "normal", 0),
tree("palmtree_normal", "normal", 2),
tree("palmtree_tall", "normal", 3),
tree("palmtree_short", "normal", 1),
tree("palmtree_burnt", "normal", 0, "burnt"),
tree("palmtree_stump", "normal", 0, "stump")
%%+%%scripts/prefabs/pirateghost.lua%%-%%local assets =
{
    Asset("ANIM", "anim/player_ghost_withhat.zip"),
    Asset("ANIM", "anim/ghost_pirate_build.zip"),
}

local function fn()
	local inst = Prefabs["ghost"].fn()
	
    inst.AnimState:SetBuild("ghost_pirate_build")
	
	return inst
end

return Prefab("pirateghost", fn, assets)
%%+%%scripts/prefabs/piratepack.lua%%-%%local assets = {
    Asset("ANIM", "anim/swap_pirate_booty_bag.zip"),
}

local function SpawnDubloon(inst, owner)
    local dubloon = SpawnPrefab("dubloon")
    local pt = Vector3(inst.Transform:GetWorldPosition()) + Vector3(0, 2, 0)

    dubloon.Transform:SetPosition(pt:Get())
    local angle = owner.Transform:GetRotation()*(PI / 180)
    local sp = (math.random() + 1) * -1
    dubloon.Physics:SetVel(sp * math.cos(angle), math.random() * 2 + 8, -sp * math.sin(angle))
	dubloon.components.inventoryitem:SetLanded(false, true)
end

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_body", "swap_pirate_booty_bag", "backpack")
    owner.AnimState:OverrideSymbol("swap_body", "swap_pirate_booty_bag", "swap_body")

    if inst.components.container ~= nil then
        inst.components.container:Open(owner)
    end

    inst.dubloon_task = inst:DoPeriodicTask(TUNING.TOTAL_DAY_TIME, function() SpawnDubloon(inst, owner) end)
end

local function onunequip(inst, owner)
    owner.AnimState:ClearOverrideSymbol("swap_body")
    owner.AnimState:ClearOverrideSymbol("backpack")

    if inst.components.container ~= nil then
        inst.components.container:Close(owner)
    end

    if inst.dubloon_task then
        inst.dubloon_task:Cancel()
        inst.dubloon_task = nil
    end
end

local function onburnt(inst)
    if inst.components.container ~= nil then
        inst.components.container:DropEverything()
        inst.components.container:Close()
    end

    SpawnPrefab("ash").Transform:SetPosition(inst.Transform:GetWorldPosition())

    inst:Remove()
end

local function onignite(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = false
    end
end

local function onextinguish(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = true
    end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("pirate_booty_bag")
    inst.AnimState:SetBuild("swap_pirate_booty_bag")
    inst.AnimState:PlayAnimation("anim")

    inst:AddTag("backpack")

    inst.MiniMapEntity:SetIcon("piratepack.tex")

    inst.foleysound = "ia/common/foley/pirate_booty_pack"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)
    inst.components.inventoryitem.cangoincontainer = false

    inst:AddComponent("equippable")
    inst.components.equippable.equipslot = EQUIPSLOTS.BACK

    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst:AddComponent("container")
    inst.components.container:WidgetSetup("piratepack")

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    inst.components.burnable:SetOnBurntFn(onburnt)
    inst.components.burnable:SetOnIgniteFn(onignite)
    inst.components.burnable:SetOnExtinguishFn(onextinguish)

    MakeHauntableLaunchAndDropFirstItem(inst)

    return inst
end

return Prefab("piratepack", fn, assets)
%%+%%scripts/prefabs/piratihatitator.lua%%-%%require "prefabutil"

local assets =
{
	Asset("ANIM", "anim/piratihatitator.zip"),
}

local prefabs =
{
	"collapse_small",
}

local function onhammered(inst, worker)
	if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
		inst.components.burnable:Extinguish()
	end
	inst.components.lootdropper:DropLoot()
	local fx = SpawnPrefab("collapse_small")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
	fx:SetMaterial("wood")
	inst:Remove()
end

local function onhit(inst, worker)
	if not inst:HasTag("burnt") then
		inst.AnimState:PlayAnimation("hit")
		if inst.components.prototyper.on then
			inst.AnimState:PushAnimation("proximity_loop", true)
		else
			inst.AnimState:PushAnimation("idle", false)
		end
	end
end

local function spawnparrots(inst)
	if not inst:HasTag("burnt") and math.random() <= 0.1 then
		local pt = inst:GetPosition()
		SpawnPrefab("parrot_pirate").Transform:SetPosition(pt.x, pt.y, pt.z)
		SpawnPrefab("dubloon").Transform:SetPosition(pt.x+1, pt.y, pt.z)
	end
end

local function onsave(inst, data)
	if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
		data.burnt = true
	end
end

local function onload(inst, data)
	if data ~= nil and data.burnt then
		inst.components.burnable.onburnt(inst)
	end
end

local function doonact(inst)
	spawnparrots(inst)
	if inst._activecount > 1 then
		inst._activecount = inst._activecount - 1
	else
		inst._activecount = 0
		inst.SoundEmitter:KillSound("sound")
	end
	inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl4_ding")
end

local function onturnon(inst)
	if inst._activetask == nil and not inst:HasTag("burnt") then
		if inst.AnimState:IsCurrentAnimation("proximity_loop")
			or inst.AnimState:IsCurrentAnimation("place") then
			--NOTE: push again even if already playing, in case an idle was also pushed
			inst.AnimState:PushAnimation("proximity_loop", true)
		else
			inst.AnimState:PlayAnimation("proximity_loop", true)
		end
		if not inst.SoundEmitter:PlayingSound("idlesound") then
			inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl4_idle_LP", "idlesound")
		end
	end
end

local function onturnoff(inst)
	if inst._activetask == nil and not inst:HasTag("burnt") then 
		inst.AnimState:PushAnimation("idle", false)
		inst.SoundEmitter:KillSound("idlesound")
	end
end

local function doneact(inst)
	inst._activetask = nil
	if not inst:HasTag("burnt") then
		if inst.components.prototyper.on then
			onturnon(inst)
		else
			onturnoff(inst)
		end
	end
end

local function onactivate(inst)
	if not inst:HasTag("burnt") then 
		inst.AnimState:PlayAnimation("use")
		inst.AnimState:PushAnimation("idle", false)
		if not inst.SoundEmitter:PlayingSound("sound") then
			inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl4_run", "sound")
		end
		inst._activecount = inst._activecount + 1
		inst:DoTaskInTime(1.5, doonact)
		if inst._activetask ~= nil then
			inst._activetask:Cancel()
		end
		inst._activetask = inst:DoTaskInTime(inst.AnimState:GetCurrentAnimationLength() + 2 * FRAMES, doneact)
	end
end

local function onbuilt(inst, data)
	inst.AnimState:PlayAnimation("place")
	inst.AnimState:PushAnimation("idle", false)
	inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl4_place")
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddMiniMapEntity()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeObstaclePhysics(inst, .4)

	inst.MiniMapEntity:SetPriority(5)
	inst.MiniMapEntity:SetIcon("piratihatitator.tex")

	inst.AnimState:SetBank("piratihatitator")
	inst.AnimState:SetBuild("piratihatitator")
	inst.AnimState:PlayAnimation("idle")

	inst:AddTag("structure")
	inst:AddTag("level4")

	--prototyper (from prototyper component) added to pristine state for optimization
	inst:AddTag("prototyper")

	MakeSnowCoveredPristine(inst)

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst._activecount = 0
	inst._activetask = nil

	inst:AddComponent("inspectable")
	inst:AddComponent("prototyper")
	inst.components.prototyper.onturnon = onturnon
	inst.components.prototyper.onturnoff = onturnoff
	inst.components.prototyper.trees = TUNING.PROTOTYPER_TREES.PRESTIHATITATOR
	inst.components.prototyper.onactivate = onactivate

	inst:ListenForEvent("onbuilt", onbuilt)

	inst:AddComponent("lootdropper")
	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)
	MakeSnowCovered(inst)

	MakeLargeBurnable(inst, nil, nil, true)
	MakeLargePropagator(inst)

	inst.OnSave = onsave
	inst.OnLoad = onload

	inst:AddComponent("hauntable")
	inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

	return inst
end

return Prefab("piratihatitator", fn, assets, prefabs),
	MakePlacer("piratihatitator_placer", "piratihatitator", "piratihatitator", "idle")
%%+%%scripts/prefabs/poisonbalm.lua%%-%%local assets =
{
	Asset("ANIM", "anim/poison_salve.zip"),
}

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("poison_salve")
	inst.AnimState:SetBuild("poison_salve")
	inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)

	inst:AddComponent("poisonhealer")

	MakeHauntableLaunch(inst)

	return inst
end

return Prefab( "poisonbalm", fn, assets) 
%%+%%scripts/prefabs/poisonbubble.lua%%-%%local assets =
{
    Asset("ANIM", "anim/poison.zip"),
}

local function kill(inst)
    if inst and inst:IsValid() then
        inst.SoundEmitter:KillSound("poisoned")
    end
    inst:Remove()
end

local function StopBubbles(inst)
    if inst and inst:IsValid() then
        inst.AnimState:PushAnimation("level"..inst.level.."_pst", false)
        inst:RemoveEventCallback("animqueueover", StopBubbles)
        inst:ListenForEvent("animqueueover", kill)
    end
end

local function common(level, loop)
    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()
    local sound = inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("poison")
    inst.AnimState:SetBuild("poison")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    if loop == nil then
        inst.loop = true
    else
        inst.loop = loop
    end
    inst.level = level or 2
    if inst.loop then
        inst.AnimState:PlayAnimation("level"..inst.level.."_pre")
        inst.AnimState:PushAnimation("level"..inst.level.."_loop", true) -- Let this loop until something externally calls StopBubbles
    else
        inst.AnimState:PlayAnimation("level"..inst.level.."_pre")
        inst.AnimState:PushAnimation("level"..inst.level.."_loop", false)
        inst:ListenForEvent("animqueueover", StopBubbles)
    end

    inst.SoundEmitter:PlaySound("ia/common/poisoned")

    inst:AddTag("fx")

    inst.StopBubbles = StopBubbles

    inst.AnimState:SetFinalOffset(2)

    return inst
end

function MakeBubble(name, level, loop)
    local function fn()
        local inst = common(2, true)
        return inst
    end

    local function shortfn()
        local inst = common(2, true)
        inst:DoTaskInTime(1, StopBubbles)
        return inst
    end

    local function lvl1()
        local inst = common(1, false)
        return inst
    end

    local function lvl1_loop()
        local inst = common(1, true)
        return inst
    end

    local function lvl2()
        local inst = common(2, false)
        return inst
    end

    local function lvl2_loop()
        local inst = common(2, true)
        return inst
    end

    local function lvl3()
        local inst = common(3, false)
        return inst
    end

    local function lvl3_loop()
        local inst = common(3, true)
        return inst
    end

    local function lvl4()
        local inst = common(4, false)
        return inst
    end

    local function lvl4_loop()
        local inst = common(4, true)
        return inst
    end

    local myFn = fn
    if level == 0 then
        myFn = shortfn
    elseif level == 1 then
        if loop then
            myFn = lvl1_loop
        else
            myFn = lvl1
        end
    elseif level == 2 then
        if loop then
            myFn = lvl2_loop
        else
            myFn = lvl2
        end
    elseif level == 3 then
        if loop then
            myFn = lvl3_loop
        else
            myFn = lvl3
        end
    elseif level == 4 then
        if loop then
            myFn = lvl4_loop
        else
            myFn = lvl4
        end
    end

    return Prefab( name, myFn, assets)
end

return MakeBubble("poisonbubble"),
    MakeBubble("poisonbubble_short", 0, true),
    MakeBubble("poisonbubble_level1", 1, false),
    MakeBubble("poisonbubble_level1_loop", 1, true),
    MakeBubble("poisonbubble_level2", 2, false),
    MakeBubble("poisonbubble_level2_loop", 2, false),
    MakeBubble("poisonbubble_level3", 3, false),
    MakeBubble("poisonbubble_level3_loop", 3, true),
    MakeBubble("poisonbubble_level4", 4, false),
    MakeBubble("poisonbubble_level4_loop", 4, true)
%%+%%scripts/prefabs/poisonhole.lua%%-%%local assets =
{
  Asset("ANIM", "anim/poison_hole.zip"),
}

local prefabs = 
{
  -- "collapse_small",
  -- "poisonbubble_short",
  "venomgland",
  "spoiled_food"
}

local function fartover(inst)
  -- print('fartover')
  if not inst.SoundEmitter:PlayingSound("poisonswamp_lp") then
    inst.SoundEmitter:PlaySound("ia/common/poisonswamp_lp", "poisonswamp_lp")
  end

  inst.AnimState:PlayAnimation("boil_start", false)
  inst.AnimState:PushAnimation("boil_loop", true)
  inst.farting = false
end

local function fart(inst, victim)
  if not inst.farting then
    inst.farting = true


    inst.AnimState:PlayAnimation("pop_pre", false)
    inst.AnimState:PushAnimation("pop", false)

    inst:DoTaskInTime(15*FRAMES, function (inst)
        inst.SoundEmitter:KillSound("poisonswamp_lp")
      end)

    inst:DoTaskInTime(20*FRAMES, function()
        inst.SoundEmitter:PlaySound("ia/common/poisonswamp_attack")
        if victim and victim:IsValid() then 
          if inst:GetDistanceSqToInst(victim) <= inst.components.areapoisoner.poisonrange*inst.components.areapoisoner.poisonrange then
            if victim.components.poisonable then
              victim.components.poisonable:Poison(true)
            end
          end
        end 
      end)


    inst:ListenForEvent("animqueueover", fartover)
  end
end

local function steam(inst)
  -- local prefab = SpawnPrefab("poisonbubble_short")
  -- prefab.Transform:SetPosition(inst:GetPosition():Get())
  if not inst.farting then
    inst.farting = true
    inst.AnimState:PlayAnimation("pop_pre", false)
    inst.AnimState:PushAnimation("pop", false)
  end
end

local function dig_up(inst, chopper)
  inst.SoundEmitter:PlaySound("ia/common/poisonswamp_hole_dig")
  if inst.steamtask then
    inst.steamtask:Cancel()
    inst.steamtask = nil
  end
  inst.components.lootdropper:DropLoot()
  inst:Remove()
end

local function OnWake(inst)
  if inst.steamtask then
    inst.steamtask:Cancel()
    inst.steamtask = nil
  end

  inst.SoundEmitter:PlaySound("ia/common/poisonswamp_lp", "poisonswamp_lp")

  inst.steamtask = inst:DoPeriodicTask(3+(math.random()*2), fart)
end

local function OnSleep(inst)
  if inst.steamtask then
    inst.steamtask:Cancel()
    inst.steamtask = nil
  end

  inst.SoundEmitter:KillSound("poisonswamp_lp")

end

local function OnPoisonAttackFn(inst, victim)
  fart(inst, victim)
end


local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("poison_hole")
  inst.AnimState:SetBuild("poison_hole")
  inst.AnimState:PlayAnimation("boil_loop", true)
  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeAreaPoisoner(inst, 3)
  inst.components.areapoisoner:SetOnPoisonAttackFn(OnPoisonAttackFn)
  inst.components.areapoisoner:StartSpreading()

  -- inst.steamtask = inst:DoPeriodicTask(3+(math.random()*2), fart)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:AddRandomLoot("venomgland" , 1)
  inst.components.lootdropper:AddRandomLoot("spoiled_food" , 1)
  inst.components.lootdropper.numrandomloot = 1
  --inst.components.lootdropper:AddChanceLoot("venomgland" , 0.5)
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetOnFinishCallback(dig_up)
  inst.components.workable:SetWorkLeft(1)

  inst.OnEntityWake = OnWake
  inst.OnEntitySleep = OnSleep

  inst:AddComponent("inspectable")

  return inst
end

return Prefab( "poisonhole", fn, assets, prefabs ) 
%%+%%scripts/prefabs/poisonmistarea.lua%%-%%local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddNetwork()

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("areaaware")

    inst:DoTaskInTime(0, function(inst)
        inst.components.areaaware:UpdatePosition()
        local node = inst.components.areaaware.current_area
        if node.area == nil then
            node.area = 1
        end 

        local mist = SpawnPrefab("poisonmist")
        local x, y, z = inst.Transform:GetWorldPosition()
        mist.Transform:SetPosition(x, 0, z)
        mist.components.emitter.area_emitter = CreateAreaEmitter(node.poly, node.cent)
        mist.components.emitter.density_factor = math.ceil(node.area / 4) / 31
        mist.components.emitter:Emit()
    end)

    return inst
end

return Prefab("poisonmistarea", fn) 
%%+%%scripts/prefabs/poisonmistparticle.lua%%-%%local TEXTURE = "levels/textures/ds_fog1.tex"
local SHADER = "shaders/vfx_particle.ksh"
local COLOUR_ENVELOPE_NAME = "mistcolourenvelope"
local SCALE_ENVELOPE_NAME = "mistscaleenvelope"

local assets =
{
    Asset("IMAGE", TEXTURE),
    Asset("SHADER", SHADER),
}

local function InitEnvelopes()
    EnvelopeManager:AddColourEnvelope(
        COLOUR_ENVELOPE_NAME,
        {	
            {0,	    {0, 1, 0, 0.312}},
            {0.1,	{0, 1, 0, 0.612}},
            {0.75,	{0, 1, 0, 0.612}},
            {1,	    {0, 1, 0, 0.312}},
        })

    local max_scale = 10
    EnvelopeManager:AddVector2Envelope(
        SCALE_ENVELOPE_NAME,
        {	
            {0,	{6, 6}},
            {1,	{max_scale, max_scale}},
        })

    InitEnvelopes = nil
end

local MAX_LIFETIME = 31
local GROUND_HEIGHT = .4
local EMITTER_RADIUS = 25

local function fn()
    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()

    inst.entity:AddNetwork()

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false
    -----------------------------------------------------	

    if InitEnvelopes ~= nil then
        InitEnvelopes()
    end


    local config =
    {
        texture = TEXTURE,
        shader = SHADER,
        max_num_particles = MAX_LIFETIME + 1,
        max_lifetime = MAX_LIFETIME,
        SV =
        {
          { x = -1, y = 0, z = 1 },
          { x = 1, y = 0, z = 1 },
        },
        sort_order = 3,
        colour_envelope_name = COLOUR_ENVELOPE_NAME,
        scale_envelope_name = SCALE_ENVELOPE_NAME
    }

    local effect = inst.entity:AddVFXEffect()
    effect:InitEmitters(1)
    effect:SetRenderResources(0, config.texture, config.shader)
    effect:SetMaxNumParticles(0, config.max_num_particles)
    effect:SetMaxLifetime(0, config.max_lifetime)
    effect:SetSpawnVectors(0,
        config.SV[1].x, config.SV[1].y, config.SV[1].z,
        config.SV[2].x, config.SV[2].y, config.SV[2].z
        )
    effect:SetSortOrder(0, config.sort_order)
    effect:SetColourEnvelope(0, config.colour_envelope_name)
    effect:SetScaleEnvelope(0, config.scale_envelope_name)
    effect:SetRadius(0, EMITTER_RADIUS)

    -----------------------------------------------------	

    inst:AddComponent("emitter")
    inst.components.emitter.config = config
    inst.components.emitter.max_lifetime = max_lifetime
    inst.components.emitter.ground_height = ground_height
    inst.components.emitter.particles_per_tick = 1
    return inst
end

return Prefab("poisonmist", fn, assets) 

%%+%%scripts/prefabs/portablecookpot_ia.lua%%-%%require "prefabutil"

local cooking = require("cooking")

local assets =
{
	Asset("ANIM", "anim/cook_pot_warly.zip"),
	Asset("ANIM", "anim/cook_pot_food.zip"),
    Asset("ANIM", "anim/ui_cookpot_1x4.zip"),
}

local prefabs = 
{
	-- "collapse_small",
}
for k, v in pairs(cooking.recipes.cookpot) do
	table.insert(prefabs, v.name)
end

-- local function onhammered(inst, worker)
    -- if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        -- inst.components.burnable:Extinguish()
    -- end
    -- if not inst:HasTag("burnt") and inst.components.stewer.product ~= nil and inst.components.stewer:IsDone() then
        -- inst.components.lootdropper:AddChanceLoot(inst.components.stewer.product, 1)
    -- end
    -- if inst.components.container ~= nil then
        -- inst.components.container:DropEverything()
    -- end
	-- inst.components.lootdropper:AddChanceLoot("portablecookpot_item", 1)
    -- inst.components.lootdropper:DropLoot()
    -- SpawnAt("collapse_small", inst):SetMaterial("metal")
    -- inst:Remove()
-- end

-- local function onhit(inst, worker)
    -- if not inst:HasTag("burnt") then
        -- if inst.components.stewer:IsCooking() then
            -- inst.AnimState:PlayAnimation("hit_empty")
            -- inst.AnimState:PushAnimation("cooking_loop", true)
        -- elseif inst.components.stewer:IsDone() then
            -- inst.AnimState:PlayAnimation("hit_empty")
            -- inst.AnimState:PushAnimation("idle_full", false)
        -- else
            -- inst.AnimState:PlayAnimation("hit_empty")
            -- inst.AnimState:PushAnimation("idle_empty", false)
        -- end
    -- end
-- end

local function refreshpickupable(inst)
	if (not inst.components.container or inst.components.container:IsEmpty())
	and (not inst.components.stewer or not (inst.components.stewer:IsCooking()
	or inst.components.stewer.product))
	and not inst:HasTag("burnt") then
		if not inst.components.pickupable.canbepickedup then
			inst.components.pickupable.canbepickedup = true
		end
	elseif inst.components.pickupable.canbepickedup then
		inst.components.pickupable.canbepickedup = false
	end
end

--anim and sound callbacks

local function ShowProduct(inst)
    if not inst:HasTag("burnt") then
        local product = inst.components.stewer.product
        if IsModCookingProduct(inst.prefab, product) then
            inst.AnimState:OverrideSymbol("swap_cooked", product, product)
        else
            inst.AnimState:OverrideSymbol("swap_cooked", "cook_pot_food", product)
        end
    end
end

local function startcookfn(inst)
    if not inst:HasTag("burnt") then
        inst.AnimState:PlayAnimation("cooking_loop", true)
        inst.SoundEmitter:KillSound("snd")
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot_rattle", "snd")
        inst.Light:Enable(true)
    end
end

local function onopen(inst)
    if not inst:HasTag("burnt") then
        inst.AnimState:PlayAnimation("cooking_pre_loop", true)
        inst.SoundEmitter:KillSound("snd")
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot_open")
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot", "snd")
    end
end

local function onclose(inst)
    if not inst:HasTag("burnt") then 
        if not inst.components.stewer:IsCooking() then
            inst.AnimState:PlayAnimation("idle_empty")
            inst.SoundEmitter:KillSound("snd")
        end
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot_close")
    end
end

local function spoilfn(inst)
    if not inst:HasTag("burnt") then
        inst.components.stewer.product = inst.components.stewer.spoiledproduct
        ShowProduct(inst)
    end
end


local function donecookfn(inst)
    if not inst:HasTag("burnt") then
        inst.AnimState:PlayAnimation("cooking_pst")
        inst.AnimState:PushAnimation("idle_full", false)
        ShowProduct(inst)
        inst.SoundEmitter:KillSound("snd")
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot_finish")
        inst.Light:Enable(false)
    end
end

local function continuedonefn(inst)
    if not inst:HasTag("burnt") then 
        inst.AnimState:PlayAnimation("idle_full")
        ShowProduct(inst)
    end
end

local function continuecookfn(inst)
    if not inst:HasTag("burnt") then 
        inst.AnimState:PlayAnimation("cooking_loop", true)
        inst.Light:Enable(true)
        inst.SoundEmitter:KillSound("snd")
        inst.SoundEmitter:PlaySound("dontstarve/common/cookingpot_rattle", "snd")
    end
end

local function harvestfn(inst)
    if not inst:HasTag("burnt") then
        inst.AnimState:PlayAnimation("idle_empty")
		-- refreshpickupable(inst) --still has product at that point
		inst.components.pickupable.canbepickedup = true
    end
end

local function getstatus(inst)
    return (inst:HasTag("burnt") and "BURNT")
        or (inst.components.stewer:IsDone() and "DONE")
        or (not inst.components.stewer:IsCooking() and "EMPTY")
        or (inst.components.stewer:GetTimeToCook() > 15 and "COOKING_LONG")
        or "COOKING_SHORT"
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle_empty", false)
    -- inst.SoundEmitter:PlaySound("dontstarve/common/cook_pot_craft")
end

local function onsave(inst, data)
    if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end
end

local function onload(inst, data)
    if data ~= nil and data.burnt then
        inst.components.burnable.onburnt(inst)
        inst.Light:Enable(false)
    end
	refreshpickupable(inst)
end

local function onFloodedStart(inst)
	if inst.components.container then 
		inst.components.container.canbeopened = false 
	end
	if inst.components.stewer then 
		if inst.components.stewer.cooking then 
			inst.components.stewer.product = "wetgoop"
		end
	end
end

local function onFloodedEnd(inst)
	if inst.components.container then 
		inst.components.container.canbeopened = true 
	end
end

local function pickupfn(inst, guy)
	if guy.components and guy.components.inventory then
		guy.components.inventory:GiveItem(SpawnPrefab("portablecookpot_item"))
		if inst.components.container then
			inst.components.container:Close() --This isn't really necessary, but it fixes Craft Pot and such. -M
		end
		inst:Remove()
		return true
	end
end

local function ondeploy(inst, pt, deployer)
	local pot = SpawnPrefab("portablecookpot") 
	if pot then 
		pot.Physics:SetCollides(false)
		pot.Physics:Teleport(pt.x, 0, pt.z) 
		pot.Physics:SetCollides(true)
		pot.SoundEmitter:PlaySound("dontstarve/common/place_structure_stone")
		pot.AnimState:PlayAnimation("place")
		pot.AnimState:PushAnimation("idle_empty", false)
		inst:Remove()
	end        
end

-- local function item_droppedfn(inst)
	-- --If this is a valid place to be deployed, auto deploy yourself.
	-- if inst.components.deployable and inst.components.deployable:CanDeploy(inst:GetPosition()) then
		-- inst.components.deployable:Deploy(inst:GetPosition(), inst)
	-- end
-- end

local function itemfn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("cook_pot_warly")
	inst.AnimState:SetBuild("cook_pot_warly")
	inst.AnimState:PlayAnimation("idle_drop")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_drop")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	
	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)
	-- inst.components.inventoryitem:SetOnDroppedFn(item_droppedfn)

	inst:AddComponent("deployable")
	inst.components.deployable.ondeploy = ondeploy
	-- inst.components.deployable:SetDeployMode(DEPLOYMODE.DEFAULT)

	-- inst:AddComponent("characterspecific")
    -- inst.components.characterspecific:SetOwner("warly")
	
	return inst
end

local function fn(Sim)
	local inst = CreateEntity()
	
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddLight()
    inst.entity:AddNetwork()
	
    MakeObstaclePhysics(inst, .5)

    inst.MiniMapEntity:SetIcon( "cookpotwarly.tex" )
	
	inst.Light:Enable(false)
	inst.Light:SetRadius(.6)
	inst.Light:SetFalloff(1)
	inst.Light:SetIntensity(.5)
	inst.Light:SetColour(235/255,62/255,12/255)

	inst:AddTag("structure")
	MakeObstaclePhysics(inst, .5)
	
	inst.AnimState:SetBank("cook_pot_warly")
	inst.AnimState:SetBuild("cook_pot_warly")
	inst.AnimState:PlayAnimation("idle_empty")

    MakeSnowCoveredPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("stewer")
	inst.components.stewer.onstartcooking = startcookfn
	inst.components.stewer.oncontinuecooking = continuecookfn
	inst.components.stewer.oncontinuedone = continuedonefn
	inst.components.stewer.ondonecooking = donecookfn
	inst.components.stewer.onharvest = harvestfn
	inst.components.stewer.onspoil = spoilfn
	
    inst:AddComponent("container")
    inst.components.container:WidgetSetup("portablecookpot")
	inst.components.container.onopenfn = onopen
	inst.components.container.onclosefn = onclose

	inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = getstatus

	--TODO floodable
	-- inst:AddComponent("floodable")
	-- inst.components.floodable.onStartFlooded = onFloodedStart
	-- inst.components.floodable.onStopFlooded = onFloodedEnd
	-- inst.components.floodable.floodEffect = "shock_machines_fx"
	-- inst.components.floodable.floodSound = "ia/creatures/jellyfish/electric_land"

	inst:AddComponent("pickupable")
	inst.components.pickupable:SetOnPickupFn(pickupfn)
	-- inst.components.pickupable.canpickupfn = canpickup

	-- inst:AddComponent("characterspecific")
    -- inst.components.characterspecific:SetOwner("warly")

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)
	
	MakeSnowCovered(inst)
	inst:ListenForEvent( "onbuilt", onbuilt)
	inst:ListenForEvent( "itemget", refreshpickupable)
	inst:ListenForEvent( "itemlose", refreshpickupable)
	
    -- MakeMediumBurnable(inst, nil, nil, true)
    -- MakeSmallPropagator(inst)

    inst.OnSave = onsave
    inst.OnLoad = onload

	return inst
end

return Prefab( "portablecookpot", fn, assets, prefabs),
	MakePlacer( "portablecookpot_item_placer", "cook_pot_warly", "cook_pot_warly", "idle_empty" ),
	Prefab( "portablecookpot_item", itemfn, assets, prefabs)
%%+%%scripts/prefabs/primeape.lua%%-%%local brain = require "brains/primeapebrain"
local nightmarebrain = require "brains/nightmareprimeapebrain"
require "stategraphs/SGprimeape"

local mods = rawget(_G, "mods")

if mods and mods.HealthInfo then
  mods.HealthInfo.AddToWhiteList("primeape")
end

local assets = 
{
  Asset("ANIM", "anim/kiki_basic_sw.zip"),
  Asset("ANIM", "anim/junglekiki_build.zip"),
  Asset("ANIM", "anim/kiki_nightmare_skin.zip"),
  Asset("SOUND", "sound/monkey.fsb"),
}

local prefabs = 
{
  "poop",
  "monkeyprojectile",
  "smallmeat",
  "cave_banana",
}

local SLEEP_DIST_FROMHOME = 1
local SLEEP_DIST_FROMTHREAT = 20
local MAX_CHASEAWAY_DIST = 80
local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 40

local function IsBanana(item)
    return item.prefab == "cave_banana" or item.prefab == "cave_banana_cooked" or item:HasTag("banana")
end

local function SetHarassPlayer(inst, player)
    if inst.harassplayer ~= player then
        if inst._harassovertask ~= nil then
            inst._harassovertask:Cancel()
            inst._harassovertask = nil
        end
        if inst.harassplayer ~= nil then
            inst:RemoveEventCallback("onremove", inst._onharassplayerremoved, inst.harassplayer)
            inst.harassplayer = nil
        end
        if player ~= nil then
            inst:ListenForEvent("onremove", inst._onharassplayerremoved, player)
            inst.harassplayer = player
            inst._harassovertask = inst:DoTaskInTime(120, SetHarassPlayer, nil)
        end
    end
end

local function WeaponDropped(inst)
	inst:Remove()
end

local function ShouldAcceptItem(inst, item)
	if inst.components.sleeper:IsAsleep() then
		return false
	end

	if item.components.equippable and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
		return true
	end

	if IsBanana(item) then
		return true
	end
end

local function OnGetItemFromPlayer(inst, giver, item)

	-- I eat bananas
	if IsBanana(item) then
		-- banana makes us friends (unless I'm a guard)
		if inst.components.combat:TargetIs(giver) then
			inst.components.combat:SetTarget(nil)
		elseif giver.components.leader ~= nil
		and giver.components.minigame_participator == nil then
			inst.sg:GoToState("befriend")
			giver:PushEvent("makefriend")
			giver.components.leader:AddFollower(inst)
			inst.components.follower:AddLoyaltyTime(item.components.edible:GetHunger() * TUNING.PRIMEAPE_LOYALTY_PER_HUNGER)
		end
		if inst.components.sleeper:IsAsleep() then
			inst.components.sleeper:WakeUp()
		end
	end

	--I wear hats
	if item.components.equippable and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
		local current = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HEAD)
		if current then
			inst.components.inventory:DropItem(current)
		end

		inst.components.inventory:Equip(item)
		inst.AnimState:Show("hat")
	end
end

local function OnRefuseItem(inst, item)
  inst.sg:GoToState("refuse")
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end

local function IsPoop(item)
    return item.prefab == "poop"
end

local function oneat(inst)
    --Monkey ate some food. Give him some poop!
    if inst.components.inventory ~= nil then
        local maxpoop = 3
        local poopstack = inst.components.inventory:FindItem(IsPoop)
        if poopstack == nil or poopstack.components.stackable.stacksize < maxpoop then
            inst.components.inventory:GiveItem(SpawnPrefab("poop"))
        end
    end
end

local function onthrow(weapon, inst)
	if inst.components.inventory ~= nil and inst.components.inventory:FindItem(IsPoop) ~= nil then
		inst.components.inventory:ConsumeByName("poop", 1)
	end
end

local function hasammo(inst)
    return inst.components.inventory ~= nil and inst.components.inventory:FindItem(IsPoop) ~= nil
end

local function EquipWeapons(inst)
	if inst.components.inventory ~= nil and not inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS) then
		local thrower = CreateEntity()
		thrower.name = "Thrower"
		thrower.entity:AddTransform()
		thrower:AddComponent("weapon")
		thrower.components.weapon:SetDamage(0)
		thrower.components.weapon:SetRange(TUNING.PRIMEAPE_RANGED_RANGE)
		thrower.components.weapon:SetProjectile("monkeyprojectile")
		thrower.components.weapon:SetOnProjectileLaunch(onthrow)
		thrower:AddComponent("inventoryitem")
		thrower.persists = false
		thrower.components.inventoryitem:SetOnDroppedFn(thrower.Remove)
		thrower:AddComponent("equippable")
		inst.components.inventory:GiveItem(thrower)
		inst.weaponitems.thrower = thrower

		local hitter = CreateEntity()
		hitter.name = "Hitter"
		hitter.entity:AddTransform()
		hitter:AddComponent("weapon")
		hitter.components.weapon:SetDamage(TUNING.PRIMEAPE_MELEE_DAMAGE)
		hitter.components.weapon:SetRange(0)
		hitter:AddComponent("inventoryitem")
		hitter.persists = false
		hitter.components.inventoryitem:SetOnDroppedFn(hitter.Remove)
		hitter:AddComponent("equippable")
		inst.components.inventory:GiveItem(hitter)
		inst.weaponitems.hitter = hitter
	end
end

local function _ForgetTarget(inst)
    inst.components.combat:SetTarget(nil)
end

local function OnAttacked(inst, data)
    inst.components.combat:SetTarget(data.attacker)
    SetHarassPlayer(inst, nil)
    if inst.task ~= nil then
        inst.task:Cancel()
    end
    inst.task = inst:DoTaskInTime(math.random(55, 65), _ForgetTarget) --Forget about target after a minute

    local x, y, z = inst.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x, y, z, 30, { "primeape" })
    for i, v in ipairs(ents) do
        if v ~= inst then
            v.components.combat:SuggestTarget(data.attacker)
            SetHarassPlayer(v, nil)
            if v.task ~= nil then
                v.task:Cancel()
            end
            v.task = v:DoTaskInTime(math.random(55, 65), _ForgetTarget) --Forget about target after a minute
        end
    end
end

local function FindTargetOfInterest(inst)
	if not inst.curious then
		return 
	end

	if inst.harassplayer == nil and inst.components.combat.target == nil then
		local x, y, z = inst.Transform:GetWorldPosition()
        -- Get all players in range
        local targets = FindPlayersInRange(x, y, z, 25)
        -- randomly iterate over all players until we find one we're interested in.
        for i = 1, #targets do
            local randomtarget = math.random(#targets)
            local target = targets[randomtarget]
            table.remove(targets, randomtarget)
            --Higher chance to follow if he has bananas
			local onboat = target.components.sailor and target.components.sailor:IsSailing()
			if not onboat and not target:HasTag("monkey") and not target:HasTag("primeape")
			and (target.components.inventory ~= nil and math.random() < (target.components.inventory:FindItem(IsBanana) ~= nil and .6 or .15)) then
				SetHarassPlayer(inst, target)
				return
			end
		end
	end
end

local function retargetfn(inst)
    return inst:HasTag("nightmare")
        and FindEntity(
                inst,
                20,
                function(guy)
                    return inst.components.combat:CanTarget(guy)
                end,
                { "_combat" }, --see entityreplica.lua
                { "playerghost", "aquatic" },
                { "character", "monster" }
            )
        or nil
end

local function shouldKeepTarget(inst, target)
	local onboat = target.components.sailor and target.components.sailor:IsSailing()
	return not onboat
end

local function _DropAndGoHome(inst)
    if inst.components.inventory ~= nil then
        inst.components.inventory:DropEverything(false, true)
    end
    if inst.components.homeseeker ~= nil and inst.components.homeseeker.home ~= nil then
        inst.components.homeseeker.home:PushEvent("primeapedanger")
    end
end

local function OnPrimeApeDeath(inst, data)
    --A monkey was killed by a player! Run home!
    if data.afflicter ~= nil and data.inst:HasTag("monkey") and data.afflicter:HasTag("player") then
        --Drop all items, go home
        inst:DoTaskInTime(math.random(), _DropAndGoHome)
    end
end

local function onpickup(inst, data)
    local item = data.item
    if item ~= nil and
        item.components.equippable ~= nil and
        item.components.equippable.equipslot == EQUIPSLOTS.HEAD and
        not inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HEAD) then
        --Ugly special case for how the PICKUP action works.
        --Need to wait until PICKUP has called "GiveItem" before equipping item.
        inst:DoTaskInTime(0, function()
            if item:IsValid() and
                item.components.inventoryitem ~= nil and
                item.components.inventoryitem.owner == inst then
                inst.components.inventory:Equip(item)
            end
        end)
    end
    -- if data.item:HasTag("monkeybait") then
    -- 	inst:DoTaskInTime(4+math.random()*2, function(inst)
    -- 		local ball = inst.components.inventory:FindItem(function(item) return item:HasTag("monkeybait") end)
    --               local action = BufferedAction(inst, TheLocalPlayer, ACTIONS.THROW, ball)
    -- 		inst.components.locomotor:PushAction(action, true)
    -- 	end)
    -- end
end

local function DoFx(inst)
  if ExecutingLongUpdate then
    return
  end
  inst.SoundEmitter:PlaySound("dontstarve/common/ghost_spawn")

    local x, y, z = inst.Transform:GetWorldPosition()
	local fx = SpawnPrefab("statue_transition_2")
	if fx then
		fx.Transform:SetPosition(x, y, z)
		fx.Transform:SetScale(.8,.8,.8)
	end
	fx = SpawnPrefab("statue_transition")
	if fx then
		fx.Transform:SetPosition(x, y, z)
		fx.Transform:SetScale(.8,.8,.8)
	end
end

local function SetNormalPrimeApe(inst)
  inst:RemoveTag("nightmare")
  inst:SetBrain(brain)
  inst.AnimState:SetBuild("junglekiki_build")
  inst.AnimState:SetMultColour(1,1,1,1)
  inst.curious = true
  inst.soundtype = "ia/creatures/monkey_island"

  -- inst.components.lootdropper:SetLoot(nil)
  inst.components.combat:SetTarget(nil)

  inst:ListenForEvent("entity_death", inst.listenfn, TheWorld)    
end

local function SetNightmarePrimeApe(inst)
  inst:AddTag("nightmare")
  inst.AnimState:SetMultColour(1,1,1,.6)
  inst:SetBrain(nightmarebrain)
  inst.AnimState:SetBuild("kiki_nightmare_skin")
  inst.soundtype = "dontstarve/creatures/monkey_nightmare"
  SetHarassPlayer(inst, nil)
  inst.curious = false
  if inst.task then
    inst.task:Cancel()
    inst.task = nil
  end

  inst.components.lootdropper:SetLoot({"beardhair"})
  inst.components.combat:SetTarget(nil)

  inst:RemoveEventCallback("entity_death", inst.listenfn, TheWorld) 
end

local function TestNightmareArea(inst, area)
    if (TheWorld.state.isnightmarewild or TheWorld.state.isnightmaredawn)
        and inst.components.areaaware:CurrentlyInTag("Nightmare")
        and not inst:HasTag("nightmare") then

        DoFx(inst)
        SetNightmareMonkey(inst)
    elseif (not TheWorld.state.isnightmarewild and not TheWorld.state.isnightmaredawn)
        and inst:HasTag("nightmare") then
        DoFx(inst)
        SetNormalMonkey(inst)
    end
end

local function TestNightmarePhase(inst, phase)
    if (phase == "wild" or phase == "dawn")
        and inst.components.areaaware:CurrentlyInTag("Nightmare")
        and not inst:HasTag("nightmare") then

        DoFx(inst)
        SetNightmareMonkey(inst)
    elseif (phase ~= "wild" and phase ~= "dawn")
        and inst:HasTag("nightmare") then
        DoFx(inst)
        SetNormalMonkey(inst)
    end
end

local function OnCustomHaunt(inst)
    inst.components.periodicspawner:TrySpawn()
    return true
end

local function OnSave(inst, data)
	data.nightmare = inst:HasTag("nightmare") or nil
end

local function OnLoad(inst, data)
	if data ~= nil and data.nightmare then
		SetNightmarePrimeApe(inst)
	end
end

local function PoofHome(inst)
	if inst.components.homeseeker then
		inst.components.homeseeker:GoHome()
	end
end

local function OnEntitySleep(inst)
	if not inst.components.timer:TimerExists("go_home_delay") then
		PoofHome(inst)
	end
end

local function ontimerdone(inst, data)
	if data.name == "CanThrow" then
		inst.CanThrowItems = true
	elseif data.name == "go_home_delay" then
		if inst:IsAsleep() then
			PoofHome(inst)
		end
	end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()   
    inst.entity:AddDynamicShadow()
    inst.entity:AddNetwork()
    inst.entity:AddLightWatcher() --solely for cave sleeping

    inst.DynamicShadow:SetSize(2, 1.25)

    inst.Transform:SetSixFaced()

    MakeCharacterPhysics(inst, 10, 0.25)

	inst.AnimState:SetBank("kiki")
	inst.AnimState:SetBuild("junglekiki_build")
	inst.AnimState:SetBuild("junglekiki_buil") --set it invalid then correctly again. Don't ask, idk either -M
	inst.AnimState:SetBuild("junglekiki_build") --fixes gitlab issue #240
	inst.AnimState:PlayAnimation("idle_loop", true)

	inst:AddTag("primeape")
	inst:AddTag("animal")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	inst.soundtype = "ia/creatures/monkey_island"

	MakeMediumBurnableCharacter(inst, "kiki_lowerbody")
	MakeMediumFreezableCharacter(inst)

    inst:AddComponent("inventory")

    inst:AddComponent("inspectable")

	inst:AddComponent("thief")
	inst.components.thief:SetCanOpenContainers(false)
	inst.canlootchests = false -- stops it's brain from trying to loot chests

	inst:AddComponent("locomotor")
	inst.components.locomotor:SetSlowMultiplier( 1 )
	inst.components.locomotor:SetTriggersCreep(false)
	inst.components.locomotor.pathcaps = { ignorecreep = false }
	inst.components.locomotor.walkspeed = TUNING.PRIMEAPE_MOVE_SPEED

	inst:AddComponent("combat")
	inst.components.combat:SetAttackPeriod(TUNING.PRIMEAPE_ATTACK_PERIOD)
	inst.components.combat:SetRange(TUNING.PRIMEAPE_MELEE_RANGE)
	inst.components.combat:SetRetargetFunction(1, retargetfn)

	inst.components.combat:SetKeepTargetFunction(shouldKeepTarget)
	inst.components.combat:SetDefaultDamage(0) --This doesn't matter, uses weapon damage

	inst:AddComponent("follower")
	inst.components.follower.maxfollowtime = TUNING.PRIMEAPE_LOYALTY_MAXTIME

	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.PRIMEAPE_HEALTH)

	inst:AddComponent("periodicspawner")
	inst.components.periodicspawner:SetPrefab("poop")
	inst.components.periodicspawner:SetRandomTimes(TUNING.PRIMEAPE_POOP_PERIOD_MIN, TUNING.PRIMEAPE_POOP_PERIOD_MAX)
	inst.components.periodicspawner:SetDensityInRange(20, 2)
	inst.components.periodicspawner:SetMinimumSpacing(15)
	inst.components.periodicspawner:Start()

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:AddRandomLoot("smallmeat", 0.5)
	inst.components.lootdropper:AddRandomLoot("cave_banana", 0.5)
	inst.components.lootdropper.numrandomloot = 1

	inst:AddComponent("eater")
	inst.components.eater:SetVegetarian()
	inst.components.eater:SetOnEatFn(oneat)

	inst:AddComponent("trader")
	inst.components.trader:SetAcceptTest(ShouldAcceptItem)
	inst.components.trader.onaccept = OnGetItemFromPlayer
	inst.components.trader.onrefuse = OnRefuseItem
	inst.components.trader.deleteitemonaccept = false

	inst:AddComponent("sleeper")
    -- inst.components.sleeper.sleeptestfn = NocturnalSleepTest
    -- inst.components.sleeper.waketestfn = NocturnalWakeTest

    -- inst:AddComponent("areaaware")
	
	inst:SetBrain(brain)
	inst:SetStateGraph("SGprimeape")

	inst.FindTargetOfInterestTask = inst:DoPeriodicTask(10, FindTargetOfInterest)	--Find something to be interested in!

    inst.HasAmmo = hasammo
    inst.curious = true
    inst.harassplayer = nil
    inst._onharassplayerremoved = function() SetHarassPlayer(inst, nil) end

	inst:AddComponent("knownlocations")    

	inst:AddComponent("timer")
	inst:DoTaskInTime(0, function()
		if not inst.components.timer:TimerExists("go_home_delay") then
			inst.components.timer:StartTimer("go_home_delay", TUNING.PRIMEAPE_GOHOME_DELAY) -- every monkey goes home a while after it spawns
		end
	end)

	inst:ListenForEvent("timerdone", ontimerdone)

	inst.listenfn = function(listento, data) OnPrimeApeDeath(inst, data) end

	inst:ListenForEvent("onpickupitem", onpickup)
	inst:ListenForEvent("attacked", OnAttacked)

    -- inst:WatchWorldState("nightmarephase", TestNightmarePhase)
    -- inst:ListenForEvent("changearea", TestNightmareArea)

    MakeHauntablePanic(inst)
    AddHauntableCustomReaction(inst, OnCustomHaunt, true, false, true)
	
    inst.weaponitems = {}
    EquipWeapons(inst)

    inst.OnSave = OnSave
    inst.OnLoad = OnLoad
	
	inst.OnEntitySleep = OnEntitySleep
	inst.CanThrowItems = true

	return inst
end

return Prefab("primeape", fn, assets, prefabs)
%%+%%scripts/prefabs/primeapebarrel.lua%%-%%if not IA_CONFIG.allowprimeapebarrel then return end --public DEBUG option

require "prefabutil"
-- require "recipes"

local assets =
{
  Asset("ANIM", "anim/monkey_barrel_tropical.zip"),
  Asset("SOUND", "sound/monkey.fsb"),
}

local prefabs =
{
  "primeape",
  "poop",
  "cave_banana",
  "collapse_small",
}

SetSharedLootTable( 'primeapebarrel',
{
    {'poop',        1.0},
    {'poop',        1.0},
    {'cave_banana', 1.0},
    {'cave_banana', 1.0},
    {'trinket_4',   .01},
})

local function shake(inst)
    inst.AnimState:PlayAnimation(math.random() > .5 and "move1" or "move2")
	inst.AnimState:PushAnimation("idle")
	inst.SoundEmitter:PlaySound("dontstarve/creatures/monkey/barrel_rattle")
end

local function enqueueShake(inst)
    if inst.shake ~= nil then
        inst.shake:Cancel()
    end
    inst.shake = inst:DoPeriodicTask(GetRandomWithVariance(10, 3), shake)
end

local function onhammered(inst)
    if inst.shake ~= nil then
		inst.shake:Cancel()
		inst.shake = nil
	end
	inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
	inst:Remove()
end

local function onhit(inst, worker)
    if inst.components.childspawner ~= nil then
        inst.components.childspawner:ReleaseAllChildren(worker)
    end
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle", false)

    enqueueShake(inst)
end

local function pushsafetospawn(inst)
    inst.safetospawntask = nil
    inst:PushEvent("safetospawn")
end

local function ReturnChildren(inst)
    for k, child in pairs(inst.components.childspawner.childrenoutside) do
        if child.components.homeseeker ~= nil then
            child.components.homeseeker:GoHome()
        end
        child:PushEvent("gohome")
    end

	if inst.safetospawntask then
		inst.safetospawntask:Cancel()
	end
	inst.safetospawntask = inst:DoTaskInTime(math.random(60, 120), pushsafetospawn)
end

local function OnIgniteFn(inst)
    inst.AnimState:PlayAnimation("shake", true)

    if inst.shake ~= nil then
        inst.shake:Cancel()
        inst.shake = nil
    end

    if inst.components.childspawner ~= nil then
        inst.components.childspawner:ReleaseAllChildren()
    end
end

local function ongohome(inst, child)
    if child.components.inventory ~= nil then
        child.components.inventory:DropEverything(false, true)
    end
end

local function onsafetospawn(inst)
    if inst.components.childspawner ~= nil then
        inst.components.childspawner:StartSpawning()
    end
end

local function OnHaunt(inst)
    if inst.components.childspawner == nil or
        not inst.components.childspawner:CanSpawn() or
        math.random() > TUNING.HAUNT_CHANCE_HALF then
        return false
    end

    local target =
        FindEntity(inst,
            25,
            nil,
            { "_combat" },
            { "playerghost", "INLIMBO" },
            { "character", "monster" }
        )

    if target ~= nil then
        onhit(inst, target)
        return true
    end

    return false
end

local function onbuilt(inst)
  inst.AnimState:PlayAnimation("place")
  inst.AnimState:PushAnimation("idle")
  inst.SoundEmitter:PlaySound("ia/common/monkey_barrel_place")
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("prime_ape.tex")

    MakeObstaclePhysics(inst, 1)

	inst.AnimState:SetBank("barrel_tropical")
	inst.AnimState:SetBuild("monkey_barrel_tropical")
	inst.AnimState:PlayAnimation("idle", true)

	-- MakeSnowCoveredPristine(inst)

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent( "childspawner" )
	inst.components.childspawner:SetRegenPeriod(120)
	inst.components.childspawner:SetSpawnPeriod(30)
	inst.components.childspawner:SetMaxChildren(math.random(3, 4))
	inst.components.childspawner:StartRegen()
	inst.components.childspawner.childname = "primeape"
	inst.components.childspawner:StartSpawning()
	inst.components.childspawner.ongohome = ongohome
	inst.components.childspawner:SetSpawnedFn(shake)

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetChanceLootTable('primeapebarrel')

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)

    local function ondanger()
        if inst.components.childspawner ~= nil then
            inst.components.childspawner:StopSpawning()
            ReturnChildren(inst) 
        end
    end
	
    --Monkeys all return on a quake start
    inst:ListenForEvent("warnquake", ondanger, TheWorld)

    --Monkeys all return on danger
    inst:ListenForEvent("primeapedanger", ondanger)

    inst:ListenForEvent("safetospawn", onsafetospawn)

	inst:ListenForEvent("onbuilt", onbuilt)

    inst:AddComponent("inspectable")

    MakeLargeBurnable(inst)
	MakeLargePropagator(inst)

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_SMALL)
    inst.components.hauntable:SetOnHauntFn(OnHaunt)

    enqueueShake(inst)

	return inst
end

return Prefab( "primeapebarrel", fn, assets, prefabs),
MakePlacer("primeapebarrel_placer", "barrel_tropical", "monkey_barrel_tropical", "idle")
%%+%%scripts/prefabs/rainbowjellyfish.lua%%-%%
local assets=
{
  Asset("ANIM", "anim/rainbowjellyfish.zip"),
  Asset("ANIM", "anim/meat_rack_food.zip"),
  Asset("INV_IMAGE", "rainbowJellyJerky"),
}


local prefabs=
{
  "rainbowjellyfish_planted",
}

local function playDeadAnimation(inst)
  inst.AnimState:PlayAnimation("death_ground", true)
  inst.AnimState:PushAnimation("idle_ground", true)
end

local function ondropped(inst)
  --Get tile under my position and set animation accordingly
  if IsOnWater(inst) then
    local replacement = SpawnPrefab("rainbowjellyfish_planted")
    replacement.Transform:SetPosition(inst.Transform:GetWorldPosition())

    inst:Remove()
  else
    local replacement = SpawnPrefab("rainbowjellyfish_dead")
    replacement.Transform:SetPosition(inst.Transform:GetWorldPosition())
    replacement.AnimState:PlayAnimation("stunned_loop", true)
    replacement:DoTaskInTime(2.5, playDeadAnimation)
    replacement:AddTag('stinger')
    inst:Remove()
  end
end

local function oneaten_light(inst, eater)
    if eater.rainbowjellylight and eater.rainbowjellylight:IsValid() then
        eater.rainbowjellylight.components.spell.lifetime = 0
        eater.rainbowjellylight.components.spell:ResumeSpell()
    else
        local light = SpawnPrefab("rainbowjellylight")

        light.components.spell:SetTarget(eater)
		if light:IsValid() then
			if not light.components.spell.target then
				light:Remove()
			else
				light.components.spell:StartSpell()
			end
		end
    end
end

local function commonfn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()
  inst.Transform:SetScale(0.8, 0.8, 0.8)

  inst.entity:AddAnimState()
  MakeInventoryPhysics(inst)
  inst.entity:AddSoundEmitter()
  
  inst.AnimState:SetRayTestOnBB(true);
  inst.AnimState:SetBank("rainbowjellyfish")
  inst.AnimState:SetBuild("rainbowjellyfish")

  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

  inst._startspell = net_event(inst.GUID, "rainbowjellyfish._startspell")

  return inst
end

local function common_master(inst)
  inst:AddComponent("inspectable")
  inst:AddComponent("perishable")

  inst:AddComponent("tradable")
  inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
  inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
end

local function defaultfn()

  local inst = commonfn()
  
  inst:AddTag("show_spoilage")
  inst:AddTag("jellyfish")
  inst:AddTag("fishmeat")
  inst:AddTag("cookable") --added to pristine state for optimization

  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

  common_master(inst)
  
  MakeInvItemIA(inst)

  inst.components.perishable:SetPerishTime(TUNING.PERISH_ONE_DAY * 1.5)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "rainbowjellyfish_dead"

  inst.components.inventoryitem:SetOnDroppedFn(ondropped)
  inst.AnimState:PlayAnimation("idle_ground", true)

--  MakeInventoryFloatable(inst, "idle_water", "idle_ground")

  inst:AddComponent("cookable")
  inst.components.cookable.product = "rainbowjellyfish_cooked"

  inst:AddComponent("health")
  inst.components.health.murdersound = "ia/creatures/jellyfish/death_murder"

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"rainbowjellyfish_dead"})

  return inst

end

local function deadfn()
  local inst = commonfn()

  inst.Transform:SetScale(0.7, 0.7, 0.7)

	--TODO this looks very nonsensical, besides serving no clear purpose (never triggers) -M
	inst:ListenForEvent("rainbowjellyfish._startspell", function(inst)
		oneaten_light(nil, inst)
	end)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle_ground")

  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

  common_master(inst)

  MakeInvItemIA(inst)

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible:SetOnEatenFn(oneaten_light)

  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst.AnimState:PlayAnimation("idle_ground", true)

  inst:AddComponent("cookable")
  inst.components.cookable.product = "rainbowjellyfish_cooked"

  inst:AddComponent("dryable")
  inst.components.dryable:SetProduct("jellyjerky")
  inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  return inst
end


local function cookedfn()
  local inst = commonfn()

  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

  common_master(inst)

  MakeInvItemIA(inst)

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.hungervalue = TUNING.CALORIES_MEDSMALL
  inst.components.edible.sanityvalue = 0

  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst.AnimState:PlayAnimation("cooked", true)
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM
  return inst
end

--this should not really exist, its just a copy of normal jellyjerky
local function driedfn()
  local inst = commonfn()

  inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

  common_master(inst)

  MakeInvItemIA(inst)

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.foodstate = "DRIED"
  inst.components.edible.hungervalue = TUNING.CALORIES_MEDSMALL
  inst.components.edible.sanityvalue = 0

  inst.components.perishable:SetPerishTime(TUNING.PERISH_PRESERVED)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst.AnimState:SetBank("meat_rack_food")
  inst.AnimState:SetBuild("meat_rack_food_sw")
  inst.AnimState:PlayAnimation("idle_dried_jellyjerky", true)
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM
  return inst

end

return Prefab( "rainbowjellyfish", defaultfn, assets),
Prefab( "rainbowjellyfish_dead", deadfn, assets),
Prefab( "rainbowjellyfish_cooked", cookedfn, assets),
Prefab( "rainbowjellyjerky", driedfn, assets)
%%+%%scripts/prefabs/rainbowjellyfishlight.lua%%-%%
local function pushbloom(inst, target)
    if target.components.bloomer ~= nil then
        target.components.bloomer:PushBloom(inst, "shaders/anim.ksh", -1)
    else
        target.AnimState:SetBloomEffectHandle("shaders/anim.ksh")
    end
end

local function popbloom(inst, target)
    if target.components.bloomer ~= nil then
        target.components.bloomer:PopBloom(inst)
    else
        target.AnimState:ClearBloomEffectHandle()
    end
end

local function light_resume(inst, time)
    inst.fx:setprogress(1 - time / inst.components.spell.duration)
end

local function light_start(inst)
    inst.fx:setprogress(0)
end

local function light_ontarget(inst, target)
    if not target or target:HasTag("playerghost") or target:HasTag("overcharge") then
		inst:Remove()
		return
	end
	
    target.rainbowjellylight = inst
    -- target:AddTag(inst.components.spell.spellname)
	
    local function forceremove()
        inst.components.spell:OnFinish()
    end

    --FollowSymbol position still works on blank symbol, just
    --won't be visible, but we are an invisible proxy anyway.
    inst.Follower:FollowSymbol(target.GUID, "", 0, 0, 0)
    inst:ListenForEvent("onremove", forceremove, target)
    inst:ListenForEvent("death", function() inst.fx:setdead() end, target)
	
    if target:HasTag("player") then
        inst:ListenForEvent("ms_becameghost", forceremove, target)
        if target:HasTag("electricdamageimmune") then --this is a bit of a hack, since this does not imply overcharging
            inst:ListenForEvent("ms_overcharge", forceremove, target)
        end
        inst.persists = false
    else
        inst.persists = not target:HasTag("critter")
    end
	
    pushbloom(inst, target)
	
    if target.components.rideable ~= nil then
        local rider = target.components.rideable:GetRider()
        if rider ~= nil then
            pushbloom(inst, rider)
            inst.fx.entity:SetParent(rider.entity)
        else
            inst.fx.entity:SetParent(target.entity)
        end

        inst:ListenForEvent("riderchanged", function(target, data)
            if data.oldrider ~= nil then
                popbloom(inst, data.oldrider)
                inst.fx.entity:SetParent(target.entity)
            end
            if data.newrider ~= nil then
                pushbloom(inst, data.newrider)
                inst.fx.entity:SetParent(data.newrider.entity)
            end
        end, target)
    else
        inst.fx.entity:SetParent(target.entity)
    end
end

local function light_onfinish(inst)
    local target = inst.components.spell.target
    if target ~= nil then
        target.rainbowjellylight = nil

        popbloom(inst, target)

        if target.components.rideable ~= nil then
            local rider = target.components.rideable:GetRider()
            if rider ~= nil then
                popbloom(inst, rider)
            end
        end
    end
end

local function light_onremove(inst)
    inst.fx:Remove()
end

local function lightfn()

    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddFollower()

    -- inst:AddComponent("lighttweener")
    -- inst.light = inst.entity:AddLight()
    -- inst.light:Enable(true)
	
    inst:Hide()
    inst.persists = false --until we get a target

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")
    local spell = inst:AddComponent("spell")
    inst.components.spell.spellname = "rainbowjellylight"
    -- inst.components.spell:SetVariables({ radius = TUNING.RAINBOWJELLYFISH_LIGHT_RADIUS })
    inst.components.spell.duration = TUNING.RAINBOWJELLYFISH_LIGHT_DURATION
    inst.components.spell.ontargetfn = light_ontarget
    inst.components.spell.onstartfn = light_start
    inst.components.spell.onfinishfn = light_onfinish
    -- inst.components.spell.fn = light_spellfn
    inst.components.spell.resumefn = light_resume
    inst.components.spell.removeonfinish = true

    inst.fx = SpawnPrefab("rainbowjellylight_fx")
    inst.OnRemoveEntity = light_onremove
	
    return inst
end
-----------------------------------------------------------------------

local function OnUpdateLight(inst, dt)
    local frame =
        inst._lightdead:value() and
        math.ceil(inst._lightframe:value() * .9 + inst._lightmaxframe * .1) or
        (inst._lightframe:value() + dt)

    if frame >= inst._lightmaxframe then
        inst._lightframe:set_local(inst._lightmaxframe)
        inst._lighttask:Cancel()
        inst._lighttask = nil
    else
        inst._lightframe:set_local(frame)
		
		--colours, only needs to happen if the light is still valid
		inst._colourframe = inst._colourframe + dt
		if inst._colourframe >= 120 then
			inst._colourframe = 0
			inst._colourprev = inst._colouridx
			inst._colouridx = inst._colouridx + 1
			if inst._colouridx > #inst._colours then
				inst._colouridx = 1
			end
		end
		
		--lerp to colour (lighttweener is not used in DST)
		local lerpk = inst._colourframe / 120
		inst.Light:SetColour(
			inst._colours[inst._colourprev][1] * (1 - lerpk) + inst._colours[inst._colouridx][1] * lerpk,
			inst._colours[inst._colourprev][2] * (1 - lerpk) + inst._colours[inst._colouridx][2] * lerpk,
			inst._colours[inst._colourprev][3] * (1 - lerpk) + inst._colours[inst._colouridx][3] * lerpk
		)
		
    end

    inst.Light:SetRadius(TUNING.RAINBOWJELLYFISH_LIGHT_RADIUS * (1 - inst._lightframe:value() / inst._lightmaxframe))
	
end

local function OnLightDirty(inst)
    if inst._lighttask == nil then
        inst._lighttask = inst:DoPeriodicTask(FRAMES, OnUpdateLight, nil, 1)
    end
    OnUpdateLight(inst, 0)
end

local function setprogress(inst, percent)
    inst._lightframe:set(math.max(0, math.min(inst._lightmaxframe, math.floor(percent * inst._lightmaxframe + .5))))
    OnLightDirty(inst)
end

local function setdead(inst)
    inst._lightdead:set(true)
    inst._lightframe:set(inst._lightframe:value())
end

local function lightfx_fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    inst.Light:SetRadius(0)
    inst.Light:SetIntensity(.8)
    inst.Light:SetFalloff(.5)
    inst.Light:SetColour(0, 0, 0)
    inst.Light:Enable(true)
    inst.Light:EnableClientModulation(true)
	
	inst._colours = {
		{0/255, 180/255, 255/255}, --skyblue
		{240/255, 230/255, 100/255}, -- ochre 
		{251/255, 30/255, 30/255}, -- red
	}
	inst._colouridx = 1
	inst._colourprev = #inst._colours
	inst._colourframe = 0

    inst._lightmaxframe = math.floor(TUNING.RAINBOWJELLYFISH_LIGHT_DURATION / FRAMES + .5)
    inst._lightframe = net_ushortint(inst.GUID, "rainbowjellyfishlight_fx._lightframe", "lightdirty")
    inst._lightframe:set(inst._lightmaxframe)
    inst._lightdead = net_bool(inst.GUID, "rainbowjellyfishlight_fx._lightdead")
    inst._lighttask = nil

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        inst:ListenForEvent("lightdirty", OnLightDirty)

        return inst
    end

    inst.setprogress = setprogress
    inst.setdead = setdead
    inst.persists = false

    return inst
end


return Prefab( "rainbowjellylight", lightfn),
Prefab( "rainbowjellylight_fx", lightfx_fn)
%%+%%scripts/prefabs/rainbowjellyfish_planted.lua%%-%%local assets=
{
  Asset("ANIM", "anim/rainbowjellyfish.zip"),
}

local prefabs = {
    "rainbowjellyfish_dead",
}

local INTENSITY = 0.65

local function swapColor(inst, light)
  if inst.ispink then
    inst.ispink = false
    inst.isgreen = true
    inst.components.lighttweener:StartTween(light, nil, nil, nil, {0/255, 180/255, 255/255}, 4, swapColor)
  elseif inst.isgreen then
    inst.isgreen = false
    inst.components.lighttweener:StartTween(light, nil, nil, nil, {240/255, 230/255, 100/255}, 4, swapColor)
  else
    inst.ispink = true
    inst.components.lighttweener:StartTween(light, nil, nil, nil, {251/255, 30/255, 30/255}, 4, swapColor)
  end
end

local function turnon(inst)
  inst._switchlightstate:push()
  if inst.Light and not inst.hidden then	
    inst.Light:Enable(true)
    local secs = 1+math.random()
    inst.components.lighttweener:StartTween(inst.Light, 0, nil, nil, nil, 0)
    inst.components.lighttweener:StartTween(inst.Light, INTENSITY, nil, nil, nil, secs, swapColor)		
  end
end

local function turnoff(inst)
  if inst.Light then
    inst.Light:Enable(false)
  end
end

local function fadein(inst)
  inst.hidden = false
  inst.AnimState:PlayAnimation("idle")
  inst:Show()
  inst:RemoveTag("NOCLICK")	
end

local function fadeout(inst)	
  inst.hidden = true
  inst:AddTag("NOCLICK")
  inst:Hide()
end


local function onwake(inst)
  if not TheWorld.state.isday then
    fadein(inst)
    turnon(inst)		
  else
    turnoff(inst)
  end
end

local function onsleep(inst)
  if TheWorld.state.isday then
    fadeout(inst)
    turnoff(inst)
  end
end


local function OnWorked(inst, worker)
    --stupid DST change, explosives do a "work" check before an attack check, this is reversed in SW
    if not worker.components.explosive then
        if worker.components.inventory then
            local toGive = SpawnPrefab("rainbowjellyfish")
            worker.components.inventory:GiveItem(toGive, nil, Vector3(TheSim:GetScreenPos(inst.Transform:GetWorldPosition())))
            worker.SoundEmitter:PlaySound("ia/common/bugnet_inwater")
            inst.Light:Enable(false)
        end
        inst:Remove()
    end
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddNetwork()
  inst.no_wet_prefix = true	

  inst:AddTag("aquatic")
  inst:AddTag("rainbowjellyfish")
  inst.entity:AddTransform()
  inst.Transform:SetScale(0.8, 0.8, 0.8)
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  local physics = inst.entity:AddPhysics()
  MakeCharacterPhysics(inst, 1, 0.5)
  inst.Transform:SetFourFaced()

  inst.AnimState:SetBank("rainbowjellyfish")
  inst.AnimState:SetBuild("rainbowjellyfish")
  inst.AnimState:PlayAnimation("idle", true)

  inst:AddComponent("lighttweener")
  local light = inst.entity:AddLight()
  inst.Light:SetColour(251/255, 30/255, 30/255)
  inst.Light:Enable(false)
  inst.Light:SetIntensity(0.65)
  inst.Light:SetRadius(1.5)
  inst.Light:SetFalloff(.45)

  inst.ispink = true
  inst.components.lighttweener:StartTween(light, nil, nil, nil, {0/255, 180/255, 255/255}, 4, swapColor)

  inst._switchlightstate = net_event(inst.GUID, "rainbowjellyfish_planted._switchlightstate")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    inst:ListenForEvent("rainbowjellyfish_planted._switchlightstate", function(inst, data)
        if inst.Light and not inst:HasTag("NOCLICK") then	
          local secs = 1+math.random()
          inst.components.lighttweener:StartTween(inst.Light, 0, nil, nil, nil, 0)
          inst.components.lighttweener:StartTween(inst.Light, INTENSITY, nil, nil, nil, secs, swapColor)
        end
      end)

    return inst
  end

-- locomotor must be constructed before the stategraph
  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.RAINBOWJELLYFISH_WALKSPEED

  inst:SetStateGraph("SGrainbowjellyfish")
--inst.AnimState:SetRayTestOnBB(true);
  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

  local brain = require "brains/rainbowjellyfishbrain"
  inst:SetBrain(brain)

  inst:AddComponent("combat")
  inst.components.combat:SetHurtSound("ia/creatures/jellyfish/hit")

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.JELLYFISH_HEALTH)

  MakeMediumFreezableCharacter(inst, "jelly")

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"rainbowjellyfish_dead"})

  inst:AddComponent("inspectable")
  inst:AddComponent("knownlocations")
  inst:AddComponent("sleeper")
  inst.components.sleeper.onlysleepsfromitems = true

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.NET)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable:SetOnFinishCallback(OnWorked)

-- light emitting
  inst.OnEntityWake = onwake
  inst.OnEntitySleep = onsleep

  inst:AddComponent("fader")

  inst:WatchWorldState("isday", function() 
      if TheWorld.state.isday then
        inst:DoTaskInTime(2, function()  turnoff(inst) end) 
      end
    end)

  inst:WatchWorldState("isdusk", function() 
      if TheWorld.state.isdusk then
        turnon(inst) 
      end
    end)

  return inst
end

return Prefab( "rainbowjellyfish_planted", fn, assets, prefabs)
%%+%%scripts/prefabs/rainbowjellyfish_spawner.lua%%-%%

local prefabs =
{
  "rainbowjellyfish_planted",
}

local function initspawn(inst, n)
  local x, y, z = inst.Transform:GetWorldPosition()
  for i = 1, n, 1 do
    local angle = 2 * PI * math.random()
    local rad = math.random(1, 30) * TILE_SCALE
    local dx, dy, dz = x + rad * math.cos(angle), y, z + rad * math.sin(angle)
    local ent = SpawnPrefab(inst.components.childspawner.childname)
    if ent:IsPosSurroundedByWater(dx, dy, dz, 1) then
      ent.Transform:SetPosition(dx, dy, dz)
    else
      ent.Transform:SetPosition(x, y, z)
    end
    -- have jellyfish remember its home, doing this here instead of the brain initialization for the migration
    -- some brains may never have turned on, yet they need to know their home to return to when the migration ends

    ent.components.knownlocations:RememberLocation("home", Vector3(ent.Transform:GetWorldPosition()))

    inst.components.childspawner:TakeOwnership(ent)		
  end
end

local function loadpostpass(inst, ents, data)
  if inst.components.childspawner.childreninside > 0  then
    initspawn(inst, inst.components.childspawner.childreninside)
    inst.components.childspawner.childreninside = 0
  end
  inst.components.childspawner:StartSpawning()
end

local function fn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddNetwork()

  inst:AddTag("NOCLICK")
  inst:AddTag("rainbowjellyfish_spawner")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end


  inst:AddComponent( "childspawner" )
  inst.components.childspawner.childname = "rainbowjellyfish_planted"
  inst.components.childspawner.spawnoffscreen = true
  inst.components.childspawner:SetRegenPeriod(60)
  inst.components.childspawner:SetSpawnPeriod(.1)
  inst.components.childspawner:SetMaxChildren(5)

  inst.OnLoadPostPass = loadpostpass

  return inst
end

return Prefab( "rainbowjellyfish_spawner", fn, nil, prefabs)
%%+%%scripts/prefabs/rawling.lua%%-%%local assets =
{
	Asset("ANIM", "anim/basketball.zip"),
	Asset("ANIM", "anim/swap_basketball.zip"),
}

local prefabs =
{
}

local function onputininventory(inst)
    inst.Physics:SetFriction(.1)
end

local function onthrown(inst)

	inst:DoTaskInTime(0.3, function(inst)
		if inst.components.sentientball then
			inst.components.sentientball:OnThrown()
		end
		inst.components.inventoryitem.canbepickedup = true
	end)
	
	inst.components.inventoryitem.canbepickedup = false
    inst.Physics:SetFriction(.2)
	inst.Transform:SetFourFaced()
	-- inst:FacePoint(pt:Get())
    inst.AnimState:PlayAnimation("throw", true)
    inst.SoundEmitter:PlaySound("ia/common/coconade_throw")

	local thrower = inst.components.complexprojectile.attacker
    if thrower and thrower.components.sanity then
    	thrower.components.sanity:DoDelta(TUNING.SANITY_SUPERTINY)
    end
end

local function onhitground(inst)
	if IsOnWater(inst) then
		--splash fx TODO -M
	else
		inst.AnimState:PlayAnimation("idle")
	end
	-- inst.components.inventoryitem:OnDropped()
end

local function oncollision(inst, other)
	inst.SoundEmitter:PlaySound("ia/common/monkey_ball/bounce")
end

local function onequip(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_basketball", "swap_basketball")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")

	if inst.components.sentientball then
		inst.components.sentientball:OnEquipped()
	end
end

local function onunequip(inst, owner)
	owner.AnimState:ClearOverrideSymbol("swap_object")
	owner.AnimState:Hide("ARM_carry")
	owner.AnimState:Show("ARM_normal")
end

local function ReticuleTargetFn()
	-- return inst.components.throwable:GetThrowPoint()
    local player = TheLocalPlayer
    local ground = TheWorld.Map
    local pos = Vector3()
    --Attack range is 8, leave room for error
    --Min range was chosen to not hit yourself (2 is the hit range)
    for r = 6.5, 3.5, -.25 do
        pos.x, pos.y, pos.z = player.entity:LocalToWorldSpace(r, 0, 0)
        if ground:IsPassableAtPoint(pos:Get()) and not ground:IsGroundTargetBlocked(pos) then
            return pos
        end
    end
    return pos
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
	
	inst.AnimState:SetBank("basketball")
	inst.AnimState:SetBuild("basketball")
	inst.AnimState:PlayAnimation("idle")
	
	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetIcon( "rawling.tex" )

	MakeInventoryPhysics(inst)

	inst:AddTag("nopunch")
	inst:AddTag("irreplaceable")
	
    inst:AddComponent("reticule")
    inst.components.reticule.targetfn = ReticuleTargetFn
    inst.components.reticule.ease = true
	
	inst:AddComponent("talker")
	inst.components.talker.fontsize = 28
	inst.components.talker.font = TALKINGFONT
	inst.components.talker.colour = Vector3(.9, .4, .4, 1)
	inst.components.talker.offset = Vector3(0,100,0)
	inst.components.talker.symbol = "swap_object"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	inst:ListenForEvent("on_landed", onhitground)

    inst.entity:SetPristine()
	
    if not TheWorld.ismastersim then
        return inst
    end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)

	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)
    inst.components.inventoryitem:SetOnPutInInventoryFn(onputininventory)
	inst.components.inventoryitem.bouncesound = "ia/common/monkey_ball/bounce"

	inst:AddComponent("equippable")
	inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)
	inst.components.equippable.equipstack = true
	inst.components.equippable.dapperness = TUNING.DAPPERNESS_MED

	-- note: We don't actually use a classified, so the lines do not sync up. Who cares? -M
	inst:AddComponent("sentientball")
	
	MakeSmallBurnable(inst, TUNING.LARGE_BURNTIME)
	MakeSmallPropagator(inst)
	
    inst:AddComponent("complexprojectile")
    inst.components.complexprojectile:SetHorizontalSpeed(10)
    inst.components.complexprojectile:SetGravity(-15)
    inst.components.complexprojectile:SetLaunchOffset(Vector3(.25, 1, 0))
    inst.components.complexprojectile:SetOnLaunch(onthrown)
    inst.components.complexprojectile:SetOnHit(onhitground)

	inst.Physics:SetCollisionCallback(oncollision)

	inst:ListenForEvent("ontalk", function() 
		if not inst.SoundEmitter:PlayingSound("special") then
			inst.SoundEmitter:PlaySound("ia/characters/rawling/talk_LP", "talk") 
		end
	end)
	inst:ListenForEvent("donetalking", function() inst.SoundEmitter:KillSound("talk") end)

	--TODO should say something, like Lucy does
    MakeHauntableLaunch(inst)
	
	return inst
end

return Prefab( "rawling", fn, assets, prefabs)
%%+%%scripts/prefabs/rock_coral.lua%%-%%local assets =
{
  Asset("ANIM", "anim/coral_rock.zip"),
  Asset("MINIMAP_IMAGE", "rock_coral")
}

local prefabs = {'coral', 'limestonenugget'}

SetSharedLootTable( 'coral_full',
  {
    {'coral', 1.00},
    {'coral', 0.50},
  })

SetSharedLootTable( 'coral_med',
  {
    {'coral', 1.00},
    {'coral', 0.25},
  })

SetSharedLootTable( 'coral_low',
  {
    {'limestonenugget', 1.00},
    {'limestonenugget', 0.66},
    {'limestonenugget', 0.33},
	{'corallarve', 1.00},
  })

local function growtime(inst) return TUNING.TOTAL_DAY_TIME * 6 end

local function SetLow(inst)
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.AnimState:PlayAnimation('low'..inst.animnumber, true)
  inst.components.workable:SetWorkLeft(1)
  inst.components.growable:StartGrowing()
  inst.components.lootdropper:SetChanceLootTable('coral_low')
end

local function SetMedium(inst)
  inst.components.workable:SetWorkAction(ACTIONS.MINE)
  inst.AnimState:PlayAnimation('med'..inst.animnumber, true)
  inst.components.workable:SetWorkLeft(TUNING.CORAL_MIN - 4)
  inst.components.growable:StartGrowing()
  inst.components.lootdropper:SetChanceLootTable('coral_med')
end

local function SetFull(inst)
  inst.components.workable:SetWorkAction(ACTIONS.MINE)
  inst.AnimState:PlayAnimation('full'..inst.animnumber, true)
  inst.components.workable:SetWorkLeft(TUNING.CORAL_MINE)
  inst.components.lootdropper:SetChanceLootTable('coral_full')
end

local growth_stages ={
  { name = "low", time = growtime, fn = SetLow, anim = "low" },
  { name = "med", time = growtime, fn = SetMedium, transition = "low_to_med", anim = "med" },
  { name = "full", fn = SetFull, transition = "med_to_full", anim = "full" }
}

local function OnGrowth(inst, last, current)
  if growth_stages[current].transition then
    inst.AnimState:PlayAnimation(growth_stages[current].transition..inst.animnumber)
    inst.AnimState:PushAnimation(growth_stages[current].anim..inst.animnumber, true)
  else
    inst.AnimState:PlayAnimation(growth_stages[current].anim..inst.animnumber, true)
  end
end

local function OnWork(inst, worker, workleft, numworks)
    local pt = Point(inst.Transform:GetWorldPosition())
	if workleft <= 0 and inst.components.growable.stage == 1 then
		--Hammered
        inst.SoundEmitter:PlaySound("ia/common/coral_break")
        SpawnPrefab("collapse_small").Transform:SetPosition(inst.Transform:GetWorldPosition())
        inst.components.lootdropper:DropLoot(pt)
        inst:Remove()
    else
        if workleft <= 1 and inst.components.growable.stage ~= 1 then
            inst.SoundEmitter:PlaySound("ia/common/coral_break")
            inst.components.lootdropper:DropLoot(pt)
            inst.components.growable:SetStage(1)
        elseif workleft <= 5 and workleft > 1 and inst.components.growable.stage ~= 2 then
            inst.components.lootdropper:DropLoot(pt)
            inst.components.growable:SetStage(2)
            -- inst.SoundEmitter:PlaySound("ia/common/coral_mine")
        end
    end
end

local function OnSave(inst, data)
  data.animnumber = inst.animnumber
  data.stage = inst.components.growable.stage
end

local function OnLoad(inst, data)
  if data then
    inst.animnumber = data.animnumber or math.random(1, 3)

    inst.components.growable:SetStage(data.stage and data.stage or 3)
  end    
end

local LappingSound
local function StartLappingSound(inst)
  local dt = 3 + math.random()*3
  inst.task = inst:DoTaskInTime(dt, function(inst) LappingSound(inst) end)
end
LappingSound = function(inst)
    inst.SoundEmitter:PlaySound("ia/common/lapping_coral")
    StartLappingSound(inst)
end

local function OnWake(inst)
  StartLappingSound(inst)
end
local function OnSleep(inst)
  if inst.task then
    inst.task:Cancel()
    inst.task = nil
  end
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("coral_rock")
  inst.AnimState:SetBuild("coral_rock")    

  MakeObstaclePhysics(inst, 1.33)

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon("rock_coral.tex")

  inst:AddTag("aquatic")
  inst:AddTag("coral")
  
  MakeSnowCoveredPristine(inst)
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('coral_full')

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.MINE)
  inst.components.workable:SetWorkLeft(TUNING.CORAL_MINE)

  inst.components.workable:SetOnWorkCallback(OnWork)

  local r = 0.8 + math.random() * 0.2
  local g = 0.8 + math.random() * 0.2
  local b = 0.8 + math.random() * 0.2
  inst.AnimState:SetMultColour(r, g, b, 1)
  inst.animnumber = math.random(1, 3)

  inst:AddComponent("growable")
  inst.components.growable.stages = growth_stages
  inst:DoTaskInTime(0, function(inst)
      inst.components.growable:SetOnGrowthFn(OnGrowth)
    end)
  inst.components.growable:SetStage(3)

  --inst:AddComponent("waveobstacle")

  inst:AddComponent("inspectable")

  MakeSnowCovered(inst, .01)

  inst.OnSave = OnSave
  inst.OnLoad = OnLoad

  return inst
end

return Prefab("rock_coral", fn, assets, prefabs)%%+%%scripts/prefabs/rock_limpet.lua%%-%%local assets =
{
  Asset("ANIM", "anim/limpetrock.zip"),
}

local prefabs =
{
  "limpets",
  "rocks",
  "flint",
}   


SetSharedLootTable( 'rock_limpet',
  {
    {'rocks', 1.00},
    {'rocks', 1.00},
    {'rocks', 1.00},
    {'flint', 1.00},
    {'flint', 0.60},
  })

local function makeemptyfn(inst)
  if inst.components.pickable and inst.components.pickable.withered then
    inst.AnimState:PlayAnimation("dead_to_empty")
    inst.AnimState:PushAnimation("empty")
  else
    inst.AnimState:PlayAnimation("empty")
  end
  inst.components.workable:SetWorkable(true)
end

local function makebarrenfn(inst)
  if inst.components.pickable and inst.components.pickable.withered then
    if not inst.components.pickable.hasbeenpicked then
      inst.AnimState:PlayAnimation("full_to_dead")
    else
      inst.AnimState:PlayAnimation("empty_to_dead")
    end
    inst.AnimState:PushAnimation("idle_dead")
  else
    inst.AnimState:PlayAnimation("idle_dead")
  end
end

local function onpickedfn(inst, picker)

  if inst.components.pickable then
    inst.components.workable:SetWorkable(true)

    inst.AnimState:PlayAnimation("limpetmost_picked")

    if inst.components.pickable:IsBarren() then
      inst.AnimState:PushAnimation("idle_dead")
    else
      inst.AnimState:PushAnimation("idle")
    end
  end
end

local function getregentimefn(inst)
  return TUNING.LIMPET_REGROW_TIME
end

local function pickanim(inst)
  if inst.components.pickable then
    if inst.components.pickable:CanBePicked() then
      return "limpetmost"
    else
      if inst.components.pickable:IsBarren() then
        return "idle_dead"
      else
        return "idle"
      end
    end
  end

  return "idle"
end

local function makefullfn(inst)
  inst.components.workable:SetWorkable(false)
  inst.AnimState:PlayAnimation(pickanim(inst))
end


local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local minimap = inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()
  inst.entity:AddSoundEmitter()

  minimap:SetIcon( "limpetrock.tex" )

  MakeObstaclePhysics(inst, 1)

  inst.AnimState:SetBank("limpetrock")
  inst.AnimState:SetBuild("limpetrock")
  inst.AnimState:PlayAnimation("limpetmost", false)

  -- inst:AddTag("witherable") --optimisation
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("pickable")
  inst.components.pickable.picksound = "ia/common/limpet_harvest"
  inst.components.pickable:SetUp("limpets", TUNING.LIMPET_REGROW_TIME)
  inst.components.pickable.getregentimefn = getregentimefn
  inst.components.pickable.onpickedfn = onpickedfn
  inst.components.pickable.makeemptyfn = makeemptyfn
  inst.components.pickable.makebarrenfn = makebarrenfn
  inst.components.pickable.makefullfn = makefullfn

  --inst.components.pickable.ontransplantfn = ontransplantfn

  -- local variance = math.random() * 4 - 2
  -- inst.makewitherabletask = inst:DoTaskInTime(TUNING.WITHER_BUFFER_TIME + variance, function(inst)
    -- inst:AddComponent("witherable")
  -- end)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('rock_limpet')

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.MINE)
  inst.components.workable:SetWorkLeft(TUNING.ROCKS_MINE)
  inst.components.workable:SetOnWorkCallback(function(inst, worker, workleft)
      local pt = Point(inst.Transform:GetWorldPosition())
      if workleft <= 0 then
        inst.SoundEmitter:PlaySound("dontstarve/wilson/rock_break")
        inst.components.lootdropper:DropLoot(pt)
        if inst.components.pickable:CanBePicked() then
			if worker and worker.components.groundpounder and worker.components.groundpounder.burner == true then
			  inst.components.lootdropper:SpawnLootPrefab("limpets_cooked", pt)
			else
			  inst.components.lootdropper:SpawnLootPrefab("limpets", pt)
			end
        end
        inst:Remove()
      else
        if workleft < TUNING.ROCKS_MINE*(1/3) then
          inst.AnimState:PlayAnimation("low")
        elseif workleft < TUNING.ROCKS_MINE*(2/3) then
          inst.AnimState:PlayAnimation("med")
        else
          inst.AnimState:PlayAnimation("idle")
        end
      end
    end)

  inst.components.workable:SetWorkable(false)

  return inst
end

return Prefab( "rock_limpet", fn, assets, prefabs)	
%%+%%scripts/prefabs/rock_obsidian.lua%%-%%local assets_obsidian = {
    Asset("ANIM", "anim/rock_obsidian.zip"),
}

local assets_charcoal = {
    Asset("ANIM", "anim/rock_charcoal.zip"),
}

local prefabs_obsidian = {
    "obsidian"
}

local prefabs_charcoal = {
    "charcoal",
    "flint"
}

SetSharedLootTable("rock_obsidian", {
    {"obsidian", 1.0},
    {"obsidian", 1.0},
    {"obsidian", 0.5},
    {"obsidian", 0.25},
    {"obsidian", 0.25},
})

SetSharedLootTable("rock_charcoal", {
    {"charcoal", 1.0},
    {"charcoal", 1.0},
    {"charcoal", 0.5},
    {"charcoal", 0.25},
    {"charcoal", 0.25},
    {"flint", 0.5},
})

local function onwork(inst, worker, workleft)
    if workleft < TUNING.ROCKS_MINE*(1/3) then
        inst.AnimState:PlayAnimation("low")
    elseif workleft < TUNING.ROCKS_MINE*(2/3) then
        inst.AnimState:PlayAnimation("med")
    else
        inst.AnimState:PlayAnimation("full")
    end
end

local function onfinish_obsidian(inst, worker)
    local pt = Point(inst.Transform:GetWorldPosition())
    inst.SoundEmitter:PlaySound("ia/common/obsidian_explode")
    inst.components.lootdropper:ExplodeLoot(pt, 6 + (math.random() * 8))
    inst.components.growable:SetStage(1)
end

local function onfinish_charcoal(inst, worker)
    local pt = Point(inst.Transform:GetWorldPosition())
    inst.SoundEmitter:PlaySound("dontstarve/wilson/rock_break")
    inst.components.lootdropper:DropLoot(pt)
    inst.components.growable:SetStage(1)
end

local function SetEmpty(inst)
    local st = TheWorld.state
    local days = st["autumnlength"] + st["winterlength"] + st["springlength"] + st["summerlength"]
    inst.components.growable:StartGrowing(days * TUNING.TOTAL_DAY_TIME)
    inst.Physics:SetCollides(false)
    inst:AddTag("NOCLICK")
    inst.MiniMapEntity:SetEnabled(false)
    inst:Hide()
end

local function SetFull(inst)
    inst.components.workable:SetWorkLeft(TUNING.ROCKS_MINE)
    inst.components.growable:StopGrowing()
    inst.Physics:SetCollides(true)
    inst:RemoveTag("NOCLICK")
    inst.MiniMapEntity:SetEnabled(true)
    inst:Show()
end

local function ongrowthfn(inst, last, current)
    inst.AnimState:PlayAnimation(inst.components.growable.stages[current].anim)
end

local grow_stages = {
    {name="empty", fn=SetEmpty},
    {name="full", fn=SetFull, anim="full"},
}

local function commonfn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 1)

    return inst 
end

local function masterfn(inst)
    inst:AddComponent("lootdropper")
    inst:AddComponent("inspectable")
    
    inst:AddComponent("workable")
    inst.components.workable:SetWorkLeft(TUNING.ROCKS_MINE)
    inst.components.workable:SetOnWorkCallback(onwork)

    inst:AddComponent("growable")
    inst.components.growable.stages = grow_stages
    inst.components.growable:SetStage(2)
    inst.components.growable:SetOnGrowthFn(ongrowthfn)
    inst.components.growable.loopstages = false
    inst.components.growable.growonly = false
    inst.components.growable.springgrowth = false
    inst.components.growable.growoffscreen = true

    return inst
end

local function obsidianfn()
    local inst = commonfn()

    inst.AnimState:SetBank("rock_obsidian")
    inst.AnimState:SetBuild("rock_obsidian")
    inst.AnimState:PlayAnimation("full")

    inst.MiniMapEntity:SetIcon("rock_obsidian.png")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst = masterfn(inst)

    inst.components.workable:SetWorkAction(nil)
    inst.components.workable:SetOnFinishCallback(onfinish_obsidian)
    inst.components.lootdropper:SetChanceLootTable("rock_obsidian")
    return inst
end

local function charcoalfn()
    local inst = commonfn()

    inst.AnimState:SetBank("rock_charcoal")
    inst.AnimState:SetBuild("rock_charcoal")
    inst.AnimState:PlayAnimation("full")

    inst.MiniMapEntity:SetIcon("rock_charcoal.png")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst = masterfn(inst)

    inst.components.workable:SetWorkAction(ACTIONS.MINE)
    inst.components.workable:SetOnFinishCallback(onfinish_charcoal)
    inst.components.lootdropper:SetChanceLootTable("rock_charcoal")
    return inst
end

return Prefab("rock_obsidian", obsidianfn, assets_obsidian, prefabs_obsidian),
    Prefab("rock_charcoal", charcoalfn, assets_charcoal, prefabs_charcoal)%%+%%scripts/prefabs/roe.lua%%-%%local assets = {
	Asset("ANIM", "anim/roe.zip"),
}

local function pickproduct(inst)
	local total_w = 0

	for k, v in pairs(FISH_FARM.SEEDWEIGHT) do
		total_w = total_w + v
	end

	local rnd = math.random(total_w)
	for k, v in pairs(FISH_FARM.SEEDWEIGHT) do        
		rnd = rnd - v
        if rnd <= 0 then
            return k
        end                
	end
	
	return "fish_tropical"
end


local function common()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()
    
    MakeInventoryPhysics(inst)
    
    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)
    
    inst.AnimState:SetBank("roe")
    inst.AnimState:SetBuild("roe")
    inst.AnimState:SetRayTestOnBB(true)

	MakeInventoryFloatable(inst)

	return inst
end
local function masterfn(inst)
	
    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.MEAT
    inst:AddTag("spawnnosharx")

    inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

    inst:AddComponent("tradable")
	inst.components.tradable.goldvalue = TUNING.GOLD_VALUES.MEAT
	inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD

    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)
    
	inst:AddComponent("perishable")
	inst.components.perishable:StartPerishing()
	inst.components.perishable.onperishreplacement = "spoiled_food"
    
    return inst
end

local function raw()
    local inst = common()
    inst.AnimState:PlayAnimation("idle")
    inst:AddTag("roe")

	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)
	

    inst.components.edible.healthvalue = TUNING.HEALING_TINY
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY/2
    
    inst:AddComponent("cookable")
    inst.components.cookable.product = "roe_cooked"

	inst:AddComponent("bait")
	
	inst.components.perishable:SetPerishTime(TUNING.PERISH_SUPERFAST)
	
    inst:AddComponent("seedable")
    inst.components.seedable.growtime = TUNING.SEEDS_GROW_TIME
    inst.components.seedable.product = pickproduct
    
    return inst
end

local function cooked()
    local inst = common()
    inst.AnimState:PlayAnimation("cooked")

	inst.components.floater:UpdateAnimations("cooked_water", "cooked")

	inst.entity:SetPristine()
	if not TheWorld.ismastersim then
		return inst
	end
	
	masterfn(inst)

    inst.components.edible.healthvalue = 0
    inst.components.edible.hungervalue = TUNING.CALORIES_TINY/2
    inst.components.edible.foodstate = FOODSTATE.COOKED
	
    inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)
    
    return inst
end

return Prefab("roe", raw, assets),
	Prefab("roe_cooked", cooked, assets)              
%%+%%scripts/prefabs/rowboat_wake.lua%%-%%local assets = {
    Asset("ANIM", "anim/rowboat_wake_trail.zip"),
}

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddNetwork()

    inst.persists = false

    inst.entity:AddAnimState()

    inst.AnimState:SetBuild("rowboat_wake_trail")
    inst.AnimState:SetBank("wakeTrail")
    inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)
    inst.AnimState:PlayAnimation("trail") 

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:ListenForEvent("animover", inst.Remove)
    inst:ListenForEvent("entitysleep", inst.Remove)

    inst:AddComponent("colourtweener")
    inst.components.colourtweener:StartTween({0, 0, 0, 0}, FRAMES*20)

    return inst
end

return Prefab("rowboat_wake", fn, assets) 
%%+%%scripts/prefabs/sail.lua%%-%%local MakeVisualBoatEquip = require("prefabs/visualboatequip")

local palmsailassets = {
    Asset("ANIM", "anim/swap_sail.zip"),
}

local clothsailassets = {
    Asset("ANIM", "anim/swap_sail_cloth.zip"),
}

local feathersailassets = {
    Asset("ANIM", "anim/swap_sail_feathers.zip"),
}

local snakeskinsailassets = {
    Asset("ANIM", "anim/swap_sail_snakeskin.zip"),
}

local ironwindassets = {
    Asset("ANIM", "anim/swap_propeller.zip"),
}

local woodlegssailassets = {
    Asset("ANIM", "anim/swap_sail_pirate.zip"),
}

local function startconsuming(inst)
    if inst.components.fueled and not inst.components.fueled.consuming then 
        inst.components.fueled:StartConsuming()
    end 
end 

local function stopconsuming(inst)
    if inst.components.fueled and inst.components.fueled.consuming then 
        inst.components.fueled:StopConsuming()
    end 
end 

local function onembarked(boat, data)
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)

    if data.sailor.components.locomotor then
        data.sailor.components.locomotor:SetExternalSpeedMultiplier(item, "SAIL", item.sail_speed_mult)
        data.sailor.components.locomotor:SetExternalAccelerationMultiplier(item, "SAIL", item.sail_accel_mult)
        data.sailor.components.locomotor:SetExternalDecelerationMultiplier(item, "SAIL", item.sail_accel_mult)
    end
end 

local function ondisembarked(boat, data) 
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
    stopconsuming(item)

    if data.sailor.components.locomotor then
        data.sailor.components.locomotor:RemoveExternalSpeedMultiplier(item, "SAIL")
        data.sailor.components.locomotor:RemoveExternalAccelerationMultiplier(item, "SAIL")
        data.sailor.components.locomotor:RemoveExternalDecelerationMultiplier(item, "SAIL")
    end
end


local function onstartmoving(boat, data)
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
    startconsuming(item)
end 

local function onstopmoving(boat, data)
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
    stopconsuming(item)
end 

local function onequip(inst, owner)
    if not owner or not owner.components.sailable then
		print("WARNING: Equipped sail (",inst,") without valid boat: ", owner)
		return false
	end

    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:SpawnBoatEquipVisuals(inst, inst.visualprefab)
    end
	
	if owner.components.sailable.sailor then 
        local sailor = owner.components.sailable.sailor
        sailor:PushEvent("sailequipped")
        inst.sailquipped:set_local(true)
        inst.sailquipped:set(true)
        if inst.flapsound then 
            sailor.SoundEmitter:PlaySound(inst.flapsound) 
        end
        if sailor.components.locomotor then
            sailor.components.locomotor:SetExternalSpeedMultiplier(inst, "SAIL", inst.sail_speed_mult)
            sailor.components.locomotor:SetExternalAccelerationMultiplier(inst, "SAIL", inst.sail_accel_mult)
            sailor.components.locomotor:SetExternalDecelerationMultiplier(inst, "SAIL", inst.sail_accel_mult)
        end
    end

    inst:ListenForEvent("embarked", onembarked, owner)
    inst:ListenForEvent("disembarked", ondisembarked, owner)
    inst:ListenForEvent("boatstartmoving", onstartmoving, owner)
    inst:ListenForEvent("boatstopmoving", onstopmoving, owner)
end

local function onunequip(inst, owner)
    if owner then
        if owner.components.boatvisualmanager then
            owner.components.boatvisualmanager:RemoveBoatEquipVisuals(inst)
        end
		if owner.components.sailable and owner.components.sailable.sailor then
			local sailor = owner.components.sailable.sailor
			sailor:PushEvent("sailunequipped")
			inst.sailquipped:set_local(false)
			inst.sailquipped:set(false)
			if inst.flapsound then 
				sailor.SoundEmitter:PlaySound(inst.flapsound) 
			end

			if sailor.components.locomotor then
				sailor.components.locomotor:RemoveExternalSpeedMultiplier(inst, "SAIL")
				sailor.components.locomotor:RemoveExternalAccelerationMultiplier(inst, "SAIL")
				sailor.components.locomotor:RemoveExternalDecelerationMultiplier(inst, "SAIL")
			end
		end 

		inst:RemoveEventCallback("embarked", onembarked, owner)
		inst:RemoveEventCallback("disembarked", ondisembarked, owner)
		inst:RemoveEventCallback("boatstartmoving", onstartmoving, owner)
		inst:RemoveEventCallback("boatstopmoving", onstopmoving, owner)
	end
	
    stopconsuming(inst)

    if inst.RemoveOnUnequip then
        inst:DoTaskInTime(2*FRAMES, inst.Remove)
    end    
end

local function sail_perish(inst)
    onunequip(inst, inst.components.inventoryitem.owner)
    inst:Remove()
end 

local function common_pristine()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    inst:AddTag("sail")

    --networking the equip/unequip event
    inst.sailquipped = net_bool(inst.GUID, "sailquipped", not TheWorld.ismastersim and "sailquipped" or nil)

    if not TheWorld.ismastersim then
        inst:ListenForEvent("sailquipped", function(inst)
            if inst.sailquipped:value() then
                TheLocalPlayer:PushEvent("sailequipped")
            else
                TheLocalPlayer:PushEvent("sailunequipped")
            end
        end)
    end

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    return inst
end

local function common_master(inst)
    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    inst:AddComponent("fueled")
    inst.components.fueled.fueltype = "USAGE"
    inst.components.fueled:SetDepletedFn(sail_perish)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)

    MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
    MakeSmallPropagator(inst)

    inst:AddComponent("equippable")
    inst.components.equippable.boatequipslot = BOATEQUIPSLOTS.BOAT_SAIL
    inst.components.equippable.equipslot = nil
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst.onembarked = onembarked
    inst.ondisembarked = ondisembarked

    return inst
end

local function palmsail_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("sail")
    inst.AnimState:SetBuild("swap_sail")
    inst.AnimState:PlayAnimation("idle")

    inst.loopsound = "ia/common/sail_LP/leaf"
    inst.flapsound = "ia/common/sail_flap/leaf"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst.visualprefab = "sail_palmleaf"

    inst.components.fueled:InitializeFuelLevel(TUNING.SAIL_PALM_PERISH_TIME)
    inst.sail_speed_mult = TUNING.SAIL_PALM_SPEED_MULT
    inst.sail_accel_mult = TUNING.SAIL_PALM_ACCEL_MULT

    return inst
end 

local function palmsail_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_sail")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

local function clothsail_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("sail")
    inst.AnimState:SetBuild("swap_sail_cloth")
    inst.AnimState:PlayAnimation("idle")

    inst.loopsound = "ia/common/sail_LP/cloth"
    inst.flapsound = "ia/common/sail_flap/cloth"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst.visualprefab = "sail_cloth"

    inst.components.fueled:InitializeFuelLevel(TUNING.SAIL_CLOTH_PERISH_TIME)
    inst.sail_speed_mult = TUNING.SAIL_CLOTH_SPEED_MULT
    inst.sail_accel_mult = TUNING.SAIL_CLOTH_ACCEL_MULT

    return inst
end 

local function clothsail_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_sail_cloth")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

local function snakeskinsail_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("sail")
    inst.AnimState:SetBuild("swap_sail_snakeskin")
    inst.AnimState:PlayAnimation("idle")

    inst.loopsound = "ia/common/sail_LP/snakeskin"
    inst.flapsound = "ia/common/sail_flap/snakeskin"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst.visualprefab = "sail_snakeskin"

    inst.components.fueled:InitializeFuelLevel(TUNING.SAIL_SNAKESKIN_PERISH_TIME)
    inst.sail_speed_mult = TUNING.SAIL_SNAKESKIN_SPEED_MULT
    inst.sail_accel_mult = TUNING.SAIL_SNAKESKIN_ACCEL_MULT

    return inst
end 

local function snakeskinsail_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_sail_snakeskin")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

local function feathersail_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("sail")
    inst.AnimState:SetBuild("swap_sail_feathers")
    inst.AnimState:PlayAnimation("idle")

    inst.loopsound = "ia/common/sail_LP/feather"
    inst.flapsound = "ia/common/sail_flap/feather"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst.visualprefab = "sail_feather"

    inst.components.fueled:InitializeFuelLevel(TUNING.SAIL_FEATHER_PERISH_TIME)
    inst.sail_speed_mult = TUNING.SAIL_FEATHER_SPEED_MULT
    inst.sail_accel_mult = TUNING.SAIL_FEATHER_ACCEL_MULT

    return inst
end 

local function feathersail_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_sail_feathers")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

local function ironwind_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("propeller")
    inst.AnimState:SetBuild("swap_propeller")
    inst.AnimState:PlayAnimation("idle")

    inst.loopsound = "ia/common/boatpropellor_lp"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst:RemoveComponent("burnable")
    inst:RemoveComponent("propagator")

    inst.visualprefab = "ironwind"

    inst.components.fueled:InitializeFuelLevel(TUNING.IRON_WIND_PERISH_TIME)
    inst.sail_speed_mult = TUNING.IRON_WIND_SPEED_MULT
    inst.sail_accel_mult = TUNING.IRON_WIND_ACCEL_MULT

    inst.components.fueled.fueltype = FUELTYPE.MECHANICAL
    inst.components.fueled.accepting = true

    return inst
end

local function ironwind_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_propeller")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, -0.05, 0) --below the boat

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --above the boat
        else
            inst.AnimState:SetSortWorldOffset(0, -0.05, 0) --below the boat
        end
    end
end

local function woodlegssail_fn()
    local inst = common_pristine()

    inst.AnimState:SetBank("sail")
    inst.AnimState:SetBuild("swap_sail_pirate")
    inst.AnimState:PlayAnimation("idle")
    
    inst.loopsound = "ia/common/sail_LP_sealegs"
    inst.flapsound = "ia/common/sail_flap_sealegs"

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    common_master(inst)

    inst.visualprefab = "sail_woodlegs"

    inst:RemoveComponent("fueled")
    inst.sail_speed_mult = TUNING.SAIL_WOODLEGS_SPEED_MULT or 1
    inst.sail_accel_mult = TUNING.SAIL_WOODLEGS_ACCEL_MULT

    inst.RemoveOnUnequip = true

    return inst
end

local function woodlegssail_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_sail_pirate")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_UP then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

return Prefab("sail_palmleaf", palmsail_fn, palmsailassets), 
    MakeVisualBoatEquip("sail_palmleaf", palmsailassets, nil, palmsail_visual_common),
    Prefab("sail_cloth", clothsail_fn, clothsailassets),
    MakeVisualBoatEquip("sail_cloth", clothsailassets, nil, clothsail_visual_common),
    Prefab("sail_snakeskin", snakeskinsail_fn, snakeskinsailassets),
    MakeVisualBoatEquip("sail_snakeskin", snakeskinsailassets, nil, snakeskinsail_visual_common),
    Prefab("sail_feather", feathersail_fn, feathersailassets),
    MakeVisualBoatEquip("sail_feather", feathersailassets, nil, feathersail_visual_common),
    Prefab("ironwind", ironwind_fn, ironwindassets),
    MakeVisualBoatEquip("ironwind", ironwindassets, nil, ironwind_visual_common),
    Prefab("sail_woodlegs", woodlegssail_fn, woodlegssailassets),
    MakeVisualBoatEquip("sail_woodlegs", woodlegssailassets, nil, woodlegssail_visual_common)%%+%%scripts/prefabs/sand.lua%%-%%local assets =
{
  Asset("ANIM", "anim/sandhill.zip")
}

local function ongustblowawayfn(inst)
  if not inst.components.inventoryitem or not inst.components.inventoryitem.owner then 
    inst:RemoveComponent("inventoryitem")
    inst:RemoveComponent("inspectable")
    inst.SoundEmitter:PlaySound("dontstarve/common/dust_blowaway")
    inst.AnimState:PlayAnimation("disappear")
    inst:ListenForEvent("animover", function() inst:Remove() end)
  end 
end

local function sandfn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBuild( "sandhill" )
  inst.AnimState:SetBank( "sandhill" )
  inst.AnimState:PlayAnimation("idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  -----------------
  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM
  ----------------------

  MakeInvItemIA(inst)
	inst.components.inventoryitem:SetSinks(true)

	inst:AddComponent("blowinwindgust")
	inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.SAND_WINDBLOWN_SPEED)
	inst.components.blowinwindgust:SetDestroyChance(TUNING.SAND_WINDBLOWN_FALL_CHANCE)
	inst.components.blowinwindgust:SetDestroyFn(ongustblowawayfn)

  return inst
end

return Prefab( "sand", sandfn, assets)
%%+%%scripts/prefabs/sandbag.lua%%-%%

local assets =
{
  Asset("ANIM", "anim/sandbag.zip"),
}

local prefabs =
{
  "gridplacer",
}

local function ondeploy(inst, pt, deployer)
  local wall = SpawnPrefab("sandbag") 
  if wall then
    local map = TheWorld.Map
    local cx, cy, cz = map:GetTileCenterPoint(pt.x, pt.y, pt.z)
    pt = Vector3(cx, cy, cz)
    wall.Physics:SetCollides(false)
    wall.Physics:Teleport(pt.x, pt.y, pt.z) 
    wall.Physics:SetCollides(true)
    inst.components.stackable:Get():Remove()
  end
end

local function onhammered(inst, worker)
  inst.components.lootdropper:SpawnLootPrefab("sand")

  SpawnPrefab("collapse_small").Transform:SetPosition(inst.Transform:GetWorldPosition())

  inst:Remove()
end

local function onhit(inst)
end

local function test_sandbag(inst, pt)
  local tiletype = GetGroundTypeAtPosition(pt)
  local ground_OK = tiletype ~= GROUND.IMPASSABLE and not IsWater(tiletype)

  if ground_OK then
    local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, 2, nil, {"NOBLOCK", "player", "FX", "INLIMBO", "DECOR"}) -- or we could include a flag to the search?

    for k, v in pairs(ents) do
      if v ~= inst and v:IsValid() and v.entity:IsVisible() and not v.components.placer and v.parent == nil then
        local dsq = distsq( Vector3(v.Transform:GetWorldPosition()), pt)
        if  dsq< 2.83 * 2.83 then return false end
      end
    end
    return true
  end
  return false
end


local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()
--  inst.entity:AddFloodingBlockerEntity()

  inst:AddTag("wall")

  MakeObstaclePhysics(inst, 1.5)
  inst.entity:SetCanSleep(false)
  inst.AnimState:SetBank("sandbag")
  inst.AnimState:SetBuild("sandbag")
  inst.AnimState:PlayAnimation("full")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  inst:AddComponent("lootdropper")

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(3)
  inst.components.workable:SetOnFinishCallback(onhammered)
  inst.components.workable:SetOnWorkCallback(onhit)

  ---------------------  
  return inst      
end

local function itemfn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("sandbag")
  inst.AnimState:SetBuild("sandbag")
  inst.AnimState:PlayAnimation("idle")
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)
	inst.components.inventoryitem:SetSinks(true)

  inst:AddComponent("deployable")
  inst.components.deployable.ondeploy = ondeploy
  inst.components.deployable.min_spacing = 2.83
  inst.components.deployable.placer = "gridplacer"	
  inst.components.deployable:SetDeployMode(DEPLOYMODE.TURF)

  ---------------------  
  return inst      
end

return Prefab( "sandbag", fn, assets, prefabs ),
Prefab( "sandbag_item", itemfn, assets, prefabs )
%%+%%scripts/prefabs/sandbagsmall.lua%%-%%require "prefabutil"

local assets =
{
  Asset("ANIM", "anim/sandbag_small.zip"),
  Asset("ANIM", "anim/sandbag.zip"),
}

local prefabs =
{
	-- "gridplacer",
	"collapse_small",
}


local function OnIsPathFindingDirty(inst)
    if inst._ispathfinding:value() then
        if inst._pfpos == nil then
            inst._pfpos = inst:GetPosition()
			TheWorld.Pathfinder:AddWall(inst._pfpos.x + 0.5, inst._pfpos.y, inst._pfpos.z + 0.5)
			TheWorld.Pathfinder:AddWall(inst._pfpos.x + 0.5, inst._pfpos.y, inst._pfpos.z - 0.5)
			TheWorld.Pathfinder:AddWall(inst._pfpos.x - 0.5, inst._pfpos.y, inst._pfpos.z + 0.5)
			TheWorld.Pathfinder:AddWall(inst._pfpos.x - 0.5, inst._pfpos.y, inst._pfpos.z - 0.5)
        end
    elseif inst._pfpos ~= nil then
		TheWorld.Pathfinder:RemoveWall(inst._pfpos.x + 0.5, inst._pfpos.y, inst._pfpos.z + 0.5)
		TheWorld.Pathfinder:RemoveWall(inst._pfpos.x + 0.5, inst._pfpos.y, inst._pfpos.z - 0.5)
		TheWorld.Pathfinder:RemoveWall(inst._pfpos.x - 0.5, inst._pfpos.y, inst._pfpos.z + 0.5)
		TheWorld.Pathfinder:RemoveWall(inst._pfpos.x - 0.5, inst._pfpos.y, inst._pfpos.z - 0.5)
        inst._pfpos = nil
    end
end

local function InitializePathFinding(inst)
    inst:ListenForEvent("onispathfindingdirty", OnIsPathFindingDirty)
    OnIsPathFindingDirty(inst)
end

local function makeobstacle(inst)
    inst.Physics:SetActive(true)
    inst._ispathfinding:set(true)
    TheWorld:PushEvent("floodblockercreated",{blocker = inst})
end

local function clearobstacle(inst)
    inst.Physics:SetActive(false)
    inst._ispathfinding:set(false)
    TheWorld:PushEvent("floodblockerremoved",{blocker = inst})
end

local anims =
{
	{ threshold = 0, anim = "rubble" },
	{ threshold = 0.4, anim = "heavy_damage" },
	{ threshold = 0.5, anim = "half" },
	{ threshold = 0.99, anim = "light_damage" },
	{ threshold = 1, anim = "full" },
}

local function resolveanimtoplay(inst, percent)
    for i, v in ipairs(anims) do
        if percent <= v.threshold then
            return v.anim
        end
    end
end

local function onhealthchange(inst, old_percent, new_percent)
    local anim_to_play = resolveanimtoplay(inst, new_percent)
	inst.AnimState:PlayAnimation(anim_to_play)
	if new_percent > 0 and old_percent <= 0 then makeobstacle(inst) end
	if old_percent > 0 and new_percent <= 0 then clearobstacle(inst) end
    -- if new_percent > 0 then
        -- if old_percent <= 0 then
            -- makeobstacle(inst)
        -- end
        -- inst.AnimState:PlayAnimation(anim_to_play.."_hit")
        -- inst.AnimState:PushAnimation(anim_to_play, false)
    -- else
        -- if old_percent > 0 then
            -- clearobstacle(inst)
        -- end
        -- inst.AnimState:PlayAnimation(anim_to_play)
    -- end
end

local function keeptargetfn()
    return false
end

local function onload(inst)
    if inst.components.health:IsDead() then
        clearobstacle(inst)
	else
		makeobstacle(inst)
    end
end

local function onremove(inst)
    inst._ispathfinding:set_local(false)
    OnIsPathFindingDirty(inst)
	if TheWorld.ismastersim and not inst.components.health:IsDead() then
		TheWorld:PushEvent("floodblockerremoved",{blocker = inst})
	end
end

local function quantizepos(pt)
	local x, y, z = TheWorld.Map:GetTileCenterPoint(pt:Get())

	if pt.x > x then
		x = x + 1
	else
		x = x - 1
	end

	if pt.z > z then
		z = z + 1
	else
		z = z - 1
	end

	return Vector3(x,y,z)
end

local function quantizeplacer(inst)
	inst.Transform:SetPosition(quantizepos(inst:GetPosition()):Get())
end

local function placerpostinitfn(inst)
	inst.components.placer.onupdatetransform = quantizeplacer
end

local function ondeploy(inst, pt, deployer)
	local wall = SpawnPrefab("sandbagsmall") 

	if wall then
		pt = quantizepos(pt)

		wall.Physics:SetCollides(false)
		wall.Physics:Teleport(pt.x, pt.y, pt.z) 
		wall.Physics:SetCollides(true)
		inst.components.stackable:Get():Remove()

		wall.SoundEmitter:PlaySound("ia/common/sandbag")

		makeobstacle(wall)
	end
end


local function onhammered(inst, worker)
	local max_loots = 2
	local num_loots = math.max(1, math.floor(max_loots*inst.components.health:GetPercent()))
	for k = 1, num_loots do
		inst.components.lootdropper:SpawnLootPrefab("sand")
	end

	local fx = SpawnPrefab("collapse_small")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
	-- fx:SetMaterial(data.material)

	inst:Remove()
end

local function onhit(inst)
	inst.SoundEmitter:PlaySound("ia/common/sandbag")		

	local healthpercent = inst.components.health:GetPercent()
	local anim_to_play = resolveanimtoplay(inst, healthpercent)
	inst.AnimState:PushAnimation(anim_to_play)
	-- if healthpercent > 0 then
		-- local anim_to_play = resolveanimtoplay(inst, healthpercent)
		-- inst.AnimState:PlayAnimation(anim_to_play.."_hit")
		-- inst.AnimState:PushAnimation(anim_to_play, false)
	-- end
end

local function onrepaired(inst)
	inst.SoundEmitter:PlaySound("ia/common/sandbag")		
	makeobstacle(inst)
end

local function fn()
	local inst = CreateEntity()
	
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst.Transform:SetEightFaced()

	MakeObstaclePhysics(inst, 1)
	inst.Physics:SetDontRemoveOnSleep(true)

    inst:SetDeployExtraSpacing(2) --only works against builder, not against deployables

	inst:AddTag("floodblocker")
	inst:AddTag("sandbag")
	inst:AddTag("wall")
	inst:AddTag("noauradamage")
	inst:AddTag("nointerpolate")

	inst.AnimState:SetBank("sandbag_small")
	inst.AnimState:SetBuild("sandbag_small")
	inst.AnimState:PlayAnimation("full", false)

	inst._pfpos = nil
	inst._ispathfinding = net_bool(inst.GUID, "_ispathfinding", "onispathfindingdirty")
	-- makeobstacle(inst) --TODO don't have position yet!
	inst:DoTaskInTime(0, makeobstacle)
	--Delay this because makeobstacle sets pathfinding on by default
	--but we don't to handle it until after our position is set
	inst:DoTaskInTime(0, InitializePathFinding)

	inst.OnRemoveEntity = onremove

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")
	inst:AddComponent("lootdropper")

	inst:AddComponent("repairable")
	inst.components.repairable.repairmaterial = MATERIALS.SANDBAGSMALL
	inst.components.repairable.onrepaired = onrepaired

	inst:AddComponent("combat")
	inst.components.combat:SetKeepTargetFunction(keeptargetfn)
	inst.components.combat.onhitfn = onhit

	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.SANDBAG_HEALTH)
	inst.components.health.currenthealth = TUNING.SANDBAG_HEALTH
	inst.components.health.ondelta = onhealthchange
	inst.components.health.nofadeout = true
	inst.components.health.canheal = false
	--apparently not burnable -M
	inst.components.health.fire_damage_scale = 0

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(3)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)

	MakeHauntableWork(inst)

	inst.OnLoad = onload

	return inst      
end

local function itemfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst:AddTag("wallbuilder")

	inst.AnimState:SetBank("sandbag")
	inst.AnimState:SetBuild("sandbag")
	inst.AnimState:PlayAnimation("idle")

	-- MakeInventoryFloatable(inst)
	-- inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
	return inst
	end

	inst:AddComponent("repairer")
	inst.components.repairer.repairmaterial = MATERIALS.SANDBAGSMALL
	inst.components.repairer.healthrepairvalue = TUNING.SANDBAG_HEALTH / 2

	inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

	inst:AddComponent("inspectable")
	MakeInvItemIA(inst)
		inst.components.inventoryitem:SetSinks(true)

	inst:AddComponent("deployable")
	inst.components.deployable.ondeploy = ondeploy
	inst.components.deployable:SetDeployMode(DEPLOYMODE.WALL)
	-- inst.components.deployable.min_spacing = 0	
	-- inst.components.deployable.placer = "sandbagsmall_placer"
	-- inst.components.deployable:SetQuantizeFunction(quantizepos)
	-- inst.components.deployable.deploydistance = 2

	MakeHauntableLaunch(inst)

	return inst
end

return Prefab( "sandbagsmall", fn, assets, prefabs ),
Prefab( "sandbagsmall_item", itemfn, assets, prefabs ), 
MakePlacer("sandbagsmall_item_placer",  "sandbag_small", "sandbag_small", "full", false, false, false, 1.0, nil, "eight", placerpostinitfn) 
%%+%%scripts/prefabs/sandcastle.lua%%-%%local assets =
{
  Asset("ANIM", "anim/sand_castle.zip")
}

local prefabs =
{
  "sand",
  "sanddune",
  "seashell"
}

-- these should match the animation names to the workleft
local anims = {"low", "med", "full"}

local function setanim(inst)
  if inst.components.workable.workleft < 1 then
    inst.AnimState:PlayAnimation(anims[1])
  else
    inst.AnimState:PlayAnimation(anims[inst.components.workable.workleft])
  end
end

local function workcallback(inst, worker, workleft)
  if workleft <= 0 then
    -- figure out which side to drop the loot
    local pt = Vector3(inst.Transform:GetWorldPosition())
    local hispos = Vector3(worker.Transform:GetWorldPosition())

    local he_right = ((hispos - pt):Dot(TheCamera:GetRightVec()) > 0)

    if he_right then
      inst.components.lootdropper:DropLoot(pt - (TheCamera:GetRightVec()*2))
    else
      inst.components.lootdropper:DropLoot(pt + (TheCamera:GetRightVec()*2))
    end

    inst:Remove()
  else
    inst.components.fueled:ChangeSection(-1)
  end
  setanim(inst)
end

local function sectioncallback(newsection, oldsection, inst)
  print("section callback", newsection, oldsection)
  inst.components.workable:SetWorkLeft(newsection)
  setanim(inst)
end

local function onperish(inst)
  inst:Remove()
end

local function onupdate(inst)
	local rain = Remap(math.max(TheWorld.state.precipitationrate, 0.5), 0.5, 1.0, 0.0, 1.0)
	local wind = TheWorld.state.gustspeed
	inst.components.fueled.rate = 1 + TUNING.SANDCASTLE_RAIN_PERISH_RATE * rain + TUNING.SANDCASTLE_WIND_PERISH_RATE * wind
end

local function onbuilt(inst)
  inst.SoundEmitter:PlaySound("ia/common/sandcastle")
end

local function getstatus(inst, viewer)
  local x, y, z = inst.Transform:GetWorldPosition()
  if TheWorld.Map:GetTileAtPoint(x, y, z) == GROUND.BEACH then
    return "SAND"
  else
    return "GENERIC"
  end
end

local function sandcastlefn(Sim)
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.AnimState:SetBuild("sand_castle")
  inst.AnimState:SetBank("sand_castle")
  inst.AnimState:PlayAnimation(anims[#anims])

  MakeObstaclePhysics(inst, .4)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aura = TUNING.SANITYAURA_SMALL

  inst:AddComponent("fueled")
  inst.components.fueled.fueltype = "NONE"
  inst.components.fueled.accepting = false
  inst.components.fueled:InitializeFuelLevel(TUNING.SANDCASTLE_PERISHTIME)
  inst.components.fueled:SetDepletedFn(onperish)
  inst.components.fueled:SetSections(#anims)
  inst.components.fueled:SetSectionCallback(sectioncallback)
  inst.components.fueled:SetUpdateFn(onupdate)
  inst.components.fueled:StartConsuming()

  ----------------------
  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = getstatus
  ----------------------
  inst:AddComponent("lootdropper")
  inst.components.lootdropper.lootpercentoverride = function()
    return inst.components.fueled:GetPercent()
  end

  --full, med, low
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetWorkLeft(#anims)
  inst.components.workable:SetOnWorkCallback(workcallback)

  inst:ListenForEvent( "onbuilt", onbuilt)

  return inst
end

return Prefab( "sandcastle", sandcastlefn, assets, prefabs),
MakePlacer( "sandcastle_placer", "sand_castle", "sand_castle", anims[#anims] )
%%+%%scripts/prefabs/sanddune.lua%%-%%local assets =
{
  Asset("ANIM", "anim/sand_dune.zip")
}

local prefabs =
{
  "sand",
}

local startregen

-- these should match the animation names to the workleft
local anims = {"low", "med", "full"}

local function onregen(inst)
  inst.components.activatable.inactive = false
  if inst.components.workable.workleft < #anims-1 then
    inst.components.workable:SetWorkLeft(math.floor(inst.components.workable.workleft)+1)
    startregen(inst)
  else
    inst.targettime = nil
  end
end

startregen = function(inst, regentime)

  if inst.components.workable.workleft < #anims-1 then
    -- more to grow
    regentime = regentime or (TUNING.SAND_REGROW_TIME + math.random()*TUNING.SAND_REGROW_VARIANCE)

    if TheWorld.state.iswinter or TheWorld.state.iswet then
      regentime = regentime / 2
    elseif TheWorld.state.isspring or TheWorld.state.isgreen then
      regentime = regentime * 2
    end

    if inst.task then
      inst.task:Cancel()
    end
    inst.task = inst:DoTaskInTime(regentime, onregen, "regen")
    inst.targettime = GetTime() + regentime
  else
    -- no more to do
    if inst.task then
      inst.task:Cancel()
    end
    inst.targettime = nil
  end

  if inst.components.workable.workleft < 1 then
    inst.AnimState:PlayAnimation(anims[1])
  else
    inst.AnimState:PlayAnimation(anims[math.floor(inst.components.workable.workleft)+1])
  end

  -- print('startregen', inst.components.workable.workleft, regentime, anims[inst.components.workable.workleft])
end

local function workcallback(inst, worker, workleft, numworks)
  -- print('trying to spawn sand', inst, worker, workleft)
  if workleft <= 0 then
    inst.components.activatable.inactive = true
  end

	local prevworkleft = numworks + workleft
	local spawns = math.min(math.ceil(prevworkleft) - math.ceil(workleft), math.ceil(prevworkleft))
	
	if spawns > 0 then

		-- figure out which side to drop the loot
		local pt = Vector3(inst.Transform:GetWorldPosition())
		local hispos = Vector3(worker.Transform:GetWorldPosition())
		local targetpt
		
		--TODO do not use TheCamera for networked activities! -M
		if ((hispos - pt):Dot(TheCamera:GetRightVec()) > 0) then
			targetpt = pt - (TheCamera:GetRightVec()*(.5+math.random()))
		else
			targetpt = pt + (TheCamera:GetRightVec()*(.5+math.random()))
		end
		
		for i = 1, spawns do
			inst.components.lootdropper:DropLoot(targetpt)
		end
		
	end

  --inst.SoundEmitter:PlaySound("ia/common/sandpile")

  startregen(inst)
end

local function onactivate(inst)
	-- SpawnAt("collapse_small", inst)
	inst.SoundEmitter:PlaySound("ia/common/sandpile")
	inst:Remove()
end

local function onsave(inst, data)
  if inst.targettime then
    local time = GetTime()
    if inst.targettime > time then
      data.time = math.floor(inst.targettime - time)
    end
    data.workleft = inst.components.workable.workleft
    -- print('sandhill onsave', data.workleft)
  end
end
local function onload(inst, data)

  if data and data.workleft then
    inst.components.workable.workleft = data.workleft

    if data.workleft <= 0 then
      inst.components.activatable.inactive = true
    end

  end
  -- print('sandhill onload', inst.components.workable.workleft)
  if data and data.time then
    startregen(inst, data.time)
  end
end

-- note: this doesn't really handle skipping 2 regens in a long update
local function LongUpdate(inst, dt)

  if inst.targettime then

    local time = GetTime()
    if inst.targettime > time + dt then
      --resechedule
      local time_to_regen = inst.targettime - time - dt
      -- print ("LongUpdate resechedule", time_to_regen)

      startregen(inst, time_to_regen)
    else
      --skipped a regen, do it now
      -- print ("LongUpdate skipped regen")
      onregen(inst)
    end
  end
end

local function onwake(inst)
  if (TheWorld.state.isspring or TheWorld.state.isgreen) and TheWorld.state.israining then
    if math.random() < TUNING.SAND_DEPLETE_CHANCE and inst.components.workable.workleft > 0 then
      -- the rain made this sandhill shrink
      inst.components.workable.workleft = inst.components.workable.workleft - math.random(0, inst.components.workable.workleft)
      startregen(inst)
    end
  end
end

local function sandhillfn()
  -- print ('sandhillfn')
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.AnimState:SetBuild("sand_dune")
  inst.AnimState:SetBank("sand_dune")
  inst.AnimState:PlayAnimation(anims[#anims])
  
	inst.GetActivateVerb = function() return "SAND" end

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.OnLongUpdate = LongUpdate
  inst.OnSave = onsave
  inst.OnLoad = onload
  inst.OnEntityWake = onwake

  ----------------------
  inst:AddComponent("inspectable")
  ----------------------
  inst:AddComponent("lootdropper")
	
	--Moved this here from workcallback because it works here too and is more modding friendly at that
	
	inst.components.lootdropper:SetLoot({"sand"})
	
	inst.components.lootdropper.numrandomloot = 1
	inst.components.lootdropper.chancerandomloot = 0.01  -- drop some random item 1% of the time
	
	inst.components.lootdropper:AddRandomLoot("seashell", 0.01)
	inst.components.lootdropper:AddRandomLoot("rock", 0.01)
	inst.components.lootdropper:AddRandomLoot("feather_crow", 0.01)
	inst.components.lootdropper:AddRandomLoot("feather_robin", 0.01)
	inst.components.lootdropper:AddRandomLoot("feather_robin_winter", 0.01)
	inst.components.lootdropper:AddRandomLoot("venomgland", 0.001)
	inst.components.lootdropper:AddRandomLoot("coconut", 0.001)
	inst.components.lootdropper:AddRandomLoot("crab", 0.001)
	inst.components.lootdropper:AddRandomLoot("snake", 0.001)
	inst.components.lootdropper:AddRandomLoot("gears", 0.002)
	inst.components.lootdropper:AddRandomLoot("redgem", 0.002)
	inst.components.lootdropper:AddRandomLoot("dubloon", 0.002)
	inst.components.lootdropper:AddRandomLoot("purplegem", 0.001)

  --full, med, low
  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetWorkLeft(#anims-1)
  inst.components.workable:SetOnWorkCallback(workcallback)

  inst:AddComponent("activatable")
  inst.components.activatable.inactive = false
  -- inst.components.activatable.getverb = function() return "SAND" end
  inst.components.activatable.OnActivate = onactivate

  return inst
end

return Prefab( "sanddune", sandhillfn, assets, prefabs)
%%+%%scripts/prefabs/seagullspawner.lua%%-%%local assets =
{
    Asset("ANIM", "anim/seagull_shadow.zip"),
}

local prefabs =
{
    "seagull",
    "circlingseagull",
}

local function RemoveSeagullShadow(inst, shadow)
    shadow:KillShadow()
    for i, v in ipairs(inst.seagullshadows) do
        if v == shadow then
            table.remove(inst.seagullshadows, i)
            return
        end
    end
end

local function SpawnSeagullShadow(inst)
    local shadow = SpawnPrefab("circlingseagull")
    shadow.components.circler:SetCircleTarget(inst)
    shadow.components.circler:Start()
    table.insert(inst.seagullshadows, shadow)
end

local function UpdateShadows(inst)
    local count = inst.components.childspawner.childreninside
    local old = #inst.seagullshadows
    if old < count then
        for i = old + 1, count do
            SpawnSeagullShadow(inst)
        end
    elseif old > count then
        for i = old, count + 1, -1 do
            RemoveSeagullShadow(inst, inst.seagullshadows[i])
        end
    end
	-- print(inst,"SHADOWS",#inst.seagullshadows)
end
-- c_sel().components.childspawner.onaddchild(c_sel())

local function OnSpawn(inst, child)
    for i, shadow in ipairs(inst.seagullshadows) do
        local dist = shadow.components.circler.distance
        local angle = shadow.components.circler.angleRad
        local pos = inst:GetPosition()
        local offset = FindWalkableOffset(pos, angle, dist, 8, false)
        if offset ~= nil then
            child.Transform:SetPosition(pos.x + offset.x, 30, pos.z + offset.z)
        else
            child.Transform:SetPosition(pos.x, 30, pos.y)
        end
        child.sg:GoToState("glide")
        RemoveSeagullShadow(inst, shadow)
        return
    end
end

--This function is a little hack against bad practises in SW -M
local function OnDeleteSeagull(seagull)
	if seagull and seagull.sg and seagull.sg.currentstate.name == "flyaway" then
		if seagull.seagullspawner then
			seagull.seagullspawner.components.childspawner:AddChildrenInside(1)
		end
	end
end

local function SpawnSeagull(inst)
    if not inst.components.childspawner:CanSpawn() then
        return
    end

	local seagull = inst.components.childspawner:SpawnChild()
	if seagull ~= nil then
		local x, y, z = inst.Transform:GetWorldPosition()
		seagull.Transform:SetPosition(x + math.random() * 20 - 10, 30, z + math.random() * 20 - 10)

		seagull.seagullspawner = inst
		inst:ListenForEvent("onremove", OnDeleteSeagull, seagull)

		-- inst.SoundEmitter:PlaySound("ia/creatures/seagull/distant")
	end
end

local function CancelAwakeTasks(inst)
    if inst.waketask ~= nil then
        inst.waketask:Cancel()
        inst.waketask = nil
    end
    if inst.spawntask ~= nil then
        inst.spawntask:Cancel()
        inst.spawntask = nil
    end
end

local function OnEntitySleep(inst)
    for i = #inst.seagullshadows, 1, -1 do
        inst.seagullshadows[i]:Remove()
        table.remove(inst.seagullshadows, i)
    end
    CancelAwakeTasks(inst)
end

local function OnWakeTask(inst)
    inst.waketask = nil
    if not inst:IsAsleep() then
        UpdateShadows(inst)
    end
end

local function OnEntityWake(inst)
    if inst.waketask == nil then
        inst.waketask = inst:DoTaskInTime(.5, OnWakeTask)
    end
    if inst.spawntask == nil then
        inst.spawntask = inst:DoPeriodicTask(TUNING.SEAGULLSPAWNER_SPAWN_PERIOD * .1, SpawnSeagull)
    end
end

local function SpawnerOnIsNight(inst, isnight)
    if isnight then
        inst.OnEntityWake = nil
        inst.components.childspawner:StopSpawning()
        if not inst.components.childspawner.regening and inst.components.childspawner.numchildrenoutside + inst.components.childspawner.childreninside < inst.components.childspawner.maxchildren then
            inst.components.childspawner:StartRegen()
        end
        -- ReturnChildren(inst)
        CancelAwakeTasks(inst)
    else
        inst.OnEntityWake = OnEntityWake
        inst.components.childspawner:StartSpawning()
        if not inst:IsAsleep() then
            OnEntityWake(inst)
        end
    end
end

local function SpawnerOnIsWinter(inst, iswinter)
    if iswinter then
        inst.OnEntityWake = nil
        inst:StopWatchingWorldState("isnight", SpawnerOnIsNight)
        inst.components.childspawner:StopSpawning()
        inst.components.childspawner:StopRegen()
        -- ReturnChildren(inst)
        CancelAwakeTasks(inst)
    else
        inst:WatchWorldState("isnight", SpawnerOnIsNight)
        SpawnerOnIsNight(inst, TheWorld.state.isnight)
    end
end

local function OnAddChild(inst)
	-- print("about to update shadows")
    UpdateShadows(inst)
    if inst.components.childspawner.numchildrenoutside + inst.components.childspawner.childreninside >= inst.components.childspawner.maxchildren then
        inst.components.childspawner:StopRegen()
    end
end

local function SpawnerOnInit(inst)
    inst.OnEntitySleep = OnEntitySleep
    inst:WatchWorldState("iswinter", SpawnerOnIsWinter)
    SpawnerOnIsWinter(inst, TheWorld.state.iswinter)
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("seagull.tex")

    inst:AddTag("seagullspawner")
    inst:AddTag("CLASSIFIED")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("childspawner")
    inst.components.childspawner.childname = "seagull"
    inst.components.childspawner:SetSpawnedFn(OnSpawn)
    inst.components.childspawner:SetOnAddChildFn(OnAddChild)
    inst.components.childspawner:SetMaxChildren(math.random(1, 2))
    inst.components.childspawner:SetSpawnPeriod(TUNING.SEAGULLSPAWNER_SPAWN_PERIOD)
    inst.components.childspawner:SetRegenPeriod(TUNING.SEAGULLSPAWNER_REGEN_PERIOD)
    inst.components.childspawner:StopRegen()

    inst.seagullshadows = {}
    inst.spawntask = nil
    inst.waketask = nil
    inst:DoTaskInTime(0, SpawnerOnInit)

    return inst
end

-----------------------------------------------------------------------------------

local MAX_FADE_FRAME = math.floor(3 / FRAMES + .5)

local function OnUpdateFade(inst, dframes)
    local done
    if inst._isfadein:value() then
        local frame = inst._fadeframe:value() + dframes
        done = frame >= MAX_FADE_FRAME
        inst._fadeframe:set_local(done and MAX_FADE_FRAME or frame)
    else
        local frame = inst._fadeframe:value() - dframes
        done = frame <= 0
        inst._fadeframe:set_local(done and 0 or frame)
    end

    local k = inst._fadeframe:value() / MAX_FADE_FRAME
    inst.AnimState:OverrideMultColour(1, 1, 1, k)

    if done then
        inst._fadetask:Cancel()
        inst._fadetask = nil
        if inst._killed then
            --don't need to check ismastersim, _killed will never be set on clients
            inst:Remove()
            return
        end
    end

    if TheWorld.ismastersim then
        if inst._fadeframe:value() > 0 then
            inst:Show()
        else
            inst:Hide()
        end
    end
end

local function OnFadeDirty(inst)
    if inst._fadetask == nil then
        inst._fadetask = inst:DoPeriodicTask(FRAMES, OnUpdateFade, nil, 1)
    end
    OnUpdateFade(inst, 0)
end

local function CircleOnIsNight(inst, isnight)
    inst._isfadein:set(not isnight)
    inst._fadeframe:set(inst._fadeframe:value())
    OnFadeDirty(inst)
end

local function CircleOnIsWinter(inst, iswinter)
    if iswinter then
        inst:StopWatchingWorldState("isnight", CircleOnIsNight)
        CircleOnIsNight(inst, true)
    else
        inst:WatchWorldState("isnight", CircleOnIsNight)
        CircleOnIsNight(inst, TheWorld.state.isnight)
    end
end

local function CircleOnInit(inst)
    -- inst:WatchWorldState("iswinter", CircleOnIsWinter)
    -- CircleOnIsWinter(inst, TheWorld.state.iswinter)
	CircleOnIsNight(inst, false)
end

local function DoFlap(inst)
    if math.random() > 0.66 then 
        inst.AnimState:PlayAnimation("shadow_flap_loop") 
        for i = 2, math.random(3, 6) do
            inst.AnimState:PushAnimation("shadow_flap_loop") 
        end
        inst.AnimState:PushAnimation("shadow") 
    end
end

local function KillShadow(inst)
    if inst._fadeframe:value() > 0 and not inst:IsAsleep() then
        inst:StopWatchingWorldState("iswinter", CircleOnIsWinter)
        inst:StopWatchingWorldState("isnight", CircleOnIsNight)
        inst._killed = true
        inst._isfadein:set(false)
        inst._fadeframe:set(inst._fadeframe:value())
        OnFadeDirty(inst)
    else
        inst:Remove()
    end
end

local function circlingseagullfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("seagull_shadow")
    inst.AnimState:SetBuild("seagull_shadow")
    inst.AnimState:PlayAnimation("shadow", true)
    inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)
    inst.AnimState:OverrideMultColour(1, 1, 1, 0)

    inst:AddTag("FX")

    inst._fadeframe = net_byte(inst.GUID, "circlingseagull._fadeframe", "fadedirty")
    inst._isfadein = net_bool(inst.GUID, "circlingseagull._isfadein", "fadedirty")
    inst._fadetask = nil

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        inst:ListenForEvent("fadedirty", OnFadeDirty)

        return inst
    end

    inst:AddComponent("circler")

    inst:DoTaskInTime(0, CircleOnInit)
    inst:DoPeriodicTask(math.random(3, 5), DoFlap)

    inst.KillShadow = KillShadow

    inst.persists = false

    return inst
end

return Prefab("seagullspawner", fn, nil, prefabs),
    Prefab("circlingseagull", circlingseagullfn, assets)
%%+%%scripts/prefabs/seasack.lua%%-%%local assets = {
    Asset("ANIM", "anim/swap_seasack.zip"),
    Asset("ANIM", "anim/ui_icepack_2x3.zip")
}

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_body", "swap_seasack", "backpack")
    owner.AnimState:OverrideSymbol("swap_body", "swap_seasack", "swap_body")

    if inst.components.container ~= nil then
        inst.components.container:Open(owner)
    end
end

local function onunequip(inst, owner)
    owner.AnimState:ClearOverrideSymbol("swap_body")
    owner.AnimState:ClearOverrideSymbol("backpack")

    if inst.components.container ~= nil then
        inst.components.container:Close(owner)
    end
end

local function onburnt(inst)
    if inst.components.container ~= nil then
        inst.components.container:DropEverything()
        inst.components.container:Close()
    end

    SpawnPrefab("ash").Transform:SetPosition(inst.Transform:GetWorldPosition())

    inst:Remove()
end

local function onignite(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = false
    end
end

local function onextinguish(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = true
    end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("seasack")
    inst.AnimState:SetBuild("swap_seasack")
    inst.AnimState:PlayAnimation("anim")

    inst:AddTag("backpack")
    
    inst:AddTag("fridge")
    inst:AddTag("nocool")

    inst.MiniMapEntity:SetIcon("icepack.tex")

    inst.foleysound = "dontstarve/movement/foley/backpack"

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
    
    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)
    inst.components.inventoryitem.cangoincontainer = false

    inst:AddComponent("equippable")
    inst.components.equippable.equipslot = EQUIPSLOTS.BACK
    
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)
    
    inst:AddComponent("container")
    inst.components.container:WidgetSetup("seasack")

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    inst.components.burnable:SetOnBurntFn(onburnt)
    inst.components.burnable:SetOnIgniteFn(onignite)
    inst.components.burnable:SetOnExtinguishFn(onextinguish)

    MakeHauntableLaunchAndDropFirstItem(inst)

    return inst
end

return Prefab("seasack", fn, assets)%%+%%scripts/prefabs/seashell.lua%%-%%local assets =
{
  Asset("ANIM", "anim/seashell.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("seashell")
  inst.AnimState:SetBuild("seashell")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("molebait")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_MEDITEM

  inst:AddComponent("tradable")

  inst:AddComponent("inspectable")

    inst:AddComponent("edible")
    inst.components.edible.foodtype = FOODTYPE.ELEMENTAL
    inst.components.edible.healthvalue = 1
    inst:AddComponent("bait")
  
  MakeInvItemIA(inst)

  return inst
end

return Prefab( "seashell", fn, assets) 

%%+%%scripts/prefabs/seashell_beached.lua%%-%%local assets=
{
  Asset("ANIM", "anim/seashell.zip"),
}


local prefabs =
{
  "seashell",
}    


--local names = {"f1","f2","f3","f4","f5","f6","f7","f8","f9","f10"}

local function onpickedfn(inst, picker)
  if picker and picker.components.sanity then
    picker.components.sanity:DoDelta(TUNING.SANITY_TINY)
    --print("up the sanity!")
  end	
  inst.hidden = true 
  inst:Hide()
  inst:AddTag("NOCLICK")
end


local function checktide(inst)
  local flooding = TheWorld.components.flooding 
  if flooding and flooding.mode == "tides" then 
    if inst:GetIsFlooded() then 

      if inst.tideTask then
        inst.tideTask:Cancel()
        inst.tideTask= nil
      end
      inst.hidden = false 
      inst:Show()
      inst.AnimState:PlayAnimation("appear")
      inst.AnimState:PushAnimation("buried")
      inst:RemoveTag("NOCLICK")
    end 
  end 
end 

local function beginTideCheckTask(inst)
  if inst.tideTask then
    inst.tideTask:Cancel()
    inst.tideTask= nil
  end
  local period = 5
  inst.tideTask = inst:DoPeriodicTask(period, checktide)
end 


local function onregenfn(inst)
  beginTideCheckTask(inst)
end 


local function onload(inst, data)
  if data then 
    if data.hidden then 
      inst.hidden = true 
      inst:Hide()
      inst:AddTag("NOCLICK")
      if data.waitingfortide then 
        beginTideCheckTask(inst)
      end 
    else 
      inst.hidden = false 
    end 
  else 
    inst.hidden = false
    --inst:Hide()
    --inst:AddTag("NOCLICK")
    --beginTideCheckTask(inst)

  end 
end 


local function onsave(inst, data)
  data.hidden = inst.hidden
  data.waitingfortide = inst.tideTask ~= nil 
end 


local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("seashell")
  inst.AnimState:SetBuild("seashell")
  inst.AnimState:PlayAnimation("buried")
  inst.AnimState:SetRayTestOnBB(true);

  inst:AddTag("seashell")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("pickable")
  inst.components.pickable.picksound = "ia/common/shell_harvest"
  inst.components.pickable:SetUp("seashell", TUNING.SEASHELL_REGEN_TIME)
  inst.components.pickable.onpickedfn = onpickedfn
  inst.components.pickable.onregenfn = onregenfn
  inst.components.pickable.quickpick = true
  inst.components.pickable.wildfirestarter =false
  --inst.hidden = true

  inst.OnSave = onsave
  inst.OnLoad = onload
  --inst:Hide()
  --inst:AddTag("NOCLICK")
  --beginTideCheckTask(inst)

  --------SaveLoad
  --inst.OnSave = onsave 
  --inst.OnLoad = onload 

  return inst
end

return Prefab( "seashell_beached", fn, assets, prefabs) 
%%+%%scripts/prefabs/seatrap.lua%%-%%local assets =
{
	Asset("ANIM", "anim/trap_sea.zip"),
}

local function onharvested(inst)
    if inst.components.finiteuses then
        inst.components.finiteuses:Use(1)
    end
end

local function onbaited(inst, bait)
	inst:PushEvent("baited")
	bait:Hide()
end

local function onpickup(inst, doer)
	if inst.components.trap and inst.components.trap.bait and doer.components.inventory then
		inst.components.trap.bait:Show()
		doer.components.inventory:GiveItem(inst.components.trap.bait)
	end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.MiniMapEntity:SetIcon("rabbittrap.png")

	inst.AnimState:SetBank("trap_sea")
	inst.AnimState:SetBuild("trap_sea")
	inst.AnimState:PlayAnimation("idle")

    inst:AddTag("trap")
	
	inst.no_wet_prefix = true

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)
	inst.components.inventoryitem.nobounce = true
	inst.components.inventoryitem:SetOnPickupFn( onpickup )

	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.TRAP_USES)
	inst.components.finiteuses:SetUses(TUNING.TRAP_USES)
	inst.components.finiteuses:SetOnFinished( inst.Remove )

    inst:AddComponent("trap")
    inst.components.trap.targettag = "canbetrapped" --TODO, ideally, this would use "lobster" -M
    inst.components.trap:SetOnHarvestFn( onharvested )
	inst.components.trap:SetOnBaitedFn( onbaited )
    -- inst.components.trap.baitsortorder = 1 --not needed, we hide the bait anyways
	inst.components.trap.range = 2
	inst.components.trap.water = true

    MakeHauntableLaunch(inst)

    inst:SetStateGraph("SGseatrap")

    return inst
end

return Prefab("seatrap", fn, assets)
%%+%%scripts/prefabs/seaweed.lua%%-%%local assets=
{
  Asset("ANIM", "anim/seaweed.zip"),
  Asset("ANIM", "anim/meat_rack_food_sw.zip"),
}


local prefabs = 
{
  "seaweed_planted",
  "seaweed_cooked",
  "seaweed_dried",
}

local function raw_onlanded(inst)
	if not inst.components.blowinwindgustitem then return end
	if IsOnWater(inst) then
		inst.components.blowinwindgustitem:SetMaxSpeedMult(TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
		inst.components.blowinwindgustitem:SetMinSpeedMult(TUNING.WINDBLOWN_SCALE_MIN.MEDIUM)
	else
		inst.components.blowinwindgustitem:SetMaxSpeedMult(TUNING.WINDBLOWN_SCALE_MAX.LIGHT)
		inst.components.blowinwindgustitem:SetMinSpeedMult(TUNING.WINDBLOWN_SCALE_MIN.LIGHT)
	end
end

local function commonfn(name)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.entity:AddSoundEmitter()

  inst.AnimState:SetRayTestOnBB(true);    
  inst.AnimState:SetBank("seaweed")
  inst.AnimState:SetBuild("seaweed")

  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

	MakeInventoryFloatable(inst)

	return inst
end

local function commonmasterfn(inst)
  inst:AddComponent("edible")
  inst.components.edible.foodtype = "VEGGIE"

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"


  --shine(inst)
end

local function defaultfn()

  local inst = commonfn("seaweed")

  inst.AnimState:PlayAnimation("idle_water", true)

	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()
  
  if not TheWorld.ismastersim then
    return inst
  end

	commonmasterfn(inst)

  inst.components.edible.healthvalue = TUNING.HEALING_TINY
  inst.components.edible.hungervalue = TUNING.CALORIES_TINY
  inst.components.edible.sanityvalue = -TUNING.SANITY_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)

  inst:AddComponent("cookable")
  inst.components.cookable.product = "seaweed_cooked"

  inst:AddComponent("dryable")
  inst.components.dryable:SetProduct("seaweed_dried")
  inst.components.dryable:SetDryTime(TUNING.DRY_FAST)

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
	inst:ListenForEvent("on_landed", raw_onlanded)

  inst:AddComponent("fertilizer")
  inst.components.fertilizer.fertilizervalue = TUNING.POOP_FERTILIZE
  inst.components.fertilizer.soil_cycles = TUNING.POOP_SOILCYCLES
  inst.components.fertilizer.withered_cycles = TUNING.POOP_WITHEREDCYCLES
  inst.components.fertilizer.oceanic = true

  return inst
end 


local function cookedfn()

  local inst = commonfn("seaweed_cooked")

  inst.AnimState:PlayAnimation("cooked", true)
 
	inst.components.floater:UpdateAnimations("cooked_water", "cooked")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end
  
	commonmasterfn(inst)

  inst.components.edible.foodstate = "COOKED"
  inst.components.edible.healthvalue = TUNING.HEALING_SMALL
  inst.components.edible.hungervalue = TUNING.CALORIES_TINY
  inst.components.edible.sanityvalue = 0--TUNING.SANITY_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_MED)

  return inst
end 

local function driedfn()
  local inst = commonfn("seaweed_dried")

  inst.AnimState:SetBank("meat_rack_food")
  inst.AnimState:SetBuild("meat_rack_food_sw")
  inst.AnimState:PlayAnimation("idle_dried_seaweed")

	inst.components.floater:UpdateAnimations("idle_dried_seaweed_water", "idle_dried_seaweed")

	inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	commonmasterfn(inst)
	
  inst.components.edible.foodstate = "DRIED"
  inst.components.edible.healthvalue = TUNING.HEALING_SMALL
  inst.components.edible.hungervalue = TUNING.CALORIES_SMALL
  inst.components.edible.sanityvalue = 0--TUNING.SANITY_SMALL
  inst.components.perishable:SetPerishTime(TUNING.PERISH_PRESERVED)


  return inst
end 

return Prefab( "seaweed", defaultfn, assets, prefabs), 
Prefab( "seaweed_cooked", cookedfn, assets), 
Prefab( "seaweed_dried", driedfn, assets)
%%+%%scripts/prefabs/seaweed_planted.lua%%-%%local assets=
{
  Asset("ANIM", "anim/seaweed.zip"),
}

local prefabs=
{
  "seaweed",
}

local function onpickedfn(inst)
  inst.AnimState:PlayAnimation("picking")
  inst.AnimState:PushAnimation("picked", true)
  --inst.entity:Hide()
end

local function ontransplantfn(inst)
	inst.components.pickable:MakeEmpty()
  inst.AnimState:PlayAnimation("picked", true)
  --inst.entity:Hide()
end

local function onregenfn(inst)
  inst.AnimState:PlayAnimation("grow")
  inst.AnimState:PushAnimation("idle_plant", true)
  --inst.entity:Show()
end

local function makeemptyfn(inst)
  inst.AnimState:PlayAnimation("picking")
  inst.AnimState:PushAnimation("picked", true)
  --inst.entity:Hide()
end

local function makebarrenfn(inst)
  inst.AnimState:PlayAnimation("picking")
  inst.AnimState:PushAnimation("picked", true)
  --inst.entity:Hide()
end

local function makefullfn(inst)
  inst.AnimState:PlayAnimation("grow")
  inst.AnimState:PushAnimation("idle_plant", true)
  --inst.entity:Show()
end


local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
	
	local _minimap = inst.entity:AddMiniMapEntity()
	_minimap:SetIcon( "seaweed.tex" )

	inst.AnimState:SetBank("seaweed")
	inst.AnimState:SetBuild("seaweed")
	inst.AnimState:PlayAnimation("idle_plant", true)

	inst.AnimState:OverrideSymbol("water_ripple", "ripple_build", "water_ripple")
	inst.AnimState:OverrideSymbol("water_shadow", "ripple_build", "water_shadow")

	inst.AnimState:SetRayTestOnBB(true)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )

    inst:AddTag("aquatic")
	inst:AddTag("plant")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("pickable")
  inst.components.pickable.picksound = "ia/common/item_wet_harvest"
  inst.components.pickable:SetUp("seaweed", TUNING.SEAWEED_REGROW_TIME +  math.random()*TUNING.SEAWEED_REGROW_VARIANCE)
  inst.components.pickable:SetOnPickedFn(onpickedfn)
  inst.components.pickable:SetOnRegenFn(onregenfn)
  inst.components.pickable.makeemptyfn = makeemptyfn
  inst.components.pickable.makebarrenfn = makebarrenfn
  inst.components.pickable.makefullfn = makefullfn
  inst.components.pickable.ontransplantfn = ontransplantfn
  inst.components.pickable.quickpick = false


  --MakeSmallBurnable(inst)
  --MakeSmallPropagator(inst)
  --MakeInventoryFloatable(inst, "idle_water", "idle")

  return inst
end

return Prefab( "seaweed_planted", fn, assets) 
%%+%%scripts/prefabs/sea_chiminea.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/fire_water_pit.zip"),
}

local prefabs = {
    "chimineafire",
    "collapse_small",
}

local function onhammered(inst, worker)
    inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("stone")
    inst:Remove()
end


local function onhit(inst, worker)
    inst.AnimState:PlayAnimation("hit")
    inst.AnimState:PushAnimation("idle_water",true)
end

local function onextinguish(inst)
    if inst.components.fueled then
        inst.components.fueled:InitializeFuelLevel(0)
    end
end

local function ontakefuel(inst)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function onupdatefueled(inst)
    if inst.components.burnable and inst.components.fueled then
        inst.components.burnable:SetFXLevel(inst.components.fueled:GetCurrentSection(), inst.components.fueled:GetSectionPercent())
    end
end

local function onfuelchange(newsection, oldsection, inst, doer)
    if newsection <= 0 then
        inst.components.burnable:Extinguish()
    else
        if not inst.components.burnable:IsBurning() then
            inst.components.burnable:Ignite(nil, nil, doer)
        end
        inst.components.burnable:SetFXLevel(newsection, inst.components.fueled:GetSectionPercent())
    end
end

local SECTION_STATUS = {
    [0] = "OUT",
    [1] = "EMBERS",
    [2] = "LOW",
    [3] = "NORMAL",
    [4] = "HIGH",
}

local function getstatus(inst)
    return SECTION_STATUS[inst.components.fueled:GetCurrentSection()]
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle_water", false)
    inst.SoundEmitter:PlaySound("dontstarve/common/fireAddFuel")
end

local function OnHaunt(inst, haunter)
    if math.random() <= TUNING.HAUNT_CHANCE_RARE and
        inst.components.fueled ~= nil and
        not inst.components.fueled:IsEmpty() then
        inst.components.fueled:DoDelta(TUNING.MED_FUEL)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        return true
    --#HAUNTFIX
    --elseif math.random() <= TUNING.HAUNT_CHANCE_HALF and
        --inst.components.workable ~= nil and
        --inst.components.workable:CanBeWorked() then
        --inst.components.workable:WorkedBy(haunter, 1)
        --inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        --return true
    end
    return false
end

local function OnInit(inst)
    if inst.components.burnable ~= nil then
        inst.components.burnable:FixFX()
    end
end


local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()
    
    MakeObstaclePhysics(inst, .3) 

    inst.MiniMapEntity:SetIcon("sea_chiminea.tex")
    inst.MiniMapEntity:SetPriority(1)

    inst.AnimState:SetBank("fire_water_pit")
    inst.AnimState:SetBuild("fire_water_pit")
    inst.AnimState:PlayAnimation("idle_water",true)

    inst:AddTag("campfire")
    inst:AddTag("structure")
    inst:AddTag("wildfireprotected")
    inst:AddTag("nowaves")

    --cooker (from cooker component) added to pristine state for optimization
    inst:AddTag("cooker")
    
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end   

    -----------------------
    inst:AddComponent("burnable")
    --inst.components.burnable:SetFXLevel(2)
    inst.components.burnable:AddBurnFX("chimineafire", Vector3(0,0,0))
    inst:ListenForEvent("onextinguish", onextinguish)

    -------------------------
    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)    

    -------------------------
    inst:AddComponent("cooker")
    -------------------------
    inst:AddComponent("fueled")
    inst.components.fueled.maxfuel = TUNING.CHIMINEA_FUEL_MAX
    inst.components.fueled.accepting = true
    
    inst.components.fueled:SetSections(4)
    inst.components.fueled.bonusmult = TUNING.CHIMINEA_BONUS_MULT
    inst.components.fueled:SetTakeFuelFn(ontakefuel)
    inst.components.fueled:SetUpdateFn(onupdatefueled)
    inst.components.fueled:SetSectionCallback(onfuelchange)
    inst.components.fueled:InitializeFuelLevel(TUNING.CHIMINEA_FUEL_START)

    -----------------------------

    inst:AddComponent("hauntable")
    inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_HUGE
    inst.components.hauntable:SetOnHauntFn(OnHaunt)
    
    -----------------------------
    
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

    inst:ListenForEvent("onbuilt", onbuilt)

    inst:DoTaskInTime(0, OnInit)

    return inst
end

return Prefab("sea_chiminea", fn, assets, prefabs),
        MakePlacer("sea_chiminea_placer", "fire_water_pit", "fire_water_pit", "idle_water") 
%%+%%scripts/prefabs/sea_lab.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/researchlab5.zip"),
}

local prefabs = {
    "collapse_small",
}

local function Default_PlayAnimation(inst, anim, loop)
    inst.AnimState:PlayAnimation(anim, loop)
end

local function Default_PushAnimation(inst, anim, loop)
    inst.AnimState:PushAnimation(anim, loop)
end

local function isgifting(inst)
    for k, v in pairs(inst.components.prototyper.doers) do
        if k.components.giftreceiver ~= nil and
            k.components.giftreceiver:HasGift() and
            k.components.giftreceiver.giftmachine == inst then
            return true
        end
    end
end

local function onhammered(inst, worker)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
    inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
    inst:Remove()
end

local function onhit(inst)
    if not inst:HasTag("burnt") then
        inst:_PlayAnimation("hit")
        if inst.components.prototyper.on then
            inst:_PushAnimation("proximity_loop", true)
        else
            inst:_PushAnimation("idle", true)
        end
    end
end

local function doonact(inst)
    if inst._activecount > 1 then
        inst._activecount = inst._activecount - 1
    else
        inst._activecount = 0
        inst.SoundEmitter:KillSound("sound")
    end
    inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl2_ding")
end

local function onturnoff(inst)
    if inst._activetask == nil and not inst:HasTag("burnt") then
        inst:_PushAnimation("idle", true)
        inst.SoundEmitter:KillSound("idlesound")
        inst.SoundEmitter:KillSound("loop")
    end
end

local function onsave(inst, data)
    if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end
end

local function onload(inst, data)
    if data ~= nil and data.burnt then
        inst.components.burnable.onburnt(inst)
    end
end

local function onturnon(inst)
    if inst._activetask == nil and not inst:HasTag("burnt") then
        if inst.AnimState:IsCurrentAnimation("proximity_loop") or
            inst.AnimState:IsCurrentAnimation("place") then
            --NOTE: push again even if already playing, in case an idle was also pushed
            inst:_PushAnimation("proximity_loop", true)
        else
            inst:_PlayAnimation("proximity_loop", true)
        end
        if isgifting(inst) then
            if not inst.SoundEmitter:PlayingSound("loop") then
                inst.SoundEmitter:KillSound("idlesound")
                inst.SoundEmitter:PlaySound("dontstarve/common/research_machine_gift_active_LP", "loop")
            end
        else
            if not inst.SoundEmitter:PlayingSound("idlesound") then
                inst.SoundEmitter:KillSound("loop")
                inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl2_idle_LP", "idlesound")
            end
        end
    end
end

local function refreshonstate(inst)
    --V2C: if "burnt" tag, prototyper cmp should've been removed *see standardcomponents*
    if not inst:HasTag("burnt") and inst.components.prototyper.on then
        onturnon(inst)
    end
end

local function doneact(inst)
    inst._activetask = nil
    if not inst:HasTag("burnt") then
        if inst.components.prototyper.on then
            onturnon(inst)
        else
            onturnoff(inst)
        end
    end
end

local function onactivate(inst)
    if not inst:HasTag("burnt") then
        inst:_PlayAnimation("use")
        inst:_PushAnimation("idle", true)
        if not inst.SoundEmitter:PlayingSound("sound") then
            inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl2_run", "sound")
        end
        inst._activecount = inst._activecount + 1
        inst:DoTaskInTime(1.5, doonact)
        if inst._activetask ~= nil then
            inst._activetask:Cancel()
        end
        inst._activetask = inst:DoTaskInTime(inst.AnimState:GetCurrentAnimationLength() + 2 * FRAMES, doneact)
    end
end

local function ongiftopened(inst)
    if not inst:HasTag("burnt") then
        inst:_PlayAnimation("use")
        inst:_PushAnimation("idle", true)
        inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_alchemy_gift_recieve")
        if inst._activetask ~= nil then
            inst._activetask:Cancel()
        end
        inst._activetask = inst:DoTaskInTime(inst.AnimState:GetCurrentAnimationLength() + 2 * FRAMES, doneact)
    end
end

local function onbuilt(inst, data)
    inst:_PlayAnimation("place")
    inst:_PushAnimation("idle", true)
    inst.SoundEmitter:PlaySound("dontstarve/common/researchmachine_lvl2_place")
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
    
    MakeObstaclePhysics(inst, .4)

    inst.MiniMapEntity:SetPriority(5)
    inst.MiniMapEntity:SetIcon("sea_lab.tex")
    
    inst.AnimState:SetBank("researchlab5")
    inst.AnimState:SetBuild("researchlab5")
    inst.AnimState:PlayAnimation("idle", true)

    inst:AddTag("giftmachine")
    inst:AddTag("structure")
    inst:AddTag("level2")

    --prototyper (from prototyper component) added to pristine state for optimization
    inst:AddTag("prototyper")

    MakeSnowCoveredPristine(inst)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst._activecount = 0
    inst._activetask = nil
    
    inst:AddComponent("inspectable")
    inst:AddComponent("prototyper")
    inst.components.prototyper.onturnon = onturnon
    inst.components.prototyper.onturnoff = onturnoff
    inst.components.prototyper.trees = TUNING.PROTOTYPER_TREES.SEALAB
    inst.components.prototyper.onactivate = onactivate

    inst:AddComponent("wardrobe")
    inst.components.wardrobe:SetCanUseAction(false) --also means NO wardrobe tag!
    inst.components.wardrobe:SetCanBeShared(true)
    inst.components.wardrobe:SetRange(TUNING.RESEARCH_MACHINE_DIST + .1)

    inst:ListenForEvent("onbuilt", onbuilt)    

    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)
    MakeSnowCovered(inst)

    inst.OnSave = onsave 
    inst.OnLoad = onload

    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

    inst:ListenForEvent("ms_addgiftreceiver", refreshonstate)
    inst:ListenForEvent("ms_removegiftreceiver", refreshonstate)
    inst:ListenForEvent("ms_giftopened", ongiftopened)

    inst._PlayAnimation = Default_PlayAnimation
    inst._PushAnimation = Default_PushAnimation

    return inst
end
return Prefab("sea_lab", fn, assets, prefabs),
    MakePlacer("sea_lab_placer", "researchlab5", "researchlab5", "placer")%%+%%scripts/prefabs/sea_yard.lua%%-%%require "prefabutil"

local assets = {
    Asset("ANIM", "anim/sea_yard.zip"),
    Asset("ANIM", "anim/sea_yard_meter.zip"),   
}

local prefabs = {
    "collapse_big",
    "sea_yard_arms_fx"
}

local function StartTimer(inst)
    if not inst.task_fix then
        inst.task_fix = inst:DoTaskInTime(1, function()
            inst.task_fix = nil
            inst.fixfn(inst)
        end)
    end
end

local function fixfn(inst)
    for i, user in ipairs(inst.components.autofixer.users) do
        if user.components.sailor and user.components.sailor.boat and user.components.sailor.boat.components.boathealth and user.armsfx then
            local boat = user.components.sailor.boat
            local oldpercent = boat.components.boathealth:GetPercent()
            local newpercent = math.min(1, oldpercent + 0.005)
            boat.components.boathealth:SetPercent(newpercent)
            if newpercent >= 1 then
                inst.components.autofixer:TurnOff(user)
            end 
        else
            inst.components.autofixer:TurnOff(user)
        end
    end
    if #inst.components.autofixer.users > 0 then
        StartTimer(inst)
    end
end

local function autofixtestfn(inst, user)
    return user.components.sailor and user.components.sailor.boat and user.components.sailor.boat.components.boathealth and user.components.sailor.boat.components.boathealth:GetPercent() < 1
end

local function canturnon(inst)
    return not inst.components.fueled:IsEmpty()
end

local function startfixing(inst, user)
    if autofixtestfn(inst, user) then
        if not user.armsfx then     
            local arms = SpawnPrefab("sea_yard_arms_fx")
            arms.entity:SetParent(user.entity)
            arms.AnimState:SetFinalOffset(5)
            
            user.armsfx = arms
            inst.components.fueled.rate = #inst.components.autofixer.users
            if not inst.components.fueled.consuming then                                       
                inst.components.fueled:StartConsuming()
            end         
        end
    end
    StartTimer(inst)
end

local function stopfixing(inst, user)
    local _usercount = #inst.components.autofixer.users
    if _usercount == 0 then
        inst.components.fueled.rate = 1
        inst.components.fueled:StopConsuming()
    elseif _usercount >= 1 then
        inst.components.fueled.rate = _usercount
    end

    if user.armsfx then
        user.armsfx.stopfx(user.armsfx, user)        
    end
end

local function onturnon(inst)
    if not inst:HasTag("burnt") then
        inst.SoundEmitter:PlaySound("ia/creatures/seagull/chirp")
        inst:DoTaskInTime(18 * FRAMES, function() inst.SoundEmitter:PlaySound("ia/creatures/seagull/chirp") end)
        inst.AnimState:PlayAnimation("enter")
        inst.AnimState:PushAnimation("idle", true)
    end
end

local function onturnoff(inst)
    if not inst:HasTag("burnt") then
        inst.AnimState:PushAnimation("idle", true)
    end
end

local function onhammered(inst, worker)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
    inst.components.lootdropper:DropLoot()
    local fx = SpawnPrefab("collapse_big")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
    inst:Remove()
end

local function onhit(inst, worker)
    if not inst:HasTag("burnt") then
        inst.AnimState:PlayAnimation("hit")

        inst.AnimState:PushAnimation("idle", true)
                
        inst.SoundEmitter:PlaySound("ia/creatures/seagull/chirp")
    end
end

local function OnSave(inst, data)
    if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end
end

local function OnLoad(inst, data)
    if data ~= nil and data.burnt and inst.components.burnable ~= nil and inst.components.burnable.onburnt ~= nil then
        inst.components.burnable.onburnt(inst)
    end
end

local function OnFuelSectionChange(new, old, inst)
    if inst._fuellevel ~= new then
        inst._fuellevel = new
        inst.AnimState:OverrideSymbol("swap_meter", "sea_yard_meter", tostring(new))
    end
end

local function OnFuelEmpty(inst)
    inst.components.autofixer:TurnOff()
end

local function OnAddFuel(inst)
    inst.SoundEmitter:PlaySound("dontstarve_DLC001/common/machine_fuel")
end

local function getstatus(inst, viewer)
    if inst.components.fueled and inst.components.fueled.currentfuel <= 0 then
        return "OFF"
    elseif inst.components.fueled and (inst.components.fueled.currentfuel / inst.components.fueled.maxfuel) <= .25 then
        return "LOWFUEL"
    else
        return "ON"
    end
end

local function onplaced(inst)
    inst.components.autofixer.locked = false
    inst:RemoveEventCallback("animover", onplaced)
end

local function onbuilt(inst)
    inst.AnimState:PlayAnimation("place")
    inst.AnimState:PushAnimation("idle", true)
    inst.SoundEmitter:PlaySound("ia/common/shipyard/craft")  

    inst:ListenForEvent("animover", onplaced) 
end

local function fn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetPriority(5)
    inst.MiniMapEntity:SetIcon("sea_yard.tex")
    
    MakeObstaclePhysics(inst, .4)
    
    inst.AnimState:SetBank("sea_yard")
    inst.AnimState:SetBuild("sea_yard")
    inst.AnimState:PlayAnimation("idle", true)

    inst.AnimState:OverrideSymbol("swap_meter", "sea_yard_meter", "10")

    inst:AddTag("structure")
    inst:AddTag("nowaves")

    --autofixer (from autofixer component) added to pristine state for optimization
    inst:AddTag("autofixer")

    MakeSnowCoveredPristine(inst)
    
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst._fuellevel = 10

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

    inst:AddComponent("autofixer")
    inst.components.autofixer:SetAutoFixUserTestFn(autofixtestfn)
    inst.components.autofixer:SetCanTurnOnFn(canturnon)
    inst.components.autofixer:SetOnTurnOnFn(onturnon)
    inst.components.autofixer:SetOnTurnOffFn(onturnoff)
    inst.components.autofixer:SetStartFixingFn(startfixing)
    inst.components.autofixer:SetStopFixingFn(stopfixing)
    inst.components.autofixer.locked = true

    inst:AddComponent("fueled")
    inst.components.fueled:SetDepletedFn(OnFuelEmpty)
    inst.components.fueled:SetTakeFuelFn(OnAddFuel)
    inst.components.fueled.accepting = true
    inst.components.fueled:SetSections(10)
    inst.components.fueled:SetSectionCallback(OnFuelSectionChange)
    inst.components.fueled:InitializeFuelLevel(TUNING.SEA_YARD_MAX_FUEL_TIME)
    inst.components.fueled.bonusmult = 5
    inst.components.fueled.fueltype = FUELTYPE.TAR

    inst:ListenForEvent("onbuilt", onbuilt)

    inst:AddComponent("lootdropper")
    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(4)
    inst.components.workable:SetOnFinishCallback(onhammered)
    inst.components.workable:SetOnWorkCallback(onhit)

    MakeSnowCovered(inst)

    inst.OnSave = OnSave 
    inst.OnLoad = OnLoad
    inst.fixfn = fixfn

    return inst
end

--Using old prefab names
return Prefab("sea_yard", fn, assets, prefabs),
    MakePlacer("sea_yard_placer", "sea_yard", "sea_yard", "placer" )
%%+%%scripts/prefabs/sea_yard_arms_fx.lua%%-%%local assets = {
   Asset("ANIM", "anim/sea_yard_tools.zip")
}

local function delete(inst, user)
     inst:Remove() 
     if user then
        user.armsfx = nil
    end
end

local function stopfx(inst, user)
    inst.AnimState:PlayAnimation("out")
    inst:ListenForEvent("animover", function() 
        inst.SoundEmitter:KillSound("fix")   
        delete(inst, user) 
    end)   
end

local function fn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst.AnimState:SetFinalOffset(10)

    inst.AnimState:SetBank("sea_yard_tools")
    inst.AnimState:SetBuild("sea_yard_tools")
    inst.AnimState:PlayAnimation("in")
    inst.AnimState:PushAnimation("loop", true)
    
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_medium")
    inst.SoundEmitter:PlaySound("ia/common/shipyard/fix_LP", "fix")   

    inst.stopfx = stopfx

    return inst
end

return Prefab("sea_yard_arms_fx", fn, assets) 
%%+%%scripts/prefabs/shadowcreature_sea.lua%%-%%local prefabs = {
    "nightmarefuel",
}

local brain = require("brains/shadowcreaturebrain")

local function NotifyBrainOfTarget(inst, target)
    if inst.brain ~= nil and inst.brain.SetTarget ~= nil then
        inst.brain:SetTarget(target)
    end
end

local function retargetfn(inst)
    local maxrangesq = TUNING.SHADOWCREATURE_TARGET_DIST * TUNING.SHADOWCREATURE_TARGET_DIST
    local rangesq, rangesq1, rangesq2 = maxrangesq, math.huge, math.huge
    local target1, target2 = nil, nil
    for i, v in ipairs(AllPlayers) do
        if v.components.sanity:IsCrazy() and not v:HasTag("playerghost") then
            local distsq = v:GetDistanceSqToInst(inst)
            if distsq < rangesq then
                if inst.components.shadowsubmissive:TargetHasDominance(v) then
                    if distsq < rangesq1 and inst.components.combat:CanTarget(v) then
                        target1 = v
                        rangesq1 = distsq
                        rangesq = math.max(rangesq1, rangesq2)
                    end
                elseif distsq < rangesq2 and inst.components.combat:CanTarget(v) then
                    target2 = v
                    rangesq2 = distsq
                    rangesq = math.max(rangesq1, rangesq2)
                end
            end
        end
    end

    if target1 ~= nil and rangesq1 <= math.max(rangesq2, maxrangesq * .25) then
        --Targets with shadow dominance have higher priority within half targeting range
        --Force target switch if current target does not have shadow dominance
        return target1, not inst.components.shadowsubmissive:TargetHasDominance(inst.components.combat.target)
    end
    return target2
end

local function onkilledbyother(inst, attacker)
    if attacker and attacker.components.sanity then
        attacker.components.sanity:DoDelta(inst.sanityreward or TUNING.SANITY_SMALL)
    end
end

local function CalcSanityAura(inst, observer)
    return inst.components.combat:HasTarget()
        and observer.components.sanity:IsCrazy()
        and -TUNING.SANITYAURA_LARGE
        or 0
end

local function ShareTargetFn(dude)
    return dude:HasTag("shadowcreature") and not dude.components.health:IsDead()
end

local function OnAttacked(inst, data)
    inst.components.combat:SetTarget(data.attacker)
    inst.components.combat:ShareTarget(data.attacker, 30, ShareTargetFn, 1)
end

local function OnNewCombatTarget(inst, data)
    NotifyBrainOfTarget(inst, data.target)
end

local function MakeShadowCreature(data)    
    local assets = {
        Asset("ANIM", "anim/"..data.build..".zip"),
    }
    
    local sounds = {
        attack = "dontstarve/sanity/creature"..data.num.."/attack",
        attack_grunt = "dontstarve/sanity/creature"..data.num.."/attack_grunt",
        death = "dontstarve/sanity/creature"..data.num.."/die",
        idle = "dontstarve/sanity/creature"..data.num.."/idle",
        taunt = "dontstarve/sanity/creature"..data.num.."/taunt",
        appear = "dontstarve/sanity/creature"..data.num.."/appear",
        disappear = "dontstarve/sanity/creature"..data.num.."/dissappear",
    }

    local function fn()
        local inst = CreateEntity()

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddSoundEmitter()
        inst.entity:AddNetwork()

        MakeCharacterPhysics(inst, 10, 1.5)
        RemovePhysicsColliders(inst)
        inst.Physics:SetCollisionGroup(COLLISION.SANITY)
        inst.Physics:CollidesWith(COLLISION.SANITY)

        inst.Transform:SetSixFaced()

        inst:AddTag("shadowcreature")
        inst:AddTag("monster")
        inst:AddTag("hostile")
        inst:AddTag("shadow")
        inst:AddTag("notraptrigger")
        inst:AddTag("aquatic")

        inst.AnimState:SetBank(data.bank)
        inst.AnimState:SetBuild(data.build)
        inst.AnimState:PlayAnimation("idle", true)
        inst.AnimState:SetMultColour(1, 1, 1, .5)

        -- this is purely view related
        inst:AddComponent("transparentonsanity")

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            return inst
        end

        inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
        inst.components.locomotor.walkspeed = data.speed
        inst.sounds = sounds
        inst:SetStateGraph("SGshadowcreature_sea")

        inst:SetBrain(brain)
        
        inst:AddComponent("sanityaura")
        inst.components.sanityaura.aurafn = CalcSanityAura
        
        inst:AddComponent("health")
        inst.components.health:SetMaxHealth(data.health)
        inst.components.health.nofadeout = true
        
        inst.sanityreward = data.sanityreward
        
        inst:AddComponent("combat")
        inst.components.combat:SetDefaultDamage(data.damage)
        inst.components.combat:SetAttackPeriod(data.attackperiod)
        inst.components.combat:SetRetargetFunction(3, retargetfn)
        inst.components.combat.onkilledbyother = onkilledbyother

        inst:AddComponent("shadowsubmissive")

        inst:AddComponent("lootdropper")
        inst.components.lootdropper:SetChanceLootTable("shadow_creature")
        
        inst:ListenForEvent("attacked", OnAttacked)
        inst:ListenForEvent("newcombattarget", OnNewCombatTarget)

        inst.persists = false

        return inst
    end
        
    return Prefab(data.name, fn, assets, prefabs)
end

local data = {
    {
        name = "swimminghorror",
        build = "shadow_insanity_water1",
        bank = "shadowseacreature",
        num = 1,
        speed = TUNING.CRAWLINGHORROR_SPEED,
        health = TUNING.CRAWLINGHORROR_HEALTH,
        damage = TUNING.CRAWLINGHORROR_DAMAGE,
        attackperiod = TUNING.CRAWLINGHORROR_ATTACK_PERIOD,
        sanityreward = TUNING.SANITY_MED
    }
}

local ret = {}
for k,v in pairs(data) do
    table.insert(ret, MakeShadowCreature(v))
end

return unpack(ret) %%+%%scripts/prefabs/shadowwaxwell_boat.lua%%-%%local assets = {
    Asset("ANIM", "anim/rowboat_basic.zip"),
	Asset("ANIM", "anim/waxwell_shadowboat_build.zip"),
}

local prefabs = {
    -- "rowboat_wake",
    -- "boat_hit_fx",
    -- "flotsam_rowboat",
}

local function update_rotation(inst)
	if inst and inst.sailor then
		inst.Transform:SetRotation(inst.sailor.Transform:GetRotation())
	end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()
    inst.entity:AddPhysics()
    -- inst.entity:AddMiniMapEntity()

    -- inst:AddTag("boat")
    inst:AddTag("NOCLICK")

    inst.AnimState:SetBank("rowboat")
    inst.AnimState:SetBuild("waxwell_shadowboat_build")
    inst.AnimState:PlayAnimation("run_loop", true)
	inst.AnimState:SetMultColour(0,0,0,.4)

    inst.Transform:SetFourFaced()

    inst.Physics:SetCylinder(0.25,2)

    inst.no_wet_prefix = true
	inst.presists = false

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	--TODO make this prefab a clientside FX so we don't network the rotation so much
	--probably requires the networked "marker" of the FX to announce the parent via netvar
	inst:DoPeriodicTask(FRAMES, update_rotation)

    -- inst:AddComponent("inspectable")
    -- inst:AddComponent("rowboatwakespawner")

    return inst
end

return Prefab("shadowwaxwell_boat", fn, assets, prefabs)%%+%%scripts/prefabs/sharkitten.lua%%-%%local assets=
{
  Asset("ANIM", "anim/sharkitten_basic.zip"),
  Asset("ANIM", "anim/sharkitten_build.zip"),
  Asset("SOUND", "sound/hound.fsb"),
}

local prefabs = 
{
  "shark_gills",
  "fish_med",
}

SetSharedLootTable('sharkitten',
  {
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 0.33},

    {"shark_gills", 0.25},
    {"shark_gills", 0.10},
  })

local function grow(inst, dt)
  if inst.components.scaler.scale < 0.75 then
    local new_scale = math.min(inst.components.scaler.scale + TUNING.ROCKY_GROW_RATE*dt, 0.75)
    inst.components.scaler:SetScale(new_scale)
  else
    if inst.growtask then
      inst.growtask:Cancel()
      inst.growtask = nil
    end
  end
end

local function applyscale(inst, scale)
  inst.DynamicShadow:SetSize(2.5 * scale, 1.5 * scale)
end

local function OnAttacked(inst, data)
  local x,y,z = inst.Transform:GetWorldPosition()
  local ents = TheSim:FindEntities(x,y,z, 30, {'sharkitten'})

  local num_friends = 0
  local maxnum = 5
  for k,v in pairs(ents) do
    v:PushEvent("gohome")
    num_friends = num_friends + 1

    if num_friends > maxnum then
      break
    end
  end

  --Try to get help from tigershark
  --check if it's nearby first
  local shark = GetClosestInstWithTag("tigershark", inst, 60)

  --try to spawn it if it isn't.
  if not shark then
    local tigersharker = TheWorld.components.tigersharker

    shark = tigersharker:SpawnShark()
    if shark then
      local spawnpt = tigersharker:GetNearbySpawnPoint(inst)
      shark.Transform:SetPosition(spawnpt:Get())
    end
  end

  if shark then  
    shark.components.combat:SuggestTarget(data.attacker)
  end
end

local TARGET_DIST = 15

local function RetargetFn(inst)
  local notags = {"FX", "NOCLICK","INLIMBO"}
  local yestags = {"prey", "smallcreature"}
  return FindEntity(inst, TARGET_DIST, function(guy)
      return inst.components.combat:CanTarget(guy)
    end, nil, notags, yestags)
end

local function KeepTargetFn(inst, target)
  return inst.components.combat:CanTarget(target)
end

local function kittenfn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local physics = inst.entity:AddPhysics()
  local sound = inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()
  inst.entity:AddNetwork()

  MakeCharacterPhysics(inst, 10, .5)

  shadow:SetSize( 2.5, 1.5 )
  trans:SetFourFaced()

  inst:AddTag("sharkitten")
  inst:AddTag("scarytoprey")
  inst:AddTag("prey")

  inst.AnimState:SetBank("sharkitten")
  inst.AnimState:SetBuild("sharkitten_build")
  inst.AnimState:PlayAnimation("idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeSmallBurnableCharacter(inst)
  -- MakeSmallPropagator(inst)

  inst:AddComponent("inspectable")
  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.SHARKITTEN_SPEED
  inst.components.locomotor.runspeed = TUNING.SHARKITTEN_SPEED

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.SHARKITTEN_HEALTH)

  inst:AddComponent("combat")
  inst.components.combat:SetRetargetFunction(2, RetargetFn)
  inst.components.combat:SetKeepTargetFunction(KeepTargetFn)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('sharkitten')

  inst:AddComponent("sleeper")

  inst:AddComponent("follower")

  inst:AddComponent("knownlocations")

  inst:AddComponent("scaler")
  inst.components.scaler.OnApplyScale = applyscale

  inst:AddComponent("eater")

  local min_scale = 0.75
  local max_scale = 1.00

  local scaleRange = max_scale - min_scale
  local start_scale = min_scale + math.random() * scaleRange

  inst.components.scaler:SetScale(start_scale)
  local dt = 60 + math.random()*10
  inst.growtask = inst:DoPeriodicTask(dt, grow, nil, dt)

  local brain = require "brains/sharkittenbrain"
  inst:SetBrain(brain)
  inst:SetStateGraph("SGsharkitten")

  inst.OnLongUpdate = grow

  inst:ListenForEvent("attacked", OnAttacked)

  return inst
end

return Prefab("sharkitten", kittenfn, assets, prefabs)
%%+%%scripts/prefabs/sharkittenspawner.lua%%-%%local assets = {
    Asset("ANIM", "anim/sharkitten_den.zip"),
}

local prefabs = {
    "sharkitten",
    "tigershark",
}

local function ReturnChildren(inst)
    for k, child in pairs(inst.components.childspawner.childrenoutside) do
        if child.components.homeseeker then
            child.components.homeseeker:GoHome()
        end
        child:PushEvent("gohome")
    end
end

local function SummonShark(inst, player)
    --Try to spawn a shark to protect this area if it's spring.
    if inst.spawneractive then
        local tigersharker = TheWorld.components.tigersharker
		if not tigersharker then return end --in case somebody spawns this in caves

        local shark = tigersharker:SpawnShark(true, false)
        if shark then
            local spawnpt = tigersharker:GetNearbySpawnPoint(player)
            if spawnpt then
                shark.Transform:SetPosition(spawnpt:Get())
                shark.components.combat:SuggestTarget(player)
            end
        end
    end
end

local function SpawnKittens(inst, num)
    for i = 1, num do
        local kitten = SpawnPrefab("sharkitten")
        kitten.Transform:SetPosition(inst:GetPosition():Get())
        inst.components.herd:AddMember(kitten)
    end
end

local function OnIsDay(inst, isday)
	if isday and inst.spawneractive then
		inst.components.childspawner:StartSpawning()
	else
		inst.components.childspawner:StopSpawning()
		ReturnChildren(inst)
	end
end

local function ActivateSpawner(inst, onload)
    if not inst.spawneractive or onload then
        inst.spawneractive = true

		inst.components.named:SetName(STRINGS.NAMES["SHARKITTENSPAWNER_ACTIVE"])
		--Queue up an animation change for next time this is off screen
		inst.AnimState:PlayAnimation("idle_active")
		--Start task to periodically blink if there are children inside
		inst.blink_task = inst:DoPeriodicTask(math.random() * 10 + 10, function()
			if inst.components.childspawner and inst.components.childspawner.childreninside > 0 then
				inst.AnimState:PlayAnimation("blink")
				inst.AnimState:PushAnimation("idle_active")
			end
		end)

		inst:WatchWorldState("isday", OnIsDay)

		if TheWorld.state.isday then
			OnIsDay(inst, true)
		end
    end
end

local function DeactiveateSpawner(inst, onload)
    if inst.spawneractive or onload then
        inst.spawneractive = false
		
		inst.components.named:SetName(STRINGS.NAMES["SHARKITTENSPAWNER_INACTIVE"])
		--Queue up an animation change for the next time this is off screen
		inst.AnimState:PlayAnimation("idle_inactive")
		--Stop task to periodically blink if there are children inside
		if inst.blink_task then
			inst.blink_task:Cancel()
			inst.blink_task = nil
		end

		inst:StopWatchingWorldState("daytime", OnIsDay)
		inst.components.childspawner:StopSpawning()
		ReturnChildren(inst)
		
    end
end

local function OnSeasonChange(inst, season)
    if season == SEASONS.SPRING or season == SEASONS.GREEN then
        --Start the spawning.
        ActivateSpawner(inst)
    else
        --Stop
        DeactiveateSpawner(inst)
    end
end

local function getstatus(inst)
    if not inst.spawneractive then 
        return "INACTIVE"
    end
end

local function OnSave(inst, data)
    data.spawneractive = inst.spawneractive
end

local function OnLoad(inst, data)
    if data and data.spawneractive then
        ActivateSpawner(inst, true)
    else
        DeactiveateSpawner(inst, true)
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()  
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("sharkden.tex")

    inst.AnimState:SetBuild("sharkitten_den")
    inst.AnimState:SetBank("sharkittenden")
    inst.AnimState:PlayAnimation("idle_inactive")

    inst:AddTag("sharkhome")

    MakeObstaclePhysics(inst, 2)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("childspawner")
    inst.components.childspawner.childname = "sharkitten"
    inst.components.childspawner:SetRegenPeriod(TUNING.SHARKITTEN_REGEN_PERIOD)
    inst.components.childspawner:SetSpawnPeriod(TUNING.SHARKITTEN_SPAWN_PERIOD)
    inst.components.childspawner:SetMaxChildren(4)
    inst.components.childspawner:StartRegen()

    inst:AddComponent("playerprox")
    inst.components.playerprox:SetOnPlayerNear(SummonShark)
    inst.components.playerprox:SetPlayerAliveMode(inst.components.playerprox.AliveModes.AliveOnly)
    inst.components.playerprox:SetDist(7.5, 10)
    inst.components.playerprox.period = 1

    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

    inst:AddComponent("named")
    inst.components.named:SetName(STRINGS.NAMES["SHARKITTENSPAWNER_INACTIVE"])

    inst.SpawnKittens = SpawnKittens
    inst.OnLoad = OnLoad
    inst.OnSave = OnSave

    inst:WatchWorldState("season", OnSeasonChange)
    OnSeasonChange(inst, TheWorld.state.season)

    return inst
end

return Prefab("sharkittenspawner", fn, assets, prefabs)%%+%%scripts/prefabs/shark_fin.lua%%-%%local assets=
{
  Asset("ANIM", "anim/shark_fin.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("shark_fin")
  inst.AnimState:SetBuild("shark_fin")
  inst.AnimState:PlayAnimation("idle")
  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("edible")
  inst.components.edible.foodtype = "MEAT"
  inst.components.edible.healthvalue = TUNING.HEALING_MED
  inst.components.edible.hungervalue = TUNING.CALORIES_MED
  inst.components.edible.sanityvalue = -TUNING.SANITY_MED

  inst:AddComponent("perishable")
  inst.components.perishable:SetPerishTime(TUNING.PERISH_FAST)
  inst.components.perishable:StartPerishing()
  inst.components.perishable.onperishreplacement = "spoiled_food"

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_SMALL

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM



  return inst
end

return Prefab( "shark_fin", fn, assets) 
%%+%%scripts/prefabs/shark_gills.lua%%-%%local assets=
{
  Asset("ANIM", "anim/shark_gills.zip"),
}

local function fn(Sim)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("shark_gills")
  inst.AnimState:SetBuild("shark_gills")
  inst.AnimState:PlayAnimation("idle")
  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_LARGE

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

  return inst
end

return Prefab( "shark_gills", fn, assets) 
%%+%%scripts/prefabs/sharx.lua%%-%%require "brains/sharxbrain"
require "stategraphs/SGsharx"

local trace = function() end

local assets=
{
  --Asset("ANIM", "anim/hound_basic.zip"),
  Asset("ANIM", "anim/sharx.zip"),
  Asset("ANIM", "anim/sharx_build.zip"),

  --Asset("SOUND", "sound/hound.fsb"),
}

local prefabs =
{
  "shark_fin",
  "shark_gills",
  "monstermeat",
  --"redgem",
  --"bluegem",
}

SetSharedLootTable( 'sharx',
  {
    {'monstermeat', 1.000},
    {'shark_fin',  0.125},
    {'houndstooth',  0.125},
  })


local SHARE_TARGET_DIST = 30


local NO_TAGS = {"FX", "NOCLICK","DECOR","INLIMBO"}


local function retargetfn(inst)
  local notags = {"FX", "NOCLICK","INLIMBO", "sharx"}
  local yestags = {"aquatic"}

  local dist = TUNING.HOUND_TARGET_DIST
  return FindEntity(inst, dist, function(guy) 
      return inst.components.combat:CanTarget(guy)
    end, yestags, notags)
end

local function KeepTarget(inst, target)
  local shouldkeep = inst.components.combat:CanTarget(target) and (not inst:HasTag("pet_hound") or inst:IsNear(target, TUNING.HOUND_FOLLOWER_TARGET_KEEP))
  -- local onboat = target.components.sailor and target.components.sailor:IsSailing()
  local onwater = target:HasTag("aquatic")
  return shouldkeep and onwater
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("sharx")  and not dude.components.health:IsDead() end, 5)
end

local function OnAttackOther(inst, data)
  inst.components.combat:ShareTarget(data.target, SHARE_TARGET_DIST, function(dude) return dude:HasTag("sharx")  and not dude.components.health:IsDead() end, 5)
end

local function OnNewTarget(inst, data)
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end

local function fncommon()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local physics = inst.entity:AddPhysics()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()
  --local shadow = inst.entity:AddDynamicShadow()
  --shadow:SetSize( 2.5, 1.5 )
  inst.Transform:SetFourFaced()

  inst:AddTag("scarytoprey")
  inst:AddTag("monster")
  inst:AddTag("hostile")
  inst:AddTag("sharx")
  inst:AddTag("aquatic")

  MakeCharacterPhysics(inst, 10, .5)

  inst.AnimState:SetBank("sharx")
  inst.AnimState:SetBuild("sharx_build")
  inst.AnimState:PlayAnimation("idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.runspeed = TUNING.SHARX_SPEED
  inst:SetStateGraph("SGsharx")

  local brain = require "brains/sharxbrain"
  inst:SetBrain(brain)

  inst:AddComponent("follower")

  inst:AddComponent("eater")
  inst.components.eater:SetCarnivore()
  inst.components.eater:SetCanEatHorrible()

  inst.components.eater.strongstomach = true -- can eat monster meat!

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.SHARX_HEALTH)

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aura = -TUNING.SANITYAURA_MED

  inst:AddComponent("combat")
  inst.components.combat:SetDefaultDamage(TUNING.SHARX_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.SHARX_ATTACK_PERIOD)
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)
  inst.components.combat:SetHurtSound( "ia/creatures/sharx/hurt")

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetChanceLootTable('sharx')

  inst:AddComponent("inspectable")

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetResistance(3)
  inst.components.sleeper.testperiod = GetRandomWithVariance(6, 2)
  inst.components.sleeper.onlysleepsfromitems = true 

  inst:ListenForEvent("newcombattarget", OnNewTarget)

  inst:ListenForEvent("attacked", OnAttacked)
  inst:ListenForEvent("onattackother", OnAttackOther)

  MakeMediumFreezableCharacter(inst, "sharx_body")
  
  return inst
end

local function fndefault()
  local inst = fncommon(Sim)

  --MakeMediumFreezableCharacter(inst, "hound_body")
  --MakeMediumBurnableCharacter(inst, "hound_body")
  return inst
end



return Prefab( "sharx", fndefault, assets, prefabs)
%%+%%scripts/prefabs/shipwreck.lua%%-%%local assets =
{
	Asset("ANIM", "anim/shipwreck.zip"),
}

local prefabs =
{
	"limpets",
	"boards",
	"pirateghost"
}

local wrecktypes = {"mast", "bow", "midship", "stern"}
local hulltypes = {"bow", "midship", "stern"}

local anims =
{
	mast =
	{
		full = "idle_full1",
		empty = "idle_empty1",
		grow = "grow1",
		picked = "picked1",
		hitfull = "hit_full1",
		hitempty = "hit_empty1"
	},
	bow =
	{
		full = "idle_full2",
		empty = "idle_empty2",
		grow = "grow2",
		picked = "picked2",
		hitfull = "hit_full2",
		hitempty = "hit_empty2"
	},
	midship =
	{
		full = "idle_full3",
		empty = "idle_empty3",
		grow = "grow3",
		picked = "picked3",
		hitfull = "hit_full3",
		hitempty = "hit_empty3"
	},
	stern =
	{
		full = "idle_full4",
		empty = "idle_empty4",
		grow = "grow4",
		picked = "picked4",
		hitfull = "hit_full4",
		hitempty = "hit_empty4"
	},
}

local sizes =
{
	mast = 0.1,
	bow = 0.9, --1.6,
	midship = 0.9, --1.5,
	stern = 0.9 --1.5
}

local sounds =
{
	mast = "ia/common/graveyard_shipwreck/shipwreck_1",
	bow = "ia/common/graveyard_shipwreck/shipwreck_2",
	midship = "ia/common/graveyard_shipwreck/shipwreck_3",
	stern = "ia/common/graveyard_shipwreck/shipwreck_4"
}

local function makeemptyfn(inst)
	inst.AnimState:PlayAnimation(anims[inst.wrecktype].empty, true)
end

local function makebarrenfn(inst)
	inst.AnimState:PlayAnimation(anims[inst.wrecktype].empty, true)
end

local function onpickedfn(inst, picker)
	if inst.components.pickable then
		inst.AnimState:PlayAnimation(anims[inst.wrecktype].picked)
		inst.AnimState:PushAnimation(anims[inst.wrecktype].empty, true)
	end
end

local function getregentimefn(inst)
	return TUNING.LIMPET_REGROW_TIME
end

local function makefullfn(inst)
	inst.AnimState:PlayAnimation(anims[inst.wrecktype].grow)
	inst.AnimState:PushAnimation(anims[inst.wrecktype].full, true)
end

local function onworked(inst, worker, workleft)
	if inst.components.pickable:CanBePicked() then
		inst.AnimState:PlayAnimation(anims[inst.wrecktype].hitfull)
		inst.AnimState:PushAnimation(anims[inst.wrecktype].full)
	else
		inst.AnimState:PlayAnimation(anims[inst.wrecktype].hitempty)
		inst.AnimState:PushAnimation(anims[inst.wrecktype].empty)
	end
end

local function onhammered(inst, worker)
	if inst:HasTag("fire") and inst.components.burnable then
		inst.components.burnable:Extinguish()
	end
	if inst.haunted and inst.haunted == true and math.random() < 0.5 then
		local ghost = SpawnPrefab("pirateghost")
		if ghost then
			local pos = Point(inst.Transform:GetWorldPosition())
			ghost.Transform:SetPosition(pos.x - .3, pos.y, pos.z - .3)
		end
	end
	if inst.components.pickable and inst.components.pickable:CanBePicked() then
		for i = 1, inst.components.pickable.numtoharvest do
			inst.components.lootdropper:SpawnLootPrefab(inst.components.pickable.product)
		end
	end
	inst.components.lootdropper:DropLoot()
	local fx = SpawnPrefab("collapse_big")
	fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
	inst:Remove()
end

local function spawnghost(inst, worker)
	if math.random() < TUNING.HAUNT_CHANCE_SUPERRARE then
		local ghost = SpawnPrefab("pirateghost")
		if ghost then
			local pos = Point(inst.Transform:GetWorldPosition())
			ghost.Transform:SetPosition(pos.x - .3, pos.y, pos.z - .3)
		end
		if inst.components.pickable:CanBePicked() then
			inst.AnimState:PlayAnimation(anims[inst.wrecktype].hitfull)
			inst.AnimState:PushAnimation(anims[inst.wrecktype].full)
		else
			inst.AnimState:PlayAnimation(anims[inst.wrecktype].hitempty)
			inst.AnimState:PushAnimation(anims[inst.wrecktype].empty)
		end
	end
end

local function settype(inst, wrecktype)
	if type(wrecktype) == "number" or wrecktype == "random" then
		inst.wrecktype = wrecktypes[math.random(1, #wrecktypes)]
	elseif wrecktype == "hull" then
		inst.wrecktype = hulltypes[math.random(1, #hulltypes)]
	else
		inst.wrecktype = wrecktype
	end
	if inst.components.pickable and inst.components.pickable:CanBePicked() then
		inst.AnimState:PlayAnimation(anims[inst.wrecktype].full, true)
	else
		inst.AnimState:PlayAnimation(anims[inst.wrecktype].empty, true)
	end
	inst.Physics:SetCapsule(sizes[inst.wrecktype], 2.0)
end

local function makenamed(inst)
	if inst.components.named == nil then
		inst:AddComponent("named")
		inst.components.named.nameformat = STRINGS.NAMES.WRECKOF
		inst.components.named.possiblenames = STRINGS.SHIPNAMES
		inst.components.named:PickNewName()
	end
end

local function makehaunted(inst)
	inst.haunted = true
end

local function onpreload(inst, data)
	if data and data.named and inst.components.named == nil then
		inst:AddComponent("named") --doing this so named gets loaded
	end
end

local function onsave(inst, data)
	data.wrecktype = inst.wrecktype
	data.haunted = inst.haunted
end

local function onload(inst, data)
	if data then
		if data.wrecktype then
			settype(inst, data.wrecktype)
		end
		if data.isnamed and data.isnamed == true then
			makenamed(inst)
		end
		if data.haunted and data.haunted == true then
			makehaunted(inst)
		end
	end
end

local function onwake(inst)
	inst.SoundEmitter:PlaySound(sounds[inst.wrecktype], "amb")
end

local function onsleep(inst)
	inst.SoundEmitter:KillSound("amb")
end

local function wreckfn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst.AnimState:SetBank("shipwreck")
	inst.AnimState:SetBuild("shipwreck")
	--inst.AnimState:PlayAnimation(anims[inst.wrecktype].full, true)

	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetIcon("wreck.tex")

	MakeObstaclePhysics(inst, 0.1)

    inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	inst:AddComponent("pickable")
	inst.components.pickable.picksound = "ia/common/limpet_harvest"
	inst.components.pickable:SetUp("limpets", TUNING.LIMPET_REGROW_TIME)
	inst.components.pickable.getregentimefn = getregentimefn
	inst.components.pickable.onpickedfn = onpickedfn
	inst.components.pickable.makeemptyfn = makeemptyfn
	inst.components.pickable.makebarrenfn = makebarrenfn
	inst.components.pickable.makefullfn = makefullfn
	inst.components.pickable.numtoharvest = math.random(2, 3)
	inst.components.pickable.witherable = false

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(3)
	inst.components.workable:SetOnWorkCallback(onworked)
	inst.components.workable:SetOnFinishCallback(onhammered)

	inst:AddComponent("inspectable")
	-- inst:AddComponent("waveobstacle")

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetLoot({"boards"})
	
	AddHauntableCustomReaction(inst, spawnghost)
	
	settype(inst, "random")

	inst.settype = settype --little hook for creative mode -M
	inst.OnPreLoad = onpreload
	inst.OnSave = onsave
	inst.OnLoad = onload
	inst.OnEntityWake = onwake
	inst.OnEntitySleep = onsleep

	return inst
end

return Prefab( "shipwreck", wreckfn, assets, prefabs)%%+%%scripts/prefabs/slotmachine.lua%%-%%require "prefabutil"

local assets = 
{
	Asset("ANIM", "anim/slot_machine.zip"),
	-- Asset("MINIMAP_IMAGE", "slot_machine"),
}

local prefabs =
{
	"armormarble",
	"armor_sanity",
	"armorsnurtleshell",
	"resurrectionstatue",
	"icestaff",
	"firestaff",
	"telestaff",
	"thulecite",
	"orangestaff",
	"greenstaff",
	"yellowstaff",
	"amulet",
	"blueamulet",
	"purpleamulet",
	"orangeamulet",
	"greenamulet",
	"yellowamulet",
	"redgem",
	"bluegem",
	"orangegem",
	"greengem",
	"purplegem",
	"stafflight",
	"gears",
	"collapse_small",
}


-- weighted_random_choice for bad, ok, good prize lists 
local prizevalues =
{
	bad = 2,
	ok = 3,
	good = 1,
}

local sounds = 
{
	ok = "ia/common/slotmachine/mediumresult",
	good = "ia/common/slotmachine/goodresult",
	bad = "ia/common/slotmachine/badresult",
}

local function SpawnCritter(inst, player, critter, lootdropper, pt, delay)
	delay = delay or GetRandomWithVariance(1,0.8)
	inst:DoTaskInTime(delay, function() 
		SpawnPrefab("collapse_small").Transform:SetPosition(pt:Get())
		local spawn = lootdropper:SpawnLootPrefab(critter, pt)
		if spawn and spawn.components.combat then
			spawn.components.combat:SetTarget(player)
		end
	end)
end

local function SpawnReward(inst, player, reward, lootdropper, pt, delay)
	delay = delay or GetRandomWithVariance(1,0.8)

	local loots = GetTreasureLootList(reward)
	for k, v in pairs(loots) do
		for i = 1, v, 1 do

			inst:DoTaskInTime(delay, function(inst) 
				-- local down = TheCamera:GetDownVec()
				-- local spawnangle = math.atan2(down.z, down.x)
				-- local angle = math.atan2(down.z, down.x) + (math.random()*90-45)*DEGREES
				-- local sp = math.random()*3+2
				--ripped right from our Octopus implementation
				local angle
				local spawnangle
				local sp = math.random()*3+2
				local x, y, z = inst.Transform:GetWorldPosition()
				
				if player ~= nil and player:IsValid() then
					angle = (225 - math.random()*90 - player:GetAngleToPoint(x, 0, z))*DEGREES
					spawnangle = player:GetAngleToPoint(x, 0, z)*DEGREES
				else
					local down = TheCamera:GetDownVec()
					angle = math.atan2(down.z, down.x) + (math.random()*90-45)*DEGREES
					spawnangle = math.atan2(down.z, down.x)
					player = nil
				end
				
				local item = SpawnPrefab(k)
				
				if  item and item:IsValid() then
					if item.components.inventoryitem and not item.components.health then
						local pt = Vector3(inst.Transform:GetWorldPosition()) + Vector3(2*math.cos(spawnangle), 3, 2*math.sin(spawnangle))
						inst.SoundEmitter:PlaySound("ia/common/slotmachine/reward")
						item.Transform:SetPosition(pt:Get())
						item.Physics:SetVel(sp*math.cos(angle), math.random()*2+9, sp*math.sin(angle))
						item.components.inventoryitem:SetLanded(false, true)
					else
						local pt = Vector3(inst.Transform:GetWorldPosition()) + Vector3(2*math.cos(spawnangle), 0, 2*math.sin(spawnangle))
						pt = pt + Vector3(sp*math.cos(angle), 0, sp*math.sin(angle))
						item.Transform:SetPosition(pt:Get())
						SpawnPrefab("collapse_small").Transform:SetPosition(pt:Get())
					end
				end
				
			end)
			delay = delay + 0.25
		end
	end
end



local function PickPrize(inst)

	local prizevalue = weighted_random_choice(prizevalues)
	-- print("slotmachine prizevalue", prizevalue)
	if prizevalue == "ok" then
		inst.prize = weighted_random_choice(SLOTMACHINE_LOOT.okspawns)
	elseif prizevalue == "good" then
		inst.prize = weighted_random_choice(SLOTMACHINE_LOOT.goodspawns)
	elseif prizevalue == "bad" then
		inst.prize = weighted_random_choice(SLOTMACHINE_LOOT.badspawns)
	else
		-- impossible!
		print("impossible slot machine prizevalue!", prizevalue)
	end

	inst.prizevalue = prizevalue
end

local function DoneSpinning(inst)

	local pos = inst:GetPosition()
	local item = inst.prize
	local doaction = SLOTMACHINE_LOOT.actions[item]
	local player = FindClosestPlayerToInst(inst, 20, true)

	local cnt = (doaction and doaction.cnt) or 1
	local func = (doaction and doaction.callback) or nil
	local radius = (doaction and doaction.radius) or 4
	local treasure = (doaction and doaction.treasure) or nil

	if doaction and doaction.var then
		cnt = GetRandomWithVariance(cnt,doaction.var)
		if cnt < 0 then cnt = 0 end
	end

	if cnt == 0 and func then
		func(inst,item,doaction)
	end

	for i=1,cnt do
		local offset, check_angle, deflected = FindWalkableOffset(pos, math.random()*2*PI, radius , 8, true, false) -- try to avoid walls
		if offset then
			if treasure then
				-- print("Slot machine treasure "..tostring(treasure))
				-- SpawnTreasureLoot(treasure, inst.components.lootdropper, pos+offset)
				-- SpawnPrefab("collapse_small").Transform:SetPosition((pos+offset):Get())
				SpawnReward(inst, player, treasure)
			elseif func then
				func(inst,item,doaction)
			elseif item == "trinket" then
				if math.random() < .5 then
					SpawnCritter(inst, player, "trinket_ia_"..tostring(math.random(13,23)), inst.components.lootdropper, pos+offset)
				else
					SpawnCritter(inst, player, "trinket_"..tostring(math.random(NUM_TRINKETS)), inst.components.lootdropper, pos+offset)
				end
			elseif item == "nothing" then
				-- do nothing
				-- print("Slot machine says you lose.")
			else
				-- print("Slot machine item "..tostring(item))
				SpawnCritter(inst, player, item, inst.components.lootdropper, pos+offset)
			end
		end
	end

	-- the slot machine collected more coins
	inst.coins = inst.coins + 1

	--inst.AnimState:PlayAnimation("idle")
	inst.prize = nil
	inst.prizevalue = nil
	
	-- print("Slot machine has "..tostring(inst.coins).." dubloons.")
end

local function StartSpinning(inst)
	inst.sg:GoToState("spinning") --"busy" statetag blocks trader component
end

local function ShouldAcceptItem(inst, item)
	
	if not inst.sg.HasStateTag("busy") and item.prefab == "dubloon" then
		return true
	else
		return false
	end
end

local function OnGetItemFromPlayer(inst, giver, item)

	-- print("Slot machine takes your dubloon.")
	giver.components.sanity:DoDelta(-TUNING.SANITY_TINY)

	PickPrize(inst)
	StartSpinning(inst)
end

local function OnRefuseItem(inst, item)
	-- print("Slot machine refuses "..tostring(item.prefab))
end

local function OnLoad(inst,data)
	if not data then
		return
	end
	
	inst.coins = data.coins or 0
	inst.prize = data.prize
	inst.prizevalue = data.prizevalue

	if inst.prize ~= nil then
		StartSpinning(inst)
	end
end

local function OnSave(inst,data)
	data.coins = inst.coins
	data.prize = inst.prize
	data.prizevalue = inst.prizevalue
end

local function onStartFlooded(inst)
	inst.components.trader:Disable()
end

local function onStopFlooded(inst)
	inst.components.trader:Enable()
end

local function CalcSanityAura(inst, observer)
	return -(TUNING.SANITYAURA_MED*(1+(inst.coins/100)))
end



local function InitFn(Sim)
	local inst = CreateEntity()

	inst.sounds = sounds

	inst.entity:AddTransform()
	
	inst.entity:AddAnimState()
	inst.AnimState:SetBank("slot_machine")
	inst.AnimState:SetBuild("slot_machine")
	inst.AnimState:PlayAnimation("idle")
	
	inst.entity:AddSoundEmitter()
	
	inst.entity:AddNetwork()
	
	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetPriority( 5 )
	minimap:SetIcon( "slot_machine.tex" )
	
	-- MakeObstaclePhysics(inst, 0.8, 1.2) -- items could get stuck on it

	inst:AddComponent("floodable")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.DoneSpinning = DoneSpinning

	-- keeps track of how many dubloons have been added
	inst.coins = 0
	
	inst:AddComponent("inspectable")
	inst.components.inspectable.getstatus = function(inst)
		return "WORKING"
	end

	inst:AddComponent("lootdropper")

	-- "payable" was identical to trader, we're lazy and will use trader directly :P
	inst:AddComponent("trader")
	inst.components.trader:SetAcceptTest(ShouldAcceptItem)
	inst.components.trader.onaccept = OnGetItemFromPlayer
	inst.components.trader.onrefuse = OnRefuseItem

	inst:AddComponent("sanityaura")
	inst.components.sanityaura.aurafn = CalcSanityAura

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

	inst:SetStateGraph("SGslotmachine")
	
	inst.OnSave = OnSave
	inst.OnLoad = OnLoad

	return inst
end

return Prefab( "slotmachine", InitFn, assets, prefabs)
%%+%%scripts/prefabs/snake.lua%%-%%require "brains/snakebrain"
require "stategraphs/SGsnake"

local trace = function() end

local assets=
{
  Asset("ANIM", "anim/snake_build.zip"),
  Asset("ANIM", "anim/snake_yellow_build.zip"),
  Asset("ANIM", "anim/snake_basic.zip"),
  Asset("ANIM", "anim/dragonfly_fx.zip"),
}

local prefabs =
{
  "monstermeat",
  "snakeskin",
  "venomgland",
  "obsidian",
  "ash",
  "charcoal",
  --"vomitfire_fx",
  "firesplash_fx",
  "firering_fx",
  --"dragonfly_fx",
  --"lavaspit",
  "snakeoil",
}

local WAKE_TO_FOLLOW_DISTANCE = 8
local SLEEP_NEAR_HOME_DISTANCE = 10
local SHARE_TARGET_DIST = 30
local HOME_TELEPORT_DIST = 30

local NO_TAGS = {"FX", "NOCLICK","DECOR","INLIMBO"}

local function ShouldWakeUp(inst)
  return TheWorld.state.isnight
  or (inst.components.combat and inst.components.combat.target)
  or (inst.components.homeseeker and inst.components.homeseeker:HasHome() )
  or (inst.components.burnable and inst.components.burnable:IsBurning() )
  or (inst.components.follower and inst.components.follower.leader)
end

local function ShouldSleep(inst)
  return TheWorld.state.isday
  and not (inst.components.combat and inst.components.combat.target)
  and not (inst.components.homeseeker and inst.components.homeseeker:HasHome() )
  and not (inst.components.burnable and inst.components.burnable:IsBurning() )
  and not (inst.components.follower and inst.components.follower.leader)
end

local function OnNewTarget(inst, data)
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end


local function retargetfn(inst)
  local dist = TUNING.SNAKE_TARGET_DIST
  local notags = {"FX", "NOCLICK","INLIMBO", "wall", "snake", "structure", "aquatic"}
  return FindEntity(inst, dist, function(guy)
      return  inst.components.combat:CanTarget(guy)
    end, nil, notags)
end

local function KeepTarget(inst, target)
  return inst.components.combat:CanTarget(target) and inst:GetDistanceSqToInst(target) <= (TUNING.SNAKE_KEEP_TARGET_DIST*TUNING.SNAKE_KEEP_TARGET_DIST) and not target:HasTag("aquatic")
end

local function OnAttacked(inst, data)
  inst.components.combat:SetTarget(data.attacker)
  inst.components.combat:ShareTarget(data.attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("snake")and not dude.components.health:IsDead() end, 5)
end

local function OnAttackOther(inst, data)
  inst.components.combat:ShareTarget(data.target, SHARE_TARGET_DIST, function(dude) return dude:HasTag("snake") and not dude.components.health:IsDead() end, 5)
end

local function DoReturn(inst)
  --print("DoReturn", inst)
  if inst.components.homeseeker then
    inst.components.homeseeker:GoHome()
  end
end

local function OnDay(inst, isday)
  --print("OnNight", inst)
  if isday and inst:IsAsleep() then
    DoReturn(inst)
  end
end


local function OnEntitySleep(inst)
  --print("OnEntitySleep", inst)
  if TheWorld.state.isday then
    DoReturn(inst)
  end
end

local function OnSave(inst, data)
end

local function OnLoad(inst, data)
end

local function SanityAura(inst, observer)

  if observer.prefab == "webber" then
    return 0
  end

  return -TUNING.SANITYAURA_SMALL
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local physics = inst.entity:AddPhysics()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()
  --local shadow = inst.entity:AddDynamicShadow()
  --shadow:SetSize( 2.5, 1.5 )
  inst.Transform:SetFourFaced()

  inst:AddTag("scarytoprey")
  inst:AddTag("monster")
  inst:AddTag("hostile")
  inst:AddTag("snake")

  MakeCharacterPhysics(inst, 10, .5)

  inst.AnimState:SetBank("snake")
  inst.AnimState:SetBuild("snake_build")
  inst.AnimState:PlayAnimation("idle")
  inst.AnimState:SetRayTestOnBB(true)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("knownlocations")

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.runspeed = TUNING.SNAKE_SPEED

  inst:SetStateGraph("SGsnake")

  local brain = require "brains/snakebrain"
  inst:SetBrain(brain)

  inst:AddComponent("follower")

  inst:AddComponent("eater")
  inst.components.eater:SetCarnivore()
  inst.components.eater:SetCanEatHorrible()

  inst.components.eater.strongstomach = true -- can eat monster meat!

  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.SNAKE_HEALTH)
  inst.components.health.poison_damage_scale = 0 -- immune to poison


  inst:AddComponent("combat")
  inst.components.combat:SetDefaultDamage(TUNING.SNAKE_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.SNAKE_ATTACK_PERIOD)
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)
  inst.components.combat:SetHurtSound("ia/creatures/snake/hurt")
  inst.components.combat:SetRange(2,3)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:AddRandomLoot("monstermeat", 1.00)
  inst.components.lootdropper:AddRandomLoot("snakeskin", 0.50)
  inst.components.lootdropper:AddRandomLoot("snakeoil", 0.01)
  inst.components.lootdropper.numrandomloot = math.random(0,1)

  inst:AddComponent("inspectable")

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aurafn = SanityAura

  inst:AddComponent("sleeper")
  inst.components.sleeper:SetNocturnal(true)
  --inst.components.sleeper:SetResistance(1)
  -- inst.components.sleeper.testperiod = GetRandomWithVariance(6, 2)
  -- inst.components.sleeper:SetSleepTest(ShouldSleep)
  -- inst.components.sleeper:SetWakeTest(ShouldWakeUp)
  inst:ListenForEvent("newcombattarget", OnNewTarget)

  inst:WatchWorldState("isday", OnDay)
  
  inst.OnEntitySleep = OnEntitySleep

  inst.OnSave = OnSave
  inst.OnLoad = OnLoad

  inst:ListenForEvent("attacked", OnAttacked)
  inst:ListenForEvent("onattackother", OnAttackOther)

  MakeMediumFreezableCharacter(inst, nil)

  return inst
end

local function commonfn(Sim)
  local inst = fn(Sim)

  if TheWorld.ismastersim then
--  MakePoisonableCharacter(inst) -- commented it as for the moment I put it in the AddPRefabPostInitAny
    MakeMediumBurnableCharacter(inst, nil, Vector3(0, 0.1, 0))
  end

  return inst
end

local function poisonfn(Sim)
  local inst = fn(Sim)

  inst.AnimState:SetBuild("snake_yellow_build")

  inst:AddTag("poisonous")

  if TheWorld.ismastersim then
    inst.components.combat.poisonous = true
    inst.components.lootdropper:AddRandomLoot("venomgland", 1.00)

    MakeMediumBurnableCharacter(inst, nil, Vector3(0, 0.1, 0))
  end

  return inst
end

local function firefn(Sim)
  local inst = fn(Sim)

  inst.AnimState:SetBuild("snake_yellow_build")

  inst:AddTag("lavaspitter")

  if TheWorld.ismastersim then
    inst.last_spit_time = nil
    inst.last_target_spit_time = nil
    inst.spit_interval = math.random(20,30)
    inst.num_targets_vomited = 0

    inst.components.health.fire_damage_scale = 0

    --inst:AddTag("poisonous")
    inst.components.lootdropper.numrandomloot = 3
    inst.components.lootdropper:AddRandomLoot("obsidian", .25)
    inst.components.lootdropper:AddRandomLoot("ash", .25)
    inst.components.lootdropper:AddRandomLoot("charcoal", .25)

    MakeLargePropagator(inst)
    inst.components.propagator.decayrate = 0
  end

  return inst
end

return Prefab("snake", commonfn, assets, prefabs),
Prefab("snake_poison", poisonfn, assets, prefabs),
Prefab("snake_fire", firefn, assets, prefabs)
-- Prefab("deadsnake", fndefault, assets, prefabs),

%%+%%scripts/prefabs/snakeden.lua%%-%%local assets=
{
  Asset("ANIM", "anim/bush_vine.zip"),
}


local prefabs =
{
  "vine",
  "dug_bush_vine",
  "hacking_fx",
  "snake_poison",
  "snake",
}

local onshake

local function stopshaking(inst)
  if inst.shaketask then
    inst.shaketask:Cancel()
    inst.shaketask = nil
  end
end

local function startshaking(inst)
  stopshaking(inst)
  inst.shaketask = inst:DoTaskInTime(5+(math.random()*2), onshake)
end

local function spawnsnake(inst, target)

  if math.random() < TUNING.SNAKE_POISON_CHANCE and TheWorld.state.cycles >= TUNING.SNAKE_POISON_START_DAY then
    inst.components.childspawner.childname = "snake_poison"
  else
    inst.components.childspawner.childname = "snake"
  end

  local snake = inst.components.childspawner:SpawnChild()
  if snake then
    local spawnpos = inst:GetPosition()
    spawnpos = spawnpos + TheCamera:GetDownVec()
    snake.Transform:SetPosition(spawnpos:Get())
    if snake and target and snake.components.combat then
      snake.components.combat:SetTarget(target)
    end
  end
  
  return snake
end

local function ontransplantfn(inst)
  if inst.components.hackable then
    inst.components.hackable:MakeBarren()
  end
end

local function dig_up(inst, chopper)
  if inst.components.hackable and inst.components.hackable:CanBeHacked() then
    inst.components.lootdropper:SpawnLootPrefab("vine")
  end
  if inst.components.hackable and not inst.components.hackable.withered then
    inst.components.lootdropper:SpawnLootPrefab("dug_bush_vine")
    inst.components.lootdropper:SpawnLootPrefab("snakeskin")
  else
    inst.components.lootdropper:SpawnLootPrefab("vine")
  end
  inst:Remove()
end

local function onregenfn(inst)
  inst.AnimState:PlayAnimation("grow")
  inst.AnimState:PushAnimation("idle", true)
  inst.Physics:SetCollides(true)
end

local function makeemptyfn(inst)
  if inst.components.hackable and inst.components.hackable.withered then
    inst.AnimState:PlayAnimation("dead_to_empty")
    inst.AnimState:PushAnimation("hacked_idle")
  else
    inst.AnimState:PlayAnimation("hacked_idle")
  end
  inst.Physics:SetCollides(false)

  inst.EvacuateAllChildren(inst)
end

local function makebarrenfn(inst)
  if inst.components.hackable and inst.components.hackable.withered then
    if not inst.components.hackable.hasbeenhacked then
      inst.AnimState:PlayAnimation("full_to_dead")
    else
      inst.AnimState:PlayAnimation("empty_to_dead")
    end
    inst.AnimState:PushAnimation("idle_dead")
  else
    inst.AnimState:PlayAnimation("idle_dead")
  end
  inst.Physics:SetCollides(true)

  inst.EvacuateAllChildren(inst)
end


local function onhackedfn(inst, hacker, hacksleft)
  local fx = SpawnPrefab("hacking_fx")
  local x, y, z= inst.Transform:GetWorldPosition()
  fx.Transform:SetPosition(x,y + math.random()*2,z)

  if(hacksleft <= 0) then

    inst.AnimState:PlayAnimation("disappear")

    if inst.components.hackable and inst.components.hackable:IsBarren() then
      inst.AnimState:PushAnimation("idle_dead")
      inst.Physics:SetCollides(true)
    else
      inst.Physics:SetCollides(false)
      inst.SoundEmitter:PlaySound("ia/common/vine_drop")
      inst.AnimState:PushAnimation("hacked_idle")
    end
  else
    inst.SoundEmitter:PlaySound("ia/common/vine_hack")
    inst.AnimState:PlayAnimation("chop")
    inst.AnimState:PushAnimation("idle")
  end

  spawnsnake(inst, hacker)
end

local function startspawning(inst)
  if inst.components.childspawner then
    local frozen = (inst.components.freezable and inst.components.freezable:IsFrozen())
    if not frozen and not TheWorld.state.isday then
      inst.components.childspawner:StartSpawning()
    end
  end
end

local function stopspawning(inst)
  if inst.components.childspawner then
    inst.components.childspawner:StopSpawning()
  end
end

onshake = function (inst)
  if inst.components.hackable and not inst.components.hackable.withered and not inst.components.hackable.hasbeenhacked and inst.components.hackable.hacksleft > 0 then

    inst.SoundEmitter:PlaySound("ia/creatures/snake/snake_bush")
    inst.AnimState:PlayAnimation("rustle_snake", false)
    inst.AnimState:PushAnimation("idle", true)

    startshaking(inst)
  end
end

local function onspawnsnake(inst)
  if inst:IsValid() and inst.components.hackable and inst.components.hackable.hacksleft > 0 then
    inst.SoundEmitter:PlaySound("ia/creatures/snake/snake_bush")
    inst.AnimState:PlayAnimation("rustle", false)
    inst.AnimState:PushAnimation("idle", true)
  end
end

local function SpawnDefenders(inst, target)
  if inst.components.childspawner.childreninside > 0 then
    for i=1,inst.components.childspawner.childreninside do
      local snake = spawnsnake(inst)
      if snake and snake.components.combat and target then
        snake.components.combat:SetTarget(target)
        snake.components.combat:BlankOutAttacks(1.5 + math.random() * 2)
      end
    end
  end
end

local function onwake(inst)
  startshaking(inst)
end

local function onsleep(inst)
  stopshaking(inst)
end

local function onremove(inst)
  stopshaking(inst)
end

local function onplayernear(inst, player)
  if inst.components.hackable and not inst.components.hackable.withered and not inst.components.hackable.hasbeenhacked and inst.components.hackable.hacksleft > 0 then
    stopshaking(inst)
    spawnsnake(inst, player)
  end
end

local function onplayerfar(inst)
  if inst.components.hackable and not inst.components.hackable.withered and not inst.components.hackable.hasbeenhacked and inst.components.hackable.hacksleft > 0 then
    startshaking(inst)
  end
end

local function inspect_vine(inst)
  if inst:HasTag("burnt") then
    return "BURNT"
  elseif inst:HasTag("stump") then
    return "CHOPPED"
  end
end

local function OnHaunt(inst)
  if math.random() <= TUNING.HAUNT_CHANCE_HALF then
    local target = FindEntity(
      inst,
      25,
      CanTarget,
      { "_combat", "_health", "character" }, --see entityreplica.lua
      { "player", "spider", "INLIMBO" }
    )
    if target ~= nil then
      SpawnDefenders(inst, target)
      inst.components.hauntable.hauntvalue = TUNING.HAUNT_MEDIUM
      return true
    end
  end

  return false
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  local minimap = inst.entity:AddMiniMapEntity()
  inst.entity:AddNetwork()

  MakeObstaclePhysics(inst, .35)

  minimap:SetIcon( "vinebush.tex" )

  inst.AnimState:SetBank("bush_vine")
  inst.AnimState:SetBuild("bush_vine")
  inst.AnimState:PlayAnimation("idle", true)
  inst.AnimState:SetTime(math.random()*2)
  local color = 0.75 + math.random() * 0.25
  inst.AnimState:SetMultColour(color, color, color, 1)

  inst:AddTag("vine")
	inst:AddTag("plant")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("hackable")
  inst.components.hackable:SetUp("vine", TUNING.VINE_REGROW_TIME)
  inst.components.hackable.onregenfn = onregenfn
  inst.components.hackable.onhackedfn = onhackedfn
  inst.components.hackable.makeemptyfn = makeemptyfn
  inst.components.hackable.makebarrenfn = makebarrenfn
  inst.components.hackable.max_cycles = 20
  inst.components.hackable.cycles_left = 20
  inst.components.hackable.ontransplantfn = ontransplantfn
  inst.components.hackable.hacksleft = TUNING.VINE_HACKS
  inst.components.hackable.maxhacks = TUNING.VINE_HACKS

  inst:AddComponent("lootdropper")
  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = inspect_vine

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.DIG)
  inst.components.workable:SetOnFinishCallback(dig_up)
  inst.components.workable:SetWorkLeft(1)

	MakeHackableBlowInWindGust(inst, TUNING.VINE_WINDBLOWN_SPEED, 0)

  MakeMediumBurnable(inst)
  inst.components.burnable:SetOnIgniteFn(function(inst)
      SpawnDefenders(inst)
      DefaultBurnFn(inst)
    end)
  MakeSmallPropagator(inst)

  inst:AddComponent("childspawner")
  inst.components.childspawner.childname = "snake"
  inst.components.childspawner:SetRegenPeriod(TUNING.SNAKEDEN_REGEN_TIME)
  inst.components.childspawner:SetSpawnPeriod(TUNING.SNAKEDEN_RELEASE_TIME)

  inst.components.childspawner:SetSpawnedFn(onspawnsnake)
  inst.components.childspawner:SetMaxChildren(TUNING.SNAKEDEN_MAX_SNAKES)
  --inst.components.childspawner:ScheduleNextSpawn(0)

  inst.EvacuateAllChildren = function(inst)
    SpawnDefenders(inst)

    for k, v in pairs(inst.components.childspawner.childrenoutside) do
      if v.components.knownlocations then
        c.components.knownlocations:ForgetLocation("home")
      end

      self.inst:RemoveEventCallback("ontrapped", self._onchildkilled, v)
      self.inst:RemoveEventCallback("death", self._onchildkilled, v)
      self.inst:RemoveEventCallback("detachchild", self._onchildkilled, v)
    end

    inst.components.childspawner.childrenoutside = {}
  end

  inst:AddComponent("playerprox")
  inst.components.playerprox:SetDist(TUNING.SNAKEDEN_TRAP_DIST, TUNING.SNAKEDEN_CHECK_DIST)
  inst.components.playerprox:SetOnPlayerNear(onplayernear)
  inst.components.playerprox:SetOnPlayerFar(onplayerfar)
  inst.components.playerprox.period = math.random()*0.16+0.32 -- mix it up a little

  inst:AddComponent("hauntable")
  inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_MEDIUM
  inst.components.hauntable:SetOnHauntFn(OnHaunt)

  inst.OnEntityWake = onwake
  inst.OnEntitySleep = onsleep
  inst.OnRemoveEntity = onremove

  inst:WatchWorldState("isdusk", function() 
      if inst.components.hackable and not inst.components.hackable.withered and not inst.components.hackable.hasbeenhacked and inst.components.hackable.hacksleft > 0 then
        startspawning(inst)
      end
    end)
  inst:WatchWorldState("isday", function()
      if inst.components.hackable and not inst.components.hackable.withered and not inst.components.hackable.hasbeenhacked and inst.components.hackable.hacksleft > 0 then
        stopspawning(inst) 
      end
    end)

  return inst
end


return Prefab("snakeden", fn, assets, prefabs)
%%+%%scripts/prefabs/snakeoil.lua%%-%%local assets=
{
  Asset("ANIM", "anim/snakeoil.zip"),
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("snakeoil")
  inst.AnimState:SetBuild("snakeoil")
  inst.AnimState:PlayAnimation("idle")
  
  -- for all-time quaffing
  inst:AddTag("poison_vaccine")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.HEAVY, TUNING.WINDBLOWN_SCALE_MAX.HEAVY)

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("fuel")
  inst.components.fuel.fuelvalue = 0

  inst:AddComponent("poisonhealer")
  inst.components.poisonhealer.enabled = false

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "snakeoil", fn, assets)%%+%%scripts/prefabs/snakeskin.lua%%-%%local assets=
{
  Asset("ANIM", "anim/snakeskin.zip"),
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("snakeskin")
  inst.AnimState:SetBuild("snakeskin")
  inst.AnimState:PlayAnimation("idle")

  MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

  inst:AddComponent("stackable")
  inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM


  MakeSmallBurnable(inst, TUNING.MED_BURNTIME)
  MakeSmallPropagator(inst)

  ---------------------       

  inst:AddComponent("inspectable")

  MakeInvItemIA(inst)

  inst:AddComponent("appeasement")
  inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_TINY

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "snakeskin", fn, assets) 

%%+%%scripts/prefabs/solofish.lua%%-%%local assets =
{
  Asset("ANIM", "anim/fish_dogfish.zip"),
}

local prefabs =
{
  "solofish_dead"
}

local brain = require "brains/solofishbrain"

local function SetLocoState(inst, state)
  --"above" or "below"
  inst.LocoState = string.lower(state)
end

local function IsLocoState(inst, state)
  return inst.LocoState == string.lower(state)
end

local function solofishfn()

  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeCharacterPhysics(inst, 1, 0.5)
  inst.Physics:ClearCollisionMask()
  inst.Physics:CollidesWith(COLLISION.WORLD)
  inst.entity:AddSoundEmitter()

  inst:AddTag("aquatic")

  inst.AnimState:SetBank("dogfish")
  inst.AnimState:SetBuild("fish_dogfish")
  inst.AnimState:PlayAnimation("shadow", true)
  inst.AnimState:SetRayTestOnBB(true)
  inst.AnimState:SetOrientation( ANIM_ORIENTATION.OnGround )

  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.SOLOFISH_WALK_SPEED
  inst.components.locomotor.runspeed = TUNING.SOLOFISH_RUN_SPEED

  inst:AddComponent("inspectable")
  inst.no_wet_prefix = true

  inst:AddComponent("knownlocations")

  inst:AddComponent("combat")
  --inst.components.combat.hiteffectsymbol = "chest"
  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.SOLOFISH_HEALTH)

  inst:AddComponent("eater")
  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"solofish_dead"})

  inst:AddComponent("sleeper")
  inst.components.sleeper.onlysleepsfromitems = true 
  MakeMediumFreezableCharacter(inst, "dogfish_body")

  SetLocoState(inst, "below")
  inst.SetLocoState = SetLocoState
  inst.IsLocoState = IsLocoState

  inst:SetStateGraph("SGsolofish")

  inst:SetBrain(brain)

  return inst
end

return Prefab( "solofish", solofishfn, assets, prefabs)
%%+%%scripts/prefabs/spearlauncher.lua%%-%%local assets =
{
	Asset("ANIM", "anim/speargun.zip"),
	Asset("ANIM", "anim/speargun_empty.zip"),

	Asset("ANIM", "anim/swap_speargun_empty.zip"),
	Asset("ANIM", "anim/swap_speargun_spear.zip"),
	Asset("ANIM", "anim/swap_speargun_obsidian.zip"),
	Asset("ANIM", "anim/swap_speargun_poison.zip"),
	Asset("ANIM", "anim/swap_speargun_wathgrithr.zip"),
}

local prefabs =
{
	"spear_projectile"
}

local _spears = {
	spear = "spear",
	spear_wathgrithr = "wathgrithr",
	spear_poison = "poison",
	spear_obsidian = "obsidian",
}

local function OnEquip(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", inst.override_bank, "swap_speargun")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function OnUnequip(inst, owner)
	owner.AnimState:ClearOverrideSymbol("swap_object")
	owner.AnimState:Hide("ARM_carry")
	owner.AnimState:Show("ARM_normal")
end

local function OnAttack(inst, attacker, target)
	local spear = inst.components.inventory:GetItemInSlot(1)
	if spear then
		local old = spear.components.weapon.attackwear
		spear.components.weapon.attackwear = TUNING.SPEAR_LAUNCHER_SPEAR_WEAR
		spear.components.weapon:OnAttack(attacker, target, true)
		spear.components.weapon.attackwear = old
		inst.components.inventory:DropItem(spear, true, false, target:GetPosition())
		local pos = spear:GetPosition()
		local vel = (pos - target:GetPosition()):Normalize()
		spear.Transform:SetPosition(pos.x + vel.x, pos.y, pos.z + vel.z) --move the position a bit so it doesn't clip through the player 
		spear.Physics:SetVel(vel.x * 4, 5, vel.z * 4)
	end
end

local function CanTakeAmmo(inst, ammo, giver)
	return _spears[ammo.prefab] ~= nil
end

local function OnTakeAmmo(inst, data)
	local ammo = data and data.item
	if not ammo then return end
	
	local ammotype = _spears[ammo.prefab] or "spear"

	inst.SoundEmitter:PlaySound("ia/common/speargun_load")

	inst.components.trader.enabled = false
	--Set up as projectile thrower instead of crummy bat
	inst:AddTag("speargun")
	inst:AddTag("projectile")
	inst.components.weapon:SetProjectile("spear_projectile")
	--Change ranges
	inst.components.weapon:SetRange(TUNING.SPEAR_LAUNCHER_ATTACK_RANGE, TUNING.SPEAR_LAUNCHER_HIT_RANGE)
	local damage = ammo.components.weapon.damage * TUNING.SPEAR_LAUNCHER_DAMAGE_MOD
	inst.components.weapon:SetDamage(damage)

	--Change equip overrides
	inst.override_bank = "swap_speargun_".. ammotype

	--If equipped, change current equip overrides
	if inst.components.equippable and inst.components.equippable:IsEquipped() then
		local owner = inst.components.inventoryitem.owner
		owner.AnimState:OverrideSymbol("swap_object", inst.override_bank, "swap_speargun")
	end
	
	--Change invo image.
	inst.components.inventoryitem:ChangeImageName("spear_launcher_".. ammotype)
end

local function OnLoseAmmo(inst, data)
	inst.components.trader.enabled = true
	--Go back to crummy bat mode
	inst:RemoveTag("speargun")
	inst:RemoveTag("projectile")
	inst.components.weapon:SetProjectile(nil)
	--Change ranges back to melee
	inst.components.weapon:SetRange(nil, nil)
	inst.components.weapon:SetDamage(TUNING.UNARMED_DAMAGE)

	--Change equip overrides
	inst.override_bank = "swap_speargun_empty"

	--If equipped, change current equip overrides
	if inst.components.equippable and inst.components.equippable:IsEquipped() then
		local owner = inst.components.inventoryitem.owner
		owner.AnimState:OverrideSymbol("swap_object", inst.override_bank, "swap_speargun")
	end

	inst.components.inventoryitem:ChangeImageName(nil)
end

local function OnDropped(inst)
	inst.components.inventory:DropEverything()
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()
	inst.entity:AddSoundEmitter()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("speargun")
	inst.AnimState:SetBuild("speargun_empty")
	inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
	inst:AddComponent("inspectable")

	inst:AddComponent("weapon")
	inst.components.weapon.onattack = OnAttack

	MakeInvItemIA(inst)
	inst.components.inventoryitem:SetOnDroppedFn(OnDropped)

	inst:AddComponent("inventory")
	inst.components.inventory.maxslots = 1
	inst:ListenForEvent("dropitem", OnLoseAmmo)
	inst:ListenForEvent("itemget", OnTakeAmmo)

	inst:AddComponent("trader")
	inst.components.trader.deleteitemonaccept = false
	inst.components.trader:SetAcceptTest(CanTakeAmmo)
	inst.components.trader.enabled = true
    inst.components.trader.acceptnontradable = true

	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.SPEAR_LAUNCHER_USES)
	inst.components.finiteuses:SetUses(TUNING.SPEAR_LAUNCHER_USES)
	inst.components.finiteuses:SetOnFinished(inst.Remove)

	inst.override_bank = "swap_speargun_empty"
	
	inst:AddComponent("equippable")
	inst.components.equippable:SetOnEquip(OnEquip)
	inst.components.equippable:SetOnUnequip(OnUnequip)

	return inst
end

local function OnHit(inst, attacker, target, weapon)
	local impactfx = SpawnPrefab("impact")
	if impactfx and attacker then
		local follower = impactfx.entity:AddFollower()
		follower:FollowSymbol(target.GUID, target.components.combat.hiteffectsymbol, 0, 0, 0)
		impactfx:FacePoint(attacker.Transform:GetWorldPosition())
	end
	inst:Remove()
end

local function OnThrown(inst, owner, target)
	inst.AnimState:SetOrientation( ANIM_ORIENTATION.OnGround)
	inst:ForceFacePoint(target:GetPosition():Get())

	--Change projectile art to match spear type.
	local spear = owner.components.inventory:GetItemInSlot(1)
	if spear then
		inst.AnimState:PlayAnimation("spear_".. ( _spears[spear.prefab] or "spear") )
	end
end

local function projectile_fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("speargun")
	inst.AnimState:SetBuild("speargun_empty")
	inst.AnimState:PlayAnimation("spear_spear")

	inst:AddTag("projectile")
	inst:AddTag("sharp")
	
	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("projectile")
	inst.components.projectile:SetSpeed(60)
	inst.components.projectile:SetOnHitFn(OnHit)
	inst.components.projectile.onthrown = OnThrown

	inst.persists = false

	return inst
end

return Prefab("spear_launcher", fn, assets, prefabs),
Prefab("spear_projectile", projectile_fn, assets)%%+%%scripts/prefabs/stungray.lua%%-%%local brain = require "brains/stungraybrain"

local assets = {
	Asset("ANIM", "anim/stinkray.zip"),
}

local prefabs = {
	"venomgland",
	"poisonbubble_short",
	"monstermeat",
	"splash_water",
}

local SLEEP_DIST_FROMHOME = 1
local SLEEP_DIST_FROMTHREAT = 20
local MAX_CHASEAWAY_DIST = 80
local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 30


local function KeepThreat(inst, threat)
	return IsOnWater(threat)
end

local function MakeTeam(inst, attacker)
	local leader = SpawnPrefab("teamleader")
	leader:AddTag("stungray")
	leader.components.teamleader.threat = attacker
	leader.components.teamleader.team_type = inst.components.teamattacker.team_type
	leader.components.teamleader:NewTeammate(inst)
	leader.components.teamleader:BroadcastDistress(inst)
	leader.components.teamleader:SetKeepThreatFn(KeepThreat)
end

local function Retarget(inst)
	local ta = inst.components.teamattacker
	local notags = {"FX", "NOCLICK","INLIMBO", "stungray"}
	local yestags = {"monster", "character"}

	local newtarget = FindEntity(inst, TUNING.STINKRAY_TARGET_DIST, function(guy)
			return (guy:HasTag("character") or guy:HasTag("monster"))
				   and not guy:HasTag("stungray")
				   and inst.components.combat:CanTarget(guy)
				   and IsOnWater(guy)
	end, nil, notags, yestags)

	if newtarget and not ta.inteam and not ta:SearchForTeam() then
		MakeTeam(inst, newtarget)
	end

	if ta.inteam and not ta.teamleader:CanAttack() then
		return newtarget
	end
end

local function KeepTarget(inst, target)
	if not IsOnWater(target) then return false end

	if (inst.components.teamattacker.teamleader and not inst.components.teamattacker.teamleader:CanAttack()) or inst.components.teamattacker.orders == "ATTACK" then
		return true
	else
		return false
	end
end

local function OnAttacked(inst, data)
	if not inst.components.teamattacker.inteam and not inst.components.teamattacker:SearchForTeam() then
		MakeTeam(inst, data.attacker)
	elseif inst.components.teamattacker.teamleader then
		inst.components.teamattacker.teamleader:BroadcastDistress()   --Ask for  help!
	end

	if inst.components.teamattacker.inteam and not inst.components.teamattacker.teamleader:CanAttack() then
		local attacker = data and data.attacker
		inst.components.combat:SetTarget(attacker)
		inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("stungray") end, MAX_TARGET_SHARES)
	end
end

local function OnCombatTarget(inst, data)
	--If you're in a team or have a combat target then run.
	if (data and data.target) or inst.components.teamattacker.inteam then
		inst.components.locomotor:SetShouldRun(true)
	else
		inst.components.locomotor:SetShouldRun(false)
	end
end

local function OnHitOther(inst, other, damage, stimuli)
	SpawnPrefab("poisonbubble_short").Transform:SetPosition(inst.Transform:GetWorldPosition())
	inst.components.areapoisoner:DoPoison(true)
end

local function SetLocoState(inst, state)
	--"gotofly" or "gotoswim"
	inst.LocoState = string.lower(state)
end

local function IsLocoState(inst, state)
	return inst.LocoState == string.lower(state)
end

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddDynamicShadow()
    inst.entity:AddNetwork()
  
	inst.DynamicShadow:SetSize(1.75, .6)
	inst.DynamicShadow:Enable(false)

	inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
	inst.Transform:SetNoFaced()

	inst.scale_flying = TUNING.STINKRAY_SCALE_FLYING
	inst.scale_water = TUNING.STINKRAY_SCALE_WATER
	inst.Transform:SetScale(inst.scale_water, inst.scale_water, inst.scale_water)

	MakeGhostPhysics(inst, 1, .5)

	inst.AnimState:SetBank("stinkray")
	inst.AnimState:SetBuild("stinkray")
  
	inst:AddTag("aquatic")
	inst:AddTag("monster")
	inst:AddTag("hostile")
	inst:AddTag("stungray")
	inst:AddTag("scarytoprey")
	inst:AddTag("flying")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("locomotor")
	inst.components.locomotor:SetSlowMultiplier( 1 )
	inst.components.locomotor:SetTriggersCreep(false)
	inst.components.locomotor.pathcaps = {ignorecreep = true}
	inst.components.locomotor.walkspeed = TUNING.STINKRAY_WALK_SPEED

	inst:AddComponent("eater")
	inst.components.eater:SetCarnivore()
	inst.components.eater.strongstomach = true

	inst:AddComponent("sleeper")
	inst.components.sleeper:SetResistance(2)
	inst.components.sleeper:SetNocturnal(true)
	inst.components.sleeper.onlysleepsfromitems = true

	inst:AddComponent("combat")
	inst.components.combat.hiteffectsymbol = "bat_body"
	inst.components.combat:SetAttackPeriod(TUNING.STINKRAY_ATTACK_PERIOD)
	inst.components.combat:SetRange(TUNING.STINKRAY_ATTACK_DIST)
	inst.components.combat:SetRetargetFunction(3, Retarget)
	inst.components.combat:SetKeepTargetFunction(KeepTarget)
	inst.components.combat.poisonous = true
	inst.components.combat.gasattack = true 
	inst.components.combat.onhitotherfn = OnHitOther
	inst.components.combat:SetDefaultDamage(0)

	MakeAreaPoisoner(inst, 3)

	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.STINKRAY_HEALTH)

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:AddRandomLoot("venomgland", 1)   
	inst.components.lootdropper:AddRandomLoot("monstermeat", 2)
	inst.components.lootdropper.numrandomloot = 1

	MakeInvItemIA(inst)
	inst.components.inventoryitem.canbepickedup = false
	
	inst:AddComponent("inspectable")
	inst:AddComponent("knownlocations")

	inst:DoTaskInTime(1*FRAMES, function() inst.components.knownlocations:RememberLocation("home", inst:GetPosition(), true) end)

	MakeMediumBurnableCharacter(inst, "ray_face")
	MakeMediumFreezableCharacter(inst, "ray_face")

	inst:AddComponent("teamattacker")
	inst.components.teamattacker.team_type = "stungray"
	inst.components.teamattacker.run = true

	inst:ListenForEvent("attacked", OnAttacked)
	inst:ListenForEvent("newcombattarget", OnCombatTarget)
	inst:ListenForEvent("losttarget", OnCombatTarget)

	SetLocoState(inst, "swim")
	inst.SetLocoState = SetLocoState
	inst.IsLocoState = IsLocoState

	inst:SetStateGraph("SGstungray")
	inst:SetBrain(brain)

	return inst
end

return Prefab("stungray", fn, assets, prefabs)
%%+%%scripts/prefabs/stungray_spawner.lua%%-%%local prefabs = {
    "stungray"
}

local function onsave(inst, data)
    data.start_day = inst.start_day
end

local function teststartspawning(inst)
    if inst.start_day then
        if TheWorld.state.cycles >= inst.start_day then
            inst.components.childspawner:StartSpawning()
            inst.start_day = nil
            inst.MiniMapEntity:SetEnabled(true)
        end
    end
end


local function onload(inst, data)
    if data and data.start_day then
        inst.start_day = data.start_day
        teststartspawning(inst)
    end
end

local function longupdate(inst, dt)
    teststartspawning(inst)
end

local function onwake(inst)
    teststartspawning(inst)
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetIcon("stinkray.tex")
    inst.MiniMapEntity:SetEnabled(false)

    inst:AddTag("NOCLICK")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent( "childspawner" )
    inst.components.childspawner:SetRegenPeriod(60)
    inst.components.childspawner:SetSpawnPeriod(.1)
    inst.components.childspawner:SetMaxChildren(6)
    inst.components.childspawner.childname = "stungray"

    inst.start_day = 5 + math.random() * 5

    inst.OnLongUpdate = longupdate
    inst.OnSave = onsave
    inst.OnLoad = onload
    inst.OnEntityWake = onwake

    return inst
end

return Prefab("stungray_spawner", fn, nil, prefabs) 
%%+%%scripts/prefabs/sunkenprefab.lua%%-%%local assets =
{
  Asset("ANIM", "anim/bubbles_sunk.zip"),
}

local function ontimerdone(inst, data)
  if data.name == "destroy" then
    inst:Remove()
  end
end

local function dobubblefx(inst)
  inst.AnimState:PlayAnimation("bubble_pre")
  inst.AnimState:PushAnimation("bubble_loop")
  inst.AnimState:PushAnimation("bubble_pst", false)
  inst:DoTaskInTime((math.random() * 15 + 15), dobubblefx)
end

local function init(inst, prefab)
  if not prefab then inst:Remove() end

  local pos = prefab:GetPosition()
  inst.Transform:SetPosition(pos:Get())
  if not prefab:HasTag("irreplaceable") then
	inst.components.timer:StartTimer("destroy", TUNING.SUNKENPREFAB_REMOVE_TIME)
  end
  inst.components.sunkenprefabinfo:SetPrefab(prefab)
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("bubbles_sunk")
  inst.AnimState:SetBuild("bubbles_sunk")
  
  inst:AddTag("FX")
  inst:AddTag("NOCLICK")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("sunkenprefabinfo")

  inst:AddComponent("timer")
  inst:ListenForEvent("timerdone", ontimerdone)

  inst:DoTaskInTime((math.random() * 15 + 12), dobubblefx)

  inst:AddTag("sunkenprefab")

  inst.Initialize = init

  return inst
end

return Prefab("sunkenprefab", fn, assets)%%+%%scripts/prefabs/sweet_potato.lua%%-%%local assets=
{
  Asset("ANIM", "anim/sweet_potato.zip"),
  --Asset("ANIM", "anim/sweetpotatoe.zip"),
}

local prefabs=
{
  "sweet_potato",
}

local function onpickedfn(inst)
  TheWorld:PushEvent("beginregrowth", inst)
  inst:Remove()
end


local function fn()
  --Carrot you eat is defined in veggies.lua
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.AnimState:SetBank("sweet_potato")
  inst.AnimState:SetBuild("sweet_potato")
  inst.AnimState:PlayAnimation("planted")
  inst.AnimState:SetRayTestOnBB(true);

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")

  inst:AddComponent("pickable")
  inst.components.pickable.picksound = "dontstarve/wilson/pickup_plants"
  inst.components.pickable:SetUp("sweet_potato", 10)
  inst.components.pickable.onpickedfn = onpickedfn

  inst.components.pickable.quickpick = true

  MakeSmallBurnable(inst)
  MakeSmallPropagator(inst)

  inst:AddComponent("hauntable")
  inst.components.hauntable:SetHauntValue(TUNING.HAUNT_TINY)

  return inst
end

return Prefab( "sweet_potato_planted", fn, assets) 
%%+%%scripts/prefabs/swordfish.lua%%-%%local assets =
{
  Asset("ANIM", "anim/fish_dogfish.zip"),
  Asset("ANIM", "anim/fish_swordfish01.zip"),
  Asset("ANIM", "anim/fish_med01.zip"),
}

local invassets=
{
  Asset("ANIM", "anim/fish_swordfish.zip"),
}

local prefabs =
{
  "swordfish_dead"
}


local brain = require "brains/swordfishbrain"


local function retargetfn(inst)
  local dist = TUNING.SWORDFISH_TARGET_DIST
  local notags = {"FX", "NOCLICK","INLIMBO", "swordfish"}
  local yestags = {"aquatic"}
  return FindEntity(inst, dist, function(guy) 
      local shouldtarget =  inst.components.combat:CanTarget(guy)
      return shouldtarget
    end, yestags, notags)
end

local function KeepTarget(inst, target)
  local shouldkeep = inst.components.combat:CanTarget(target)
  local onwater = target:HasTag("aquatic")
  -- local onboat = target.components.sailor and target.components.sailor:IsSailing()
  return shouldkeep and onwater
end

local function SetLocoState(inst, state)
  --"above" or "below"
  inst.LocoState = string.lower(state)
end

local function IsLocoState(inst, state)
  return inst.LocoState == string.lower(state)
end

local function swordfishfn()

  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddNetwork()
  --trans:SetFourFaced()
  inst.entity:AddSoundEmitter()
  inst.entity:AddAnimState()

  MakeCharacterPhysics(inst, 5, 1.25)
  inst.Physics:ClearCollisionMask()
  inst.Physics:CollidesWith(COLLISION.WORLD)

  inst:AddTag("aquatic")
  inst:AddTag("swordfish")
  inst:AddTag("scarytoprey")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("locomotor")
  inst.components.locomotor.walkspeed = TUNING.SWORDFISH_WALK_SPEED
  inst.components.locomotor.runspeed = TUNING.SWORDFISH_RUN_SPEED


  inst.AnimState:SetBank("swordfish")
  inst.AnimState:SetBuild("fish_swordfish")  
  inst.AnimState:PlayAnimation("shadow", true)
  inst.AnimState:SetRayTestOnBB(true)
  inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)

  inst.AnimState:SetLayer(LAYER_BACKGROUND)
  inst.AnimState:SetSortOrder(3)

  inst:AddComponent("inspectable")
  inst.no_wet_prefix = true

  inst:AddComponent("knownlocations")

  inst:AddComponent("combat")
  inst.components.combat:SetDefaultDamage(TUNING.SWORDFISH_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.SWORDFISH_ATTACK_PERIOD)
  inst.components.combat:SetRetargetFunction(3, retargetfn)
  inst.components.combat:SetKeepTargetFunction(KeepTarget)
  --inst.components.combat.hiteffectsymbol = "chest"
  inst:AddComponent("health")
  inst.components.health:SetMaxHealth(TUNING.SWORDFISH_HEALTH)

  inst:AddComponent("eater")
  inst:AddComponent("lootdropper")
  inst.components.lootdropper:SetLoot({"swordfish_dead"})

  inst:AddComponent("sleeper")
  inst.components.sleeper.onlysleepsfromitems = true 
  MakeMediumFreezableCharacter(inst, "swordfish_body")

  SetLocoState(inst, "below")
  inst.SetLocoState = SetLocoState
  inst.IsLocoState = IsLocoState

  inst:SetStateGraph("SGswordfish")

  inst:SetBrain(brain)

  return inst
end

return Prefab("swordfish", swordfishfn, assets, prefabs)
%%+%%scripts/prefabs/swordfish_spawner.lua%%-%%local assets = {
}

local prefabs = 
{
  "swordfish",
}

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddNetwork()

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent( "childspawner" )
  inst.components.childspawner:SetRegenPeriod(60)
  inst.components.childspawner:SetSpawnPeriod(55)
  inst.components.childspawner:SetMaxChildren(1)
  inst.components.childspawner.childname = "swordfish"
  inst.components.childspawner.spawnoffscreen = true

  inst.components.childspawner:StartSpawning()

  return inst
end

return Prefab( "swordfish_spawner", fn, assets, prefabs) %%+%%scripts/prefabs/tar.lua%%-%%local itemassets =
{
	Asset("ANIM", "anim/tar.zip"),
}
local assets =
{
	Asset("ANIM", "anim/tar_trap.zip"),
}

local itemprefabs=
{
	"tar_trap",
}

local function onRemove(inst)
	for i,slowedinst in pairs( inst.slowed_objects ) do
		i.slowing_objects[inst] = nil      
	end
end

local function updateslowdowners(inst)

	local x,y,z = inst.Transform:GetWorldPosition() 
	local slowdowns = TheSim:FindEntities(x,y,z, 1.5, {"locomotor"})
	local tempSlowedObjects = {}

	for i=#slowdowns,1,-1 do
		if not slowdowns[i].sg or not slowdowns[i].sg:HasStateTag("moving") then
			table.remove(slowdowns,i)
		end            
	end

	if #slowdowns > 0 then
		if not next(inst.slowed_objects) then
			inst.components.fueled:StartConsuming()
		end
	elseif next(inst.slowed_objects) then
		inst.components.fueled:StopConsuming()
	end

	for i,slowinst in ipairs(slowdowns)do
		if not slowinst.slowing_objects then
			slowinst.slowing_objects  = {}
		end

		slowinst.slowing_objects[inst] = true                    

		tempSlowedObjects[slowinst] = true
	end

	for i,slowedinst in pairs( inst.slowed_objects ) do
		if not tempSlowedObjects[i] then
			i.slowing_objects[inst] = nil
		end       
	end

	inst.slowed_objects = tempSlowedObjects

	--I increased the delay from 2 to 5 frames, because muh performance. -M
	inst:DoTaskInTime(5/30, updateslowdowners)
end

local function updateAnim(inst,section)
	if section == 1 then
		inst.AnimState:PlayAnimation("idle_25")
	elseif section == 2 then
		inst.AnimState:PlayAnimation("idle_50")
	elseif section == 3 then
		inst.AnimState:PlayAnimation("idle_75")                
	elseif section == 4 then
		inst.AnimState:PlayAnimation("idle_full")                
	end
end

local function ontakefuelfn(inst)
	-- inst.SoundEmitter:PlaySound("dontstarve_DLC001/common/machine_fuel")
	updateAnim(inst,inst.components.fueled:GetCurrentSection())
end

local function sectionfn(section, oldsection, inst)
	if section == 0 then
		--when we burn out
		if inst.components.burnable then
			inst.components.burnable:Extinguish()
		end
	else
		updateAnim(inst, section)
	end
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()
	
	MakeInventoryPhysics(inst)

	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )
   
	inst.AnimState:SetBank("tar_trap")
	inst.AnimState:SetBuild("tar_trap")

	inst.AnimState:PlayAnimation("idle_full")
	
	-- inst:AddTag("tar_trap") --unused
	-- inst:AddTag("locomotor_slowdown") --unused

	inst.slowed_objects = {}
	inst:DoTaskInTime(1/30, updateslowdowners)

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")

	MakeLargeBurnable(inst, TUNING.SMALL_BURNTIME)
	MakeLargePropagator(inst)

	inst.slowdowners = {}

	inst:AddComponent("fueled")
	inst.components.fueled.fueltype = FUELTYPE.TAR
	inst.components.fueled.accepting = true
	inst.components.fueled.ontakefuelfn = ontakefuelfn
	inst.components.fueled:SetSections(4)
	inst.components.fueled:InitializeFuelLevel(TUNING.TAR_TRAP_TIME/2)
	inst.components.fueled:SetDepletedFn(inst.Remove)
	inst.components.fueled:SetSectionCallback(sectionfn)

	inst.OnRemoveEntity = onRemove

	return inst
end


local function quantizepos(pt)
	local x, y, z = TheWorld.Map:GetTileCenterPoint(pt:Get())

	if pt.x > x then
		x = x + 1
	else
		x = x - 1
	end

	if pt.z > z then
		z = z + 1
	else
		z = z - 1
	end

	return Vector3(x,y,z)
end

local function quantizeplacer(inst)
	inst.Transform:SetPosition(quantizepos(inst:GetPosition()):Get())
end

local function oncannotbuild(inst)
	inst:Hide()
	for i, v in ipairs(inst.components.placer.linked) do
		v:Hide()
	end
end

local function placerpostinitfn(inst)
	inst.components.placer.onupdatetransform = quantizeplacer
	inst.components.placer.oncannotbuild = oncannotbuild
end

local function ondeploy(inst, pt, deployer)
	--[[
	local ents = TheSim:FindEntities(pt.x,pt.y,pt.z, 0.2, {"tar_trap"}) -- or we could include a flag to the search?
	for i, ent in ipairs(ents) do
		ent:Remove()
	end
	]]
	local wall = SpawnPrefab("tar_trap") 

	if wall then
		pt = quantizepos(pt)
		wall.AnimState:PlayAnimation("place")
		wall.AnimState:PushAnimation("idle_full")
		wall.Physics:Teleport(pt.x, pt.y, pt.z)

		inst.components.stackable:Get():Remove()

		wall.SoundEmitter:PlaySound("dontstarve/common/poop_splat")
	end
end

local function itemfn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()
	MakeInventoryPhysics(inst)
	
	inst.AnimState:SetBank("tar")
	inst.AnimState:SetBuild("tar")

	inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)

	MakeInvItemIA(inst)
	
	inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_SMALLITEM

	inst:AddComponent("tradable")

	inst:AddComponent("inspectable")

	inst:AddComponent("fuel")
	inst.components.fuel.fuelvalue = TUNING.LARGE_FUEL
	inst.components.fuel.secondaryfueltype = FUELTYPE.TAR
	
	MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
	MakeSmallPropagator(inst)

	inst:AddComponent("deployable")
	inst.components.deployable.ondeploy = ondeploy
	inst.components.deployable:SetDeploySpacing(0)
	-- inst.components.deployable:SetDeployMode(DEPLOYMODE.WALL)
	-- inst.components.deployable.deploydistance = 2

	return inst
end

return Prefab( "tar", itemfn, itemassets, itemprefabs),
	Prefab("tar_trap", fn, assets),
	MakePlacer("tar_placer",  "tar_trap", "tar_trap", "idle_full", false, false, false, 1, nil, nil, placerpostinitfn)
%%+%%scripts/prefabs/tarlamp.lua%%-%%local MakeVisualBoatEquip = require("prefabs/visualboatequip")

local assets =
{
	Asset("ANIM", "anim/tarlamp.zip"),
	Asset("ANIM", "anim/swap_tarlamp.zip"),
	Asset("ANIM", "anim/swap_tarlamp_boat.zip"),
}

local prefabs =
{
	-- "tarlampfire",
}

--Note: The tarlamp combines "lantern", "torch" and "boat_lantern" in one prefab. Good luck reading the code!

local function toggleon(inst)
    inst.components.machine:TurnOn()
end

local function toggleoff(inst)
    inst.components.machine:TurnOff()
end

local function DoTurnOffSound(inst, owner)
	inst._soundtask = nil
	(owner ~= nil and owner:IsValid() and owner.SoundEmitter or inst.SoundEmitter):PlaySound("dontstarve/wilson/lighter_off")
end

local function PlayTurnOffSound(inst)
	if inst._soundtask == nil and inst:GetTimeAlive() > 0 then
		inst._soundtask = inst:DoTaskInTime(0, DoTurnOffSound, inst.components.inventoryitem.owner)
	end
end

local function PlayTurnOnSound(inst)
	if inst._soundtask ~= nil then
		inst._soundtask:Cancel()
		inst._soundtask = nil
	elseif not POPULATING then
		inst._light.SoundEmitter:PlaySound("dontstarve/wilson/lighter_on")
	end
end

local function stoptrackingowner(inst)
	if inst._owner ~= nil then
		inst:RemoveEventCallback("equip", inst._onownerequip, inst._owner)
		inst._owner = nil
	end
end

local function starttrackingowner(inst, owner)
	if owner ~= inst._owner then
		stoptrackingowner(inst)
        inst._owner = owner
		if owner ~= nil and owner.components.inventory ~= nil then
			inst:ListenForEvent("equip", inst._onownerequip, owner)
		end
	end
end

local function setswapsymbol(inst, symbol)
	if inst._owner ~= nil then
		if inst.visual then
			inst.visual.AnimState:OverrideSymbol("swap_lantern", "swap_tarlamp_boat", symbol)
		else
			inst._owner.AnimState:OverrideSymbol("swap_object", "swap_tarlamp", symbol)
		end
	end
end

local function turnoff(inst)
	inst.components.fueled:StopConsuming()
	inst.components.burnable:Extinguish()
	
	if inst._light ~= nil then
		if inst._light:IsValid() then
            inst._light:Remove()
        end
        inst._light = nil
		PlayTurnOffSound(inst)
	end
	
	if inst.components.equippable:IsEquipped() then
		setswapsymbol(inst, "swap_lantern_off")
	else       
		if inst:GetIsOnWater() then
			inst.AnimState:PlayAnimation("idle_off_water")
		else
			inst.AnimState:PlayAnimation("idle_off")
		end
	end
end

local function turnon(inst)
    if not inst.components.fueled:IsEmpty() then

        inst.components.fueled:StartConsuming()
        inst.components.burnable:Ignite()

        if inst._light == nil then
            inst._light = SpawnPrefab("tarlamplight")
            PlayTurnOnSound(inst)
        end
        local owner = inst.components.inventoryitem.owner

        inst._light.entity:SetParent((owner or inst).entity)

        if inst.components.equippable:IsEquipped() then
            setswapsymbol(inst, "swap_lantern")      
        else
            if inst:GetIsOnWater() then
                inst.AnimState:PlayAnimation("idle_on_water")
            else
                inst.AnimState:PlayAnimation("idle_on")
            end
        end
    end
end

local function onequip(inst, owner)
    if owner and owner.sg and owner.sg:HasStateTag("rowing") then return end
    starttrackingowner(inst, owner)
    
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:SpawnBoatEquipVisuals(inst, "tarlamp")
    else
        owner.AnimState:Show("ARM_carry")
        owner.AnimState:Hide("ARM_normal")
    end
    setswapsymbol(inst, "swap_lantern_off")

    if inst.wason then
        inst.components.equippable:ToggleOn()
    end
end

local function onunequip(inst, owner)
    stoptrackingowner(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:RemoveBoatEquipVisuals(inst)
    else
        owner.AnimState:Hide("ARM_carry")
        owner.AnimState:Show("ARM_normal")
    end
    
    inst.wason = inst.components.fueled.consuming
    inst.components.equippable:ToggleOff()
end

--------------------------------------------------------------------------

local function onfueledupdate(inst)
    local owner = inst.components.inventoryitem ~= nil and inst.components.inventoryitem.owner or nil
    local rate = 1
    if TheWorld.state.israining and not 
    (owner and owner.components.sheltered and
    owner.components.sheltered.sheltered) then
        rate = rate + TUNING.TORCH_RAIN_RATE * TheWorld.state.precipitationrate
    end
    --rate = rate + TUNING.TORCH_WIND_RATE * TheWorld.state.hurricanewindspeed
    inst.components.fueled.rate = rate
end

local function depleted(inst)
    if not inst._owner then
        SpawnPrefab("ash").Transform:SetPosition(inst:GetPosition():Get())        
    end
end

local function ondropped(inst)
   inst.components.equippable:ToggleOff()
   inst.components.equippable:ToggleOn()
end

local function onpickup(inst)
    inst.components.equippable:ToggleOff()
end

local function OnLoad(inst,data)
    if not data then
        return
    end
    inst.wason = data.wason
end

local function OnSave(inst,data)
    data.wason = inst.wason
end

--------------------------------------------------------------------------

local function nofuel(inst)
    depleted(inst)
	turnoff(inst)
	inst:Remove()
end

local function caninteractfn()
    return not inst.components.fueled:IsEmpty() and inst.components.inventoryitem.owner == nil
end

local function onattack(weapon, attacker, target)
	--target may be killed or removed in combat damage phase
	if target ~= nil and target:IsValid()
	and weapon.components.burnable.burning
	and target.components.burnable ~= nil
	and math.random() < TUNING.LIGHTER_ATTACK_IGNITE_PERCENT * target.components.burnable.flammability then
		target.components.burnable:Ignite(nil, attacker)
	end
end

local function OnRemove(inst)
    if inst._light ~= nil then
        if inst._light:IsValid() then
            inst._light:Remove()
        end
        inst._light = nil
    end
    if inst._soundtask ~= nil then
        inst._soundtask:Cancel()
        inst._soundtask = nil
    end
end

--------------------------------------------------------------------------

local function OnLightWake(inst)
	if not inst.SoundEmitter:PlayingSound("loop") then
		inst.SoundEmitter:PlaySound("dontstarve/wilson/torch_LP", "loop")
		inst.SoundEmitter:SetParameter("loop", "intensity", 1)
	end
end

local function OnLightSleep(inst)
	inst.SoundEmitter:KillSound("loop")
end

--------------------------------------------------------------------------

local function lightfn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddLight()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst:AddTag("FX")

	inst.Light:SetColour(197/255, 197/255, 50/255)
	inst.Light:SetIntensity( .75 )
	inst.Light:SetFalloff( 0.5 )
	inst.Light:SetRadius( 2 )

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.persists = false

	inst.OnEntityWake = OnLightWake
	inst.OnEntitySleep = OnLightSleep

	return inst
end

local function fn()
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("tarlamp")
	inst.AnimState:SetBuild("tarlamp")
	inst.AnimState:PlayAnimation("idle_off")

	inst:AddTag("light")
	inst:AddTag("wildfireprotected")
	inst:AddTag("lighter") --added to pristine state for optimization
	-- inst:AddTag("waterproofer") --added to pristine state for optimization

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	-----------------------------------
	
	inst:AddComponent("inspectable")

	MakeInvItemIA(inst)
	inst.components.inventoryitem:SetOnDroppedFn(ondropped)
    inst.components.inventoryitem:SetOnPickupFn(onpickup)
	inst.components.inventoryitem:SetSinks(true)
	
	-----------------------------------
	
	--TODO these components should only exist when turned on!
	-- For the heater, we might get away with setting equippedheat to 0
	
	inst:AddComponent("lighter")
	
	inst:AddComponent("heater")
	inst.components.heater.equippedheat = 5

	-----------------------------------
	
	inst:AddComponent("weapon")
	inst.components.weapon:SetDamage(TUNING.LIGHTER_DAMAGE)
	inst.components.weapon:SetAttackCallback(onattack)
	
	inst:AddComponent("equippable")
	inst.components.equippable:SetOnPocket(function(owner) turnoff(inst) end)
	inst.components.equippable:SetOnEquip(onequip)
	inst.components.equippable:SetOnUnequip(onunequip)

	inst.components.equippable.boatequipslot = BOATEQUIPSLOTS.BOAT_LAMP
	inst.components.equippable.togglable = true
	inst.components.equippable.toggledonfn = toggleon
	inst.components.equippable.toggledofffn = toggleoff
	
	-----------------------------------
	
	inst:AddComponent("burnable")
	inst.components.burnable.canlight = false
	inst.components.burnable.fxprefab = nil

	inst:AddComponent("machine")
	inst.components.machine.turnonfn = turnon
	inst.components.machine.turnofffn = turnoff
	inst.components.machine.cooldowntime = 0
	inst.components.machine.caninteractfn = caninteractfn
	
	inst:AddComponent("fueled")
    inst.components.fueled:SetUpdateFn(onfueledupdate)
    inst.components.fueled:SetDepletedFn(nofuel)
    inst.components.fueled:SetFirstPeriod(TUNING.TURNON_FUELED_CONSUMPTION, TUNING.TURNON_FULL_FUELED_CONSUMPTION)
	inst.components.fueled:InitializeFuelLevel(TUNING.TORCH_FUEL)
	
	-----------------------------------
	
	inst._light = nil

	inst._onownerequip = function(owner, data)
		if data.item ~= inst and
			(   data.eslot == EQUIPSLOTS.HANDS or
				(data.eslot == EQUIPSLOTS.BODY and data.item:HasTag("heavy"))
			) then
			turnoff(inst)
		end
	end

	MakeHauntableLaunch(inst)

    inst:ListenForEvent("startrowing", function(inst,data) 
        onunequip(inst, data.owner)
    end, inst)  

    inst:ListenForEvent( "stoprowing", function(inst, data) 
        onequip(inst, data.owner)
    end, inst) 

	inst.OnRemoveEntity = OnRemove
    inst.wason = true
	
	return inst
end

function tarlamp_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_tarlamp_boat")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player

    function inst.components.boatvisualanims.update(inst, dt)
        if inst.AnimState:GetCurrentFacing() == FACING_DOWN then
            inst.AnimState:SetSortWorldOffset(0, 0.15, 0) --above the player
        else
            inst.AnimState:SetSortWorldOffset(0, 0.05, 0) --below the player
        end
    end
end

return Prefab("tarlamp", fn, assets, prefabs),
    MakeVisualBoatEquip("tarlamp", assets, nil, tarlamp_visual_common),
	Prefab("tarlamplight", lightfn)
%%+%%scripts/prefabs/tar_extractor.lua%%-%%require "prefabutil"

local assets=
{
	Asset("ANIM", "anim/tar_extractor.zip"),
	Asset("ANIM", "anim/tar_extractor_meter.zip"),	
}

local prefabs=
{
	"tar",
    "collapse_small",
}

local RESOURCE_TIME = TUNING.SEG_TIME*4
local POOP_ANIMATION_LENGTH = 70

local startTar

local function spawnTarProp(inst)
	inst.task_spawn = nil
	local tar = SpawnPrefab("tar")

 	local pt = inst:GetPosition() + Vector3(0,4.5,0)

	-- local right = TheCamera:GetRightVec()
	-- local offset = 1.3
	-- local variation = 0.2
	-- tar.Transform:SetPosition(pt.x + (right.x*offset) +(math.random()*variation),0, pt.z + (right.z*offset)+(math.random()*variation) )
	
	tar.Transform:SetPosition(pt.x + 1, 0, pt.z + 1)
	
	tar.AnimState:PlayAnimation("drop") 
	tar.AnimState:PushAnimation("idle_water",true)	
	--inst:RemoveEventCallback("animover", spawnTarProp )
	if inst.components.machine:IsOn() and not inst.components.fueled:IsEmpty() then
		startTar(inst)
		inst.AnimState:PlayAnimation("active",true)
	else
		inst.AnimState:PlayAnimation("idle", true)
	end
end

local function makeTar(inst)	
	inst.SoundEmitter:PlaySound("ia/common/tar_extractor/poop")
	inst.AnimState:PlayAnimation("poop")	
	inst.task_spawn = inst:DoTaskInTime(POOP_ANIMATION_LENGTH * FRAMES, spawnTarProp)
	inst.task_tar = nil
	--inst:ListenForEvent("animover", spawnTarProp )
end

startTar = function(inst)
	inst.task_tar = inst:DoTaskInTime(RESOURCE_TIME, makeTar )
	inst.task_tar_time = GetTime()
end

local function placeAlign(inst)
	local range = 1
	local pt = inst:GetPosition()
	local tarpits = TheSim:FindEntities(pt.x, pt.y, pt.z, range, {"tarpit"})

	if #tarpits > 0 then
		for k, v in pairs(tarpits) do
			if not v:HasTag("NOCLICK") then
				inst.Transform:SetPosition(v.Transform:GetWorldPosition())
				return true
			end
		end
	end
	return false
end

local function placeTestFn(pt, rot)
	local range = .1
	local tarpits = TheSim:FindEntities(pt.x, pt.y, pt.z, range, {"tarpit"})

	if #tarpits > 0 then
		for k, v in pairs(tarpits) do
			if not v:HasTag("NOCLICK") then
				return true, false
			end
		end
	end
	return false, false
end

local function onBuilt(inst)
	inst.SoundEmitter:PlaySound("ia/common/tar_extractor/craft")
	inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_medium")
	inst.AnimState:PlayAnimation("place")
	inst.AnimState:PushAnimation("idle",true)	

	local range = .1
	local pt = inst:GetPosition()
	local tarpits = TheSim:FindEntities(pt.x, pt.y, pt.z, range, {"tarpit"}, nil)
	for i,tarpit in ipairs(tarpits)do
		if tarpit:IsValid() and not tarpit:HasTag("NOCLICK") then
			inst.tarpit = tarpit
			tarpit:AddTag("NOCLICK")
			break
		end		
	end
	
	if not inst.tarpit then
		--This should not happen, panic!
		inst.components.workable:Destroy(inst)
	end
end

local function onRemove(inst, worker)
	if inst.tarpit then
		inst.tarpit:RemoveTag("NOCLICK")
	end
end


local function onhit(inst, worker)
	if not inst:HasTag("burnt") and not inst.task_spawn then
		inst.AnimState:PlayAnimation("hit")
		if inst.components.machine:IsOn() then 
			inst.AnimState:PushAnimation("active",true)
		else
			inst.AnimState:PushAnimation("idle", true)
		end
	end
end

local function onhammered(inst, worker)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
    inst.components.lootdropper:DropLoot()
    local fx = SpawnAt("collapse_small", inst)
    fx:SetMaterial("metal")
	inst.SoundEmitter:KillSound("suck")
    inst:Remove()
end

local function TurnOff(inst)
	if inst.task_tar then
		inst.task_tar:Cancel()
		inst.task_tar = nil
		inst.task_tar_time = nil
	end
	inst.components.fueled:StopConsuming()
	inst.AnimState:PlayAnimation("idle", true)
	inst.SoundEmitter:KillSound("suck")
end

local function TurnOn(inst)
	startTar(inst)
	inst.components.fueled:StartConsuming()
	inst.AnimState:PlayAnimation("active", true)
	inst.SoundEmitter:PlaySound("ia/common/tar_extractor/active_LP", "suck")  
end

local function CanInteract(inst)	
	return not inst.components.fueled:IsEmpty()
end

local function OnFuelSectionChange(new, old, inst)
    if inst._fuellevel ~= new then
        inst._fuellevel = new
		inst.AnimState:OverrideSymbol("swap_meter", "tar_extractor_meter", tostring(new))
    end
end

local function OnFuelEmpty(inst)
	inst.components.machine:TurnOff()
end

local function ontakefuelfn(inst)
	inst.SoundEmitter:PlaySound("dontstarve_DLC001/common/machine_fuel")
	--Turn machine on?
end

local function getstatus(inst, viewer)
	if inst.components.machine.ison then
		if inst.components.fueled
		and inst.components.fueled.currentfuel / inst.components.fueled.maxfuel <= .25 then
			return "LOWFUEL"
		else
			return "ON"
		end
	else
		return "OFF"
	end
end

local function OnSave(inst, data)
    if inst:HasTag("burnt")
	or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end 

	if inst.task_spawn then
		data.task_spawn = true
    elseif inst.task_tar then
		data.task_tar_time = RESOURCE_TIME - (GetTime() - inst.task_tar_time)
    end
	
	if inst.tarpit then
		data.tarpit = inst.tarpit.GUID
		return {tarpit = inst.tarpit.GUID}
	end
end

local function OnLoad(inst, data)
	if data and data.burnt and inst.components.burnable and inst.components.burnable.onburnt then
        inst.components.burnable.onburnt(inst)
    end

    inst:DoTaskInTime(0, function()
	    if data.task_spawn then
			makeTar(inst)
		elseif data.task_tar_time then
	    	if inst.task_tar then
	    		inst.task_tar:Cancel()
	    		inst.task_tar = nil
	    	end
			inst.task_tar = inst:DoTaskInTime(data.task_tar_time, makeTar )
			inst.task_tar_time = GetTime()    	
	    end
	end)
end

local function OnLoadPostPass(inst, newents, data)
    if data and data.tarpit then
		local tarpit = newents[data.tarpit]
		if tarpit then
			inst.tarpit = tarpit.entity
			inst.tarpit:AddTag("NOCLICK")
			return
		end
    end
	--This should not happen, panic!
	inst.components.workable:Destroy(inst)
end

local function OnSpawn(inst)
    if inst and not inst.tarpit then
		print("Please do not spawn Tar Extractors using the debug console. Consider using c_mat(\"tar_extractor\") to get the crafting materials, and spawn a tar_pool where you want to place the extractor.")
		--This should not happen, panic!
		inst.components.workable:Destroy(inst)
    end
end

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeObstaclePhysics(inst, .4)

	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetPriority( 5 )
	minimap:SetIcon( "tar_extractor.tex" )
    
	inst.AnimState:SetBank("tar_extractor")
	inst.AnimState:SetBuild("tar_extractor")
	inst.AnimState:PlayAnimation("idle",true)

	inst.AnimState:OverrideSymbol("swap_meter", "tar_extractor_meter", 10)
	
	inst:AddTag("structure")
	
	MakeSnowCoveredPristine(inst)
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
   
	inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

	inst:AddComponent("lootdropper")
	
	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
	inst.components.workable:SetWorkLeft(4)
	inst.components.workable:SetOnFinishCallback(onhammered)
	inst.components.workable:SetOnWorkCallback(onhit)		


	inst:AddComponent("machine")
	inst.components.machine.turnonfn = TurnOn
	inst.components.machine.turnofffn = TurnOff
	inst.components.machine.caninteractfn = CanInteract
	inst.components.machine.cooldowntime = 0.5

	inst:AddComponent("fueled")
	inst.components.fueled:SetDepletedFn(OnFuelEmpty)
    inst.components.fueled:SetTakeFuelFn(ontakefuelfn)
	inst.components.fueled.accepting = true
	inst.components.fueled:SetSections(10)
	inst.components.fueled:SetSectionCallback(OnFuelSectionChange)
	inst.components.fueled:InitializeFuelLevel(TUNING.TAR_EXTRACTOR_MAX_FUEL_TIME)
	inst.components.fueled.bonusmult = 5
	inst.components.fueled.secondaryfueltype = FUELTYPE.CHEMICAL

	--MakeLargeBurnable(inst, nil, nil, true)
	--MakeLargePropagator(inst)
	
	MakeSnowCovered(inst)
	
	inst.OnSave = OnSave 
    inst.OnLoad = OnLoad
    inst.OnLoadPostPass = OnLoadPostPass
	inst.OnRemoveEntity = onRemove
	inst:ListenForEvent( "onbuilt", onBuilt)
	inst:DoTaskInTime(0, OnSpawn)
	
	return inst
end

local function placerfn(inst)
	inst.components.placer.onupdatetransform = placeAlign
	-- inst.components.placer.testfn = placeTestFn
end

return Prefab( "tar_extractor", fn, assets, prefabs ),
MakePlacer( "tar_extractor_placer", "tar_extractor", "tar_extractor", "idle", nil, nil, nil, nil, nil, nil, placerfn)
%%+%%scripts/prefabs/tar_pool.lua%%-%%local assets=
{
	Asset("ANIM", "anim/tar_pit.zip"),
}

local prefabs=
{
	"tar",
}

local function fn(Sim)
	local inst = CreateEntity()
	inst.entity:AddSoundEmitter()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()
	
	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetIcon("tar.tex")
	
	inst.AnimState:SetBank("tar_pit")
	inst.AnimState:SetBuild("tar_pit")
	inst.AnimState:PlayAnimation("idle", true)
	--inst.AnimState:SetRayTestOnBB(true)
	inst.AnimState:SetLayer( LAYER_BACKGROUND )
	inst.AnimState:SetSortOrder( 3 )
	
	inst:AddTag("NOBLOCK")
	inst:AddTag("aquatic")
	inst:AddTag("tarpit")

	-- This looping sound seems to show up at 0,0,0..
	-- so waiting a frame to start it when the tarpool will be in the world at it's location.
	inst:DoTaskInTime(0, function() inst.SoundEmitter:PlaySound("ia/common/tar_LP","burble") end)
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")
	
	-- MakeSmallBurnable(inst)
	-- MakeSmallPropagator(inst)

	return inst
end

return Prefab( "tar_pool", fn, assets) 
%%+%%scripts/prefabs/telescope.lua%%-%%local normalassets=
{
	Asset("ANIM", "anim/telescope.zip"),
	Asset("ANIM", "anim/swap_telescope.zip"),
}
local superassets=
{
	Asset("ANIM", "anim/telescope_long.zip"),
	Asset("ANIM", "anim/swap_telescope_long.zip"),
}

local prefabs =
{
}

local function onfinished(inst)
	local user = inst.components.inventoryitem:GetGrandOwner()
	if not user then
		inst:Remove()
	else
		user:ListenForEvent("animover", function() 
			inst:Remove()
		end)
	end
end

local function onequip(inst, owner) 
	owner.AnimState:OverrideSymbol("swap_object", "swap_telescope", "swap_object")
	owner.AnimState:Show("ARM_carry") 
	owner.AnimState:Hide("ARM_normal") 
end

local function onsuperequip(inst, owner) 
	owner.AnimState:OverrideSymbol("swap_object", "swap_telescope_long", "swap_object")
	owner.AnimState:Show("ARM_carry") 
	owner.AnimState:Hide("ARM_normal") 
end

local function onunequip(inst, owner)
	owner.AnimState:Hide("ARM_carry") 
	owner.AnimState:Show("ARM_normal") 
end

local function oncast(inst, doer, pos)
	-- You can find this line in SGWilson and SGWilsonboating in the peertelescope state
	-- Because the telescope needs to exist after casting the last spell so the putaway animation can play.
	inst.components.finiteuses:Use()
	inst.SoundEmitter:PlaySound("ia/common/use_spyglass_reveal")
end

local function onsupercast(inst, doer, pos)
	inst.components.finiteuses:Use()
	inst.SoundEmitter:PlaySound("ia/common/supertelescope")
end

local function ReticuleTargetFn()
	return Vector3(ThePlayer.entity:LocalToWorldSpace(5,0,0))
end

--I stole these function from the Forge weapons without much thinking about it.
--Could be a neat visual upgrade. -M
-- local function ReticuleMouseTargetFn(inst, mousepos)
    -- if mousepos ~= nil then
        -- local x, y, z = inst.Transform:GetWorldPosition()
        -- local dx = mousepos.x - x
        -- local dz = mousepos.z - z
        -- local l = dx * dx + dz * dz
        -- if l <= 0 then
            -- return inst.components.reticule.targetpos
        -- end
        -- l = 6.5 / math.sqrt(l)
        -- return Vector3(x + dx * l, 0, z + dz * l)
    -- end
-- end
-- local function ReticuleUpdatePositionFn(inst, pos, reticule, ease, smoothing, dt)
    -- local x, y, z = inst.Transform:GetWorldPosition()
    -- reticule.Transform:SetPosition(x, 0, z)
    -- local rot = -math.atan2(pos.z - z, pos.x - x) / DEGREES
    -- if ease and dt ~= nil then
        -- local rot0 = reticule.Transform:GetRotation()
        -- local drot = rot - rot0
        -- rot = Lerp((drot > 180 and rot0 + 360) or (drot < -180 and rot0 - 360) or rot0, rot, dt * smoothing)
    -- end
    -- reticule.Transform:SetRotation(rot)
-- end


local function commonpristine()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst:AddTag("nopunch")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst:AddComponent("reticule")
	inst.components.reticule.targetfn = ReticuleTargetFn
	-- inst.components.reticule.mousetargetfn = ReticuleMouseTargetFn
	-- inst.components.reticule.updatepositionfn = ReticuleUpdatePositionFn
	inst.components.reticule.ease = true

	return inst
end

local function commonmaster(inst)

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
	MakeHauntableLaunch(inst)

	-------
	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.TELESCOPE_USES)
	inst.components.finiteuses:SetUses(TUNING.TELESCOPE_USES)
	inst.components.finiteuses:SetOnFinished(onfinished)
	-------
	
	inst:AddComponent("inspectable")
	MakeInvItemIA(inst)
	
	inst:AddComponent("equippable")
	inst.components.equippable:SetOnUnequip(onunequip)

	inst:AddComponent("telescope")
	-- inst:AddComponent("spellcaster")
	-- inst.components.spellcaster:SetAction(ACTIONS.PEER)
    -- inst.components.spellcaster:SetSpellFn(oncast)
    -- inst.components.spellcaster:SetSpellTestFn(peertest)
    -- inst.components.spellcaster.canuseonpoint = true
    -- inst.components.spellcaster.canusefrominventory = false
end

local function normalfn()
	local inst = commonpristine()

	inst.AnimState:SetBank("telescope")
	inst.AnimState:SetBuild("telescope")
	inst.AnimState:PlayAnimation("idle")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	commonmaster(inst)

	inst.components.equippable:SetOnEquip(onequip)

	inst.components.telescope:SetOnUseFn(oncast)
	inst.components.telescope:SetRange(TUNING.TELESCOPE_RANGE)
	-- inst.components.spellcaster:SetSpellFn(oncast)

	return inst
end

local function superfn()
	local inst = commonpristine()

	inst.AnimState:SetBank("telescope_long")
	inst.AnimState:SetBuild("telescope_long")
	inst.AnimState:PlayAnimation("idle")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	commonmaster(inst)
	
	inst.components.equippable:SetOnEquip(onsuperequip)

	inst.components.telescope:SetOnUseFn(onsupercast)
	inst.components.telescope:SetRange(TUNING.SUPERTELESCOPE_RANGE)
	-- inst.components.spellcaster:SetSpellFn(onsupercast)

	return inst
end

return Prefab( "telescope", normalfn, normalassets, prefabs),
	Prefab( "supertelescope", superfn, superassets, prefabs)
%%+%%scripts/prefabs/terraformstaff.lua%%-%%-- Debug weapon of mass glitchiness

local assets =
{
	Asset("ANIM", "anim/trident.zip"),
	Asset("ANIM", "anim/swap_trident.zip"),
}

local prefabs = {}


local function onequip(inst, owner)
	owner.AnimState:OverrideSymbol("swap_object", "swap_staffs", "swap_opalstaff")
	owner.AnimState:Show("ARM_carry")
	owner.AnimState:Hide("ARM_normal")
end

local function onunequip(inst, owner)
    owner.AnimState:Hide("ARM_carry")
    owner.AnimState:Show("ARM_normal")
end

local function terraform(staff, target, pt)
    local caster = staff.components.inventoryitem.owner

    local world = TheWorld
    local map = world.Map

    local original_tile_type = map:GetTileAtPoint(pt:Get())
    local x, y = map:GetTileCoordsAtPoint(pt:Get())

    local targettile = GROUND.OCEAN_SHALLOW

    if IsWater(original_tile_type) then
        targettile = GROUND.DIRT
    end

    map:SetTile(x, y, targettile)
    map:RebuildLayer(original_tile_type, x, y)
    map:RebuildLayer(targettile, x, y)
    --world.components.shorecollisions:UpdateTileCollisions(x, y)

    world.minimap.MiniMap:RebuildLayer(original_tile_type, x, y)
    world.minimap.MiniMap:RebuildLayer(targettile, x, y)
end

local function light_reticuletargetfn()
    return Vector3(TheLocalPlayer.entity:LocalToWorldSpace(5, 0, 0))
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("trident")
	inst.AnimState:SetBuild("trident")
	inst.AnimState:PlayAnimation("idle")

    inst:AddTag("nopunch")

    inst:AddComponent("reticule")
    inst.components.reticule.targetfn = light_reticuletargetfn
    inst.components.reticule.ease = true

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst, "trident")

    inst:AddComponent("equippable")
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst:AddComponent("spellcaster")
    inst.components.spellcaster:SetSpellFn(terraform)
    inst.components.spellcaster.canuseonpoint_water = true
    inst.components.spellcaster.canuseonpoint = true
    inst.components.spellcaster.quickcast = true

    return inst
end

return Prefab("terraformstaff", fn, assets, prefabs)
%%+%%scripts/prefabs/thatchpack.lua%%-%%local assets = {
    Asset("ANIM", "anim/swap_thatchpack.zip"),
    Asset("ANIM", "anim/ui_thatchpack_1x4.zip"),
}

local function onequip(inst, owner)
    owner.AnimState:OverrideSymbol("swap_body", "swap_thatchpack", "backpack")
    owner.AnimState:OverrideSymbol("swap_body", "swap_thatchpack", "swap_body")

    if inst.components.container ~= nil then
        inst.components.container:Open(owner)
    end
end

local function onunequip(inst, owner)
    owner.AnimState:ClearOverrideSymbol("swap_body")
    owner.AnimState:ClearOverrideSymbol("backpack")
    if inst.components.container ~= nil then
        inst.components.container:Close(owner)
    end
end

local function onburnt(inst)
    if inst.components.container ~= nil then
        inst.components.container:DropEverything()
        inst.components.container:Close()
    end

    SpawnPrefab("ash").Transform:SetPosition(inst.Transform:GetWorldPosition())

    inst:Remove()
end

local function onignite(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = false
    end
end

local function onextinguish(inst)
    if inst.components.container ~= nil then
        inst.components.container.canbeopened = true
    end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("thatchpack")
    inst.AnimState:SetBuild("swap_thatchpack")
    inst.AnimState:PlayAnimation("anim")

    inst:AddTag("backpack")

    inst.MiniMapEntity:SetIcon("thatchpack.tex")

    inst.foleysound = "ia/common/foley/grass_thatch_pack"
	
	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "anim")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)
    inst.components.inventoryitem.cangoincontainer = false

    inst:AddComponent("equippable")
    inst.components.equippable.equipslot = EQUIPSLOTS.BACK

    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst:AddComponent("container")
    inst.components.container:WidgetSetup("thatchpack")

    MakeSmallBurnable(inst)
    MakeSmallPropagator(inst)
    inst.components.burnable:SetOnBurntFn(onburnt)
    inst.components.burnable:SetOnIgniteFn(onignite)
    inst.components.burnable:SetOnExtinguishFn(onextinguish)

    MakeHauntableLaunchAndDropFirstItem(inst)

    return inst
end

return Prefab("thatchpack", fn, assets)
%%+%%scripts/prefabs/tidalpool.lua%%-%%local assets =
{
  Asset("ANIM", "anim/tidal_pool.zip")
}

local prefabs =
{
  "tidal_plant",
  "fish_tropical",
}

local function SpawnPlants(inst, plantname, count, maxradius)

  if inst.decor then
    for i,item in ipairs(inst.decor) do
      item:Remove()
    end
  end
  inst.decor = {}

  local plant_offsets = {}

  for i=1,math.random(math.ceil(count/2),count) do
    local a = math.random()*math.pi*2
    local x = math.sin(a)*maxradius+math.random()*0.2
    local z = math.cos(a)*maxradius+math.random()*0.2
    table.insert(plant_offsets, {x,0,z})
  end

  for k, offset in pairs( plant_offsets ) do
    local plant = SpawnPrefab( plantname )
    plant.entity:SetParent( inst.entity )
    plant.Transform:SetPosition( offset[1], offset[2], offset[3] )
    table.insert( inst.decor, plant )
  end
end

local sizes =
{
  {anim="small_idle", rad=2.0, plantcount=2, plantrad=1.6},
  {anim="med_idle", rad=2.6, plantcount=3, plantrad=2.5},
  {anim="big_idle", rad=3.6, plantcount=4, plantrad=3.4},
}

local function SetSize(inst, size)
  inst.size = math.random(1, #sizes)
  inst.AnimState:PlayAnimation(sizes[inst.size].anim, true)
  inst.Physics:SetCylinder(sizes[inst.size].rad, 1.0)
  SpawnPlants(inst, "marsh_plant_tropical", sizes[inst.size].plantcount, sizes[inst.size].plantrad)
end

local function onsave(inst, data)
  data.size = inst.size
end

local function onload(inst, data, newents)
  if data and data.size then
    SetSize(inst, data.size)
  end
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()
  
  MakeObstaclePhysics( inst, 3.5)

  inst.AnimState:SetBuild("tidal_pool")
  inst.AnimState:SetBank("tidal_pool")
  inst.AnimState:SetOrientation( ANIM_ORIENTATION.OnGround )
  inst.AnimState:SetLayer( LAYER_BACKGROUND )
  inst.AnimState:SetSortOrder( 3 )

  local minimap = inst.entity:AddMiniMapEntity()
  minimap:SetIcon( "pond_cave.png" )

  inst:AddTag("fishable")
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  inst.no_wet_prefix = true

  inst:AddComponent("fishable")
  inst.components.fishable:AddFish("fish_tropical")
  inst.components.fishable:SetRespawnTime(TUNING.FISH_RESPAWN_TIME)

  inst.OnSave = onsave
  inst.OnLoad = onload

  SetSize(inst)

  return inst
end

return Prefab( "tidalpool", fn, assets, prefabs)

%%+%%scripts/prefabs/tigereye.lua%%-%%local assets = {
    Asset("ANIM", "anim/eye_of_the_tiger.zip"),
}

local function fn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.AnimState:SetBuild("eye_of_the_tiger")
    inst.AnimState:SetBank("eye_of_the_tiger")
    inst.AnimState:PlayAnimation("idle")

    MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    MakeInvItemIA(inst)

    inst:AddComponent("appeasement")
    inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_LARGE

    inst:AddComponent("inspectable")

    inst:AddComponent("edible")
    inst.components.edible.foodtype = "MEAT"
    inst.components.edible.healthvalue = TUNING.HEALING_HUGE
    inst.components.edible.hungervalue = TUNING.CALORIES_HUGE
    inst.components.edible.sanityvalue = -TUNING.SANITY_MED

    inst:AddComponent("stackable")
    inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

    return inst
end

return Prefab("tigereye", fn, assets) %%+%%scripts/prefabs/tigershark.lua%%-%%--Need to make this enemy much less player focused.
--Doesn"t target player by default.
--Only if hit or if sharkittens threatened.

local assets =
{
    Asset("ANIM", "anim/tigershark_build.zip"),
    Asset("ANIM", "anim/tigershark_ground_build.zip"),
    Asset("ANIM", "anim/tigershark_ground.zip"),
    Asset("ANIM", "anim/tigershark_water_build.zip"),
    Asset("ANIM", "anim/tigershark_water.zip"),
    Asset("ANIM", "anim/tigershark_water_ripples_build.zip"),
}

local prefabs =
{
    "tigersharkshadow",
    "splash_water_big",
    "groundpound_fx",
    "groundpoundring_fx",
    "mysterymeat",
    "fish_med",
    "tigereye",
    "shark_gills",
}

SetSharedLootTable("tigershark",
{
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},
    {"fish_med", 1.00},

    {"tigereye", 1.00},
    {"tigereye", 0.50},

    {"shark_gills", 1.00},
    {"shark_gills", 1.00},
    {"shark_gills", 0.33},
    {"shark_gills", 0.10},
})

local TARGET_DIST = 20
local HEALTH_THRESHOLD = 0.1
local HOME_PROTECTION_DISTANCE = 60

local brain = require "brains/tigersharkbrain"

local function ShouldSleep(inst)
    return false
end

local function ShouldWake(inst)
    return true
end

local function GetTarget(inst)
    --Used for logic of moving between land and water states
    local target = inst.components.combat.target and inst.components.combat.target:GetPosition()

    if not target and inst:GetBufferedAction() then
        target = (inst:GetBufferedAction().target and inst:GetBufferedAction().target:GetPosition()) or inst:GetBufferedAction().pos
    end

    --Returns a position
    return target
end

local function GroundTypesMatch(inst, target)
    local target = target and target.prefab and target:GetPosition() or GetTarget(inst)

    if target and target.x and target.y and target.z then
        local targettile = GetVisualTileType(target:Get())
        return (inst:CanOnLand() and IsLand(targettile)) or
            (inst:CanOnWater() and IsWater(targettile))            
    end

    return true
end

local function FindSharkHome(inst)
    if not inst.sharkHome then
        if TheWorld.components.tigersharker and TheWorld.components.tigersharker.shark_home then
            inst.sharkHome = TheWorld.components.tigersharker.shark_home
        else
            inst.sharkHome = GetClosestInstWithTag("sharkhome", inst, 10000)
        end
    end
    return inst.sharkHome
end

local function OnAttacked(inst, data)
    inst.components.combat:SetTarget(data.attacker)
end

local function RetargetFn(inst)
    local home = FindSharkHome(inst)

    if home and home:GetPosition():Dist(inst:GetPosition()) < HOME_PROTECTION_DISTANCE then
        --Aggressive to the player if close to home
        return FindEntity(inst, TARGET_DIST, 
            function(tar) return inst.components.combat:CanTarget(tar) end, nil, 
            {"prey", "smallcreature", "bird", "butterfly", "sharkitten"})
    elseif inst.components.health:GetPercent() > HEALTH_THRESHOLD then
        --Not aggressive to the player if far from home
        return FindEntity(inst, TARGET_DIST, 
            function(tar) return inst.components.combat:CanTarget(tar) end, nil,
            {"prey", "smallcreature", "bird", "butterfly", "sharkitten", "player", "companion"})
    end
end

local function KeepTargetFn(inst, target)
    --If this thing is close to my kittens keep target no matter what.
    local home = FindSharkHome(inst)
    if inst.components.health:GetPercent() < HEALTH_THRESHOLD and home and home:GetPosition():Dist(inst:GetPosition()) > HOME_PROTECTION_DISTANCE then
        --If I'm low health & not protecting my home, flee.
        return false
    else
        return inst.components.combat:CanTarget(target)
    end
end

local function ontimerdone(inst, data)
    if data.name == "Run" then
        inst.CanRun = true
    end
end

local function MakeWater(inst)
    inst:ClearStateGraph()
    inst:SetStateGraph("SGtigershark_water")
    inst.AnimState:SetBuild("tigershark_water_build")
    inst.AnimState:AddOverrideBuild("tigershark_water_ripples_build")
    inst:AddTag("aquatic")
    inst.DynamicShadow:Enable(false)
end

local function MakeGround(inst)
    inst:ClearStateGraph()
    inst:SetStateGraph("SGtigershark_ground")
    inst.AnimState:SetBuild("tigershark_ground_build")
    inst:RemoveTag("aquatic")
    inst.DynamicShadow:Enable(true)
end

local function oncollapse(inst, other)
    if other:IsValid() and other.components.workable ~= nil and other.components.workable:CanBeWorked() then
        SpawnPrefab("collapse_small").Transform:SetPosition(other.Transform:GetWorldPosition())
        other.components.workable:Destroy(inst)
    end
end

local function oncollide(inst, other)
    if other ~= nil and
        (other:HasTag("tree") or other:HasTag("boulder")) and --HasTag implies IsValid
        Vector3(inst.Physics:GetVelocity()):LengthSq() >= 1 then
        inst:DoTaskInTime(2 * FRAMES, oncollapse, other)
    end
end

local function OnSave(inst, data)
    data.CanRun = inst.CanRun
    data.NextFeedTime = GetTime() - inst.NextFeedTime
end

local function OnLoad(inst, data)
    if data then
        inst.CanRun = data.CanRun or true
        inst.NextFeedTime = data.NextFeedTime or 0
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddDynamicShadow()
    inst.entity:AddNetwork()

    inst.Transform:SetFourFaced()
    inst.DynamicShadow:SetSize(6, 3)
    inst.DynamicShadow:Enable(false)

    inst:AddTag("aquatic")
    inst:AddTag("scarytoprey")
    inst:AddTag("tigershark")
    inst:AddTag("monster") --for "mine" components, can be "animal" instead if "monster" is problematic -M
    inst:AddTag("largecreature")
    inst:AddTag("epic")

    MakeCharacterPhysics(inst, 1000, 1.33)

    inst.AnimState:SetBank("tigershark")
    inst.AnimState:SetBuild("tigershark_water_build")
    inst.AnimState:PlayAnimation("water_run", true)
    inst.AnimState:SetRayTestOnBB(true)
    inst.AnimState:AddOverrideBuild("tigershark_water_ripples_build")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.Physics:SetCollisionCallback(oncollide)

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = TUNING.TIGERSHARK_WALK_SPEED
    inst.components.locomotor.runspeed = TUNING.TIGERSHARK_RUN_SPEED

    inst:AddComponent("rowboatwakespawner")

    inst:AddComponent("inspectable")
    inst.no_wet_prefix = true

    inst:AddComponent("knownlocations")

    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.TIGERSHARK_HEALTH)

    inst:AddComponent("eater")
    inst.components.eater:SetDiet({FOODGROUP.TIGERSHARK}, {FOODGROUP.TIGERSHARK})--{FOODTYPE.MEAT})

    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetChanceLootTable("tigershark")

    inst:AddComponent("groundpounder")
    inst.components.groundpounder.destroyer = true
    inst.components.groundpounder.damageRings = 3
    inst.components.groundpounder.destructionRings = 1
    inst.components.groundpounder.numRings = 3
    inst.components.groundpounder.noTags = {"FX", "NOCLICK", "DECOR", "INLIMBO", "sharkitten"}

    inst:AddComponent("combat")
    inst.components.combat:SetDefaultDamage(TUNING.TIGERSHARK_DAMAGE)
    inst.components.combat.playerdamagepercent = TUNING.TIGERSHARK_DAMAGE_PLAYER_PERCENT
    inst.components.combat:SetRange(TUNING.TIGERSHARK_ATTACK_RANGE)
    inst.components.combat:SetAreaDamage(TUNING.TIGERSHARK_SPLASH_RADIUS, TUNING.TIGERSHARK_SPLASH_DAMAGE/TUNING.TIGERSHARK_DAMAGE)
    inst.components.combat:SetAttackPeriod(TUNING.TIGERSHARK_ATTACK_PERIOD)
    inst.components.combat:SetRetargetFunction(3, RetargetFn)
    inst.components.combat:SetKeepTargetFunction(KeepTargetFn)
    inst.components.combat:SetHurtSound("dontstarve_DLC001/creatures/bearger/hurt")
    inst.components.combat.notags = {"sharkitten"}

    inst:AddComponent("sleeper")
    inst.components.sleeper:SetResistance(4)
    inst.components.sleeper:SetSleepTest(ShouldSleep)
    inst.components.sleeper:SetWakeTest(ShouldWake)

    inst:ListenForEvent("killed", function(inst, data)
        if inst.components.combat and data and data.victim == inst.components.combat.target then
            inst.components.combat.target = nil
        end
    end)

    inst.CanRun = true --Can do charge attack

    inst.CanFly = false --Can do leap attack

    --[[
    - While in water, tigershark jumps every third attack.
    - While on ground, tigershark *can* jump after every third attack, but will
    only jump to close distance.

    This logic is controlled through the tigershark's stategraphs.
    --]]

    inst.AttackCounter = 0
    inst.NextFeedTime = 0
    inst.OnSave = OnSave
    inst.OnLoad = OnLoad
    inst.GroundTypesMatch = GroundTypesMatch
    inst.FindSharkHome = FindSharkHome
    inst.GetTarget = GetTarget
    inst.MakeGround = MakeGround
    inst.MakeWater = MakeWater

    inst:SetStateGraph("SGtigershark_water")
    inst:SetBrain(brain)

    inst:AddComponent("timer")
    inst:ListenForEvent("timerdone", ontimerdone)
    inst:ListenForEvent("attacked", OnAttacked)

    inst:DoTaskInTime(1*FRAMES, function(inst)
        if inst:GetIsOnWater() then
            inst:MakeWater()
            inst.sg:GoToState("idle")
        else
            inst:MakeGround()
            inst.sg:GoToState("idle")
        end
    end)

    return inst
end

return Prefab( "tigershark", fn, assets, prefabs)%%+%%scripts/prefabs/tigersharkshadow.lua%%-%%local easing = require("easing")

local assets = {
    Asset("ANIM", "anim/tigershark_shadow.zip")
}

local function OnRemove(inst)
    if inst.sizeTask then
        inst.sizeTask:Cancel()
        inst.sizeTask = nil
    end
end

local function SetUpScale(inst, start_scale, end_scale, scale_time, fade_type, ease_type)
    ease_type = ease_type or easing.inExpo
    local start_time = GetTime()
    inst.Transform:SetScale(start_scale,start_scale,start_scale)

    if inst.sizeTask then
        inst.sizeTask:Cancel()
        inst.sizeTask = nil
    end

    inst.sizeTask = inst:DoPeriodicTask(FRAMES, function(inst)
        local scale = ease_type(GetTime() - start_time, start_scale, end_scale - start_scale, scale_time)
        inst.Transform:SetScale(scale, scale, scale)
    end)

    if fade_type == "OUT" then
        inst.AnimState:SetMultColour(0,0,0,0.6)
        inst.components.colourtweener:StartTween({0,0,0,0}, scale_time)
    else
        inst.AnimState:SetMultColour(0,0,0,0)
        inst.components.colourtweener:StartTween({0,0,0,0.6}, scale_time)
    end
end

local MAX_SCALE = 1.5
local MIN_SCALE = 0.5

local function Ground_Fall(inst)
    --Big -> Small
    SetUpScale(inst, MAX_SCALE, MIN_SCALE, 1.8, "IN")
    inst:DoTaskInTime(1.8, inst.Remove)
end

local function Water_Jump(inst)
    --Small -> Big
    SetUpScale(inst, MIN_SCALE, MAX_SCALE, 91 * FRAMES)
    --Big -> Small
    inst:DoTaskInTime(91 * FRAMES, function() SetUpScale(inst, MAX_SCALE, MIN_SCALE, FRAMES * 15, "OUT", easing.outExpo) end)
    inst:DoTaskInTime(106 * FRAMES, inst.Remove)
end

local function Water_Fall(inst)
    --Big -> Small
    SetUpScale(inst, MAX_SCALE, MIN_SCALE, 1.8, "IN")
    inst:DoTaskInTime(1.8, inst.Remove)
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("tigershark_shadow")
    inst.AnimState:SetBuild("tigershark_shadow")
    inst.AnimState:PlayAnimation("air", true)
    inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("colourtweener")

    inst.Ground_Fall = Ground_Fall
    inst.Water_Jump = Water_Jump
    inst.Water_Fall = Water_Fall
    inst.OnRemoveEntity = OnRemove
    inst.persists = false

    return inst
end

return Prefab("tigersharkshadow", fn, assets, prefabs)%%+%%scripts/prefabs/tilestatecore.lua%%-%%local assets = {
	Asset('ANIM','anim/webtile.zip'),
	-- Asset('ANIM','anim/snowtile.zip'),
}

local function onsave(inst, data)
	data.tiles = SaveTileState()
end

local function onload(inst, data)
	if data and data.tiles then
		LoadTileState(data.tiles)
	end
end


local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()

	inst:AddTag('NOCLICK')
	inst:AddTag('tilestate')
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst.OnSave = onsave
	inst.OnPreLoad = onload

	return inst
end

return Prefab( 'tilestatecore', fn, assets) 
%%+%%scripts/prefabs/trawlnet.lua%%-%%local MakeVisualBoatEquip = require("prefabs/visualboatequip")

local net_assets=
{
    Asset("ANIM", "anim/swap_trawlnet.zip"),
    Asset("ANIM", "anim/swap_trawlnet_half.zip"),
    Asset("ANIM", "anim/swap_trawlnet_full.zip"),
}

local dropped_assets=
{
    Asset("ANIM", "anim/swap_trawlnet.zip"),
    -- Asset("ANIM", "anim/ui_chest_3x2.zip"),
}

local chance =
{
    verylow = 1,
    low = 2,
    medium = 4,
    high = 8,
}

local loot =
{
    shallow =
    {
     
        {"roe", chance.medium},

        {"seaweed", chance.high},
        {"mussel", chance.medium},
        {"lobster", chance.low},
        {"jellyfish", chance.low},
        {"fish", chance.medium},
        {"coral", chance.medium},
        {"messagebottleempty", chance.medium},
        {"fish_med", chance.low},
        {"rocks", chance.high},
    },


    medium =
    {
        {"roe", chance.medium},

        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.low},
        {"jellyfish", chance.medium},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.medium},
        {"messagebottleempty", chance.medium},
        {"boneshard", chance.medium},
        {"spoiled_fish", chance.medium},
        {"dubloon", chance.low},
        {"goldnugget", chance.low},
        {"telescope", chance.verylow},
        {"firestaff", chance.verylow},
        {"icestaff", chance.verylow},
        {"panflute", chance.verylow},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.medium},
        {"trinket_ia_18", chance.verylow},
    },

    deep =
    {
        {"roe", chance.low},

        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.low},
        {"jellyfish", chance.high},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.high},
        {"messagebottleempty", chance.medium},
        {"boneshard", chance.medium},
        {"spoiled_fish", chance.medium},
        {"dubloon", chance.medium},
        {"goldnugget", chance.medium},
        {"telescope", chance.low},
        {"firestaff", chance.low},
        {"icestaff", chance.low},
        {"panflute", chance.low},
        {"redgem", chance.low},
        {"bluegem", chance.low},
        {"purplegem", chance.low},
        {"goldenshovel", chance.low},
        {"goldenaxe", chance.low},
        {"razor", chance.low},
        {"spear", chance.low},
        {"compass", chance.low},
        {"amulet", chance.verylow},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.low},
        {"trinket_ia_18", chance.verylow},
        {"trident", chance.verylow},
    }
}

local hurricaneloot =
{
    shallow =
    {

        {"roe", chance.medium},

        {"seaweed", chance.high},
        {"mussel", chance.medium},
        {"lobster", chance.medium},
        {"jellyfish", chance.medium},
        {"fish", chance.high},
        {"coral", chance.high},
        {"messagebottleempty", chance.high},
        {"fish_med", chance.medium},
        {"rocks", chance.high},
        {"dubloon", chance.low},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.low},
    },


    medium =
    {
         {"roe", chance.medium},

        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.medium},
        {"jellyfish", chance.high},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.high},
        {"messagebottleempty", chance.high},
        {"boneshard", chance.high},
        {"spoiled_fish", chance.high},
        {"dubloon", chance.medium},
        {"goldnugget", chance.medium},
        {"telescope", chance.low},
        {"firestaff", chance.low},
        {"icestaff", chance.low},
        {"panflute", chance.low},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.low},
        {"trinket_ia_18", chance.verylow},
        {"trident", chance.verylow},
    },


    deep =
    {
        {"roe", chance.low},

        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.low},
        {"jellyfish", chance.high},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.high},
        {"messagebottleempty", chance.high},
        {"boneshard", chance.high},
        {"spoiled_fish", chance.high},
        {"dubloon", chance.medium},
        {"goldnugget", chance.medium},
        {"telescope", chance.medium},
        {"firestaff", chance.low},
        {"icestaff", chance.medium},
        {"panflute", chance.medium},
        {"redgem", chance.medium},
        {"bluegem", chance.medium},
        {"purplegem", chance.medium},
        {"goldenshovel", chance.medium},
        {"goldenaxe", chance.medium},
        {"razor", chance.medium},
        {"spear", chance.medium},
        {"compass", chance.medium},
        {"amulet", chance.verylow},
        {"trinket_ia_16", chance.medium},
        {"trinket_ia_17", chance.medium},
        {"trinket_ia_18", chance.verylow},
        {"trident", chance.low},
    }
}

local dryloot =
{
    shallow =
    {
        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.medium},
        {"jellyfish", chance.medium},
        {"fish", chance.high},
        {"coral", chance.high},
        {"messagebottleempty", chance.high},
        {"fish_med", chance.medium},
        {"rocks", chance.high},
        {"dubloon", chance.low},
        {"obsidian", chance.high},
    },


    medium =
    {
        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.medium},
        {"jellyfish", chance.high},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.high},
        {"messagebottleempty", chance.high},
        {"boneshard", chance.high},
        {"spoiled_fish", chance.high},
        {"dubloon", chance.medium},
        {"goldnugget", chance.medium},
        {"telescope", chance.low},
        {"firestaff", chance.medium},
        {"icestaff", chance.low},
        {"panflute", chance.low},
        {"obsidian", chance.medium},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.low},
        {"trinket_ia_18", chance.verylow},
        {"trident", chance.verylow},
    },


    deep =
    {
        {"seaweed", chance.high},
        {"mussel", chance.high},
        {"lobster", chance.low},
        {"jellyfish", chance.high},
        {"fish", chance.high},
        {"coral", chance.high},
        {"fish_med", chance.high},
        {"messagebottleempty", chance.high},
        {"boneshard", chance.high},
        {"spoiled_fish", chance.high},
        {"dubloon", chance.medium},
        {"goldnugget", chance.medium},
        {"telescope", chance.medium},
        {"firestaff", chance.medium},
        {"icestaff", chance.low},
        {"panflute", chance.medium},
        {"redgem", chance.medium},
        {"bluegem", chance.medium},
        {"purplegem", chance.medium},
        {"goldenshovel", chance.medium},
        {"goldenaxe", chance.medium},
        {"razor", chance.medium},
        {"spear", chance.medium},
        {"compass", chance.medium},
        {"amulet", chance.verylow},
        {"obsidian", chance.medium},
        {"trinket_ia_16", chance.low},
        {"trinket_ia_17", chance.low},
        {"trinket_ia_18", chance.verylow},
        {"trident", chance.low},
    }
}

local uniqueItems =
{
    "trinket_ia_16",
    "trinket_ia_17",
    "trinket_ia_18",
    "trident",
}

local function gettrawlbuild(inst)
	if not inst.components.inventory then return "swap_trawlnet" end
    local fullness = inst.components.inventory:NumItems()/inst.components.inventory.maxslots
    if fullness <= 0.33 then
        return "swap_trawlnet"
    elseif fullness <= 0.66 then
        return "swap_trawlnet_half"
    else
        return "swap_trawlnet_full"
    end
end

local function ontrawlpickup(inst, numitems, pickup)
    local owner = inst.components.inventoryitem.owner
    local sailor = nil

    if owner and owner.components.sailable then
        sailor = owner.components.sailable.sailor
        if inst.visual then
            inst.visual.AnimState:SetBuild(gettrawlbuild(inst))
        end
        if sailor then
            sailor:PushEvent("trawlitem")
            inst.trawlitem:set_local(true)
            inst.trawlitem:set(true)
        end
    end

    inst.SoundEmitter:PlaySound("ia/common/trawl_net/collect")
end


local function updatespeedmult(inst)
    local fullpenalty = TUNING.TRAWLING_SPEED_MULT
    local penalty = fullpenalty * (inst.components.inventory:NumItems()/TUNING.TRAWLNET_MAX_ITEMS)

    local owner = inst.components.inventoryitem.owner
    if owner and owner.components.sailable then
        local sailor = owner.components.sailable.sailor
        if sailor then
            sailor.components.locomotor:SetExternalSpeedMultiplier(inst, "TRAWL", 1 - penalty)
        end
    end
end

local function pickupitem(inst,pickup)
    if pickup then
        print("Trawl net caught a...", pickup.prefab)
        local num = inst.components.inventory:NumItems()
        inst.components.inventory:GiveItem(pickup, num + 1)
        ontrawlpickup(inst, num + 1, pickup)

        if inst.components.inventory:IsFull() then
            local owner = inst.components.inventoryitem.owner
            if owner then
                if owner.components.sailable and owner.components.sailable.sailor then
                    owner.components.sailable.sailor:PushEvent("trawl_full")
                end
                owner.components.container:DropItem(inst)
            end
        else
            updatespeedmult(inst)
        end
    end
end

local specialCasePrefab =
{
    ["seaweed_planted"] = function(inst,net)
        if inst and inst.components.pickable then
            if inst.components.pickable.canbepicked
            and inst.components.pickable.caninteractwith then
                pickupitem(net, SpawnPrefab(inst.components.pickable.product))
            end            
            inst:Remove()
            return SpawnPrefab("seaweed_stalk")            
        end
    end,
    ["jellyfish_planted"] = function(inst)
        inst:Remove()
        return SpawnPrefab("jellyfish")
    end,
    ["mussel_farm"] = function(inst,net)
        if inst then     
            if inst.growthstage <= 0 then                              
                inst:Remove()
                return SpawnPrefab(inst.components.pickable.product)  
            end
        end
    end,
    ["sunkenprefab"] = function(inst)
		local record = inst.components.sunkenprefabinfo:GetSunkenPrefab()
		if not record or not record.prefab then record = {prefab = ""} end --prevent crash from missing record
        local sunken = SpawnSaveRecord(record)
		if sunken and sunken:IsValid() then --might be nil if the thing is a prefab from a no-longer-enabled mod
			sunken:LongUpdate(inst.components.sunkenprefabinfo:GetTimeSubmerged() or 0)
		end
        inst:Remove()
        return sunken and sunken:IsValid() and sunken
    end,
    ["lobster"] = function(inst)
        return inst
    end,
}

local function isItemUnique(item)
    for i = 1, #uniqueItems do
        if uniqueItems[i] == item then
            return true
        end
    end
    return false
end

local function hasUniqueItem(inst)
    for k,v in pairs(inst.components.inventory.itemslots) do
        for i = 1, #uniqueItems do
            if uniqueItems[i] == v then
                return true
            end
        end
    end

    return false
end

local function getLootList(inst)
    local loottable = loot
    if TheWorld.state.iswinter then
        loottable = hurricaneloot
    elseif TheWorld.state.issummer then
        loottable = dryloot
    end

    local owner = inst.components.inventoryitem.owner
    local pos = owner:GetPosition() or inst:GetPosition()
    if owner and owner.components.sailable and owner.components.sailable.sailor then
        pos = owner.components.sailable.sailor:GetPosition()
    end
	
    local tile = GROUND.OCEAN_SHALLOW
    tile = TheWorld.Map:GetTileAtPoint(pos:Get())
    if tile == GROUND.OCEAN_MEDIUM then
        return loottable.medium
    elseif tile == GROUND.OCEAN_DEEP then
        return loottable.deep
    else
        return loottable.shallow
    end
end

local function selectLoot(inst)
    local total = 0
    local lootList = getLootList(inst)

    for i = 1, #lootList do
        total = total + lootList[i][2]
    end

    local choice = math.random(0,total)
    total = 0
    for i = 1, #lootList do
        total = total + lootList[i][2]
        if choice <= total then
            local loot = lootList[i][1]

            --Check if the player has already found one of these
            if isItemUnique(loot) and hasUniqueItem(inst) then
                --If so, pick a different item to give
                loot = selectLoot(inst)
                --NOTE - Possible infinite loop here if only possible loot is unique items.
            end

            return loot
        end
    end
end

local function droploot(inst, owner)
    local chest = SpawnPrefab("trawlnetdropped")
    local pt = inst:GetPosition()

    chest:DoDetach()

    chest.Transform:SetPosition(pt.x, pt.y, pt.z)

    local slotnum = 1
    for k,v in pairs(inst.components.inventory.itemslots) do
        chest.components.container:GiveItem(v, slotnum)
        slotnum = slotnum + 1
    end

    if owner and owner.components.sailable and owner.components.sailable.sailor then
        local sailor = owner.components.sailable.sailor
        local angle = sailor.Transform:GetRotation()
        local dist = -3
        local offset = Vector3(dist * math.cos(angle*DEGREES), 0, -dist*math.sin(angle*DEGREES))
        local chestpos = sailor:GetPosition() + offset        
        chest.Transform:SetPosition(chestpos:Get())
        chest:FacePoint(pt:Get())
    end
end

local function generateLoot(inst)
    return SpawnPrefab(selectLoot(inst))
end

local function stoptrawling(inst)
    inst.trawling = false
    if inst.trawltask then
        inst.trawltask:Cancel()
    end
end

local function isBehind(inst, tar)
    local pt = inst:GetPosition()
    local hp = tar:GetPosition()

    local heading_angle = -(inst.Transform:GetRotation())
    local dir = Vector3(math.cos(heading_angle*DEGREES),0, math.sin(heading_angle*DEGREES))

    local offset = (hp - pt):GetNormalized()     
    local dot = offset:Dot(dir)

    local dist = pt:Dist(hp)

    return dot <= 0 and dist >= 1
end

local function updateTrawling(inst)
    if not inst.trawling then
        return
    end

    local owner = inst.components.inventoryitem.owner
    local sailor = nil

    if owner and owner.components.sailable then
        sailor = owner.components.sailable.sailor
    end

    if not sailor then
        print("NO SAILOR IN TRAWLNET?! SOMETHING WENT WRONG!")
        stoptrawling(inst)
        return
    end

    local pickup = nil
    local pos = inst:GetPosition()
    local displacement = pos - inst.lastPos
    inst.distanceCounter = inst.distanceCounter + displacement:Length()

    if inst.distanceCounter > TUNING.TRAWLNET_ITEM_DISTANCE then
        pickup = generateLoot(inst)
        inst.distanceCounter = 0
    end

    inst.lastPos = pos

    if not pickup then
        local range = 2
        pickup = FindEntity(sailor, range, function(item)
            return isBehind(sailor, item)
                and ((item.components.inventoryitem and not item.components.inventoryitem:IsHeld()
				and item.components.inventoryitem.cangoincontainer)
                and item.components.floater
                or specialCasePrefab[item.prefab] ~= nil) end, nil, {"trap", "FX", "NOCLICK", "player"})
    end

	-- I have no idea why FindEntity can detect the NOCLICK sunkenprefab in SW -M
    if not pickup then
        local range = 2
        pickup = FindEntity(sailor, range, function(item)
				return isBehind(sailor, item)
			end, {"sunkenprefab"})
    end
	
    if pickup and specialCasePrefab[pickup.prefab] then
        pickup = specialCasePrefab[pickup.prefab](pickup,inst)
    end

    if pickup then
        pickupitem(inst,pickup)
    end

end

local function starttrawling(inst)
    inst.trawling = true
    inst.lastPos = inst:GetPosition()
    inst.trawltask = inst:DoPeriodicTask(FRAMES * 5, updateTrawling)
    inst.SoundEmitter:PlaySound("ia/common/trawl_net/attach")
end

local function embarked(boat, data)
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
    starttrawling(item)
    updatespeedmult(item)
end

local function disembarked(boat, data)
    local item = boat.components.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
    stoptrawling(item)

    if data.sailor.components.locomotor then
        data.sailor.components.locomotor:RemoveExternalSpeedMultiplier(item, "TRAWL")
    end
end

local function onequip(inst, owner)
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:SpawnBoatEquipVisuals(inst, "trawlnet")
    end
    inst.components.inventoryitem.cangoincontainer = false
    inst:ListenForEvent("embarked", embarked, owner)
    inst:ListenForEvent("disembarked", disembarked, owner)
    updatespeedmult(inst)
	starttrawling(inst)
end

local function onunequip(inst, owner)	
    if owner.components.boatvisualmanager then
        owner.components.boatvisualmanager:RemoveBoatEquipVisuals(inst)
    end
    if owner.components.sailable and owner.components.sailable.sailor then	
        if owner.components.sailable.sailor.components.locomotor then
            owner.components.sailable.sailor.components.locomotor:RemoveExternalSpeedMultiplier(inst, "TRAWL")
        end
    end

    inst:RemoveEventCallback("embarked", embarked, owner)
    inst:RemoveEventCallback("disembarked", disembarked, owner)
    stoptrawling(inst)
	--Only do the following if this entity is not in the process of getting removed already (fixes issue #246 - Duplication Bug)
	if Ents[inst.GUID] then
		droploot(inst, owner)
		inst:DoTaskInTime(2*FRAMES, inst.Remove)
	end
end

local loots = {}

local function net(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

    inst.AnimState:SetBank("trawlnet")
    inst.AnimState:SetBuild("swap_trawlnet")
    inst.AnimState:PlayAnimation("idle")
	
    MakeInventoryPhysics(inst)

    inst:AddTag("trawlnet")
    inst:AddTag("show_invspace")

    inst.trawlitem = net_bool(inst.GUID, "trawlitem", not TheWorld.ismastersim and "trawlitem" or nil)

    if not TheWorld.ismastersim then
        inst:ListenForEvent("trawlitem", function(inst)
            TheLocalPlayer:PushEvent("trawlitem")
        end)
    end

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
    inst:AddComponent("inspectable")

    MakeInvItemIA(inst)

    MakeSmallBurnable(inst, TUNING.SMALL_BURNTIME)
    MakeSmallPropagator(inst)

    inst:AddComponent("inventory")
    inst.components.inventory.maxslots = TUNING.TRAWLNET_MAX_ITEMS

	inst:AddComponent("equippable")
    inst.components.equippable.boatequipslot = BOATEQUIPSLOTS.BOAT_SAIL
    inst.components.equippable.equipslot = nil
    inst.components.equippable:SetOnEquip(onequip)
    inst.components.equippable:SetOnUnequip(onunequip)

    inst.currentLoot = {}
    inst.uniqueItemsFound = {}
    inst.distanceCounter = 0
    inst.trawltask = nil
    inst.rowsound = "ia/common/trawl_net/move_LP"
    updatespeedmult(inst)

    return inst
end


local function sink(inst, instant)
    if not instant then
        inst.AnimState:PlayAnimation("sink_pst")
        inst:ListenForEvent("animover", function()
            inst.components.container:DropEverything()            
            inst:Remove()
        end)
    else
        -- this is to catch the nets that for some reason dont have the right timer save data. 
        inst.components.container:DropEverything()
        inst:Remove()
    end
end

local function getsinkstate(inst)
    if inst.components.timer:TimerExists("sink") then
        return "sink"
    elseif inst.components.timer:TimerExists("startsink") then
        return "full"
    end
    return "sink"
end

local function startsink(inst)
    inst.AnimState:PlayAnimation("full_to_sink")
    inst.components.timer:StartTimer("sink", TUNING.TRAWL_SINK_TIME * 1/3)
    inst.AnimState:PushAnimation("idle_"..getsinkstate(inst), true)
end


local function dodetach(inst)
    inst.components.timer:StartTimer("startsink", TUNING.TRAWL_SINK_TIME * 2/3)
    inst.AnimState:PlayAnimation("detach")
    inst.AnimState:PushAnimation("idle_"..getsinkstate(inst), true)
    inst.SoundEmitter:PlaySound("ia/common/trawl_net/detach")
end

local function onopen(inst)
    inst.AnimState:PlayAnimation("interact_"..getsinkstate(inst))
    inst.AnimState:PushAnimation("idle_"..getsinkstate(inst), true)
    inst.SoundEmitter:PlaySound("ia/common/trawl_net/open")
end

local function onclose(inst)
    inst.AnimState:PlayAnimation("interact_"..getsinkstate(inst))
    inst.AnimState:PushAnimation("idle_"..getsinkstate(inst), true)
    inst.SoundEmitter:PlaySound("ia/common/trawl_net/close")
end

local function ontimerdone(inst, data)
    if data.name == "startsink" then
        startsink(inst)
    end

    if data.name == "sink" then
        sink(inst)
    end
    --These are sticking around some times.. maybe the timer name is being lost somehow? This will catch that?
    if data.name ~= "sink" and data.name ~= "startsink" then
        sink(inst)
    end
end


local function getstatusfn(inst, viewer)
    local sinkstate = getsinkstate(inst)
    local timeleft = (inst.components.timer and inst.components.timer:GetTimeLeft("startsink")) or TUNING.TRAWL_SINK_TIME
    if sinkstate == "sink" then
        return "SOON"
    elseif sinkstate == "full" and timeleft <= (TUNING.TRAWL_SINK_TIME * 0.66) * 0.5 then
        return "SOONISH"
    else
        return "GENERIC"
    end
end

local function onloadtimer(inst)
    if not inst.components.timer:TimerExists("sink") and not inst.components.timer:TimerExists("startsink") then
        print("TRAWL NET HAD NO TIMERS AND WAS FORCE SUNK")
        sink(inst, true)
    end
end

local function onload(inst, data)
    inst.AnimState:PlayAnimation("idle_"..getsinkstate(inst), true)    
end

local function dropped_net()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

    inst.Transform:SetTwoFaced()

    inst:AddTag("structure")
    inst:AddTag("chest")

    inst.AnimState:SetBank("trawlnet")
    inst.AnimState:SetBuild("swap_trawlnet")
    inst.AnimState:PlayAnimation("idle_full", true)
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(3)

    MakeInventoryPhysics(inst)

	inst.entity:SetPristine()
	
	if not TheWorld.ismastersim then
		return inst
	end
	
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatusfn

    inst:AddComponent("container")
    inst.components.container:WidgetSetup("trawlnetdropped")
    inst.components.container.onopenfn = onopen
    inst.components.container.onclosefn = onclose

    inst:AddComponent("timer")
    inst:ListenForEvent("timerdone", ontimerdone)
    inst.onloadtimer = onloadtimer

    inst.DoDetach = dodetach

    -- this task is here because sometimes the savedata on the timer is empty.. so no timers are reloaded.
    -- when that happens, the nets sit around forever. 
    inst:DoTaskInTime(0,function() onloadtimer(inst) end)

    inst.OnLoad = onload

    return inst
end

function trawlnet_visual_common(inst)
    inst.AnimState:SetBank("sail_visual")
    inst.AnimState:SetBuild("swap_trawlnet")
    inst.AnimState:PlayAnimation("idle_loop")
    inst.AnimState:SetSortWorldOffset(0, -0.05, 0) --below the boat
end

return Prefab("trawlnet", net, net_assets),
    MakeVisualBoatEquip("trawlnet", net_assets, nil, trawlnet_visual_common),
	Prefab("trawlnetdropped", dropped_net, dropped_assets)
	%%+%%scripts/prefabs/treeguard_coconut.lua%%-%%local assets=
{
  Asset("ANIM", "anim/coconut_cannon.zip"),
}

local prefabs = 
{
  "small_puff_light",
  "coconut_chunks",
  "bombsplash",
}

local function onhit(inst) --, thrower, target)
	local pos = inst:GetPosition()
	local ents = TheSim:FindEntities(pos.x, pos.y, pos.z, 1.5)

	for k,v in pairs(ents) do
	  if v.components.combat and v ~= inst and v.prefab ~= "leif_palm" then
		v.components.combat:GetAttacked(inst.thrower, TUNING.PALMTREEGUARD_COCONUT_DAMAGE)
	  end
	end

	if IsOnWater(inst) then
	  SpawnAt("bombsplash", pos)
	  inst.SoundEmitter:PlaySound("ia/common/cannonball_impact")
	  inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large")
	else
	  SpawnAt("small_puff_light", pos)
	  if math.random() < 0.05 then
		SpawnAt("coconut", pos)
	  else
		SpawnAt("coconut_chunks", pos)
	  end
	end

	inst:Remove()
end

local function trackheight(inst)
	if inst:GetPosition().y < 0.3 then
		onhit(inst)
	end
end

local function onthrown(inst, thrower, pt, time_to_target)
	inst.Physics:SetFriction(.2)
	inst.Transform:SetFourFaced()
	inst:FacePoint(pt:Get())
	inst.AnimState:PlayAnimation("throw", true)

	local shadow = SpawnPrefab("warningshadow")
	shadow.Transform:SetPosition(pt:Get())
	shadow:shrink(time_to_target, 1.75, 0.5)
	
	inst.thrower = thrower
	inst.TrackHeight = inst:DoPeriodicTask(.1, trackheight)
end

local function onremove(inst)
	if inst.TrackHeight then
		inst.TrackHeight:Cancel()
		inst.TrackHeight = nil
	end
end

local function fn()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst.AnimState:SetBank("coconut_cannon")
  inst.AnimState:SetBuild("coconut_cannon")
  inst.AnimState:PlayAnimation("throw", true)

  inst:AddTag("thrown")
  inst:AddTag("projectile")

  inst.persists = false
  
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	inst:AddComponent("throwable")
	inst.components.throwable.onthrown = onthrown
	inst.components.throwable.random_angle = 0
	inst.components.throwable.max_y = 50
	inst.components.throwable.yOffset = 3
	
	inst.OnRemoveEntity = onremove
	
    -- inst:AddComponent("complexprojectile")
    -- inst.components.complexprojectile:SetHorizontalSpeed(10)
    -- -- inst.components.complexprojectile:SetGravity(-35)
    -- inst.components.complexprojectile:SetLaunchOffset(Vector3(0, 3, 0))
    -- inst.components.complexprojectile:SetOnLaunch(onthrown)
    -- inst.components.complexprojectile:SetOnHit(onhit)

  return inst
end

return Prefab("treeguard_coconut", fn, assets, prefabs)%%+%%scripts/prefabs/trident.lua%%-%%local assets =
{
	Asset("ANIM", "anim/trident.zip"),
	Asset("ANIM", "anim/swap_trident.zip"),
}

local function onfinished(inst)
	inst:Remove()
end

local function refreshDamage(owner, data)
	-- Practically doesn't matter if that trident is a different one, but it should be the same -M
	if owner and data and data.weapon and data.weapon.prefab == "trident" then
		if owner:HasTag("aquatic") then 
			data.weapon.components.weapon:SetDamage( TUNING.SPEAR_DAMAGE*3 )
		else
			data.weapon.components.weapon:SetDamage( TUNING.SPEAR_DAMAGE )
		end
	end
end 

local function onequip(inst, owner) 
	owner.AnimState:OverrideSymbol("swap_object", "swap_trident", "swap_trident")
	owner.AnimState:Show("ARM_carry") 
	owner.AnimState:Hide("ARM_normal")
	
	-- Cleanest way to callback before the damage is actually used -M
	inst:ListenForEvent("onattackother", refreshDamage, owner)
end

local function onunequip(inst, owner) 
	owner.AnimState:Hide("ARM_carry") 
	owner.AnimState:Show("ARM_normal")
	
	inst:RemoveEventCallback("onattackother", refreshDamage, owner)
end

-- local function getDamage(inst)
	-- if inst.components.inventoryitem and inst.components.inventoryitem.owner then 
		-- if inst.components.inventoryitem.owner:HasTag("aquatic") then 
			-- return TUNING.SPEAR_DAMAGE*3
		-- end 
	-- end 
	-- return TUNING.SPEAR_DAMAGE
-- end 

-- local function onattack(inst, attacker, target)
	-- if attacker:HasTag("aquatic") then
		-- inst.components.weapon:SetDamage(TUNING.SPEAR_DAMAGE*3)
	-- else
		-- inst.components.weapon:SetDamage(TUNING.SPEAR_DAMAGE)
	-- end
-- end


local function commonfn(Sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddNetwork()
	
	MakeInventoryPhysics(inst)
	
	inst.AnimState:SetBank("trident")
	inst.AnimState:SetBuild("trident")
	inst.AnimState:PlayAnimation("idle")
	
	inst:AddTag("sharp")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()
	
    if not TheWorld.ismastersim then
        return inst
    end
	
	-------
	
	
	inst:AddComponent("weapon")
	inst.components.weapon:SetDamage(TUNING.SPEAR_DAMAGE)
	-- inst.components.weapon:SetOnAttack(onattack)
	-- inst.components.weapon.getdamagefn = getDamage
	
	inst:AddComponent("finiteuses")
	inst.components.finiteuses:SetMaxUses(TUNING.SPEAR_USES)
	inst.components.finiteuses:SetUses(TUNING.SPEAR_USES)
	
	inst.components.finiteuses:SetOnFinished( onfinished )

	inst:AddComponent("inspectable")
	
	MakeInvItemIA(inst)
	
	inst:AddComponent("equippable")
	inst.components.equippable:SetOnEquip( onequip )
	inst.components.equippable:SetOnUnequip( onunequip )
	
	return inst
end

return Prefab( "trident", commonfn, assets)
%%+%%scripts/prefabs/tropicalfan.lua%%-%%local assets =
{
    Asset("ANIM", "anim/fan_tropical.zip"),
}

local function OnUse(inst, target)
    local x, y, z = target.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x, y, z, TUNING.FEATHERFAN_RADIUS, nil, { "FX", "NOCLICK", "DECOR", "INLIMBO", "playerghost" }, { "smolder", "fire", "player" })
    for i, v in pairs(ents) do
        if v.components.burnable ~= nil then
            -- Extinguish smoldering/fire and reset the propagator to a heat of .2
            v.components.burnable:Extinguish(true, 0)
        end
        if v.components.temperature ~= nil then
            -- cool off yourself and any other nearby players
            v.components.temperature:DoDelta(math.clamp(TUNING.FEATHERFAN_MINIMUM_TEMP - v.components.temperature:GetCurrent(), TUNING.FEATHERFAN_COOLING, 0))
        end
    end
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)

    inst.AnimState:SetBank("fan_tropical")
    inst.AnimState:SetBuild("fan_tropical")
    inst.AnimState:PlayAnimation("idle")

    inst:AddTag("fan")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.LIGHT, TUNING.WINDBLOWN_SCALE_MAX.LIGHT)
	
    inst:AddComponent("inspectable")
    inst:AddComponent("inventoryitem")

    inst:AddComponent("fan")
    inst.components.fan:SetOnUseFn(OnUse)
	inst.components.fan:SetOverrideSymbol("fan01")
	inst.components.fan.overridebuild = "fan_tropical"

    inst:AddComponent("finiteuses")
    inst.components.finiteuses:SetMaxUses(TUNING.FEATHERFAN_USES)
    inst.components.finiteuses:SetUses(TUNING.FEATHERFAN_USES)
    inst.components.finiteuses:SetOnFinished(inst.Remove)
    inst.components.finiteuses:SetConsumption(ACTIONS.FAN, 1)

    MakeHauntableLaunch(inst)

    return inst
end

return Prefab("tropicalfan", fn, assets)
%%+%%scripts/prefabs/tropical_spider_warrior.lua%%-%%local assets = {
    Asset("ANIM", "anim/spider_tropical_build.zip")
}

local prefabs = {
    "spider_warrior"
}

local function fn()
    local inst = Prefabs["spider_warrior"].fn()
    
    inst.AnimState:SetBuild("spider_tropical_build")

    inst.realprefab = "tropical_spider_warrior"

    inst:SetPrefabName("spider_warrior")

    if not TheWorld.ismastersim then
        return inst
    end

    inst.components.combat.poisonous = true

    inst.components.lootdropper:AddRandomLoot("venomgland", .5)

    return inst
end

return Prefab("tropical_spider_warrior", fn, assets, prefabs)%%+%%scripts/prefabs/tunacan.lua%%-%%local assets=
{
	Asset("ANIM", "anim/tuna.zip"),
}

local prefabs =
{
    "fish_med_cooked",
}    

local function fn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst.AnimState:SetBank("tuna")
    inst.AnimState:SetBuild("tuna")
    inst.AnimState:PlayAnimation("idle")
    
    MakeInventoryPhysics(inst)

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
    MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)
    
    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst, "tuna")
    
    inst:AddComponent("tradable")
    inst.components.tradable.goldvalue = 1

    -- inst:AddComponent("useableitem")
    -- inst.components.useableitem.verb = "OPEN"
    -- inst.components.useableitem:SetCanInteractFn(function() return true end)
    -- inst.components.useableitem:SetOnUseFn(function(inst)
        -- inst.SoundEmitter:PlaySound("ia/common/can_open")
        -- local steak = SpawnPrefab("fish_med_cooked")
        -- TheLocalPlayer.components.inventory:GiveItem(steak)
        -- inst:Remove()
    -- end)
	
	inst:AddComponent("unwrappable")
	-- inst.components.unwrappable.itemdata = {{prefab = "fish_med_cooked"}}
	inst.components.unwrappable.onunwrappedfn = function(inst, pos, doer)
        if doer and doer.SoundEmitter then
			doer.SoundEmitter:PlaySound("ia/common/can_open")
		else
			--This sound does not play on client, presumably because the Remove gets networked/processed first. -M
			inst.SoundEmitter:PlaySound("ia/common/can_open")
		end
        inst:Remove()
		local steak = SpawnPrefab("fish_med_cooked")
		if doer and doer.components.inventory then
			--TODO test if we're in the doers inv, remember the slot, and put the steak there. -M
			doer.components.inventory:GiveItem(steak)
		else
			steak.Transform:SetPosition(pos:Get())
			steak.components.inventoryitem:OnDropped(false, .5)
		end
    end
	
    return inst
end

return Prefab("tunacan", fn, assets, prefabs)
%%+%%scripts/prefabs/turbine_blades.lua%%-%%local assets=
{
	Asset("ANIM", "anim/blades.zip"),
}

local function fn()
	local inst = CreateEntity()
    
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    MakeInventoryPhysics(inst)
    
    inst.AnimState:SetBank("blades")
    inst.AnimState:SetBuild("blades")
    inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
    
    MakeInvItemIA(inst)
    
    inst:AddComponent("stackable")
	inst.components.stackable.maxsize = TUNING.STACK_SIZE_LARGEITEM

	return inst
end

return Prefab("turbine_blades", fn, assets)%%+%%scripts/prefabs/twister.lua%%-%%local assets =
{
    Asset("ANIM", "anim/twister_build.zip"),
    Asset("ANIM", "anim/twister_basic.zip"),
    Asset("ANIM", "anim/twister_actions.zip"),
    Asset("ANIM", "anim/twister_seal.zip"),
}

local prefabs =
{
    "collapse_small",
    "turbine_blades",
    "twister_seal",
    "magic_seal",
}

SetSharedLootTable("twister",
{
    {"turbine_blades",   1.00},
})

local TARGET_DIST = 20

local function OnEntitySleep(inst)
    if inst.shouldGoAway then
        inst.shouldGoAway = false
        TheWorld:PushEvent("storetwister", inst)
        inst:Remove()
    end
end

local function CalcSanityAura(inst, observer)
    if inst.components.combat.target then
        return -TUNING.SANITYAURA_HUGE
    end

    return -TUNING.SANITYAURA_LARGE
end

local function RetargetFn(inst)
    return FindEntity(inst, TARGET_DIST, function(guy)
        return inst.components.combat:CanTarget(guy)
    end, nil, {"prey", "smallcreature"})
end

local function KeepTargetFn(inst, target)
    return inst.components.combat:CanTarget(target) 
end

local function OnSave(inst, data)
    data.CanVacuum = inst.CanVacuum
    data.CanCharge = inst.CanCharge
    data.shouldGoAway = inst.shouldGoAway
end

local function OnLoad(inst, data)
    if data then
        inst.CanVacuum = data.CanVacuum
        inst.CanCharge = data.CanCharge
        inst.shouldGoAway = data.shouldGoAway or false
    end
end

local function OnSeasonChange(inst, data)
    inst.shouldGoAway = not TheWorld.state.isspring or inst.shouldGoAway

    if inst:IsAsleep() then
        OnEntitySleep(inst)
    end
end

local function OnAttacked(inst, data)
    inst.components.combat:SetTarget(data.attacker)
    if data.attacker:HasTag("player") then
        inst.shouldGoAway = false
    end
end

local function OnRemove(inst)
    TheWorld:PushEvent("twisterremoved", inst)
end

local function OnDead(inst)
    TheWorld:PushEvent("twisterkilled", inst)
end

local function ontimerdone(inst, data)
    if data.name == "Vacuum" then 
        inst.CanVacuum = true 
    elseif data.name == "Charge" then
        inst.CanCharge = true
    end
end

local function OnKill(inst, data)
    if data and data.victim and data.victim:HasTag("player") then
        inst.shouldGoAway = true
    end
end

local function fn(Sim)
    local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddDynamicShadow()
    inst.entity:AddPhysics()
    inst.entity:AddNetwork()
    
    inst.Transform:SetFourFaced()
    inst.DynamicShadow:SetSize(6, 3.5)
    
    inst.Transform:SetScale(1, 1, 1)

    inst.Physics:SetMass(1000)
    inst.Physics:SetCapsule(1.5, 1)
    inst.Physics:SetFriction(0)
    inst.Physics:SetDamping(5)
    inst.Physics:SetCollisionGroup(COLLISION.CHARACTERS)
    inst.Physics:ClearCollisionMask()
    inst.Physics:CollidesWith(COLLISION.WORLD)
    inst.Physics:CollidesWith(COLLISION.CHARACTERS)
	inst.Physics:CollidesWith(COLLISION.WAVES)

    inst.AnimState:SetBank("twister")
    inst.AnimState:SetBuild("twister_build")
    inst.AnimState:PlayAnimation("idle_loop", true)

    inst:AddTag("amphibious")
	inst:AddTag("epic")
    inst:AddTag("monster")
    inst:AddTag("hostile")
    inst:AddTag("twister")
    inst:AddTag("scarytoprey")
    inst:AddTag("largecreature")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    ------------------

    inst:AddComponent("inventory")
    inst:AddComponent("timer")

    ------------------
    
    inst:AddComponent("sanityaura")
    inst.components.sanityaura.aurafn = CalcSanityAura

    ------------------
    
    inst:AddComponent("health")
    inst.components.health:SetMaxHealth(TUNING.TWISTER_HEALTH)
    inst.components.health.destroytime = 5
    
    ------------------

    inst:AddComponent("combat")
    inst.components.combat:SetDefaultDamage(TUNING.TWISTER_DAMAGE)
    inst.components.combat.playerdamagepercent = TUNING.TWISTER_DAMAGE_PLAYER_PERCENT
    inst.components.combat:SetRange(TUNING.TWISTER_ATTACK_RANGE, TUNING.TWISTER_MELEE_RANGE)
    inst.components.combat:SetAreaDamage(TUNING.TWISTER_MELEE_RANGE, 0.8)
    inst.components.combat:SetAttackPeriod(TUNING.TWISTER_ATTACK_PERIOD)
    inst.components.combat:SetRetargetFunction(3, RetargetFn)
    inst.components.combat:SetKeepTargetFunction(KeepTargetFn)
    --inst.components.combat:SetHurtSound("")
 
    ------------------

    inst:AddComponent("lootdropper")
    inst.components.lootdropper:SetChanceLootTable("twister")
    
    ------------------

    inst:AddComponent("inspectable")
    inst.components.inspectable:RecordViews()

    ------------------

    inst:AddComponent("vacuum")
    inst.components.vacuum:TurnOn()
    inst.components.vacuum.playervacuumdamage = TUNING.TWISTER_VACUUM_DAMAGE
    inst.components.vacuum.playervacuumsanityhit = TUNING.TWISTER_VACUUM_SANITY_HIT
    inst.components.vacuum.vacuumradius = TUNING.TWISTER_VACUUM_DISTANCE
    inst.components.vacuum.playervacuumradius = TUNING.TWISTER_PLAYER_VACUUM_DISTANCE

    ------------------

    inst:AddComponent("locomotor")
    inst.components.locomotor.walkspeed = TUNING.TWISTER_CALM_WALK_SPEED
    inst.components.locomotor.runspeed = TUNING.TWISTER_RUN_SPEED
    inst.components.locomotor:SetShouldRun(true)

    ------------------

    inst:AddComponent("knownlocations")
    
    inst:SetStateGraph("SGtwister")
    local brain = require("brains/twisterbrain")
    inst:SetBrain(brain)

    ------------------
    inst:WatchWorldState("season", OnSeasonChange)

    inst:ListenForEvent("attacked", OnAttacked)
    inst:ListenForEvent("entitysleep", OnEntitySleep)
    inst:ListenForEvent("timerdone", ontimerdone)
    inst:ListenForEvent("killed", OnKill)
    inst:ListenForEvent("death", OnDead)
    inst:ListenForEvent("onremove", OnRemove)

    ------------------

    inst.CanVacuum = true
    inst.CanCharge = true
    inst.shouldGoAway = false
    inst.OnSave = OnSave
    inst.OnLoad = OnLoad

    inst.SoundEmitter:PlaySound("ia/creatures/twister/active_LP", "wind_loop")
    inst.SoundEmitter:SetParameter("wind_loop", "intensity", 0)

    inst.AnimState:Hide("twister_water_fx")
    ------------------

    return inst
end

return Prefab("twister", fn, assets, prefabs)%%+%%scripts/prefabs/twister_seal.lua%%-%%local assets =
{
    Asset("ANIM", "anim/twister_build.zip"),
    Asset("ANIM", "anim/twister_seal.zip"),
}


SetSharedLootTable("twister_seal",
{
	{"meat", 1.00},	
	{"meat", 1.00},	
	{"meat", 1.00},	
	{"meat", 1.00},
	{"magic_seal", 1.00},
	--Drop an item here too?
})

local function OnEntitySleep(inst)
	--This means the player let the seal live.
	--Let the seal escape & leave a gift of some sort behind.
	local seal = SpawnPrefab("magic_seal")
	seal.Transform:SetPosition(inst:GetPosition():Get())
	inst:Remove()
end

local function fn()
    local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddDynamicShadow()
    inst.entity:AddNetwork()

	MakePoisonableCharacter(inst)
	MakeCharacterPhysics(inst, 1000, 1)
	inst.DynamicShadow:SetSize(2.5, 1.5)

	inst.Transform:SetTwoFaced()

	inst.AnimState:SetBank("twister")
	inst.AnimState:SetBuild("twister_build")
	inst.AnimState:PlayAnimation("seal_idle", true)

  	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	inst:AddComponent("inspectable")

	inst:AddComponent("lootdropper")
	inst.components.lootdropper:SetChanceLootTable("twister_seal")

	inst:AddComponent("health")
	inst.components.health:SetMaxHealth(TUNING.TWISTER_SEAL_HEALTH)

	inst:AddComponent("combat")

	inst:SetStateGraph("SGtwister_seal")
	
    local brain = require("brains/twistersealbrain")
    inst:SetBrain(brain)

    inst:DoTaskInTime(1*FRAMES, function()
    	inst:ListenForEvent("entitysleep", OnEntitySleep)
    end)

	return inst
end

return Prefab("twister_seal", fn, assets, {})
%%+%%scripts/prefabs/venomgland.lua%%-%%local assets=
{
  Asset("ANIM", "anim/venom_gland.zip"),
}

local function OnCure(inst, target)
  if target.components.health then
    local currenthealth = target.components.health.currenthealth
    local damage = math.clamp( currenthealth - TUNING.VENOM_GLAND_MIN_HEALTH, 0, TUNING.VENOM_GLAND_DAMAGE )
    target.components.health:DoPoisonDamage(damage)
    target:PushEvent("poisondamage", {damage=damage})
  end
end

local function fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddNetwork()

  MakeInventoryPhysics(inst)

  inst:AddTag("cattoy")
  inst:AddTag("venomgland")

  inst.AnimState:SetBank("venom_gland")
  inst.AnimState:SetBuild("venom_gland")
  inst.AnimState:PlayAnimation("idle")

	MakeInventoryFloatable(inst)
	inst.components.floater:UpdateAnimations("idle_water", "idle")
	
  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN.MEDIUM, TUNING.WINDBLOWN_SCALE_MAX.MEDIUM)

  inst:AddComponent("stackable")

  MakeSmallBurnable(inst, TUNING.TINY_BURNTIME)
  MakeSmallPropagator(inst)

  inst:AddComponent("inspectable")    
  MakeInvItemIA(inst)

  inst:AddComponent("tradable")

  inst:AddComponent("poisonhealer")
  inst.components.poisonhealer.oncure = OnCure

  MakeHauntableLaunch(inst)

  return inst
end

return Prefab( "venomgland", fn, assets)
%%+%%scripts/prefabs/vine.lua%%-%%local assets=
{
  Asset("ANIM", "anim/bush_vine.zip"),
--  Asset("MINIMAP_IMAGE", "vinebush"),
}


local prefabs =
{
  "vine",
  "dug_bush_vine",
  "hacking_fx",
}

local function ontransplantfn(inst)
  if inst.components.hackable then
    inst.components.hackable:MakeBarren()
  end
end

local function dig_up(inst, chopper)
	if inst.components.hackable and inst.components.hackable:CanBeHacked() then
		inst.components.lootdropper:SpawnLootPrefab(inst.components.hackable.product)
	end
	
	if inst.components.diseaseable ~= nil and inst.components.diseaseable:IsBecomingDiseased() then
		SpawnDiseasePuff(inst)
		if chopper then
			chopper:PushEvent("digdiseasing")
		end
	end
	if inst.components.diseaseable ~= nil and inst.components.diseaseable:IsDiseased() then
		inst.components.lootdropper:SpawnLootPrefab("vine")
		SpawnDiseasePuff(inst)
	elseif inst.components.witherable and inst.components.witherable:IsWithered() then
		inst.components.lootdropper:SpawnLootPrefab("vine")
	else
		inst.components.lootdropper:SpawnLootPrefab("dug_bush_vine")
	end
	inst:Remove()
end

local function onregenfn(inst)
  inst.AnimState:PlayAnimation("grow")
  inst.AnimState:PushAnimation("idle", true)
  inst.Physics:SetCollides(true)
end

local function makeemptyfn(inst)
  if not POPULATING and inst.components.witherable and inst.components.witherable:IsWithered() then
    inst.AnimState:PlayAnimation("dead_to_empty")
    inst.AnimState:PushAnimation("hacked_idle")
  else
    inst.AnimState:PlayAnimation("hacked_idle")
  end
  inst.Physics:SetCollides(false)
end

local function makebarrenfn(inst)
  if inst.components.witherable and inst.components.witherable:IsWithered() then
	if POPULATING then
		inst.AnimState:PlayAnimation("idle_dead")
	else
		if not inst.components.hackable.hasbeenhacked then
			inst.AnimState:PlayAnimation("full_to_dead")
		else
			inst.AnimState:PlayAnimation("empty_to_dead")
		end
		inst.AnimState:PushAnimation("idle_dead")
	end
  else
    inst.AnimState:PlayAnimation("idle_dead")
  end
  inst.Physics:SetCollides(true)
end


local function onhackedfn(inst, hacker, hacksleft)
	local fx = SpawnPrefab("hacking_fx")
    local x, y, z= inst.Transform:GetWorldPosition()
    fx.Transform:SetPosition(x,y + math.random()*2,z)

	if(hacksleft <= 0) then

		inst.AnimState:PlayAnimation("disappear")

		if inst.components.diseaseable and inst.components.diseaseable:IsDiseased() then
			SpawnDiseasePuff(inst)
		elseif inst.components.diseaseable and inst.components.diseaseable:IsBecomingDiseased() then
			SpawnDiseasePuff(inst)
			if hacker ~= nil then
				hacker:PushEvent("pickdiseasing")
			end
		end

		if inst.components.hackable and inst.components.hackable:IsBarren() then
			inst.AnimState:PushAnimation("idle_dead")
			inst.Physics:SetCollides(true)
		else
			inst.Physics:SetCollides(false)
			inst.SoundEmitter:PlaySound("ia/common/vine_drop")
			inst.AnimState:PushAnimation("hacked_idle")
		end
	else
		inst.AnimState:PlayAnimation("chop")
		inst.AnimState:PushAnimation("idle")
	end

	inst.SoundEmitter:PlaySound("ia/common/vine_hack")
end

local function inspect_vine(inst)
  if inst:HasTag("burnt") then
    return "BURNT"
  elseif inst:HasTag("stump") then
    return "CHOPPED"
  end
end

local function makefn(stage)
  local function fn()
    local inst = CreateEntity()
    local trans = inst.entity:AddTransform()
    inst.entity:AddAnimState()
    local sound = inst.entity:AddSoundEmitter()
    local minimap = inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .35)

    minimap:SetIcon( "vinebush.tex" )

    inst.AnimState:SetBank("bush_vine")
    inst.AnimState:SetBuild("bush_vine")
    inst.AnimState:PlayAnimation("idle",true)
    inst.AnimState:SetTime(math.random()*2)
    local color = 0.75 + math.random() * 0.25
    inst.AnimState:SetMultColour(color, color, color, 1)

	inst:AddTag("witherable") -- added to pristine state for optimization
    inst:AddTag("vine")
	inst:AddTag("plant")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
      return inst
    end

    inst:AddComponent("hackable")
    inst.components.hackable:SetUp("vine", TUNING.VINE_REGROW_TIME)
    inst.components.hackable.onregenfn = onregenfn
    inst.components.hackable.onhackedfn = onhackedfn
    inst.components.hackable.makeemptyfn = makeemptyfn
    inst.components.hackable.makebarrenfn = makebarrenfn
    inst.components.hackable.max_cycles = 20
    inst.components.hackable.cycles_left = 20
    inst.components.hackable.ontransplantfn = ontransplantfn
    inst.components.hackable.hacksleft = TUNING.VINE_HACKS
    inst.components.hackable.maxhacks = TUNING.VINE_HACKS

	inst:AddComponent("witherable")
	
    if stage == 1 then
      inst.components.hackable:MakeBarren()
    end

    inst:AddComponent("lootdropper")
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = inspect_vine

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.DIG)
    inst.components.workable:SetOnFinishCallback(dig_up)
    inst.components.workable:SetWorkLeft(1)

	MakeHackableBlowInWindGust(inst, TUNING.VINE_WINDBLOWN_SPEED, TUNING.VINE_WINDBLOWN_FALL_CHANCE)

    ---------------------

    MakeMediumBurnable(inst)
    MakeSmallPropagator(inst)

    MakeHauntableIgnite(inst)

    --MakeNoGrowInWinter(inst)

    ---------------------

    return inst
  end

  return fn
end


local function vine(name, stage)
  return Prefab(name, makefn(stage), assets, prefabs)
end

return vine("bush_vine", 0),
vine("depleted_bush_vine", 1)
%%+%%scripts/prefabs/visualboatequip.lua%%-%%local function MakeVisualBoatEquip(name, assets, prefabs, commonfn, masterfn, onreplicate)
    local function fn()
        local inst = CreateEntity()

        inst:AddTag("can_offset_sort_pos")

        inst.entity:AddTransform()
        inst.entity:AddAnimState()
        inst.entity:AddNetwork()

        inst.Transform:SetFourFaced()

        inst:AddTag("NOCLICK")
        inst:AddTag("FX")
        inst:AddTag("nointerpolate")

        inst:AddComponent("boatvisualanims")

        inst:Hide()

        --sigh, why is nothing ever simple.
        inst._showtask = inst:DoPeriodicTask(FRAMES, function(inst)
            if inst.boat and inst.Transform:GetRotation() == inst.boat.Transform:GetRotation() then
                inst:DoTaskInTime(FRAMES, inst.Show)
                inst._showtask:Cancel()
                inst._showtask = nil
            end
        end)

        if commonfn then
            commonfn(inst)
        end

        inst.entity:SetPristine()

        if not TheWorld.ismastersim then
            function inst.OnEntityReplicated(inst)
                inst.boat = inst.entity:GetParent()

                inst.boat.boatvisuals[inst] = true
                inst:ListenForEvent("onremove", function(inst)
                    inst.boat.boatvisuals[inst] = nil
                end)

                inst.Transform:SetRotation(inst.boat.Transform:GetRotation())
                inst:StartUpdatingComponent(inst.components.boatvisualanims)

                if onreplicate then
                    onreplicate(inst)
                end
            end
            return inst
        end

        if masterfn then
            masterfn(inst)
        end

        inst.persists = false

        return inst
    end
    return Prefab("visual_"..name.."_boat", fn, assets, prefabs)
end

return MakeVisualBoatEquip%%+%%scripts/prefabs/volcano.lua%%-%%local BigPopupDialogScreen = require "screens/bigpopupdialog"

local assets =
{
	Asset("ANIM", "anim/volcano.zip"),
}


local function OnSummer(inst, issummer, instant)
    if issummer then
        inst.sg:GoToState(instant and "active" or "dormant_pst")
    else
        inst.sg:GoToState(instant and "dormant" or "active_pst")
    end
end

local function OnWake(inst)
    inst.SoundEmitter:PlaySound("ia/common/volcano/volcano_external_amb", "volcano")
    local state = 1.0
    if inst.sg and inst.sg.currentstate == "dormant" then
        state = 0.0
    end
    inst.SoundEmitter:SetParameter("volcano", "volcano_state", state)
end

local function OnSleep(inst)
    inst.SoundEmitter:KillSound("volcano")
end


-- local maxmod = 70
-- local distToFinish = 10 * 10 --Distance to volcano where you reach max zoom
-- local distToStart = 65 * 65 --Distance from the volcano where you start to zoom

local function CalcCameraDistMod(camera, mod, data)
	local dist = data.inst:GetDistanceSqToPoint(camera.currentpos)
	-- if dist < distToStart then --is in range
	if dist < 4225 then
		mod = mod +
			-- (  dist < distToFinish and maxmod --peak
			(  dist < 100 and 70
			-- or maxmod * (1 - (dist - distToFinish) / (distToStart - distToFinish))  ) --Lerp
			or 70 * (1 - (dist - 100) / 4125)  )
	end
	return mod
end

local function OnRemoveEntity_camera(inst)
	if TheCamera then
		for k, v in pairs(TheCamera.envdistancemods) do
			if v.inst == inst then
				table.remove(TheCamera.envdistancemods, k)
				return
			end
		end
	end
end


local function fn()
	local inst = CreateEntity()
	local trans = inst.entity:AddTransform()

	inst.entity:AddAnimState()
    inst.AnimState:SetBuild("volcano")
    inst.AnimState:SetBank("volcano")
    inst.AnimState:PlayAnimation("dormant_idle", true)

	--use "globalmapiconunderfog" prefab to avoid issue #188 ?
    local minimap = inst.entity:AddMiniMapEntity()
    minimap:SetIcon("volcano.tex")
	
    inst.entity:AddLight()
    inst.Light:SetFalloff(0.4)
    inst.Light:SetIntensity(.7)
    inst.Light:SetRadius(10)
    inst.Light:SetColour(249/255, 130/255, 117/255)
    inst.Light:Enable(true)

    inst.entity:AddPhysics()
 	inst.Physics:SetMass(0)
    inst.Physics:SetCollisionGroup(COLLISION.OBSTACLES)
    inst.Physics:ClearCollisionMask()
    inst.Physics:CollidesWith(COLLISION.ITEMS)
    inst.Physics:CollidesWith(COLLISION.CHARACTERS)
	inst.Physics:CollidesWith(COLLISION.WAVES)
    inst.Physics:SetCapsule(40, 5)
	
    inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	inst:AddTag("theVolcano") -- for rainbow jellyfish
	
    inst.entity:SetPristine()

	if not TheNet:IsDedicated() then
		if TheCamera and TheCamera.envdistancemods then
			table.insert(TheCamera.envdistancemods, {fn = CalcCameraDistMod, inst = inst})
			inst.OnRemoveEntity = OnRemoveEntity_camera
		else
			print(inst,"PANIC! no camera!")
		end
	end

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("inspectable")
	
    -- inst:AddComponent("waveobstacle")
	
	--TODO let players climb the volcano
    -- inst:AddComponent("worldmigrator")

    -- inst:AddComponent("activatable")
    -- inst.components.activatable.OnActivate = OnActivate
    -- inst.components.activatable.inactive = true
    -- inst.components.activatable.getverb =  function()
		-- return STRINGS.ACTIONS.ACTIVATE.CLIMB
	-- end
    -- inst.components.activatable.quickaction = true

    -- inst.OnLoadPostPass = function(inst, ents, data)
    	-- GetWorld().components.volcanomanager:AddVolcano(inst)
	-- end

    -- inst.OnRemoveEntity = function(inst)
    	-- GetWorld().components.volcanomanager:RemoveVolcano(inst)
	-- end

	--TODO handle those elsehow (worldstate probably won't work)
    -- inst:ListenForEvent("OnVolcanoEruptionBegin", function (it)
        -- if inst and inst.sg then
            -- inst.sg:GoToState("erupt")
        -- end
        -- -- print(">>>OnVolcanoEruptionBegin", inst)
    -- end, GetWorld())

    -- inst:ListenForEvent("OnVolcanoEruptionEnd", function (it)
        -- if inst and inst.sg then
            -- inst.sg:GoToState("rumble")
        -- end
        -- -- print(">>>OnVolcanoEruptionEnd", inst)
    -- end, GetWorld())

    -- inst:ListenForEvent("OnVolcanoWarningQuake", function (it)
        -- if inst and inst.sg then
            -- inst.sg:GoToState("rumble")
        -- end
        -- -- print(">>>OnVolcanoEruptionEnd", inst)
    -- end, GetWorld())

    inst:SetStateGraph("SGvolcano")

    OnSummer(inst, TheWorld.state.issummer, true)
    inst:WatchWorldState("issummer", OnSummer)

    inst.OnEntityWake = OnWake
    inst.OnEntitySleep = OnSleep

	return inst
end

return Prefab( "volcano", fn, assets)
%%+%%scripts/prefabs/volcanolavafx.lua%%-%%local prefabs = {
    "lava_erupt",
    "lava_bubbling"
}

local function GetPrefab()
    local vm = TheWorld.components.volcanomanager
    if vm and vm:IsErupting() and math.random() < 0.5 then
        return "lava_erupt"
    end
    return "lava_bubbling"
end

local function CanSpawn(inst, ground, x, y, z)
    return inst:IsPosSurroundedByTileType(x, y, z, 6, GROUND.VOLCANO_LAVA)
end

local function SetRadius(inst, radius)
    inst.radius = radius
    inst.Light:SetRadius(inst.radius)
    inst.components.areaspawner:SetDensityInRange(inst.radius)
end

local function OnEntitySleep(inst)
    inst.components.areaspawner:Stop()
end

local function OnEntityWake(inst)
    inst.components.areaspawner:Start()
end

local function OnSave(inst, data)
    if data then
        data.radius = inst.radius
    end
end

local function OnLoad(inst, data)
    if data and data.radius then
        SetRadius(inst, data.radius)
    end
end

local function fn()
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst.Light:SetIntensity(0.2)
    inst.Light:SetFalloff(2.5)
    inst.Light:SetColour(255/255,84/255,61/255)

    inst:AddTag("FX")
    inst:AddTag("NOCLICK")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false

    inst.OnEntitySleep = OnEntitySleep
    inst.OnEntityWake = OnEntityWake
    inst.OnSave = OnSave
    inst.OnLoad = OnLoad
    inst.SetRadius = SetRadius

    inst:AddComponent("areaspawner")
    inst.components.areaspawner:SetPrefabFn(GetPrefab)
    inst.components.areaspawner:SetSpawnTestFn(CanSpawn)
    inst.components.areaspawner:SetRandomTimes(0.5, 0.25)
    inst.components.areaspawner:SetValidTileType(GROUND.VOLCANO_LAVA)

    return inst
end

return Prefab("volcanolavafx", fn, nil, prefabs)
%%+%%scripts/prefabs/volcano_altar.lua%%-%%require "prefabutil"

local LARGE_APPEASEMENT = TUNING.APPEASEMENT_LARGE
local LARGE_WRATH = TUNING.WRATH_LARGE

local prefabs = {
    "obsidian",
    "volcano_altar_tower",
    "volcano_altar_meter"
}

local baseassets = {
    Asset("ANIM", "anim/volcano_altar_fx.zip"),
}

local towerassets = {
    Asset("ANIM", "anim/volcano_altar.zip"),
}

local meterassets = {
    Asset("ANIM", "anim/volcano_altar.zip"),
}

local pillarassets = {
    Asset("ANIM", "anim/altar_pillar.zip"),
}

local function UpdateMeter(inst)
    --[[
    local sm = GetSeasonManager()
    local vm = GetVolcanoManager()
    if vm:IsFireRaining() then
        inst.components.volcanometer.targetseg = 0
    elseif sm:GetSeason() == SEASONS.DRY then
        inst.components.volcanometer.maxseg = vm:GetNumSegmentsOfEruption() or 67
        inst.components.volcanometer.targetseg = vm:GetNumSegmentsUntilEruption() or inst.components.volcanometer.maxseg
    else]]
        inst.components.volcanometer.maxseg = 10
        inst.components.volcanometer.targetseg = 10
    --end
    inst.components.volcanometer:Start()
end

local function OnGetItemFromPlayer(inst, giver, item)
    --[[
    local vm = TheWorld.components.volcanomanager
    local appeasesegs = item.components.appeasement.appeasementvalue
    vm:Appease(appeasesegs)

    inst.appeasements = inst.appeasements + 1

    if inst.meterprefab then 
        UpdateMeter(inst.meterprefab)
    end

    inst.fullappeased = inst.meterprefab.components.volcanometer.targetseg >= inst.meterprefab.components.volcanometer.maxseg

    if appeasesegs > 0 then
        inst.sg:GoToState("appeased")
    else
        if giver and giver.components.health then
            giver.components.health:DoFireDamage(TUNING.VOLCANO_ALTAR_DAMAGE, inst, true)
        end
        inst.sg:GoToState("unappeased")
    end

    print(string.format("Volcano Altar takes your %d seg appeasement from %s\n", appeasesegs, tostring(item.prefab)))
    --]]
end

local function AcceptTest(inst, item, giver)
    return inst.sg.currentstate.name == "opened"
end

local function SetIsOpen(inst)
    --[[
    local sm = GetSeasonManager()
    local vm = GetVolcanoManager()
    if not inst:FullAppeased() and sm:IsDrySeason() and not vm:IsFireRaining() then
    --if inst.appeasements < TUNING.VOLCANO_ALTAR_MAXAPPEASEMENTS and sm:IsDrySeason() and not vm:IsErupting() then
        if inst.sg.currentstate.name ~= "opened" then
            inst.sg:GoToState("open")
        end
        inst.components.appeasable:Enable()
    else
        if inst.sg.currentstate.name ~= "closed" then
            inst.sg:GoToState("close")
        end
        inst.components.appeasable:Disable()
    end
    --]]
end

local function getstatus(inst)
    if false and inst.components.appeasable.enabled then 
        return "OPEN"
    else
        return "CLOSED"
    end
end

local function onsave(inst, data)
    data.fullappeased = inst.fullappeased
    data.appeasements = inst.appeasements
end

local function onload(inst, data)
    inst.fullappeased = data and data.fullappeased and data.fullappeased == true
    inst.appeasements = (data and data.appeasements) or 0
end

local function onloadpostpass(inst, ents, data)
    SetIsOpen(inst)
end

local function fullappeased(inst)
    return inst.meterprefab and inst.meterprefab.components.volcanometer.targetseg >= inst.meterprefab.components.volcanometer.maxseg
end

local toweroff = 0
local meteroff = 1
local altaroff = 2

local function baseFn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddSoundEmitter()
    inst.entity:AddLight()
    inst.entity:AddNetwork()

    inst.MiniMapEntity:SetPriority(5)
    inst.MiniMapEntity:SetIcon("volcano_altar.tex")
    inst.Transform:SetScale(1,1,1)
    
    MakeObstaclePhysics(inst, 2.0, 1.2)

    inst.AnimState:SetBank("volcano_altar_fx")
    inst.AnimState:SetBuild("volcano_altar_fx")
    inst.AnimState:PlayAnimation("idle_close")
    inst.AnimState:SetFinalOffset(altaroff)

    inst.Light:Enable(true)
    inst.Light:SetIntensity(0.75)
    inst.Light:SetColour(197/255, 197/255, 50/255)
    inst.Light:SetFalloff(0.5)
    inst.Light:SetRadius(2)

    inst:AddTag("altar")
    inst:AddTag("structure")
    inst:AddTag("stone")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
    
    inst:AddComponent("inspectable")
    inst.components.inspectable.getstatus = getstatus

    --[[
    inst:AddComponent("appeasable")
    inst.components.appeasable.onaccept = OnGetItemFromPlayer
    inst.components.appeasable:SetAcceptTest(AcceptTest)
    inst.components.appeasable:Disable()
    --]]

    local function createExtras(inst)
        local x, y, z = inst.Transform:GetWorldPosition()
        inst.meterprefab = SpawnPrefab("volcano_altar_meter")
        inst.meterprefab.Transform:SetPosition(x, y, z)
        inst.towerprefab = SpawnPrefab("volcano_altar_tower")
        inst.towerprefab.Transform:SetPosition(x, y, z)
        UpdateMeter(inst.meterprefab)
        inst.meterprefab.components.volcanometer.curseg = inst.meterprefab.components.volcanometer.targetseg
        inst.meterprefab.components.volcanometer:UpdateMeter()
    end

    inst.fullappeased = false
    inst.appeasements = 0

    inst:DoPeriodicTask(10, SetIsOpen)

    inst:WatchWorldState("season", function(inst, season)
        if season ~= SEASONS.SUMMER then
            inst.appeasements = 0
        end
        SetIsOpen(inst)
    end)

    --[[
    inst:ListenForEvent("OnVolcanoEruptionBegin", function(it, data)
        SetIsOpen(inst)
    end, GetWorld())

    inst:ListenForEvent("OnVolcanoFireRainEnd", function(it, data)
        inst.fullappeased = false
        SetIsOpen(inst)
    end, GetWorld())
    --]]
 
    inst:DoTaskInTime(FRAMES * 1, createExtras)

    inst:SetStateGraph("SGvolcanoaltar")

    inst.OnSave = onsave
    inst.OnLoad = onload
    inst.OnLoadPostPass = onloadpostpass
    inst.FullAppeased = fullappeased

    SetIsOpen(inst)

    return inst
end


local function meterFn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.Transform:SetScale(1,1,1)
    
    inst.AnimState:SetBank("volcano_altar")
    inst.AnimState:SetBuild("volcano_altar")
    inst.AnimState:PlayAnimation("meter")
    inst.AnimState:SetFinalOffset(meteroff)
    inst.AnimState:SetPercent("meter", 0)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false

    inst:AddComponent("volcanometer")
    inst.components.volcanometer.targetseg = 66 --66 seems to the longest time between eruptions but this number really shouldn't be hardcoded.
    inst.components.volcanometer.curseg = 66
    inst.components.volcanometer.maxseg = 66
    inst.components.volcanometer.updatemeterfn = function(inst, perc)
        inst.AnimState:SetPercent("meter", perc)
    end
    inst.components.volcanometer.updatedonefn = function(inst)
        inst:PushEvent("MeterDone")
    end

    UpdateMeter(inst)

    inst:DoPeriodicTask(10, UpdateMeter)

    inst:WatchWorldState("season", function(inst, season)
        UpdateMeter(inst)
        if season == SEASONS.SUMMER then
            inst.components.volcanometer.curseg = inst.components.volcanometer.targetseg
        end
    end)

    --[[
    inst:ListenForEvent("OnVolcanoEruptionBegin", function(it, data)
        UpdateMeter(inst)
    end, GetWorld())

    inst:ListenForEvent("OnVolcanoFireRainEnd", function(it, data)
        UpdateMeter(inst)
    end, GetWorld())
    --]]

    return inst
end

local function towerFn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    inst.Transform:SetScale(1,1,1)
    
    inst.AnimState:SetBank("volcano_altar")
    inst.AnimState:SetBuild("volcano_altar")
    inst.AnimState:PlayAnimation("idle_close")
    inst.AnimState:SetFinalOffset(toweroff)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst.persists = false

    return inst
end

local function pillarFn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, .25)

    inst.Transform:SetScale(1,1,1)
    
    inst.AnimState:SetBank("altar_pillar")
    inst.AnimState:SetBuild("altar_pillar")
    inst.AnimState:PlayAnimation("idle")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    return inst
end



return Prefab("volcano_altar", baseFn, baseassets, prefabs), 
       Prefab("volcano_altar_tower", towerFn, towerassets),
       Prefab("volcano_altar_meter", meterFn, meterassets),  
       Prefab("volcano_altar_pillar", pillarFn, pillarassets)%%+%%scripts/prefabs/volcano_exit.lua%%-%%local assets = {
    Asset("ANIM", "anim/volcano_entrance.zip"),
}

local function fn(Sim)
    local inst = CreateEntity()
    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddLight()
    inst.entity:AddMiniMapEntity()
    inst.entity:AddNetwork()

    MakeObstaclePhysics(inst, 1)
     
    inst.MiniMapEntity:SetIcon("volcano_entrance.tex")
    
    inst.AnimState:SetBank("volcano_entrance")
    inst.AnimState:SetBuild("volcano_entrance")
    inst.AnimState:PlayAnimation("idle")
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(1)

    inst.Light:Enable(true)
    inst.Light:SetIntensity(0.75)
    inst.Light:SetColour(197/255, 197/255, 50/255)
    inst.Light:SetFalloff(0.5)
    inst.Light:SetRadius(1)

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
    
    inst:AddComponent("inspectable")

    --inst:AddComponent("activatable")

    return inst
end

return Prefab("volcano_exit", fn, assets) 
%%+%%scripts/prefabs/volcano_shrub.lua%%-%%local assets = {
	Asset("ANIM", "anim/volcano_shrub.zip"),
}

local prefabs = {
	"ash"
}

local function chopfn(inst)
	RemovePhysicsColliders(inst)
	inst.SoundEmitter:PlaySound("dontstarve/forest/treeCrumble")
	inst.SoundEmitter:PlaySound("dontstarve/wilson/use_axe_tree")
	inst.AnimState:PlayAnimation("break")

	local function animfinish(inst) inst.components.growable:SetStage(1) inst:RemoveEventCallback("animover", animfinish) end
	inst:ListenForEvent("animover", animfinish)

	inst.components.lootdropper:SpawnLootPrefab("ash")
	inst.components.lootdropper:DropLoot()
end

local function SetEmpty(inst)
    local st = TheWorld.state
	local days = st["autumnlength"] + st["winterlength"] + st["springlength"] + st["summerlength"]
	inst.components.growable:StartGrowing(days * TUNING.TOTAL_DAY_TIME)
	inst.Physics:SetCollides(false)
	inst:AddTag("NOCLICK")
	inst.MiniMapEntity:SetEnabled(false)
	inst:Hide()
end

local function SetFull(inst)
	inst.components.workable:SetWorkLeft(1)
	inst.components.growable:StopGrowing()
	inst.AnimState:PlayAnimation("idle", true)
	inst.Physics:SetCollides(true)
	inst:RemoveTag("NOCLICK")
	inst.MiniMapEntity:SetEnabled(true)
	inst:Show()
end

local grow_stages = {
	{name="empty", fn=SetEmpty},
	{name="full", fn=SetFull},
}

local function fn(Sim)
	local inst = CreateEntity()

	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddMiniMapEntity()
	inst.entity:AddNetwork()

	MakeObstaclePhysics(inst, .25)

	inst.AnimState:SetBank("volcano_shrub")
	inst.AnimState:SetBuild("volcano_shrub")
	inst.AnimState:PlayAnimation("idle", true)

	inst.MiniMapEntity:SetIcon("volcano_shrub.png")

	inst:AddTag("burnt")
	inst:AddTag("tree")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.CHOP)
	inst.components.workable:SetWorkLeft(1)
	inst.components.workable:SetOnFinishCallback(chopfn)

	inst:AddComponent("inspectable")
	inst:AddComponent("lootdropper")

	inst:AddComponent("growable")
	inst.components.growable.stages = grow_stages
	inst.components.growable:SetStage(2)
	inst.components.growable.loopstages = false
	inst.components.growable.growonly = false
	inst.components.growable.springgrowth = false
	inst.components.growable.growoffscreen = true

	return inst
end

return Prefab("volcano_shrub", fn, assets, prefabs)%%+%%scripts/prefabs/wallyintro.lua%%-%%local assets =
{
  Asset("ANIM", "anim/parrot_pirate_intro.zip"),
}

local prefabs = {
  "wallyintro_bird",
  "wallyintro_debris_1",
  "wallyintro_debris_2",
  "wallyintro_debris_3",
  "wallyintro_shipmast",
}

local function TakeOff(inst)
  local bird = SpawnPrefab("wallyintro_bird")
  bird.Transform:SetPosition(inst:GetPosition():Get())
  bird.Transform:SetRotation(inst.Transform:GetRotation())
  bird.AnimState:PlayAnimation("takeoff_diagonal_pre")
  local toplayer = (TheLocalPlayer:GetPosition() - inst:GetPosition()):Normalize()

  bird.animoverfn = function()
    bird:RemoveEventCallback("animover", bird.animoverfn)

    bird.AnimState:PlayAnimation("takeoff_diagonal_loop", true)

    bird:DoTaskInTime(2, function() bird:Remove() end)

    bird:DoPeriodicTask(7 * FRAMES, function()
        bird.SoundEmitter:PlaySound("dontstarve/birds/flyin")
      end)

    bird:DoPeriodicTask(0, function()
        local currentpos = bird:GetPosition()
        local flightspeed = 7.5
        local posdelta = Vector3(toplayer.x * flightspeed, flightspeed, toplayer.z * flightspeed) * FRAMES
        local newpos = currentpos + posdelta
        bird.Transform:SetPosition(newpos:Get())
      end)
  end

  bird:ListenForEvent("animover", bird.animoverfn)

  local mast = SpawnPrefab("wallyintro_shipmast")
  mast.Transform:SetPosition(inst:GetPosition():Get())
  mast.Transform:SetRotation(inst.Transform:GetRotation())

  inst:Remove()
end

local PlayPecks = nil
PlayPecks = function(inst)
  inst:RemoveEventCallback("animover", PlayPecks)
  local peckfn = function() 
    if inst then 
      inst.SoundEmitter:PlaySound("ia/creatures/parrot/peck") 
    end
  end
  inst:DoTaskInTime(6*FRAMES, peckfn)
  inst:DoTaskInTime(11*FRAMES, peckfn)
end

local SPEECH =
{
  NULL_SPEECH=
  {
    voice = "dontstarve/maxwell/talk_LP",
    appearanim = "idle_peck",
    idleanim= "idle",
    --dialogpreanim = "dialog_pre",
    dialoganim="speak",
    --dialogpostanim = "dialog_pst",
    disappearanim = TakeOff,
    disableplayer = true,
    skippable = true,
    {
      string = "There is no speech number.", --The string maxwell will say
      wait = 2, --The time this segment will last for
      anim = nil, --If there's a different animation, the animation maxwell will play
      sound = nil, --if there's an extra sound, the sound that will play
    },
    {
      string = nil, 
      wait = 0.5, 
      anim = "smoke", 
      sound = "dontstarve/common/destroy_metal", 
    },
    {
      string = "Go set one.", 
      wait = 2, 
      anim = nil, 
      sound = nil, 
    },
    {
      string = "Goodbye", 
      wait = 1,
      anim = nil,
      sound = "dontstarve/common/destroy_metal",
    },

  },

  SHIPWRECKED_1 =
  {
    voice = "ia/creatures/parrot/chirp",
    idleanim= "idle",
    dialoganim="speak",
    disappearanim = TakeOff,
    disableplayer = true,
    skippable = true,
    {
      string = nil,
      wait = 1,
      anim = "idle",
      pushanim = true,
      sound = nil,
    },
    {
      string = STRINGS.WALLY_SANDBOXINTROS and STRINGS.WALLY_SANDBOXINTROS.ONE or "Mobbstar please update the STRINGS :-p",
      wait = 1,
      anim = nil,
      sound = nil,
    },
    {
      string = nil,
      wait = 3,
      anim = "idle_peck",
      pushanim = true,
      sectionfn = function(inst)
        inst:ListenForEvent("animover", PlayPecks)
      end,
    },
    {
      string = STRINGS.WALLY_SANDBOXINTROS and STRINGS.WALLY_SANDBOXINTROS.TWO or "Mobbstar please update the STRINGS :-p", 
      wait = 0.5, 
      anim = nil, 
      sound = nil,
    },
  },
}

local function onhammered(inst, worker)
  if inst:HasTag("fire") and inst.components.burnable then
    inst.components.burnable:Extinguish()
  end
  inst.components.lootdropper:DropLoot()
  SpawnPrefab("collapse_small").Transform:SetPosition(inst.Transform:GetWorldPosition())
  inst.SoundEmitter:PlaySound("dontstarve/common/destroy_wood")
  inst:Remove()
end

local function onworked(inst, hitanim, anim)
  inst.AnimState:PlayAnimation(hitanim)
  inst.AnimState:PushAnimation(anim)
end

local function fn()  
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()
  inst.Transform:SetTwoFaced()

  inst.AnimState:SetBank("parrot_pirate_intro")
  inst.AnimState:SetBuild("parrot_pirate_intro")
  inst.AnimState:PlayAnimation("idle")

  inst:AddTag("notarget")
  inst:AddTag("wallyintro")

  inst:AddComponent("talker")
  inst.components.talker.fontsize = 40
  inst.components.talker.font = TALKINGFONT
  inst.components.talker.offset = Vector3(0,-550,0)

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(1)
  inst.components.workable:SetOnFinishCallback(onhammered)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:AddChanceLoot("log", 1)

  inst:AddComponent("maxwelltalker")
  inst.components.maxwelltalker.speeches = SPEECH
  inst.components.maxwelltalker.cleartrees = true 

  return inst
end

local function bird_fn()
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.Transform:SetTwoFaced()

  inst.AnimState:SetBank("parrot_pirate_intro")
  inst.AnimState:SetBuild("parrot_pirate_intro")
  inst.AnimState:PlayAnimation("takeoff_diagonal_pre")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst:AddComponent("inspectable")
  inst.components.inspectable.nameoverride = "wallyintro"
  inst.displaynamefn = function(inst) return STRINGS.NAMES["WALLYINTRO"] end

  inst.persists = false

  return inst
end


local function debris_fn(anim, hitanim, workoverride, lootoverride, collision)
  local inst = CreateEntity()
  inst.entity:AddTransform()
  inst.entity:AddAnimState()
  inst.entity:AddSoundEmitter()
  inst.entity:AddNetwork()

  inst.Transform:SetTwoFaced()

  if collision then
    MakeObstaclePhysics(inst, .1)
  end

  inst.AnimState:SetBank("parrot_pirate_intro")
  inst.AnimState:SetBuild("parrot_pirate_intro")
  inst.AnimState:PlayAnimation(anim)

  inst:AddComponent("inspectable")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

  inst.components.inspectable.nameoverride = "wallyintro_debris"
  inst.displaynamefn = function(inst) return STRINGS.NAMES["WALLYINTRO_DEBRIS"] end

  inst:AddComponent("workable")
  inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
  inst.components.workable:SetWorkLeft(workoverride or 1)
  if workoverride and workoverride > 1 then
    inst.components.workable:SetOnWorkCallback(function() onworked(inst, hitanim, anim) end)
  end
  inst.components.workable:SetOnFinishCallback(onhammered)

  inst:AddComponent("lootdropper")
  inst.components.lootdropper:AddChanceLoot(lootoverride or "log", 1)

  MakeSmallBurnable(inst)
  MakeSmallPropagator(inst)

  return inst
end

return Prefab("wallyintro", fn, assets, prefabs),
Prefab("wallyintro_bird", bird_fn, assets),
Prefab("wallyintro_debris_1", function() return debris_fn("debris_1") end, assets),
Prefab("wallyintro_debris_2", function() return debris_fn("debris_2") end, assets),
Prefab("wallyintro_debris_3", function() return debris_fn("debris_3") end, assets),
Prefab("wallyintro_shipmast", function() return debris_fn("idle_empty", "hit", 4, "boatrepairkit", true) end, assets)%%+%%scripts/prefabs/warly_ia.lua%%-%%local MakePlayerCharacter = require "prefabs/player_common"

local assets = {
	Asset("SCRIPT", "scripts/prefabs/player_common.lua"),
	Asset("SOUNDPACKAGE", "sound/ia_warly.fsb"),
	Asset("ANIM", "anim/warly.zip"),
	Asset("ANIM", "anim/ghost_warly_build.zip"),
}
local prefabs = {
	"chefpack",
	"portablecookpot_item",
}

-- Custom starting items
local start_inv = {
	-- "chefpack", --does not spawn properly, check onnewspawn
	"portablecookpot_item",
}


local function refresh_consumed_foods(inst)
	local to_remove = {}
	local timetonext
	for k,v in pairs(inst.consumed_foods) do
		if GetTime() >= v.time_of_reset then
			table.insert(to_remove, k)
		else
			timetonext = math.min(timetonext or TUNING.WARLY_IA_SAME_OLD_COOLDOWN, v.time_of_reset - GetTime()) 
		end
	end

	for k,v in pairs(to_remove) do
		inst.consumed_foods[v] = nil
	end

	if inst.refreshfoodstask then
		inst.refreshfoodstask:Cancel()
	end
	if timetonext then
		inst.refreshfoodstask = inst:DoTaskInTime(timetonext, refresh_consumed_foods)
	else
		inst.refreshfoodstask = nil
	end
end

local function wisecrack(inst, foodstate)
	if foodstate and inst and inst.components.talker and not inst.components.talker.task then
		inst.components.talker:Say(GetString(inst, "ANNOUNCE_EAT", foodstate))
	end
end

local function oneatpre(inst, data)
	local s = 1
	local foodstate
	if data and data.food and data.food.components.edible then
		if data.food:HasTag("preparedfood") then
			--repeat meal penalty
			local prefab = data.food.prefab
			if prefab:sub(-8) == "_gourmet" then
				prefab = prefab:sub(1, -9)
			end
			if inst.consumed_foods[prefab] then
				local stage = math.min(inst.consumed_foods[prefab].count or 1, #TUNING.WARLY_IA_SAME_OLD_MULTIPLIERS)
				s = TUNING.WARLY_IA_SAME_OLD_MULTIPLIERS[stage]
				foodstate = "SAME_OLD_".. stage
			else
				inst.consumed_foods[prefab] = {}
				if prefab == "monstertartare" or prefab == "freshfruitcrepes" then
					foodstate = "TASTY"
				else
					foodstate = "PREPARED"
				end
			end
			if prefab == "wetgoop" then
				foodstate = "PAINFUL"
			end
			inst.consumed_foods[prefab].count = (inst.consumed_foods[prefab].count or 0) + 1
			inst.consumed_foods[prefab].time_of_reset = GetTime() + TUNING.WARLY_IA_SAME_OLD_COOLDOWN
			refresh_consumed_foods(inst)
		elseif data.food.components.edible.foodstate == "COOKED" or string.find(data.food.prefab, "cooked") then
			s = TUNING.WARLY_IA_MULT_COOKED
			foodstate = "COOKED"
		elseif data.food.components.edible.foodstate == "DRIED" or string.find(data.food.prefab, "dried") then
			s = TUNING.WARLY_IA_MULT_DRIED
			foodstate = "DRIED"
		else
			s = TUNING.WARLY_IA_MULT_RAW
			foodstate = "RAW"
		end
	end
	-- print("warly eatmultiplier:",s)
	inst.components.eater:SetAbsorptionModifiers(s, s, s)
	inst:DoTaskInTime(0,wisecrack,foodstate)
end

local function onlongupdate(inst, dt)
	for k,v in pairs(inst.consumed_foods) do
		v.time_of_reset = v.time_of_reset - dt
	end
	refresh_consumed_foods(inst)
end

-- When the character is revived from ghost
-- local function onbecamehuman(inst)
-- end

-- local function onbecameghost(inst)
-- end

-- When loading or spawning the character
local function onload(inst, data)
	-- inst:ListenForEvent("ms_respawnedfromghost", onbecamehuman)
	-- inst:ListenForEvent("ms_becameghost", onbecameghost)

	-- if inst:HasTag("playerghost") then
		-- onbecameghost(inst)
	-- else
		-- onbecamehuman(inst)
	-- end
	
	if data and data.consumed_foods then
		inst.consumed_foods = data.consumed_foods
		refresh_consumed_foods(inst) --kick the timer off
	end
end
local function onsave(inst, data)
	refresh_consumed_foods(inst) --clean up first
	local consumed_foods = {}
	for k,v in pairs(inst.consumed_foods) do
		consumed_foods[k] = {}
		consumed_foods[k].count = v.count
		consumed_foods[k].time_of_reset = v.time_of_reset - GetTime()
	end
	data.consumed_foods = consumed_foods
end

local function onnewspawn(inst)
	onload(inst)
	-- inst:DoTaskInTime(1,function()
		-- inst.components.inventory:GiveItem(SpawnAt("chefpack",inst))
	-- end)
	inst.components.inventory:Equip(SpawnAt("chefpack",inst))
end



local common_postinit = function(inst) 
	inst.MiniMapEntity:SetIcon( "warly.tex" )
	inst:AddTag("warly")
end

local master_postinit = function(inst)
	-- choose which sounds this character will play
	inst.soundsname = "warly"
	inst.talker_path_override = "ia/characters/"
	
	-- inst.components.health:SetMaxHealth(150)
	inst.components.hunger:SetMax(TUNING.WARLY_HUNGER)
	-- inst.components.sanity:SetMax(200)
	
	inst.components.hunger.burnratemodifiers:SetModifier(inst, TUNING.WARLY_IA_HUNGER_RATE_MODIFIER, "warly")
	
	inst:ListenForEvent("oneatpre", oneatpre)
	
	inst.consumed_foods = {}
	
	inst.OnSave = onsave
	inst.OnLoad = onload
	inst.OnNewSpawn = onnewspawn
	inst.OnLongUpdate = onlongupdate
	
end

return MakePlayerCharacter("warly", prefabs, assets, common_postinit, master_postinit, start_inv)
%%+%%scripts/prefabs/warly_ia_none.lua%%-%%local assets = {
	Asset( "ANIM", "anim/warly.zip" ),
	Asset( "ANIM", "anim/ghost_warly_build.zip" ),
}

return CreatePrefabSkin("warly_none",
{
	base_prefab = "warly", 
	type = "base",
	build_name_override = "warly",
	rarity = "Character",
	skin_tags = { "BASE", "WARLY", },
	skins = { normal_skin = "warly", ghost_skin = "ghost_warly_build", },
	release_group = 0,
	
	-- bigportrait = { build = "bigportraits/warly_none.xml", symbol = "warly_none_oval.tex"},
	
	assets = assets,
	skip_item_gen = true,
	skip_giftable_gen = true,
})%%+%%scripts/prefabs/wave_ripple.lua%%-%%local waveassets =
{
	Asset( "ANIM", "anim/wave_ripple.zip" ),
}

local rogueassets = 
{
    Asset( "ANIM", "anim/wave_rogue.zip" ),
}

local function wetanddamage(inst, other)
	if not other then return end
    --get wet and take damage 
	local boat
	if other.components.sailor then
		boat = other.components.sailor:GetBoat()
	end
    if other.components.moisture then 
        local hitmoisturerate = 1
        if boat and boat.components.sailable then
            hitmoisturerate = boat.components.sailable:GetHitMoistureRate()
        end
        local waterproofMultiplier = 1 
        if other.components.inventory then 
            waterproofMultiplier = 1 - other.components.inventory:GetWaterproofness()
        end 
        other.components.moisture:DoDelta(inst.hitmoisture * hitmoisturerate * waterproofMultiplier)
    end 
    if boat and boat.components.boathealth then
        boat.components.boathealth:DoDelta(inst.hitdamage, "wave")
    end 
end

local function splash(inst)
    SpawnAt("splash_water", inst)
    inst:Remove()
end 


local function oncollidewave(inst, other)
    local boostThreshold = TUNING.WAVE_BOOST_ANGLE_THRESHOLD
    if other and other:HasTag("player") and not other:HasTag("playerghost") and not other.ignorewaves then
        local moving = other.sg:HasStateTag("moving")
		if other.SoundEmitter then
			other.SoundEmitter:PlaySound("ia/common/waves/break")
		end

        local playerAngle =  other.Transform:GetRotation()
        if playerAngle < 0 then playerAngle = playerAngle + 360 end 

        local waveAngle = inst.Transform:GetRotation()
        if waveAngle < 0 then waveAngle = waveAngle + 360 end 

        local angleDiff = math.abs(waveAngle - playerAngle)
        if angleDiff > 180 then angleDiff = 360 - angleDiff end

        local surfer = false
        if other.components.locomotor then
            surfer = other.components.locomotor:GetExternalSpeedAdder(other, "SURF") ~= 0
        end

        if (angleDiff < boostThreshold or surfer) and moving then
            --Do boost
            local rogueboost
            if other.components.sailor and other.components.sailor.boat and other.components.sailor.boat:HasTag("surfboard") and inst.prefab == "wave_rogue" then
                rogueboost = TUNING.SURFBOARD_ROGUEBOOST
            end
            other:PushEvent("boostbywave", {position = inst.Transform:GetWorldPosition(), velocity = inst.Physics:GetVelocity(), boost = rogueboost})
			if other.SoundEmitter then
				other.SoundEmitter:PlaySound("ia/common/waves/boost")
			end
        elseif not surfer then
            wetanddamage(inst, other)
        end 

        splash(inst)
    elseif other and other.components.waveobstacle then
        other.components.waveobstacle:OnCollide(inst)
        wetanddamage(inst, other)
        splash(inst)
    end
end 


local function oncolliderogue(inst, other)
    -- check for surfboard, which actually just boosts
    if other and other:HasTag("player") and not other:HasTag("playerghost") and not other.ignorewaves then
        local surfer = false
        if other.components.locomotor then
            surfer = other.components.locomotor:GetExternalSpeedAdder(other, "SURF") ~= 0
        end

        if surfer or (other.components.sailor and other.components.sailor.boat and other.components.sailor.boat:HasTag("surfboard")) then
            oncollidewave(inst, other)
            return
        else
            wetanddamage(inst, other)
            splash(inst)
            return 
        end
    end

    if other and other.components.waveobstacle then
        other.components.waveobstacle:OnCollide(inst)
        wetanddamage(inst, other)
        splash(inst)
    end
end

local function CheckGround(inst, dt)
    --Check if I'm about to hit land 
    local x, y, z = inst.Transform:GetWorldPosition()
    local vx, vy, vz = inst.Physics:GetVelocity()
    
    local tile = GROUND.DIRT
    if TheWorld.Map then
        tile = TheWorld.Map:GetTileAtPoint(x + vx, y, z + vz)
    end

    if not IsWater(tile) then 
        splash(inst)
    end
end 

local function onsave(inst, data)
    if inst and data then
        data.speed = inst.Physics:GetMotorSpeed()
        data.angle = inst.Transform:GetRotation()
        if inst.sg and inst.sg.currentstate and inst.sg.currentstate.name then
            data.state = inst.sg.currentstate.name
        end
    end
end

local function onload(inst, data)
    if inst and data then
        inst.Transform:SetRotation(data.angle or 0)
        inst.Physics:SetMotorVel(data.speed or 0, 0, 0)
        if inst.sg and data.state then
            inst.sg:GoToState(data.state)
        end
    end
end

local function activate_collision(inst)
	inst.Physics:SetCollisionGroup(COLLISION.WAVES)
	inst.Physics:CollidesWith(COLLISION.CHARACTERS)
    inst.Physics:CollidesWith(COLLISION.GIANTS)
	inst.Physics:CollidesWith(COLLISION.OBSTACLES)
    inst.Physics:CollidesWith(COLLISION.SMALLOBSTACLES)
end

local function onRemove(inst)
    if inst and inst.soundloop then
        inst.SoundEmitter:KillSound(inst.soundloop)
    end
end

local function onSleep(inst)
    inst:Remove()
end

local function fn_common()
	local inst = CreateEntity()
	inst.entity:AddTransform()
    inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()
	
    inst.Transform:SetFourFaced()
	
    inst.entity:AddPhysics()
    inst.Physics:SetSphere(1)
    inst.Physics:ClearCollisionMask()
    --Zarklord: if this is inside activate_collision, the wave doesnt move until activate_collision gets called, moving it here causes it to behave like SW(move immediatly).
    inst.Physics:SetCollides(false) --Still will get collision callback, just not dynamic collisions.
	
    inst:AddTag("FX")
	inst:AddTag("aquatic")
	
	return inst
end

local function fn_master(inst)
	inst.checkgroundtask = inst:DoPeriodicTask(0.5, CheckGround)
	
	inst.OnEntitySleep = onSleep
	inst.done = false
	
    inst:SetStateGraph("SGwave")
    inst.activate_collision = activate_collision

	return inst
end 

local function ripple()
	local inst = fn_common()
	
    inst.entity:AddAnimState()
    inst.AnimState:SetBuild("wave_ripple")
	inst.AnimState:SetBank("wave_ripple")
	
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end
	
	fn_master(inst)

    inst.persists = false
	
    inst.Physics:SetCollisionCallback(oncollidewave)
	
	inst.hitdamage = -TUNING.WAVE_HIT_DAMAGE
	inst.hitmoisture = TUNING.WAVE_HIT_MOISTURE
	
	inst.soundrise = "ia/common/waves/small"
	
	return inst
end

local function rogue()
	local inst = fn_common()
	
    inst.entity:AddAnimState()
    inst.AnimState:SetBuild("wave_rogue")
	inst.AnimState:SetBank("wave_rogue")
	
    inst.entity:SetPristine()
  
    if not TheWorld.ismastersim then
        return inst
    end
	
	fn_master(inst)
	
    inst.Physics:SetCollisionCallback(oncolliderogue)
	
    inst.hitdamage = -TUNING.ROGUEWAVE_HIT_DAMAGE
    inst.hitmoisture = TUNING.ROGUEWAVE_HIT_MOISTURE

    inst.idle_time = 1
    
    inst.soundrise = "ia/common/waves/large"
    inst.soundloop = "ia/common/waves/large_LP"
    inst.soundtidal = "ia/common/waves/tidal"

    inst:ListenForEvent("onremove", onRemove)
	
	inst.OnSave = onsave
	inst.OnLoad = onload
	
	return inst
end


return Prefab("wave_ripple", ripple, waveassets), 
       Prefab("wave_rogue", rogue, rogueassets)
%%+%%scripts/prefabs/wave_shimmer.lua%%-%%local assets =
{
	Asset( "ANIM", "anim/wave_shimmer.zip" ),
	Asset( "ANIM", "anim/wave_shimmer_med.zip" ),
	Asset( "ANIM", "anim/wave_shimmer_deep.zip" ),
	Asset( "ANIM", "anim/wave_shimmer_river.zip" ),
	Asset( "ANIM", "anim/wave_shimmer_flood.zip" ),
	Asset( "ANIM", "anim/wave_hurricane.zip" )
}

local function onSleep(inst)
	inst:Remove()
end

local function animover(inst)
	inst:Remove()
end

local function commonfn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()

	inst.AnimState:SetBank("wave_hurricane")
	inst.AnimState:SetBuild("wave_hurricane")
	-- inst.AnimState:PlayAnimation( "idle", false )
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(ANIM_SORT_ORDER.OCEAN_WAVES)

	inst:AddTag("FX")
	inst:AddTag("NOCLICK")
	inst:AddTag("NOBLOCK")
	inst:AddTag("ignorewalkableplatforms")
	
	inst.persists = false

	inst.OnEntitySleep = onSleep
	inst:ListenForEvent( "animover", animover )
	
    return inst
end

local function shallowfn()
	local inst = commonfn()
	if TheWorld.state.iswinter then
		-- local ocean = GetWorld().components.ocean
		-- inst.Transform:SetRotation(-ocean:GetCurrentAngle())
		inst.Transform:SetTwoFaced()
	    inst.AnimState:SetBuild( "wave_hurricane" )
	    inst.AnimState:SetBank( "wave_hurricane" )
	    inst.AnimState:PlayAnimation( "idle_small", false )
	else
	    inst.AnimState:SetBuild( "wave_shimmer" )
	    inst.AnimState:SetBank( "shimmer" )
	    inst.AnimState:PlayAnimation( "idle", false )
	end
	return inst
end

local function medfn()
	local inst = commonfn()
	if TheWorld.state.iswinter then
		-- local ocean = GetWorld().components.ocean
		-- inst.Transform:SetRotation(-ocean:GetCurrentAngle())
		inst.Transform:SetTwoFaced()
	    inst.AnimState:SetBuild( "wave_hurricane" )
	    inst.AnimState:SetBank( "wave_hurricane" )
	    inst.AnimState:PlayAnimation( "idle_med", false )
	else
	    inst.AnimState:SetBuild( "wave_shimmer_med" )
	    inst.AnimState:SetBank( "shimmer" )
	    inst.AnimState:PlayAnimation( "idle", false )
	end
	return inst
end

local function deepfn()
	local inst = commonfn()
	if TheWorld.state.iswinter then
		-- local ocean = GetWorld().components.ocean
		-- inst.Transform:SetRotation(-ocean:GetCurrentAngle())
		inst.Transform:SetTwoFaced()
	    inst.AnimState:SetBuild( "wave_hurricane" )
	    inst.AnimState:SetBank( "wave_hurricane" )
	    inst.AnimState:PlayAnimation( "idle_deep", false )
	else
	    inst.AnimState:SetBuild( "wave_shimmer_deep" )
	    inst.AnimState:SetBank( "shimmer_deep" )
	    inst.AnimState:PlayAnimation( "idle", false )
	end
	return inst
end

local function floodfn(Sim)
	local inst = commonfn()
    inst.AnimState:SetBuild( "wave_shimmer_flood" )
    inst.AnimState:SetBank( "wave_shimmer_flood" )
    inst.AnimState:PlayAnimation( "idle", false )
	return inst
end

local function riverfn(Sim)
	local inst = commonfn()
    inst.AnimState:SetBuild( "wave_shimmer_river" )
    inst.AnimState:SetBank( "shimmer" )
    inst.AnimState:PlayAnimation( "a".. math.random(2), false )
	return inst
end

return Prefab( "wave_shimmer", shallowfn, assets ),
		Prefab( "wave_shimmer_med", medfn, assets ),
		Prefab( "wave_shimmer_deep", deepfn, assets ),
		Prefab( "wave_shimmer_river", riverfn, assets ),
		Prefab( "wave_shimmer_flood", floodfn, assets )
%%+%%scripts/prefabs/wave_shore.lua%%-%%local assets =
{
	Asset( "ANIM", "anim/wave_shore.zip" )
}

local function onSleep(inst)
	inst:Remove()
end

local function SetAnim(inst)
	local ex, ey, ez = inst.Transform:GetWorldPosition()
	local bearing = -(inst.Transform:GetRotation() + 90) * DEGREES

	local map = TheWorld.Map
	local xr45, yr45 = map:GetTileXYAtPoint(ex + math.cos(bearing - 0.25*math.pi), ey, ez + math.sin(bearing - 0.25*math.pi))
	local xr90, yr90 = map:GetTileXYAtPoint(ex + math.cos(bearing - 0.5*math.pi), ey, ez + math.sin(bearing - 0.5*math.pi))
	local xl45, yl45 = map:GetTileXYAtPoint(ex + math.cos(bearing + 0.25*math.pi), ey, ez + math.sin(bearing + 0.25*math.pi))
	local xl90, yl90 = map:GetTileXYAtPoint(ex + math.cos(bearing + 0.5*math.pi), ey, ez + math.sin(bearing + 0.5*math.pi))

	local left = not IsWater(map:GetTile(xl45, yl45)) and IsWater(map:GetTile(xl90, yl90))
	local right = not IsWater(map:GetTile(xr45, yr45)) and IsWater(map:GetTile(xr90, yr90))

	if left and right then
		inst.AnimState:PlayAnimation("idle_big", false)
	elseif left then
		inst.Transform:SetPosition(ex - 0.5 * TILE_SCALE * math.cos(bearing - 0.5*math.pi), ey, ez - 0.5 * TILE_SCALE * math.sin(bearing - 0.5*math.pi))
		inst.AnimState:PlayAnimation("idle_med", false)
	elseif right then
		inst.Transform:SetPosition(ex + 0.5 * TILE_SCALE * math.cos(bearing - 0.5*math.pi), ey, ez + 0.5 * TILE_SCALE * math.sin(bearing - 0.5*math.pi))
		inst.AnimState:PlayAnimation("idle_med", false)
	else
		local small = {"idle_small", "idle_small2", "idle_small3", "idle_small4"}
		inst.AnimState:PlayAnimation(small[math.random(1, #small)], false)
	end
end

local function fn(Sim)
    local inst = CreateEntity()

    inst.entity:AddTransform()
	inst.entity:AddAnimState()

	inst.AnimState:SetBank("wave_shore")
	inst.AnimState:SetBuild("wave_shore")
    inst.AnimState:PlayAnimation( "idle_small", false )
    inst.AnimState:SetOrientation( ANIM_ORIENTATION.OnGround )
    inst.AnimState:SetLayer(LAYER_BACKGROUND)
    inst.AnimState:SetSortOrder(ANIM_SORT_ORDER.OCEAN_WAVES)
	
	inst:AddTag("FX")
	inst:AddTag("NOCLICK")
	inst:AddTag("NOBLOCK")
	inst:AddTag("ignorewalkableplatforms")
	
	inst.persists = false

	inst.OnEntitySleep = onSleep
	inst:ListenForEvent( "animover", function(inst) inst:Remove() end )

	inst.SetAnim = SetAnim

    return inst
end

return Prefab( "wave_shore", fn, assets )
%%+%%scripts/prefabs/whale.lua%%-%%local bluebrain = require "brains/bluewhalebrain"
local whitebrain = require "brains/whitewhalebrain"
require "stategraphs/SGwhale"

local assets_blue=
{
	Asset("ANIM", "anim/whale.zip"),
	Asset("ANIM", "anim/whale_blue_build.zip"),
	-- Asset("SOUND", "sound/koalefant.fsb"),
}
local assets_white=
{
	Asset("ANIM", "anim/whale.zip"),
	Asset("ANIM", "anim/whale_moby_build.zip"),
	-- Asset("SOUND", "sound/koalefant.fsb"),
}

local prefabs =
{
	"fish_med_cooked",
	"boneshard",
	"whale_carcass_blue",
	"whale_carcass_white",
	"whale_bubbles",
	"whale_track",
}

local bluesounds = 
{
	death = "ia/creatures/blue_whale/death",
	hit = "ia/creatures/blue_whale/hit",
	idle = "ia/creatures/blue_whale/idle",
	breach_swim = "ia/creatures/blue_whale/breach_swim",
	sleep = "ia/creatures/blue_whale/sleep",
	rear_attack = "ia/creatures/blue_whale/rear_attack",
	mouth_open = "ia/creatures/blue_whale/mouth_open",
	bite_chomp = "ia/creatures/blue_whale/chomp",
	bite = "ia/creatures/blue_whale/bite",
}

local whitesounds = 
{
	death = "ia/creatures/white_whale/death",
	hit = "ia/creatures/white_whale/hit",
	idle = "ia/creatures/white_whale/idle",
	breach_swim = "ia/creatures/white_whale/breach_swim",
	sleep = "ia/creatures/white_whale/sleep",
	rear_attack = "ia/creatures/white_whale/rear_attack",
	mouth_open = "ia/creatures/white_whale/mouth_open",
	bite_chomp = "ia/creatures/white_whale/chomp",
	bite = "ia/creatures/white_whale/bite",
}

local loot_blue = {"fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","boneshard","boneshard","boneshard","boneshard"}
local loot_white = {"fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","fish_med_cooked","boneshard","boneshard","boneshard","boneshard"}


local WAKE_TO_RUN_DISTANCE = 10
local SLEEP_NEAR_ENEMY_DISTANCE = 14

local function ShouldWakeUp(inst)
    local x, y, z = inst.Transform:GetWorldPosition()
	return DefaultWakeTest(inst) or IsAnyPlayerInRange(x, y, z, WAKE_TO_RUN_DISTANCE)
end

local function ShouldSleep(inst)
    -- local x, y, z = inst.Transform:GetWorldPosition()
	-- return DefaultSleepTest(inst) and not IsAnyPlayerInRange(x, y, z, SLEEP_NEAR_ENEMY_DISTANCE)
	return false --only sleep from items
end

local function OnAttacked(inst, data)
	inst.components.combat:SetTarget(data.attacker)
	inst.components.combat:ShareTarget(data.attacker, 30,function(dude)
		return dude:HasTag("whale") and not dude:HasTag("player") and not dude.components.health:IsDead()
	end, 5)
end

local function OnEntityWake(inst)
	inst.components.tiletracker:Start()
end

local function OnEntitySleep(inst)
	inst.components.tiletracker:Stop()
end

local function OnLoad(inst, data)
	if not data then
		return
	end
	
	inst.hitshallow = data.hitshallow
end

local function OnSave(inst, data)
	data.hitshallow = inst.hitshallow
end

local function fn_common()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()
	inst.Transform:SetFourFaced()

	MakeCharacterPhysics(inst, 140, .75)

	inst.AnimState:SetBank("whale")
	inst.AnimState:PlayAnimation("idle", true)

	inst:AddTag("whale")
	inst:AddTag("animal")
	inst:AddTag("largecreature")
	inst:AddTag("aquatic")
	-- inst:AddTag("scarytoprey")
	
	return inst
end

local function fn_master(inst)
	inst:AddComponent("combat")

	inst:ListenForEvent("attacked", function(inst, data) OnAttacked(inst, data) end)

	inst:AddComponent("health")

	inst:AddComponent("inspectable")

	MakePoisonableCharacter(inst)
	MakeLargeFreezableCharacter(inst)

	inst:AddComponent("knownlocations")
	inst:AddComponent("locomotor")

	inst:AddComponent("sleeper")
	inst.components.sleeper.onlysleepsfromitems = true 
	inst.components.sleeper:SetSleepTest(ShouldSleep)
	inst.components.sleeper:SetWakeTest(ShouldWakeUp)

	inst:SetStateGraph("SGwhale")

	inst:AddComponent("tiletracker")
	-- inst.components.tiletracker:SetOnWaterChangeFn(OnWaterChange)

	inst.OnEntityWake = OnEntityWake
	inst.OnEntitySleep = OnEntitySleep

	inst.OnLoad = OnLoad
	inst.OnSave = OnSave
end

local function KeepTargetBlue(inst, target)
	return inst:IsNear(target, TUNING.WHALE_BLUE_CHASE_DIST)
end

local function fn_blue(sim)
	local inst = fn_common(sim)

	inst.AnimState:SetBuild("whale_blue_build")
	inst.carcass = "whale_carcass_blue"

	inst.sounds = bluesounds
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end

	fn_master(inst)
	
	inst.components.combat:SetHurtSound(inst.sounds.hit)

	inst.components.locomotor.walkspeed = TUNING.WHALE_BLUE_SPEED * 0.5
	inst.components.locomotor.runspeed = TUNING.WHALE_BLUE_SPEED

	inst.components.combat:SetKeepTargetFunction(KeepTargetBlue)
	inst.components.combat:SetDefaultDamage(TUNING.WHALE_BLUE_DAMAGE)
	inst.components.combat:SetAttackPeriod(3.5)

	inst.components.health:SetMaxHealth(TUNING.WHALE_BLUE_HEALTH)

	inst.components.sleeper:SetResistance(3)

	inst:SetBrain(bluebrain)

	return inst
end

local function KeepTargetWhite(inst, target)
	return inst:IsNear(target, TUNING.WHALE_WHITE_CHASE_DIST)
end

local function RetargetWhite(inst)
	--White Whale is aggressive. Look for targets.
	local notags = {"FX", "NOCLICK","INLIMBO"}
    return FindEntity(inst, TUNING.WHALE_WHITE_TARGET_DIST, function(guy) 
        return inst.components.combat:CanTarget(guy) and guy:HasTag("aquatic")
    end, nil, notags)
end

local function fn_white(sim)
	local inst = fn_common(sim)

	local s = 1.25
	inst.Transform:SetScale(s,s,s)

	inst.AnimState:SetBuild("whale_moby_build")
	inst.carcass = "whale_carcass_white"

	inst.sounds = whitesounds
	
	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	fn_master(inst)
	
	inst.components.combat:SetHurtSound(inst.sounds.hit)

	inst.components.locomotor.walkspeed = TUNING.WHALE_WHITE_SPEED * 0.5
	inst.components.locomotor.runspeed = TUNING.WHALE_WHITE_SPEED

	inst.components.combat:SetKeepTargetFunction(KeepTargetWhite)
	inst.components.combat:SetDefaultDamage(TUNING.WHALE_WHITE_DAMAGE)
	inst.components.combat:SetRetargetFunction(1, RetargetWhite)
	inst.components.combat:SetAttackPeriod(3)

	inst.components.health:SetMaxHealth(TUNING.WHALE_WHITE_HEALTH)

	inst.components.sleeper:SetResistance(5)

	inst:SetBrain(whitebrain)

	return inst
end

return Prefab( "whale_blue", fn_blue, assets_blue, prefabs),
	   Prefab( "whale_white", fn_white, assets_white, prefabs)
%%+%%scripts/prefabs/whale_bubbles.lua%%-%%local assets =
{
	Asset("ANIM", "anim/whale_tracks.zip"),
	Asset("ANIM", "anim/whale_bubbles.zip"),
	Asset("ANIM", "anim/whale_bubble_follow.zip"),
}

local prefabs =
{
	-- "small_puff"
}

local function GetVerb(inst)
	return "INVESTIGATE"
end

local function addbubblefx(inst)
	local fx = SpawnPrefab("whale_bubbles_fx")
	fx.entity:SetParent(inst.entity)
    fx.AnimState:SetTime(math.random())
	local offset = Vector3(math.random(-1, 1) * math.random(), 0, math.random(-1, 1) * math.random())
	fx.Transform:SetPosition(offset:Get())
end

local function OnInvestigated(inst, doer)
	local pt = Vector3(inst.Transform:GetWorldPosition())
	if TheWorld.components.whalehunter then
		TheWorld.components.whalehunter:OnDirtInvestigated(pt, doer)
	end
	inst.AnimState:PlayAnimation("bubble_pst")
    inst:ListenForEvent("animover", inst.Remove)
end

local function bubblefn(sim)
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	-- inst.entity:AddPhysics()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("whaletrack")
	inst.AnimState:SetBuild("whale_tracks")
	inst.AnimState:PlayAnimation("bubble_pre")
	inst.AnimState:PushAnimation("bubble_loop", true)
	inst.AnimState:SetRayTestOnBB(true);
    inst.AnimState:SetOrientation( ANIM_ORIENTATION.OnGround )
    inst.AnimState:SetLayer( LAYER_BACKGROUND )
    inst.AnimState:SetSortOrder( 3 )

    inst.SoundEmitter:PlaySound("ia/common/whale_trail/discovery_LP", "discovery_LP")
	
    inst.GetActivateVerb = GetVerb

	inst:AddTag("dirtpile")
    inst.no_wet_prefix = true

	local numbubbles = math.random(2, 4)

	for i = 0, numbubbles do
		addbubblefx(inst)
	end
    
	inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end
	
	inst:AddComponent("inspectable")
	inst:AddComponent("activatable")
	-- set required
	inst.components.activatable.OnActivate = OnInvestigated
	inst.components.activatable.inactive = true
	-- inst.components.activatable.getverb = GetVerb
	
    inst:AddComponent("hauntable")
    inst.components.hauntable:SetHauntValue(TUNING.HAUNT_SMALL)
    inst.components.hauntable:SetOnHauntFn(function(inst, haunter)
        OnInvestigated(inst, haunter)
        return true
    end)
	
    inst.persists = false

	return inst
end

local function trackfn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	-- inst.entity:AddPhysics()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("whalebubblefollow")
	inst.AnimState:SetBuild("whale_bubble_follow")
	inst.AnimState:PlayAnimation("bubblepop")

	inst.SoundEmitter:PlaySound("ia/common/whale_trail/bubble_pop")

	inst:AddTag("track")
	inst:AddTag("FX")
	inst:AddTag("NOCLICK")
    
	inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:ListenForEvent("animover", inst.Remove)
	
    inst.persists = false

	return inst
end

local function fxfn()
	local inst = CreateEntity()
	inst.entity:AddTransform()
	inst.entity:AddAnimState()
	-- inst.entity:AddPhysics()
	inst.entity:AddSoundEmitter()
	-- inst.entity:AddNetwork()
	--[[Non-networked entity]]

	MakeInventoryPhysics(inst)

	inst.AnimState:SetBank("whalebubbles")
	inst.AnimState:SetBuild("whale_bubbles")
	inst.AnimState:PlayAnimation("bubble_loop", true)

    -- inst.SoundEmitter:PlaySound("ia/common/whale_trail/discovery_LP", "discovery_LP")

	-- inst.entity:SetCanSleep(false)
	inst.persists = false

	inst:AddTag("FX")
	inst:AddTag("NOCLICK")

	return inst
end

return Prefab( "whale_bubbles", bubblefn, assets, prefabs),
Prefab("whale_bubbles_fx", fxfn, assets, prefabs),
Prefab("whale_track", trackfn, assets, prefabs)
%%+%%scripts/prefabs/whale_carcass.lua%%-%%local assets_blue = {
	Asset("ANIM", "anim/whale_carcass.zip"),
	Asset("ANIM", "anim/whale_carcass_build.zip"),
	-- Asset("MINIMAP_IMAGE", "whale_carcass"),
}
local assets_white = {
	Asset("ANIM", "anim/whale_carcass.zip"),
	Asset("ANIM", "anim/whale_moby_carcass_build.zip"),
	-- Asset("MINIMAP_IMAGE", "whale_carcass"),
}

local prefabs = {
	"fish_small",
	"boneshard",
	"coconade",
	"tophat",
	"sail_palmleaf",
	"gashat",
	"blowdart_sleep",
	"blowdart_poison",
	"blowdart_fire",
	"cutlass",
	"sail_cloth",
	"lobster_dead",
	"spear_launcher",
	"coconut",
	"boat_lantern",
	"bottlelantern",
	"telescope",
	"captainhat",
	"piratehat",
	"spear",
	"seatrap",
	"machete",
	"messagebottleempty",
	-- "fish_small",
	-- "boneshard",
	"seaweed",
	"seashell",
	"jellyfish",
	"coral",
	"harpoon",
	"blubber",
	"bamboo",
	"vine",
}

local alwaysloot_blue = {"blubber","blubber","blubber","blubber","fish_small","fish_small","fish_small","fish_small"}
local alwaysloot_white = {"blubber","blubber","blubber","blubber","fish_small","fish_small","fish_small","fish_small","harpoon","boneshard"}


local loots = {
	{
		-- LOW % ITEMS, 2 of these are picked
		"coconade",
		--"raft", -- flies away
		"tophat",
		"sail_palmleaf",
		"gashat",
		--"boatcannon",
		"blowdart_sleep",
		"blowdart_poison",
		"blowdart_fire",
		"cutlass",
	},
	{
		--MEDIUM % ITEMS, 3 of these
		"sail_cloth",
		"lobster_dead",
		"spear_launcher",
		"coconut",
		"boat_lantern",
		"bottlelantern",
		"telescope",
		"captainhat",
		"piratehat",
		"spear",
		"seatrap",
		"machete",
		"messagebottleempty",
	},
	{
		--HIGH % ITEMS, 4 of these
		"blubber",
		"fish_small",
		"boneshard",
		"seaweed",
		-- "seashell",
		"jellyfish",
		"coral",
		"vine",
		"bamboo",
	},
}


local bluesounds = {
	stinks = "ia/creatures/blue_whale/bloated_stinks",
	bloated1 = "ia/creatures/blue_whale/bloated_plump_1",
	bloated2 = "ia/creatures/blue_whale/bloated_plump_2",
	explosion = "ia/creatures/blue_whale/explosion",
	hit = "ia/creatures/blue_whale/blubber_hit",
}

local whitesounds = {
	stinks = "ia/creatures/white_whale/bloated_stinks",
	bloated1 = "ia/creatures/white_whale/bloated_plump_1",
	bloated2 = "ia/creatures/white_whale/bloated_plump_2",
	explosion = "ia/creatures/white_whale/explosion",
	hit = "ia/creatures/white_whale/blubber_hit",
}

local function playsinglestinksound(inst) inst.SoundEmitter:PlaySound(inst.sounds.stinks) end
local function playstinksounds(inst, delay)
	delay = delay or 20*FRAMES
	--animation bloat3 takes 81 frames, or ~2.434 seconds
	inst.soundtask1 = inst:DoPeriodicTask(2.434, playsinglestinksound, delay)
	inst.soundtask2 = inst:DoPeriodicTask(2.434, playsinglestinksound, delay + 18*FRAMES)
	inst.soundtask3 = inst:DoPeriodicTask(2.434, playsinglestinksound, delay + 48*FRAMES)
end
local function killstinksounds(inst)
	if inst.soundtask1 then
		inst.soundtask1:Cancel()
		inst.soundtask2:Cancel()
		inst.soundtask3:Cancel()
		inst.soundtask1 = nil
		inst.soundtask2 = nil
		inst.soundtask3 = nil
	end
end

local function workcallback(inst, worker, workleft)
	killstinksounds(inst)
	inst.SoundEmitter:PlaySound(inst.sounds.hit)
	inst.AnimState:PlayAnimation("idle_trans2_3")
	inst.AnimState:PushAnimation("idle_bloat3",true)
	playstinksounds(inst)
end

local function workfinishedcallback(inst, worker)
	-- inst.components.growable:SetStage(#growth_stages)
	inst.components.growable:DoGrowth()
end


local growth_stages = {
	{
		name = "bloat1",
		time = function(inst)
			return GetRandomWithVariance(TUNING.WHALE_ROT_TIME[1].base, TUNING.WHALE_ROT_TIME[1].random)
		end,
		fn = function (inst)
			inst.AnimState:PlayAnimation("idle_pre")
			inst.AnimState:PushAnimation("idle_bloat1", true)
			inst.components.workable:SetWorkable(false)
		end,
	},
	{
		name = "bloat2",
		time = function(inst)
			return GetRandomWithVariance(TUNING.WHALE_ROT_TIME[1].base, TUNING.WHALE_ROT_TIME[1].random)
		end,
		fn = function (inst)
			inst.AnimState:PlayAnimation("idle_trans1_2")
			inst.SoundEmitter:PlaySound(inst.sounds.bloated1)
			inst.AnimState:PushAnimation("idle_bloat2", true)
			inst.components.workable:SetWorkable(false)
		end,
	},
	{
		name = "bloat3",
		time = function(inst)
			return GetRandomWithVariance(TUNING.WHALE_ROT_TIME[2].base, TUNING.WHALE_ROT_TIME[2].random)
		end,
		fn = function (inst)
			inst.AnimState:PlayAnimation("idle_trans2_3")
			inst.SoundEmitter:PlaySound(inst.sounds.bloated2)
			inst.AnimState:PushAnimation("idle_bloat3", true)
			playstinksounds(inst)
			inst.components.workable:SetWorkable(true)
		end,
	},
	{
		name = "explode",
		time = function(inst)
			return GetRandomWithVariance(TUNING.WHALE_ROT_TIME[2].base, TUNING.WHALE_ROT_TIME[2].random)
		end,
		fn = function (inst)
			inst.components.workable:SetWorkable(false)
			killstinksounds(inst)
			
			-- guarding against ending up here multiple times due to F9 testing
			if not inst.alreadyexploding then
				inst.alreadyexploding = true
				inst.AnimState:PlayAnimation("explode", false)
				inst.SoundEmitter:PlaySound(inst.sounds.explosion)
				
				inst:DoTaskInTime(57*FRAMES, function (inst)
					-- cannot use "explosive" as it force-removes in DST
					for i, v in ipairs(AllPlayers) do
						local distSq = v:GetDistanceSqToInst(inst)
						local k = math.max(0, math.min(1, distSq / 1600))
						local intensity = k * (k - 2) + 1 --easing.outQuad(k, 1, -1, 1)
						if intensity > 0 then
							v:ScreenFlash(intensity)
							v:ShakeCamera(CAMERASHAKE.FULL, .7, .02, intensity / 2)
						end
					end

					local x, y, z = inst.Transform:GetWorldPosition()
					local ents = TheSim:FindEntities(x, y, z, 3, nil, {"INLIMBO"})
					
					for i, v in ipairs(ents) do
						if v ~= inst and v:IsValid() and not v:IsInLimbo() then
							if v.components.workable ~= nil and v.components.workable:CanBeWorked() then
								v.components.workable:WorkedBy(inst, 10)
							end

							--Recheck valid after work
							if v:IsValid() and not v:IsInLimbo() then
								if v.components.combat ~= nil and not (v.components.health ~= nil and v.components.health:IsDead()) then
									local dmg = inst.explosivedamage
									if v.components.explosiveresist ~= nil then
										dmg = dmg * (1 - v.components.explosiveresist:GetResistance())
										v.components.explosiveresist:OnExplosiveDamage(dmg, inst)
									end
									v.components.combat:GetAttacked(inst, dmg, nil)
								end

								v:PushEvent("explosion", { explosive = inst })
							end
						end
					end

					TheWorld:PushEvent("explosion", {damage = inst.explosivedamage})
				end )

				inst:DoTaskInTime(58*FRAMES, function(inst)

					local i = 1
					for ii = 1, i+1 do
						inst.components.lootdropper.speed = 3 + (math.random() * 8)
						local loot = GetRandomItem(loots[i])
						local newprefab = inst.components.lootdropper:SpawnLootPrefab(loot)
						if newprefab then
							local vx, vy, vz = newprefab.Physics:GetVelocity()
							newprefab.Physics:SetVel(vx, 20+(math.random() * 5), vz)
						end
					end
				end)
				inst:DoTaskInTime(60*FRAMES, function(inst)

					local i = 2
					for ii = 1, i+1 do
						inst.components.lootdropper.speed = 4 + (math.random() * 8)
						local loot = GetRandomItem(loots[i])
						local newprefab = inst.components.lootdropper:SpawnLootPrefab(loot)
						if newprefab then
							local vx, vy, vz = newprefab.Physics:GetVelocity()
							newprefab.Physics:SetVel(vx, 25+(math.random() * 5), vz)
						end
					end
				end)
				inst:DoTaskInTime(63*FRAMES, function(inst)

					local i = 3
					for ii = 1, i+1 do
						inst.components.lootdropper.speed = 6 + (math.random() * 8)
						local loot = GetRandomItem(loots[i])
						local newprefab = inst.components.lootdropper:SpawnLootPrefab(loot)
						if newprefab then
							local vx, vy, vz = newprefab.Physics:GetVelocity()
							newprefab.Physics:SetVel(vx, 30+(math.random() * 5), vz)
						end
					end

					inst.components.lootdropper:DropLoot()
				end)

				inst:ListenForEvent("animqueueover", function (inst)
					inst:Remove()
				end)
			end
		end,
	},
}

local function OnHaunt(inst)
    if inst.components.growable --and inst.components.growable.stage ~= 4
	and math.random() <= TUNING.HAUNT_CHANCE_RARE then
		inst.components.growalbe:DoGrowth()
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_LARGE
        return true
    end

    return false
end

local function fn(Sim)
	local inst = CreateEntity()	
	inst.entity:AddTransform()
	inst.entity:AddSoundEmitter()
	inst.entity:AddNetwork()
	local minimap = inst.entity:AddMiniMapEntity()
	minimap:SetIcon("whale_carcass.tex")

	MakeObstaclePhysics(inst, 1.3)

	inst.entity:AddAnimState()
	inst.AnimState:SetBank("whalecarcass")
	inst.AnimState:SetBuild("whale_carcass_build")
	
	-- inst:AddTag("carcass")
	inst:AddTag("aquatic")

	return inst
end

local function fn_master(inst)
	
	inst:AddComponent("inspectable")
	inst:AddComponent("lootdropper")

	inst:AddComponent("growable")
	-- inst.components.growable.springgrowth = true
	inst.components.growable.stages = growth_stages
	inst.components.growable:StartGrowing()

	-- inst:AddComponent("explosive")

	-- inst.components.explosive.lightonexplode = false
	-- inst.components.explosive.noremove = true

	inst:AddComponent("workable")
	inst.components.workable:SetWorkAction(ACTIONS.HACK)

	inst.components.workable:SetOnWorkCallback(workcallback)
	inst.components.workable:SetOnFinishCallback(workfinishedcallback)
	inst.components.workable:SetWorkable(false)
	
	inst:AddComponent("hauntable")
	inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_MEDIUM
	inst.components.hauntable:SetOnHauntFn(OnHaunt)
	
	-- Remind me why Capy used states when the spiderden does the same without -M
	-- inst:SetStateGraph("SGwhalecarcass")
end

local function bluefn(Sim)
	local inst = fn(Sim)

	inst.AnimState:SetBuild("whale_carcass_build")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	fn_master(inst)
	
	inst.components.lootdropper:SetLoot(alwaysloot_blue)

	inst.sounds = bluesounds

	inst.components.growable:SetStage(1)
	inst.components.growable:StartGrowing()

	inst.components.workable:SetWorkLeft(TUNING.WHALE_BLUE_EXPLOSION_HACKS)
	inst.components.workable:SetWorkable(false)
	inst.explosivedamage = TUNING.WHALE_BLUE_EXPLOSION_DAMAGE

	return inst
end

local function whitefn(Sim)
	local inst = fn(Sim)

	inst.Transform:SetScale(1.25, 1.25, 1.25)

	inst.AnimState:SetBuild("whale_moby_carcass_build")

	inst.entity:SetPristine()

	if not TheWorld.ismastersim then
		return inst
	end
	
	fn_master(inst)

	inst.components.lootdropper:SetLoot(alwaysloot_white)

	inst.sounds = whitesounds

	inst.components.growable:SetStage(1)
	inst.components.growable:StartGrowing()

	inst.components.workable:SetWorkLeft(TUNING.WHALE_WHITE_EXPLOSION_HACKS)
	inst.components.workable:SetWorkable(false)
	inst.explosivedamage = TUNING.WHALE_WHITE_EXPLOSION_DAMAGE

	return inst
end


return Prefab( "common/objects/whale_carcass_blue", bluefn, assets_blue, prefabs),
	   Prefab( "common/objects/whale_carcass_white", whitefn, assets_white, prefabs)
%%+%%scripts/prefabs/wildbore.lua%%-%%local brain = require "brains/wildborebrain"
local brainguard = require "brains/pigguardbrain"
local brainwere = require "brains/werepigbrain"

local assets =
{
  Asset("ANIM", "anim/ds_pig_basic.zip"),
  Asset("ANIM", "anim/ds_pig_actions.zip"),
  Asset("ANIM", "anim/ds_pig_attacks.zip"),
  Asset("ANIM", "anim/ds_pig_charge.zip"),
  Asset("ANIM", "anim/wildbore_build.zip"),
  Asset("ANIM", "anim/pigspotted_build.zip"),
  Asset("ANIM", "anim/pig_guard_build.zip"),
  Asset("ANIM", "anim/werepig_build.zip"),
  Asset("ANIM", "anim/werepig_basic.zip"),
  Asset("ANIM", "anim/werepig_actions.zip"),
  Asset("ANIM", "anim/werepig_wildbore_build.zip"),
  Asset("SOUND", "sound/pig.fsb"),
}

local prefabs =
{
  "meat",
  "monstermeat",
  "poop",
  "tophat",
  "strawhat",
  "pigskin",
}

local MAX_TARGET_SHARES = 5
local SHARE_TARGET_DIST = 30
local FORCE_GIVEUP_TIME = 24

local function ontalk(inst, script)
  inst.SoundEmitter:PlaySound("ia/creatures/wild_boar/grunt")
end

local function CalcSanityAura(inst, observer)
  if inst.components.werebeast
  and inst.components.werebeast:IsInWereState() then
    return -TUNING.SANITYAURA_LARGE
  end

  if inst.components.follower and inst.components.follower.leader == observer then
    return TUNING.SANITYAURA_SMALL
  end

  return 0
end


local function ShouldAcceptItem(inst, item)
  if inst.components.sleeper:IsAsleep() then
    return false
  end

  if item.components.equippable and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
    return true
  end
  if item.components.edible then

    if (item.components.edible.foodtype == "MEAT" or item.components.edible.foodtype == "HORRIBLE")
    and inst.components.follower.leader
    and inst.components.follower:GetLoyaltyPercent() > 0.9 then
      return false
    end

    if (item.components.edible.foodtype == "VEGGIE" or item.components.edible.foodtype == "RAW") then
      local last_eat_time = inst.components.eater:TimeSinceLastEating()
      if last_eat_time and last_eat_time < TUNING.PIG_MIN_POOP_PERIOD then        
        return false
      end

      if inst.components.inventory:Has(item.prefab, 1) then
        return false
      end
    end

    return true
  end
end

local function OnGetItemFromPlayer(inst, giver, item)

  --I eat food
  if item.components.edible then
    --meat makes us friends (unless I'm a guard)
    if item.components.edible.foodtype == "MEAT" or item.components.edible.foodtype == "HORRIBLE" then
      if inst.components.combat.target and inst.components.combat.target == giver then
        inst.components.combat:SetTarget(nil)
      elseif giver.components.leader and not inst:HasTag("guard") then
        inst.SoundEmitter:PlaySound("dontstarve/common/makeFriend")
        giver.components.leader:AddFollower(inst)
        inst.components.follower:AddLoyaltyTime(item.components.edible:GetHunger() * TUNING.PIG_LOYALTY_PER_HUNGER)
      end
    end
    if inst.components.sleeper:IsAsleep() then
      inst.components.sleeper:WakeUp()
    end
  end

  --I wear hats
  if item.components.equippable and item.components.equippable.equipslot == EQUIPSLOTS.HEAD then
    local current = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HEAD)
    if current then
      inst.components.inventory:DropItem(current)
    end

    inst.components.inventory:Equip(item)
    inst.AnimState:Show("hat")
  end
end

local function OnRefuseItem(inst, item)
  inst.sg:GoToState("refuse")
  if inst.components.sleeper:IsAsleep() then
    inst.components.sleeper:WakeUp()
  end
end

local function OnEat(inst, food)
  if food.components.edible
  and food.components.edible.foodtype == "MEAT"
  and inst.components.werebeast
  and not inst.components.werebeast:IsInWereState() then
    if food.components.edible:GetHealth() < 0 then
      inst.components.werebeast:TriggerDelta(1)
    end
  end

  if food.components.edible and food.components.edible.foodtype == "VEGGIE" then
    local poo = SpawnPrefab("poop")
    poo.Transform:SetPosition(inst.Transform:GetWorldPosition())		
  end

end

local function OnAttackedByDecidRoot(inst, attacker)
  local fn = function(dude) return dude:HasTag("pig") and not dude:HasTag("werepig") and not dude:HasTag("guard") end

  local x,y,z = inst.Transform:GetWorldPosition()
  local ents = nil
  if (TheWorld.state.isspring or TheWorld.state.isgreen) then
    ents = TheSim:FindEntities(x,y,z, (SHARE_TARGET_DIST * TUNING.SPRING_COMBAT_MOD) / 2)
  else
    ents = TheSim:FindEntities(x,y,z, SHARE_TARGET_DIST / 2)
  end

  if ents then
    local num_helpers = 0
    for k,v in pairs(ents) do
      if v ~= inst and v.components.combat and not (v.components.health and v.components.health:IsDead()) and fn(v) then
        if v:PushEvent("suggest_tree_target", {tree=attacker}) then
          num_helpers = num_helpers + 1
        end
      end
      if num_helpers >= MAX_TARGET_SHARES then
        break
      end     
    end
  end
end

local function OnAttacked(inst, data)
  --print(inst, "OnAttacked")
  local attacker = data.attacker
  inst:ClearBufferedAction()

  if attacker.prefab == "deciduous_root" and attacker.owner then 
    OnAttackedByDecidRoot(inst, attacker.owner)
  elseif attacker.prefab ~= "deciduous_root" then
    inst.components.combat:SetTarget(attacker)

    if inst:HasTag("werepig") then
      inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("werepig") end, MAX_TARGET_SHARES)
    elseif inst:HasTag("guard") then
      inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("pig") and (dude:HasTag("guard") or not attacker:HasTag("pig")) end, MAX_TARGET_SHARES)
    else
      if not (attacker:HasTag("pig") and attacker:HasTag("guard") ) then
        inst.components.combat:ShareTarget(attacker, SHARE_TARGET_DIST, function(dude) return dude:HasTag("pig") and not dude:HasTag("werepig") end, MAX_TARGET_SHARES)
      end
    end
  end
end

local function OnNewTarget(inst, data)
  if inst:HasTag("werepig") then
    --print(inst, "OnNewTarget", data.target)
    inst.components.combat:ShareTarget(data.target, SHARE_TARGET_DIST, function(dude) return dude:HasTag("werepig") end, MAX_TARGET_SHARES)
  end
end

local builds = {"wildbore_build", "pigspotted_build"}
local guardbuilds = {"pig_guard_build"}


local function NormalRetargetFn(inst)
    return FindEntity(
        inst,
        TUNING.PIG_TARGET_DIST,
        function(guy)
            return (guy.LightWatcher == nil or guy.LightWatcher:IsInLight())
                and inst.components.combat:CanTarget(guy)
        end,
        { "monster", "_combat" }, -- see entityreplica.lua
        inst.components.follower.leader ~= nil and
        { "playerghost", "INLIMBO", "abigail" } or
        { "playerghost", "INLIMBO" })
end

local function NormalKeepTargetFn(inst, target)
    --give up on dead guys, or guys in the dark, or werepigs
    return inst.components.combat:CanTarget(target)
        and (target.LightWatcher == nil or target.LightWatcher:IsInLight())
        and not (target.sg ~= nil and target.sg:HasStateTag("transform"))
		--because ChaseAndRam never ever gives up, just autofail if we couldn't attack or get attacked for that long
		-- and GetTime() - (inst.components.combat.lastdoattacktime or GetTime()) < FORCE_GIVEUP_TIME
		-- and GetTime() - inst.components.combat:GetLastAttackedTime() < FORCE_GIVEUP_TIME
		and inst:IsNear(target, 26)
end

local function NormalShouldSleep(inst)
  if inst.components.follower and inst.components.follower.leader then
    local fire = FindEntity(inst, 6, function(ent)
        return ent.components.burnable
        and ent.components.burnable:IsBurning()
      end, {"campfire"})
    return DefaultSleepTest(inst) and fire and (not inst.LightWatcher or inst.LightWatcher:IsInLight())
  else
    return DefaultSleepTest(inst)
  end
end

local function SetNormalPig(inst)
  inst:RemoveTag("werepig")
  inst:RemoveTag("guard")
  inst:SetBrain(brain)
  inst:SetStateGraph("SGwildbore")
  inst.AnimState:SetBuild(inst.build)

  inst.components.werebeast:SetOnNormalFn(SetNormalPig)
  inst.components.sleeper:SetResistance(2)

  inst.components.combat:SetDefaultDamage(TUNING.PIG_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.PIG_ATTACK_PERIOD)
  inst.components.combat:SetKeepTargetFunction(NormalKeepTargetFn)
  inst.components.locomotor.runspeed = TUNING.PIG_RUN_SPEED
  inst.components.locomotor.walkspeed = TUNING.PIG_WALK_SPEED

  inst.components.sleeper:SetSleepTest(NormalShouldSleep)
  inst.components.sleeper:SetWakeTest(DefaultWakeTest)

  inst.components.lootdropper:SetLoot({})
  inst.components.lootdropper:AddRandomLoot("meat",3)
  inst.components.lootdropper:AddRandomLoot("pigskin",1)
  inst.components.lootdropper.numrandomloot = 1

  inst.components.health:SetMaxHealth(TUNING.PIG_HEALTH)
  inst.components.combat:SetRetargetFunction(3, NormalRetargetFn)
  inst.components.combat:SetTarget(nil)
  inst:ListenForEvent("suggest_tree_target", function(inst, data)
      if data and data.tree and inst:GetBufferedAction() ~= ACTIONS.CHOP then
        inst.tree_target = data.tree
      end
    end)

  inst.components.trader:Enable()
  inst.components.talker:StopIgnoringAll("becamewerepig")
end

local function GuardRetargetFn(inst)
  local home = inst.components.homeseeker and inst.components.homeseeker.home
  --defend the king, then the torch, then myself
  local notags = {"FX", "NOCLICK","INLIMBO"}
  local defenseTarget = FindEntity(inst, TUNING.PIG_GUARD_DEFEND_DIST, function(guy) return guy:HasTag("king") end, {"king"}, notags)
  if not defenseTarget and home and inst:GetDistanceSqToInst(home) < SpringCombatMod(TUNING.PIG_GUARD_DEFEND_DIST*TUNING.PIG_GUARD_DEFEND_DIST) then
    defenseTarget = home
  end
  if not defenseTarget then
    defenseTarget = inst
  end
  local invader = FindEntity(defenseTarget or inst, SpringCombatMod(TUNING.PIG_GUARD_TARGET_DIST), function(guy)
      return guy:HasTag("character") and not guy:HasTag("guard")
    end, {"character"}, notags)
  if not defenseTarget.happy then
    if invader
    and not (defenseTarget.components.trader and defenseTarget.components.trader:IsTryingToTradeWithMe(invader) )
    and not (inst.components.trader and inst.components.trader:IsTryingToTradeWithMe(invader) ) then
      return invader
    end
    if TheWorld.state.isnight and home and home.components.burnable and home.components.burnable:IsBurning() then
      local lightThief = FindEntity(home, home.components.burnable:GetLargestLightRadius(), function(guy)
          return guy:HasTag("player")
          and guy.LightWatcher:IsInLight()
          and not (defenseTarget.components.trader and defenseTarget.components.trader:IsTryingToTradeWithMe(guy) ) 
          and not (inst.components.trader and inst.components.trader:IsTryingToTradeWithMe(guy) ) 
        end, {"player"}, notags)
      if lightThief then
        return lightThief
      end
    end
  end
  return FindEntity(defenseTarget, SpringCombatMod(TUNING.PIG_GUARD_DEFEND_DIST), function(guy)
      return guy:HasTag("monster")
    end, {"monster"}, notags)
end

local function GuardKeepTargetFn(inst, target)
  local home = inst.components.homeseeker and inst.components.homeseeker.home
  if home then
    local defendDist = SpringCombatMod(TUNING.PIG_GUARD_DEFEND_DIST)
    if TheWorld.state.isnight and home.components.burnable and home.components.burnable:IsBurning() then
      defendDist = home.components.burnable:GetLargestLightRadius()
    end
    return home:GetDistanceSqToInst(target) < defendDist*defendDist
    and home:GetDistanceSqToInst(inst) < defendDist*defendDist
  end
  return inst.components.combat:CanTarget(target)     
  and not (target.sg and target.sg:HasStateTag("transform") )
end
local function GuardShouldSleep(inst)
  return false
end
local function GuardShouldWake(inst)
  return true
end
local function SetGuardPig(inst)
  inst:RemoveTag("werepig")
  inst:AddTag("guard")
  inst:SetBrain(brainguard)
  inst:SetStateGraph("SGwildbore")
  inst.AnimState:SetBuild(inst.build)

  inst.components.werebeast:SetOnNormalFn(SetGuardPig)
  inst.components.sleeper:SetResistance(3)

  inst.components.health:SetMaxHealth(TUNING.PIG_GUARD_HEALTH)
  inst.components.combat:SetDefaultDamage(TUNING.PIG_GUARD_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.PIG_GUARD_ATTACK_PERIOD)
  inst.components.combat:SetKeepTargetFunction(GuardKeepTargetFn)
  inst.components.combat:SetRetargetFunction(1, GuardRetargetFn)
  inst.components.combat:SetTarget(nil)
  inst.components.locomotor.runspeed = TUNING.PIG_RUN_SPEED
  inst.components.locomotor.walkspeed = TUNING.PIG_WALK_SPEED

  inst.components.sleeper:SetSleepTest(GuardShouldSleep)
  inst.components.sleeper:SetWakeTest(GuardShouldWake)

  inst.components.lootdropper:SetLoot({})
  inst.components.lootdropper:AddRandomLoot("meat",3)
  inst.components.lootdropper:AddRandomLoot("pigskin",1)
  inst.components.lootdropper.numrandomloot = 1


  inst.components.trader:Enable()
  inst.components.talker:StopIgnoringAll("becamewerepig")
  inst.components.follower:SetLeader(nil)
end

local function WerepigRetargetFn(inst)
  local notags = {"FX", "NOCLICK","INLIMBO", "werepig", "alwaysblock"}
  return FindEntity(inst, SpringCombatMod(TUNING.PIG_TARGET_DIST), function(guy)
      return inst.components.combat:CanTarget(guy)
      and not guy:HasTag("werepig")
      and not (guy.sg and guy.sg:HasStateTag("transform") )
      and not guy:HasTag("alwaysblock")
    end, nil, notags)
end
local function WerepigKeepTargetFn(inst, target)
  return inst.components.combat:CanTarget(target)
  and not target:HasTag("werepig")
  and not (target.sg and target.sg:HasStateTag("transform") )
end
local function WerepigSleepTest(inst)
  return false
end
local function WerepigWakeTest(inst)
  return true
end
local function SetWerePig(inst)
  inst:AddTag("werepig")
  inst:RemoveTag("guard")
  inst:SetBrain(brainwere)
  inst:SetStateGraph("SGwerepig")
  inst.AnimState:SetBuild("werepig_build")

  inst.components.sleeper:SetResistance(3)

  inst.components.combat:SetDefaultDamage(TUNING.WEREPIG_DAMAGE)
  inst.components.combat:SetAttackPeriod(TUNING.WEREPIG_ATTACK_PERIOD)
  inst.components.locomotor.runspeed = TUNING.WEREPIG_RUN_SPEED 
  inst.components.locomotor.walkspeed = TUNING.WEREPIG_WALK_SPEED 

  inst.components.sleeper:SetSleepTest(WerepigSleepTest)
  inst.components.sleeper:SetWakeTest(WerepigWakeTest)

  inst.components.lootdropper:SetLoot({"meat","meat", "pigskin"})
  inst.components.lootdropper.numrandomloot = 0

  inst.components.health:SetMaxHealth(TUNING.WEREPIG_HEALTH)
  inst.components.combat:SetTarget(nil)
  inst.components.combat:SetRetargetFunction(3, WerepigRetargetFn)
  inst.components.combat:SetKeepTargetFunction(WerepigKeepTargetFn)

  inst.components.trader:Disable()
  inst.components.follower:SetLeader(nil)
  inst.components.talker:IgnoreAll("becamewerepig")
end


local function common()
  local inst = CreateEntity()
  local trans = inst.entity:AddTransform()
  inst.entity:AddAnimState()
  local sound = inst.entity:AddSoundEmitter()
  local shadow = inst.entity:AddDynamicShadow()
  inst.entity:AddNetwork()
  shadow:SetSize( 1.5, .75 )
  inst.Transform:SetFourFaced()

  inst.entity:AddLightWatcher()

  inst:AddComponent("talker")
  inst.components.talker.fontsize = 35
  inst.components.talker.font = TALKINGFONT
  --inst.components.talker.colour = Vector3(133/255, 140/255, 167/255)
  inst.components.talker.offset = Vector3(0,-400,0)
	inst.components.talker:MakeChatter()

  MakeCharacterPhysics(inst, 50, .5)

  inst:AddTag("character")
  inst:AddTag("pig")
  inst:AddTag("scarytoprey")
  inst.AnimState:SetBank("pigman")
  inst.AnimState:PlayAnimation("idle_loop")
  inst.AnimState:Hide("hat")

  inst.entity:SetPristine()

  if not TheWorld.ismastersim then
    return inst
  end

	inst.components.talker.ontalk = ontalk

  inst:AddComponent("locomotor") -- locomotor must be constructed before the stategraph
  inst.components.locomotor.runspeed = TUNING.PIG_RUN_SPEED --5
  inst.components.locomotor.walkspeed = TUNING.PIG_WALK_SPEED --3

  ------------------------------------------
  inst:AddComponent("eater")
  inst.components.eater:SetOmnivore()
  inst.components.eater:SetCanEatHorrible()
	inst.components.eater:SetCanEatRaw()
  inst.components.eater.strongstomach = true -- can eat monster meat!
  inst.components.eater:SetOnEatFn(OnEat)
  ------------------------------------------
  inst:AddComponent("combat")
  inst.components.combat.hiteffectsymbol = "pig_torso"

  MakeMediumBurnableCharacter(inst, "pig_torso")

  inst:AddComponent("named")
  inst.components.named.possiblenames = STRINGS.PIGNAMES
  inst.components.named:PickNewName()

  ------------------------------------------
  inst:AddComponent("werebeast")
  inst.components.werebeast:SetOnWereFn(SetWerePig)
  inst.components.werebeast:SetTriggerLimit(4)

  inst:ListenForEvent("exitlimbo", function(inst)
      inst:DoTaskInTime(.2, function(inst)
          if TheWorld.state.isfullmoon and TheWorld.state.isnight and inst.entity:IsVisible() and not inst.components.werebeast:IsInWereState() then
            inst.components.werebeast:SetWere()
          end
        end)
    end)

  ------------------------------------------
  inst:AddComponent("follower")
  inst.components.follower.maxfollowtime = TUNING.PIG_LOYALTY_MAXTIME
  ------------------------------------------
  inst:AddComponent("health")

  ------------------------------------------

  inst:AddComponent("inventory")

  ------------------------------------------

  inst:AddComponent("lootdropper")

  ------------------------------------------

  inst:AddComponent("knownlocations")


  ------------------------------------------

  inst:AddComponent("trader")
  inst.components.trader:SetAcceptTest(ShouldAcceptItem)
  inst.components.trader.onaccept = OnGetItemFromPlayer
  inst.components.trader.onrefuse = OnRefuseItem
  inst.components.trader.deleteitemonaccept = false

  ------------------------------------------

  inst:AddComponent("sanityaura")
  inst.components.sanityaura.aurafn = CalcSanityAura


  ------------------------------------------

  inst:AddComponent("sleeper")

  ------------------------------------------
  MakeMediumFreezableCharacter(inst, "pig_torso")

  ------------------------------------------


  inst:AddComponent("inspectable")
  inst.components.inspectable.getstatus = function(inst)
    if inst:HasTag("werepig") then
      return "WEREPIG"
    elseif inst:HasTag("guard") then
      return "GUARD"
    elseif inst.components.follower.leader ~= nil then
      return "FOLLOWER"
    end
  end
  ------------------------------------------

  inst.annoyance = 0

  inst.OnSave = function(inst, data)
    data.build = inst.build
  end        

  inst.OnLoad = function(inst, data)    
    if data then
      inst.build = data.build or builds[1]
      if not inst.components.werebeast:IsInWereState() then
        inst.AnimState:SetBuild(inst.build)
      end
    end
  end           

  inst:ListenForEvent("attacked", OnAttacked)    
  inst:ListenForEvent("newcombattarget", OnNewTarget)

  return inst
end

local function normal()
  local inst = common()
  -- inst.build = builds[math.random(#builds)]
  inst.build = "wildbore_build"
  inst.AnimState:SetBuild(inst.build)

  if not TheWorld.ismastersim then
    return inst
  end

  SetNormalPig(inst)
  return inst
end

local function guard()
  local inst = common()
  inst.build = guardbuilds[math.random(#guardbuilds)]
  inst.AnimState:SetBuild(inst.build)

  if not TheWorld.ismastersim then
    return inst
  end

  SetGuardPig(inst)
  return inst
end

return Prefab("wildbore", normal, assets, prefabs),
Prefab("wildboreguard", guard, assets, prefabs) 
%%+%%scripts/prefabs/wildborehead.lua%%-%%local assets =
{
    Asset("ANIM", "anim/wildbore_head.zip"),
}

local prefabs =
{
    "flies",
    "pigskin",
    "bamboo",
    "collapse_small",
}

local function OnFinish(inst)
    if inst.components.burnable ~= nil and inst.components.burnable:IsBurning() then
        inst.components.burnable:Extinguish()
    end
    local fx = SpawnPrefab("collapse_small")
    fx.Transform:SetPosition(inst.Transform:GetWorldPosition())
    fx:SetMaterial("wood")
    if TheWorld.state.isfullmoon then
        inst.components.lootdropper:SpawnLootPrefab("nightmarefuel")
    end
    inst.components.lootdropper:DropLoot()
    inst:Remove()
end

local function OnWorked(inst) 
    if not inst:HasTag("burnt") then 
        inst.AnimState:PlayAnimation("hit")
        inst.AnimState:PushAnimation(inst.awake and "idle_awake" or "idle_asleep")
    end
end

local function OnFullMoon(inst, isfullmoon)
    if not inst:HasTag("burnt") then
        if isfullmoon then
            if not inst.awake then
                inst.awake = true
                inst.AnimState:PlayAnimation("wake")
                inst.AnimState:PushAnimation("idle_awake", false)
            end
        elseif inst.awake then
            inst.awake = nil
            inst.AnimState:PlayAnimation("sleep")
            inst.AnimState:PushAnimation("idle_asleep", false)
        end
    end
end

local function onsave(inst, data)
    if inst:HasTag("burnt") or (inst.components.burnable ~= nil and inst.components.burnable:IsBurning()) then
        data.burnt = true
    end
end

local function onload(inst, data)
    if data ~= nil and data.burnt then
        inst.components.burnable.onburnt(inst)
    end
end

local function OnFinishHaunt(inst)
    if inst.awake and not (TheWorld.state.isfullmoon or inst:HasTag("burnt")) then
        inst.awake = nil
        inst.AnimState:PlayAnimation("sleep")
        inst.AnimState:PushAnimation("idle_asleep", false)
    end
end

local function OnHaunt(inst, haunter)
    --#HAUNTFIX
    --if math.random() <= TUNING.HAUNT_CHANCE_OCCASIONAL and
        --inst.components.workable ~= nil and
        --inst.components.workable:CanBeWorked() then
        --inst.components.workable:WorkedBy(haunter, 1)
        --inst.components.hauntable.hauntvalue = TUNING.HAUNT_SMALL
        --return true
    --else
    if not (inst.awake or inst:HasTag("burnt")) then
        inst.awake = true
        inst.AnimState:PlayAnimation("wake")
        inst.AnimState:PushAnimation("idle_awake")
        inst:DoTaskInTime(4, OnFinishHaunt)
        inst.components.hauntable.hauntvalue = TUNING.HAUNT_TINY
        return true
    end
    return false
end

local function fn()
    local inst = CreateEntity()

    inst.entity:AddTransform()
    inst.entity:AddAnimState()
    inst.entity:AddSoundEmitter()
    inst.entity:AddNetwork()

    inst:AddTag("structure")
    inst:AddTag("chewable")  -- for werebeaver

    inst.AnimState:SetBank("wildbore_head")
    inst.AnimState:SetBuild("wildbore_head")
    inst.AnimState:PlayAnimation("idle_asleep")

    inst.entity:SetPristine()

    if not TheWorld.ismastersim then
        return inst
    end

    inst:AddComponent("lootdropper")

    inst:AddComponent("inspectable")

    inst.flies = inst:SpawnChild("flies")
    inst.awake = nil

    inst:AddComponent("workable")
    inst.components.workable:SetWorkAction(ACTIONS.HAMMER)
    inst.components.workable:SetWorkLeft(3)
    inst.components.workable:SetOnWorkCallback(OnWorked)
    inst.components.workable.onfinish = OnFinish

    MakeSmallBurnable(inst, nil, nil, true)
    MakeSmallPropagator(inst)

    inst.OnSave = onsave
    inst.OnLoad = onload

    inst:WatchWorldState("isfullmoon", OnFullMoon)
    OnFullMoon(inst, TheWorld.state.isfullmoon)

    inst:AddComponent("hauntable")
    inst.components.hauntable.cooldown = TUNING.HAUNT_COOLDOWN_MEDIUM
    inst.components.hauntable:SetOnHauntFn(OnHaunt)

    return inst
end


return Prefab("wildborehead", fn, assets, prefabs)
%%+%%scripts/scenarios/chest_kraken.lua%%-%%chestfunctions = require("scenarios/chestfunctions")

local function OnCreate(inst, scenariorunner)

	local items = 
	{
		{
			--The Quacken Beak
			item = "quackenbeak",
			chance = 1.00
		},
		{
			--Body Items
			item = {"armorruins", "armorobsidian"},
			chance = 1.00,
			initfn = function(item) if item.components.armor then item.components.armor:SetCondition(math.random(item.components.armor.maxcondition * 0.75, item.components.armor.maxcondition)) end end
		},
		{
			--Body Items
			item = "ruinshat",
			chance = 1.00,
			initfn = function(item) if item.components.armor then item.components.armor:SetCondition(math.random(item.components.armor.maxcondition * 0.75, item.components.armor.maxcondition)) end end
		},
		{
			--Weapon Items
			item = {"volcanostaff", "cane"},
			chance = 1.00,
			initfn = function(item) if item.components.finiteuses then item.components.finiteuses:SetUses(math.random(item.components.finiteuses.total * 0.75, item.components.finiteuses.total)) end end
		},
		{
			--Misc Items
			item = {"blueprint", "tunacan"},
			chance = 1.00,
		},
		{
			item = {"obsidian", "dubloon"},
			count = math.random(7, 14),
			chance = 1.00,
		},
		{
			item = {"coral", "seaweed"},
			count = math.random(7, 10),
			chance = 1.00,
		},
	}

	chestfunctions.AddChestItems(inst, items)
end

return 
{
	OnCreate = OnCreate
}%%+%%scripts/scenarios/chest_luggage1.lua%%-%%local chestfunctions = require("scenarios/chestfunctions")

local items = 
{
	{
		item = "hawaiianshirt",
		initfn = function(inst)
			if inst.components.fueled then
				inst.components.fueled:SetPercent(GetRandomWithVariance(0.78, 0.1))
			end
		end
	},
	{
		item = "umbrella",
		initfn = function(inst)
			if inst.components.fueled then
				inst.components.fueled:SetPercent(GetRandomWithVariance(0.35, 0.1))
			end
		end
	},
	{
		item = "coconut",
		count = 2
	},
	{
		item = "trinket_ia_13",
	},
}

local function OnCreate(inst, scenariorunner)
	chestfunctions.AddChestItems(inst, items)
end

local function OnDestroy(inst)
    chestfunctions.OnDestroy(inst)
end

return 
{
	OnCreate = OnCreate,
	OnDestroy = OnDestroy
}
%%+%%scripts/scenarios/chest_luggage2.lua%%-%%local chestfunctions = require("scenarios/chestfunctions")

local items = 
{
	{
		item = "reflectivevest",
		initfn = function(inst)
			if inst.components.fueled then
				inst.components.fueled:SetPercent(GetRandomWithVariance(0.45, 0.1))
			end
		end
	},
	{
		item = "double_umbrellahat",
		initfn = function(inst)
			if inst.components.fueled then
				inst.components.fueled:SetPercent(GetRandomWithVariance(0.56, 0.1))
			end
		end
	},
	{
		item = "coconade",
		count = 2
	},
	{
		item = "trinket_ia_14",
	},
}

local function OnCreate(inst, scenariorunner)
	chestfunctions.AddChestItems(inst, items)
end

local function OnDestroy(inst)
    chestfunctions.OnDestroy(inst)
end

return 
{
	OnCreate = OnCreate,
	OnDestroy = OnDestroy
}
%%+%%scripts/scenarios/chest_luggage3.lua%%-%%local chestfunctions = require("scenarios/chestfunctions")

local items = 
{
	{
		item = "trinket_ia_15",
	},
	{
		item = "snakeskinhat",
	},
	{
		item = "sewing_kit",
	},
	{
		item = "armor_lifejacket",
	},
}

local function OnCreate(inst, scenariorunner)
	chestfunctions.AddChestItems(inst, items)
end

local function OnDestroy(inst)
    chestfunctions.OnDestroy(inst)
end

return 
{
	OnCreate = OnCreate,
	OnDestroy = OnDestroy
}
%%+%%scripts/scenarios/chest_luggage4.lua%%-%%local chestfunctions = require("scenarios/chestfunctions")

local items = 
{
	{
		item = "goldnugget",
		count = 2
	},
	{
		item = "bedroll_straw",
	},
	{
		item = "bandage",
	},
	{
		item = "captainhat",
	},
	{
		item = "palmleaf_umbrella",
	},
	{
		item = "trinket_ia_19",
	},
}

local function OnCreate(inst, scenariorunner)
	chestfunctions.AddChestItems(inst, items)
end

local function OnDestroy(inst)
    chestfunctions.OnDestroy(inst)
end

return 
{
	OnCreate = OnCreate,
	OnDestroy = OnDestroy
}
%%+%%scripts/scenarios/chest_shipgrave.lua%%-%%chestfunctions = require("scenarios/chestfunctions")

local function RandomDamage(item, min, max)
	if item then
		if item.components.armor then
			item.components.armor:SetCondition(math.random(min * item.components.armor.maxcondition, max * item.components.armor.maxcondition))
		end
		if item.components.finiteuses then
			item.components.finiteuses:SetUses(math.random(min * item.components.finiteuses.total, max * item.components.finiteuses.total))
			if item.components.finiteuses.current <= 0 and item.components.finiteuses.total >= 1 then
				item.components.finiteuses.current = 1
			end
		end
		if item.components.fueled then
			item.components.fueled.currentfuel = math.random(min * item.components.fueled.maxfuel, max * item.components.fueled.maxfuel)
		end
	end
end

local function OnCreate(inst, scenariorunner)

	local items = 
	{
		{
			--Body Items
			item = {"strawhat", "armorwood"},
			chance = 0.25,
			initfn = function(item) RandomDamage(item, 0.15, 0.55) end
		},
		{
			--Tool Items
			item = {"axe", "machete", "pickaxe", "shovel"},
			chance = 1.00,
			initfn = function(item) RandomDamage(item, 0.15, 0.65) end
		},
		{
			--Misc Items
			item = {"flint", "dubloon"},
			count = math.random(1, 3),
			chance = 0.5,
		},
		{
			item = {"coral", "seaweed"},
			count = math.random(3, 5),
			chance = 1.00,
		},
	}

	chestfunctions.AddChestItems(inst, items)
end

return 
{
	OnCreate = OnCreate
}%%+%%scripts/scenarios/derelict_sailboat.lua%%-%%
local function OnCreate(inst, scenariorunner)
	if inst == nil or inst.components.container == nil then
		return
	end

	inst.components.boathealth:SetPercent(GetRandomWithVariance(0.48, 0.1))

	local pt = inst:GetPosition()
	
	if math.random() < 0.99 then
		local choices = {"sail_palmleaf", "sail_cloth"}
		local sail = SpawnPrefab( choices[math.random(#choices)] )
		if sail then
			sail.Transform:SetPosition(pt.x + 1, 0, pt.z + 1.8)
			sail.components.fueled:SetPercent(GetRandomWithVariance(0.3, 0.1))
			--inst.components.boatequip:EquipSail(sail) --This does not seem to work, not critical though
		end
	end

	if math.random() < 0.9 then
		local lantern = SpawnPrefab("boat_lantern")
		if lantern then
			lantern.Transform:SetPosition(pt.x - 1.5, 0, pt.z - .5)
			lantern.components.fueled:SetPercent(GetRandomWithVariance(0.25, 0.1))
			-- inst.components.boatequip:EquipLamp(lantern)
			-- lantern.components.equippable:ToggleOff() --TODO
		end
	end
end

return
{
	OnCreate = OnCreate
}%%+%%scripts/scenarios/fog_shipgrave.lua%%-%%
local function OnCreate(inst, scenariorunner)
	if not TheWorld or not TheWorld.Map then
		return 
	end

	local radius = 16
	local ex, ey, ez = inst.Transform:GetWorldPosition()
	local tx, ty = TheWorld.Map:GetTileCoordsAtPoint(ex, ey, ez)
	local extents = {left=tx, right=tx, bottom=ty, top=ty}

	--print("OCEAN_SHIPGRAVEYARD", tx, ty, tostring(TheWorld.Map:GetTile(tx, ty)))

	for y = ty - radius, ty + radius, 1 do
		local x = tx - 1
		repeat
			local tile = TheWorld.Map:GetTile(x, y)
			x = x - 1
			--print("OCEAN_SHIPGRAVEYARD left", tx - radius, x, tx)
		until x < tx - radius or tile ~= GROUND.OCEAN_SHIPGRAVEYARD
		extents.left = math.min(extents.left, x)

		x = tx + 1
		repeat
			local tile = TheWorld.Map:GetTile(x, y)
			x = x + 1
			--print("OCEAN_SHIPGRAVEYARD, right", tx, x, tx + radius)
		until x > tx + radius or tile ~= GROUND.OCEAN_SHIPGRAVEYARD
		extents.right = math.max(extents.right, x)
	end

	for x = extents.left, extents.right, 1 do
		local y = ty - 1
		repeat
			local tile = TheWorld.Map:GetTile(x, y)
			y = y - 1
			--print("OCEAN_SHIPGRAVEYARD bottom", ty - radius, y, ty)
		until y < ty - radius or tile ~= GROUND.OCEAN_SHIPGRAVEYARD
		extents.bottom = math.min(extents.bottom, y)

		y = ty + 1
		repeat
			local tile = TheWorld.Map:GetTile(x, y)
			y = y + 1
			--print("OCEAN_SHIPGRAVEYARD top", ty, y, ty + radius)
		until y > ty + radius or tile ~= GROUND.OCEAN_SHIPGRAVEYARD
		extents.top = math.max(extents.top, y)
	end

	local newrad = 0.5 * TILE_SCALE * math.max(extents.right - extents.left, extents.top - extents.bottom)
	inst:SetRadius(newrad)

	local width, height = TheWorld.Map:GetSize()
	local newx = ((0.5 * (extents.left + extents.right)) - width/2.0)*TILE_SCALE
	local newz = ((0.5 * (extents.top + extents.bottom)) - height/2.0)*TILE_SCALE
	inst.Transform:SetPosition(newx, ey, newz)

	scenariorunner:ClearScenario()
end

return 
{
	OnCreate = OnCreate
}%%+%%scripts/scenarios/moored_boat.lua%%-%%
local function PlaceBoatOnShore(inst, prefab)
	local world = TheWorld

	local findtile = function(checkFn, x, y, radius)
		for i = -radius, radius, 1 do
			if checkFn(world.Map:GetTile(x - radius, y + i)) then
				return x - radius, y + i
			end
			if checkFn(world.Map:GetTile(x + radius, y + i)) then
				return x + radius, y + i
			end
		end
		for i = -(radius - 1), radius - 1, 1 do
			if checkFn(world.Map:GetTile(x + i, y - radius)) then
				return x + i, y - radius
			end
			if checkFn(world.Map:GetTile(x + i, y + radius)) then
				return x + i, y + radius
			end
		end
		return nil, nil
	end

	local findtileradius = function(checkFn, px, py, pz, max_radius)
		local x, y = world.Map:GetTileXYAtPoint(px, py, pz)

		for i=1, max_radius, 1 do
			local bx, by = findtile(checkFn, x, y, i)
			if bx and by then
				return bx, by
			end
		end
		return nil, nil
	end

	local boat
	local px, py, pz = inst.Transform:GetWorldPosition()
	local shorex, shorey = findtileradius(function(tile) return tile == GROUND.BEACH end, px, py, pz, 50)
	if shorex and shorey then
		boat = SpawnPrefab(prefab)
		if boat then
			local width, height = world.Map:GetSize()
			local tx = (shorex - width/2.0)*TILE_SCALE
			local tz = (shorey - height/2.0)*TILE_SCALE

			local shalx, shaly = findtileradius(function(tile) return tile == GROUND.OCEAN_SHALLOW end, tx, 0, tz, 1)
			--local landx, landy = findtileradius(function(tile) return world.Map:IsLand(tile) end, tx, 0, tz, 1)
			if shalx and shaly then
				--offset slightly
				local tx2 = (shalx - width/2.0)*TILE_SCALE
				local tz2 = (shaly - height/2.0)*TILE_SCALE
				--local tx2 = (landx - width/2.0)*TILE_SCALE
				--local tz2 = (landy - height/2.0)*TILE_SCALE
				tx = Lerp(tx, tx2, 0.5) --tx = tx + 0.5 * (tx2 - tx)
				tz = Lerp(tz, tz2, 0.5) --tz = tz + 0.5 * (tz2 - tz)
			end

			boat.Transform:SetPosition(tx, 0, tz)
		end
	end

	return boat
end

local function OnCreate(inst, scenariorunner)
	if inst == nil then
		return
	end

	local boat = PlaceBoatOnShore(inst, "boat_row")
	if boat then
		local pt = inst:GetPosition()
		--[[local sail = SpawnPrefab("sail_palmleaf")
		if sail then
			boat.components.boatequip:EquipSail(sail)
		end]]
		local lantern = SpawnPrefab("boat_lantern")
		if lantern then
			lantern.Transform:SetPosition(pt.x + .5, 0, pt.z - 1)
			-- boat.components.boatequip:EquipLamp(lantern)
			-- lantern.components.equippable:ToggleOff() --TODO
		end
	else
		print("Unable to place Boat!")
	end

	inst:Remove()
end

return
{
	OnCreate = OnCreate
}%%+%%scripts/scenarios/sharx_ambush.lua%%-%%
local SHARX_SPAWN_DIST = 40

local function SpawnSharx(inst, threatprefab)
	
	local threat = SpawnPrefab(threatprefab)
	if threat then
		local x, y, z = inst.Transform:GetWorldPosition()
		local rads = math.random(0, 359) * DEGREES
		threat.Transform:SetPosition(x + SHARX_SPAWN_DIST * math.cos(rads), y, z + SHARX_SPAWN_DIST * math.sin(rads))
		threat.components.combat:SetTarget(inst)
	end
end

local function TriggerTrap(inst, scenariorunner)
	local loots = {"smallmeat", "smallmeat", "smallmeat", "spear_launcher", "spear"}
	for i = 1, #loots, 1 do
		local prefab = SpawnPrefab(loots[i])
		inst.components.container:GiveItem(prefab)
	end

	local threats = {"sharx","crocodog"}
	local threat = threats[math.random(#threats)]
	for i = 1, 3, 1 do
		inst:DoTaskInTime(math.random(0, 3), function() SpawnSharx(inst, threat) end)
	end

	scenariorunner:ClearScenario()
end

local function OnCreate(inst, scenariorunner)
	inst.components.boathealth:SetPercent(GetRandomWithVariance(0.48, 0.1))
end

local function OnLoad(inst, scenariorunner)
    inst.scene_mountedfn = function() TriggerTrap(inst, scenariorunner) end
	inst:ListenForEvent("mounted", inst.scene_mountedfn)
end

local function OnDestroy(inst)
    if inst.scene_mountedfn then
        inst:RemoveEventCallback("mounted", inst.scene_mountedfn)
        inst.scene_mountedfn = nil
    end
end

return
{
	OnCreate = OnCreate,
	OnLoad = OnLoad,
	OnDestroy = OnDestroy
}%%+%%scripts/scenarios/snake_ambush.lua%%-%%local function SpawnSnake(vine, target)
    local snake = SpawnPrefab("snake_poison")
    local spawnpos = vine:GetPosition()
    local offset = FindWalkableOffset(spawnpos, math.random() * 2 * PI, 1, 8, true, false, IsPositionValidForEnt(inst, 2))
    spawnpos = offset ~= nil and spawnpos + offset or spawnpos
    snake.Transform:SetPosition(spawnpos:Get())
    snake.components.combat:SetTarget(target)
end

local function TriggerTrap(inst, scenariorunner, owner)
	local x, y, z = inst.Transform:GetWorldPosition()

	local vines = TheSim:FindEntities(x, y, z, 10, {"vinehideout"})
	for i = 1, #vines, 1 do
		if vines[i].components.hackable:CanBeHacked() then
			inst:DoTaskInTime(math.random(0, 2), function() SpawnSnake(vines[i], owner) end)
		end
	end

	local vinetraps = TheSim:FindEntities(x, y, z, 10, {"vinetrap"})
	for i = 1, #vinetraps, 1 do
		vinetraps[i].components.scenariorunner:ClearScenario()
	end
	scenariorunner:ClearScenario()
end

local function OnLoad(inst, scenariorunner)
	inst:AddTag("vinetrap")
    inst.scene_putininventoryfn = function(inst, owner) TriggerTrap(inst, scenariorunner, owner) end
	inst:ListenForEvent("onputininventory", inst.scene_putininventoryfn)
	-- RemoveBlowInHurricane(inst)
end

local function OnDestroy(inst)
	inst:RemoveTag("vinetrap")
    if inst.scene_putininventoryfn then
        inst:RemoveEventCallback("onputininventory", inst.scene_putininventoryfn)
        inst.scene_putininventoryfn = nil
    end
end

return {
	OnLoad = OnLoad,
	OnDestroy = OnDestroy
}%%+%%scripts/scenarios/staff_erruption.lua%%-%%local function TriggerTrap(inst, scenariorunner)
	local vm = TheWorld.components.volcanomanager
	if vm then
		vm:StartStaffTrap(inst)
	end
	scenariorunner:ClearScenario()
end

local function OnLoad(inst, scenariorunner)
	if not inst:HasTag("nosteal") then
		inst:AddTag("nosteal")
	end
    inst.scene_putininventoryfn = function() TriggerTrap(inst, scenariorunner) end
	inst:ListenForEvent("onputininventory", inst.scene_putininventoryfn)
end

local function OnDestroy(inst)
    if inst.scene_putininventoryfn then
        inst:RemoveEventCallback("onputininventory", inst.scene_putininventoryfn)
        inst.scene_putininventoryfn = nil
    end
end

return
{
	OnLoad = OnLoad,
	OnDestroy = OnDestroy
}%%+%%scripts/stategraphs/SGballphin.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
	ActionHandler(ACTIONS.GOHOME, "gohome"),
	ActionHandler(ACTIONS.EAT, "eat"),
	ActionHandler(ACTIONS.PICKUP, "pickup"),
	ActionHandler(ACTIONS.EQUIP, "pickup"),
	ActionHandler(ACTIONS.TAKEITEM, "pickup"),
	ActionHandler(ACTIONS.MINE, "mine"),
}


local events=
{
	CommonHandlers.OnSleep(),
	CommonHandlers.OnLocomote(false,true),
	CommonHandlers.OnAttacked(true),
	CommonHandlers.OnAttack(),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnDeath(),
}

local states=
{

	State{

		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("idle", true)
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/idle_swim")
			inst.sg:SetTimeout(4 + math.random()*3)
		end,

		ontimeout = function(inst)
			inst.sg:GoToState("flip")
		end,
	},

	State{

		name = "flip",
		tags = {"busy", "canrotate"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("jump")
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/emerge")
		end,

		timeline=
		{
			TimeEvent(7*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_sml") end),
		},

		events=
		{
			EventHandler("animover", function(inst) 
				inst.sg:GoToState("idle")
			end),
		},
	},

	State{

		name = "hiding",
		tags = {"busy", "invisible"},
		onenter = function(inst, playanim)
		end,

		timeline=
		{
			TimeEvent(TUNING.SEG_TIME, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_sml")  inst.AnimState:PlayAnimation("leap") inst:Show() end),
			TimeEvent(TUNING.SEG_TIME + 14*FRAMES, function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{

		name = "searching",
		tags = {"busy", "invisible"},
		onexit = function(inst, playanim)
			if inst.components.follower then
				local leader = inst.components.follower.leader
				if leader and leader.components.searchable
				and leader.components.searchable.OnSearchEnd ~= nil then
					leader.components.searchable.OnSearchEnd(leader, inst)
					leader.sg:GoToState("dismount")
				end
			end

		end,

		timeline=
		{
			TimeEvent(100*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_sml")  inst.AnimState:PlayAnimation("leap") inst:Show() end),
			TimeEvent(100*FRAMES + 14*FRAMES, function(inst) inst.sg:GoToState("idle") end),
		},
	},
	
	State{
		name = "mine",
		tags = {"mining"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("atk")
		end,
		
		timeline=
		{
			
			TimeEvent(13*FRAMES, function(inst) inst:PerformBufferedAction() end ),
		},
		
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

    State{
        name = "eat",
        tags = {"busy"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("sleep_pre")
            inst.AnimState:PushAnimation("sleep_loop", false)
        end,

        timeline=
        {
            TimeEvent(10*FRAMES, function(inst) inst:PerformBufferedAction() end),
            TimeEvent(60*FRAMES, function(inst) inst.sg:GoToState("idle") end),
        },
    },
	
	State{
		name = "walk_start",
		tags = {"moving", "canrotate"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("walk_pre")
		end,

		events =
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
		},
	},

	State{
		name = "walk",
		tags = {"moving", "canrotate"},

		onenter = function(inst)
			inst.components.locomotor:WalkForward()
			if math.random() < 0.8 then
				inst.AnimState:PlayAnimation("walk_loop")
			else
				inst.AnimState:PlayAnimation("leap")
			end
		end,
		timeline=
		{
			TimeEvent(21*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimbreach_sml") end),
			TimeEvent(48*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimbreach_sml") end),
		},
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),
		},
	},

	State{
		name = "leap",
		tags = {},
		onenter = function(inst)

		end,
	},

	State{
		name = "walk_stop",
		tags = {"canrotate"},

		onenter = function(inst)
			inst.components.locomotor:StopMoving()
			inst.AnimState:PlayAnimation("walk_pst")
		end,

		timeline=
		{
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_sml") end),
			TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/balphin/emerge") end),
		},

		events=
		{   
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),        
		},
	},

	State{
		name = "death",
		tags = {"busy"},

		onenter = function(inst)
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/death")
			inst.AnimState:PlayAnimation("death")
			inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
		end,

	},

	State{
		name = "hit",
		tags = {"busy", "hit"},

		onenter = function(inst, cb)
			inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default )
			inst.AnimState:PlayAnimation("hit")
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/hit")
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "attack",
		tags = {"attack", "busy"},

		onenter = function(inst, target)
			inst.sg.statemem.target = target
			inst.Physics:Stop()
			inst.components.combat:StartAttack()
			inst.AnimState:PlayAnimation("atk", false)
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/attack")
		end,

		onexit = function(inst)
		end,

		timeline=
		{
			TimeEvent(16*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
		},

		events=
		{
			EventHandler("animqueueover",  function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "taunt",
		tags = {"busy"},

		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("taunt")
			inst.SoundEmitter:PlaySound("ia/creatures/balphin/taunt")
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},
}

CommonStates.AddSleepStates(states, 
{
	sleeptimeline = 
	{
		TimeEvent(1, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/balphin/sleep") end)
	},
})

CommonStates.AddFrozenStates(states)
CommonStates.AddSimpleActionState(states,"pickup", "jump", 10*FRAMES, {"busy"})
CommonStates.AddSimpleActionState(states, "gohome", "jump", 4*FRAMES, {"busy"})
  
return StateGraph("ballphin", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGbermudatriangle.lua%%-%%require("stategraphs/commonstates")

local actionhandlers=
{

}

local events=
{

}

local states=
{
	State{
		name = "idle",
		tags = {"idle"},
		onenter = function(inst)
			inst.AnimState:PlayAnimation("idle_loop")
		end,

		onexit = function(inst)
			inst.SoundEmitter:SetVolume("idle", 0.0)
		end,

        timeline=
        {
            TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/bermuda/sparks_inactive", "idle") end),
        },

		events =
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("idle")
			end),
		},
	},

	State{
		name = "open",
		tags = {"idle", "open"},
		onenter = function(inst)
			inst.AnimState:PlayAnimation("open_loop")
			-- since we can jump right to the open state, retrigger this sound.
			inst.SoundEmitter:PlaySound("ia/common/bermuda/lp", "wormhole_open")
		end,

		onexit = function(inst)
			inst.SoundEmitter:KillSound("wormhole_open")
		end,

        timeline=
        {
            TimeEvent(2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/bermuda/sparks_active") end),
            TimeEvent(42*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/bermuda/sparks_active") end),
        },

		events =
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("open")
			end),
		},
	},

	State{
		name = "opening",
		tags = {"busy", "open"},
		onenter = function(inst)
			inst.AnimState:PlayAnimation("open_pre")
			inst.SoundEmitter:PlaySound("ia/common/bermuda/open", "wormhole_opening")
		end,

		events=
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("open")
			end),
		},
	},
		
	State{
		name = "closing",
		tags = {"busy"},
		onenter = function(inst)
			inst.AnimState:PlayAnimation("open_pst")
			inst.SoundEmitter:PlaySound("ia/common/bermuda/close", "wormhole_closing")
		end,

		events=
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("idle")
			end),
		},
	},
}

return StateGraph("bermudatriangle", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGbuoy.lua%%-%%local actionhandlers = {

}

local events = {

}

local states = {
    State{
        name = "idle",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("idle", true)
        end,

        timeline = {
            TimeEvent(23*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/buoy_bell") end),
            TimeEvent(77*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/buoy_bell") end)
        },

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },

    State{
        name = "hit",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("hit")
            inst.SoundEmitter:PlaySound("ia/common/bouy_bell")
        end,

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },

    State{
        name = "place",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("place")
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_lrg")
        end,

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },
}

return StateGraph("buoy", states, events, "idle", actionhandlers)%%+%%scripts/stategraphs/SGcrab.lua%%-%%local WALK_SPEED = 4
local RUN_SPEED = 7

require("stategraphs/commonstates")

local actionhandlers = 
{
  ActionHandler(ACTIONS.EAT, "eat"),
  ActionHandler(ACTIONS.GOHOME, "action"),
  ActionHandler(ACTIONS.CRAB_HIDE, "hide_pre"),
}

local function PlayCrabFootstep(inst)
  local sound = inst.SoundEmitter

  if sound then
    local tile, tileinfo = inst:GetCurrentTileType()

    if tile and tileinfo then
      local x, y, z = inst.Transform:GetWorldPosition()

      if tile == GROUND.BEACH then
        sound:PlaySound("ia/creatures/crab/walk_sand")
        return
      end

      local oncreep = TheWorld.GroundCreep:OnCreep( x, y, z )
      if oncreep then
        sound:PlaySound("ia/creatures/crab/walk_web")
        return
      end

      local onflood = TheWorld.components.flooding and TheWorld.components.flooding:OnFlood( x, y, z )
      if onflood then
        sound:PlaySound("ia/creatures/crab/walk_mud")
        return
      end

      if TheWorld.state.snowlevel > 0.15 then
        sound:PlaySound("ia/creatures/crab/walk_snow")
        return
      end

      if TheWorld.state.moisture > 15 then
        sound:PlaySound("ia/creatures/crab/walk_mud")
        return
      end

      if tile == GROUND.FLOOD or tile == GROUND.MARSH or tile == GROUND.MUD then
        sound:PlaySound("ia/creatures/crab/walk_mud")
        return
      end

      if tile == GROUND.FUNGUS or tile == GROUND.FUNGUSRED or tile == GROUND.FUNGUSGREEN then
        sound:PlaySound("ia/creatures/crab/walk_moss")
        return
      end

      if tile == GROUND.GRASS then
        sound:PlaySound("ia/creatures/crab/walk_grass")
        return
      end

      if tile == GROUND.SAVANNA then
        sound:PlaySound("ia/creatures/crab/walk_tallgrass")
        return
      end

      if tile == GROUND.CARPET then
        sound:PlaySound("ia/creatures/crab/walk_carpet")
        return
      end

      if tile == GROUND.ROAD or tile == GROUND.ROCKY or tile == GROUND.CHECKER or 
      tile == GROUND.VOLCANO or tile == GROUND.UNDERROCK or tile == GROUND.BRICK_GLOW or tile == GROUND.BRICK then

        sound:PlaySound("ia/creatures/crab/walk_marble")
        return
      end

      -- catch all
      if TheWorld.state.snowlevel > 0.15 then
        sound:PlaySound("ia/creatures/crab/walk_ice")
      else
        sound:PlaySound("ia/creatures/crab/walk_dirt")
      end
    end
  end

end

local function PlayCrabFootstepRun(inst)
  local sound = inst.SoundEmitter

  if sound then
    local tile, tileinfo = inst:GetCurrentTileType()

    if tile and tileinfo then
      local x, y, z = inst.Transform:GetWorldPosition()

      if tile == GROUND.BEACH then
        sound:PlaySound("ia/creatures/crab/run_sand")
        return
      end

      local oncreep = TheWorld.GroundCreep:OnCreep( x, y, z )
      if oncreep then
        sound:PlaySound("ia/creatures/crab/run_web")
        return
      end

      local onflood = TheWorld.components.flooding and TheWorld.components.flooding:OnFlood( x, y, z )
      if onflood then
        sound:PlaySound("ia/creatures/crab/run_mud")
        return
      end

      if TheWorld.state.snowlevel > 0.15 then
        sound:PlaySound("ia/creatures/crab/run_snow")
        return
      end

      if TheWorld.state.snowlevel > 0.15 then
        sound:PlaySound("ia/creatures/crab/run_mud")
        return
      end

      if tile == GROUND.FLOOD or tile == GROUND.MARSH or tile == GROUND.MUD then
        sound:PlaySound("ia/creatures/crab/run_mud")
        return
      end

      if tile == GROUND.FUNGUS or tile == GROUND.FUNGUSRED or tile == GROUND.FUNGUSGREEN then
        sound:PlaySound("ia/creatures/crab/run_moss")
        return
      end

      if tile == GROUND.GRASS then
        sound:PlaySound("ia/creatures/crab/run_grass")
        return
      end

      if tile == GROUND.SAVANNA then
        sound:PlaySound("ia/creatures/crab/run_tallgrass")
        return
      end

      if tile == GROUND.CARPET then
        sound:PlaySound("ia/creatures/crab/run_carpet")
        return
      end

      if tile == GROUND.ROAD or tile == GROUND.ROCKY or tile == GROUND.CHECKER or 
      tile == GROUND.VOLCANO or tile == GROUND.UNDERROCK or tile == GROUND.BRICK_GLOW or tile == GROUND.BRICK then

        sound:PlaySound("ia/creatures/crab/run_marble")
        return
      end

      -- catch all
      if TheWorld.state.snowlevel > 0.15 then
        sound:PlaySound("ia/creatures/crab/run_ice")
      else
        sound:PlaySound("ia/creatures/crab/run_dirt")
      end
    end
  end
end

local events=
{
  CommonHandlers.OnSleep(),
  CommonHandlers.OnFreeze(),
  CommonHandlers.OnLocomote(true, true),
  EventHandler("attacked", function(inst) if inst.components.health:GetPercent() > 0 then inst.sg:GoToState("hit") end end),
  EventHandler("death", function(inst, data) inst.sg:GoToState("death", data) end),
  EventHandler("trapped", function(inst) inst.sg:GoToState("trapped") end),
  EventHandler("locomote",
    function(inst)
      if not inst.sg:HasStateTag("idle") and not inst.sg:HasStateTag("moving") then return end

      if not inst.components.locomotor:WantsToMoveForward() then
        if not inst.sg:HasStateTag("idle") then
          if not inst.sg:HasStateTag("running") then
            inst.sg:GoToState("idle")
          end
          inst.sg:GoToState("idle")
        end
      elseif inst.components.locomotor:WantsToRun() then
        if not inst.sg:HasStateTag("running") then
          inst.sg:GoToState("run")
        end
      else
        if not inst.sg:HasStateTag("hopping") then
          inst.sg:GoToState("hop")
        end
      end
    end),
  EventHandler("stunned", function(inst) inst.sg:GoToState("stunned") end),
}

local states=
{

  State{
    name = "look",
    tags = {"idle", "canrotate" },
    onenter = function(inst)

      inst.data.lookingup = nil
      inst.data.donelooking = nil

      if math.random() > .5 then
        inst.AnimState:PlayAnimation("lookup_pre")
        inst.AnimState:PushAnimation("lookup_loop", true)
        inst.data.lookingup = true
      else
        inst.AnimState:PlayAnimation("lookdown_pre")
        inst.AnimState:PushAnimation("lookdown_loop", true)
      end

      inst.sg:SetTimeout(2.5 + math.random()*0.5)
    end,

    ontimeout = function(inst)
      inst.data.donelooking = true
      if inst.data.lookingup then
        inst.AnimState:PlayAnimation("lookup_pst")
      else
        inst.AnimState:PlayAnimation("lookdown_pst")
      end
    end,

    events=
    {
      EventHandler("animover", function (inst, data)
          if inst.data.donelooking then
            inst.sg:GoToState("idle")
          end
        end),
    }
  },

  State{

    name = "idle",
    tags = {"idle", "canrotate"},
    onenter = function(inst, playanim)
      inst.Physics:Stop()
      if playanim then
        inst.AnimState:PlayAnimation(playanim)
        inst.AnimState:PushAnimation("idle", true)
      else
        inst.AnimState:PlayAnimation("idle", true)
      end                                
      inst.sg:SetTimeout(1 + math.random()*1)
    end,

    ontimeout= function(inst)
      inst.sg:GoToState("look")
    end,

  },

  State{

    name = "action",
    onenter = function(inst, playanim)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("idle")
      inst:PerformBufferedAction()
    end,
    events=
    {
      EventHandler("animover", function (inst, data) inst.sg:GoToState("idle") end),
    }
  },    

  State{
    name = "eat",

    onenter = function(inst)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("rabbit_eat_pre", false)
      inst.AnimState:PushAnimation("rabbit_eat_loop", true)
      inst.sg:SetTimeout(1+math.random())
    end,

    ontimeout = function(inst)
      inst:PerformBufferedAction()
      inst.sg:GoToState("idle", "rabbit_eat_pst")
    end,

    onexit = function(inst)
      inst:ClearBufferedAction()
    end,
  },    

  State{
    name = "hop",
    tags = {"moving", "canrotate", "hopping"},

    timeline=
    {
      TimeEvent(0*FRAMES, PlayCrabFootstep),
      TimeEvent(3*FRAMES, PlayCrabFootstep),
      TimeEvent(7*FRAMES, PlayCrabFootstep),
      TimeEvent(12*FRAMES, PlayCrabFootstep),
      TimeEvent(16*FRAMES, PlayCrabFootstep),
      TimeEvent(20*FRAMES, PlayCrabFootstep),
      TimeEvent(24*FRAMES, PlayCrabFootstep),
      TimeEvent(28*FRAMES, PlayCrabFootstep),
    },

    onenter = function(inst) 
      inst.AnimState:PlayAnimation("walk_pre")
      inst.AnimState:PushAnimation("walk")
      inst.components.locomotor:WalkForward()
      inst.sg:SetTimeout(1.25+math.random())
    end,

    onupdate= function(inst)
      if not inst.components.locomotor:WantsToMoveForward() then
        inst.sg:GoToState("idle", "walk_pst")
      end
    end,

    ontimeout= function(inst)
      inst.sg:GoToState("hop")
    end,
  },

  State{
    name = "run",
    tags = {"moving", "running", "canrotate"},

    onenter = function(inst) 
      local play_scream = true
      if inst.components.inventoryitem then
        play_scream = inst.components.inventoryitem.owner == nil
      end
      if play_scream then
        inst.SoundEmitter:PlaySound(inst.sounds.scream)
      end
      inst.AnimState:PlayAnimation("run_pre")
      inst.components.locomotor:RunForward()
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("run_loop") end ),
    },
  },

  State{
    name = "run_loop",
    tags = {"moving", "running", "canrotate"},

    onenter = function(inst) 
      inst.AnimState:PlayAnimation("run")
      PlayCrabFootstepRun(inst)
      inst.components.locomotor:RunForward()
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("run_loop") end ),
    },
  },

  State{
    name = "death",
    tags = {"busy"},

    onenter = function(inst, data)
      inst.SoundEmitter:PlaySound(inst.sounds.scream)
      inst.AnimState:PlayAnimation("death")
      inst.Physics:Stop()
      RemovePhysicsColliders(inst)
		-- KAJ: I'm not happy with this, I'd rather set this somewhere else
		-- Mobb: I concur, this is rather obscure.
		inst.causeofdeath = data and data.afflicter or nil   
      inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
    end,

  }, 

  State{
    name = "fall",
    tags = {"busy", "stunned"},
    onenter = function(inst)
      inst.Physics:SetDamping(0)
      inst.Physics:SetMotorVel(0,-20+math.random()*10,0)
      inst.AnimState:PlayAnimation("stunned_loop", true)
      inst:CheckTransformState()
    end,

    onupdate = function(inst)
      local pt = Point(inst.Transform:GetWorldPosition())
      if pt.y < 2 then
        inst.Physics:SetMotorVel(0,0,0)
      end

      if pt.y <= .1 then
        pt.y = 0

        inst.Physics:Stop()
        inst.Physics:SetDamping(5)
        inst.Physics:Teleport(pt.x,pt.y,pt.z)
        inst.DynamicShadow:Enable(true)
        inst.sg:GoToState("stunned")
      end
    end,

    onexit = function(inst)
      local pt = inst:GetPosition()
      pt.y = 0
      inst.Transform:SetPosition(pt:Get())
    end,
  },

  State{
    name = "stunned",
    tags = {"busy", "stunned"},

    onenter = function(inst) 
      --inst.Physics:Stop()
      inst.AnimState:PlayAnimation("stunned_loop", true)
      inst.sg:SetTimeout(GetRandomWithVariance(6, 2) )
      if inst.components.inventoryitem then
        inst.components.inventoryitem.canbepickedup = true
      end
    end,

    onexit = function(inst)
      if inst.components.inventoryitem then
        inst.components.inventoryitem.canbepickedup = false
      end
    end,

    ontimeout = function(inst) inst.sg:GoToState("idle") end,
  },    

  State{
    name = "stunned_post",
    tags = {"busy", "stunned"},

    onenter = function(inst)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("stunned_pst")
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
    },
  },

  State{
    name = "trapped",
    tags = {"busy", "trapped"},

    onenter = function(inst) 
      inst.Physics:Stop()
      inst:ClearBufferedAction()
      inst.AnimState:PlayAnimation("stunned_loop", true)
      inst.sg:SetTimeout(1)
    end,

    ontimeout = function(inst) inst.sg:GoToState("idle") end,
  },

  State{
    name = "hit",
    tags = {"busy"},

    onenter = function(inst)
      inst.SoundEmitter:PlaySound(inst.sounds.hurt)
      inst.AnimState:PlayAnimation("hit")
      inst.Physics:Stop()            
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
    },
  },

  State{
    name = "hide_pre",
    tags = {"busy", "invisible"},

    onenter = function(inst)
      if not inst:HasTag("crab_hidden") then inst:AddTag("crab_hidden") end
      inst.SoundEmitter:PlaySound("ia/creatures/crab/bury")
      inst.AnimState:PlayAnimation("hide")
      inst.Physics:Stop()
      inst:PerformBufferedAction()
      ChangeToInventoryPhysics(inst)
      inst.components.health:SetInvincible(true)
    end,

    onexit = function(inst)
      ChangeToCharacterPhysics(inst)
      inst.components.health:SetInvincible(false)
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("hide_loop") end ),
    },
  },

  State{
    name = "hide_loop",
    tags = {"busy", "invisible"},

    onenter = function(inst)
      inst.AnimState:PlayAnimation("hide_idle")
      inst.Physics:Stop()
      ChangeToInventoryPhysics(inst)
      inst.components.health:SetInvincible(true)
      if inst.components.workable then
        inst.components.workable.workable = true
        inst.components.workable:SetWorkLeft(1)
      end
      inst.sg:SetTimeout(GetRandomWithVariance(6, 2))
    end,

    onexit = function(inst)
      if inst.components.workable then
        inst.components.workable.workable = false
      end
      ChangeToCharacterPhysics(inst)
      inst.components.health:SetInvincible(false)
    end,

    ontimeout = function(inst)
      inst.sg:GoToState("hide_check")
    end,

  },

  State{
    name = "hide_check",
    tags = {"busy", "invisible"},

    onenter = function(inst)
      inst.AnimState:PlayAnimation("look_pre")
      inst.AnimState:PushAnimation("look")
      inst.AnimState:PushAnimation("look_pst", false)
      inst.SoundEmitter:PlaySound("ia/creatures/crab/sandeyes")
      inst.Physics:Stop()
      ChangeToInventoryPhysics(inst)
      inst.components.health:SetInvincible(true)
      if inst.components.workable then
        inst.components.workable.workable = true
        inst.components.workable:SetWorkLeft(1)
      end
    end,

    onexit = function(inst)
      if inst.components.workable then
        inst.components.workable.workable = false
      end
      ChangeToCharacterPhysics(inst)
      inst.components.health:SetInvincible(false)
    end,

    events=
    {
      EventHandler("animqueueover", function(inst)
          local danger = FindEntity(inst, 7, nil, {"scarytoprey"}, {'notarget'}) ~= nil
          if not danger then
            inst.sg:GoToState("hide_post")
          else
            inst.sg:GoToState("hide_loop")
          end
        end),
    },
  },

  State{
    name = "hide_post",
    tags = {"busy"},

    onenter = function(inst)
      inst.SoundEmitter:PlaySound("ia/creatures/crab/emerge")
      inst.AnimState:PlayAnimation("hide_pst")
      inst.Physics:Stop()
      if inst:HasTag("crab_hidden") then inst:RemoveTag("crab_hidden") end
    end,

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
    },
  },

}
-- CommonStates.AddWalkStates(states,
-- {
--     walktimeline = {
--         TimeEvent(0*FRAMES, PlayCrabFootstep),
--         TimeEvent(3*FRAMES, PlayCrabFootstep),
--         TimeEvent(7*FRAMES, PlayCrabFootstep),
--         TimeEvent(12*FRAMES, PlayCrabFootstep),
--         TimeEvent(16*FRAMES, PlayCrabFootstep),
--         TimeEvent(20*FRAMES, PlayCrabFootstep),
--         TimeEvent(24*FRAMES, PlayCrabFootstep),
--         TimeEvent(28*FRAMES, PlayCrabFootstep),
--     },
-- }, {walk = "walk"})
-- CommonStates.AddRunStates(states,
-- {
--     starttimeline = {
--         TimeEvent(0, function(inst) 
--             local play_scream = true
--             if inst.components.inventoryitem then
--                 play_scream = inst.components.inventoryitem.owner == nil
--             end
--             if play_scream then
--                 inst.SoundEmitter:PlaySound(inst.sounds.scream)
--             end
--         end)
--     },
-- }, {run = "run", stoprun = "idle"})
CommonStates.AddSleepStates(states)
CommonStates.AddFrozenStates(states)

return StateGraph("crab", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGcrocodog.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
  ActionHandler(ACTIONS.EAT, "eat"),
  ActionHandler(ACTIONS.HARVEST, "eat"),
}

local events=
{
  EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
  EventHandler("death", function(inst) inst.sg:GoToState("death") end),
  EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then inst.sg:GoToState("attack", data.target) end end),

  EventHandler("locomote", function(inst)
      local is_moving = inst.sg:HasStateTag("moving")
      local is_running = inst.sg:HasStateTag("running")

      local is_idling = inst.sg:HasStateTag("idle")
      local can_run = true 
      local can_walk = true 

      local should_move = inst.components.locomotor:WantsToMoveForward()
      local should_run = inst.components.locomotor:WantsToRun()
      if is_moving and not should_move then
        if is_running then
          inst.sg:GoToState("idle")
        else
          inst.sg:GoToState("idle")
        end
      elseif (is_idling and should_move) or (is_moving and should_move and is_running ~= should_run and can_run and can_walk) then
        if can_run and (should_run or not can_walk) then
          inst.sg:GoToState("run")
        elseif can_walk then
          inst.sg:GoToState("walk")
        end
      end
    end),
  CommonHandlers.OnSleep(),
  CommonHandlers.OnFreeze(),
}

local states=
{

  State{
    name = "idle",
    tags = {"idle", "canrotate"},
    onenter = function(inst, playanim)
      --inst.SoundEmitter:PlaySound("ia/creatures/crocodog/idle")
      inst.Physics:Stop()
      if playanim then
        inst.AnimState:PlayAnimation(playanim)
        inst.AnimState:PushAnimation("idle", true)
      else
        inst.AnimState:PlayAnimation("idle", true)
      end

      if math.random() < .333 and inst:HasTag("enable_shake") then
        inst.sg:GoToState("shake")
      end
    end,

    timeline=
    {
      TimeEvent(13*FRAMES, 
        function(inst) 
          if inst.components.tiletracker.onwater == false then
            -- inst.SoundEmitter:PlaySound("ia/creatures/crocodog/idle") --This sound does not exist in SW fev -M
          else
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/thrust") 
          end
        end),
    },

  },

  State{
    name = "shake",
    tags = {"busy"},

    onenter = function(inst, cb)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("shake")

      if TheWorld.state.isspring or TheWorld.state.isgreen and TheWorld.state.elapseddaysinseason / (TheWorld.state.elapseddaysinseason+TheWorld.state.remainingdaysinseason) > 0.25 then
        local x,y,z = inst.Transform:GetWorldPosition()
        if TheWorld.components.flooding then
          TheWorld.components.flooding:SetPositionPuddleSource(x,0,z)
        end
      end

    end,

    timeline=
    {
      TimeEvent(8*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/shake") end),
    },

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
    },
  },

  State{
    name = "attack",
    tags = {"attack", "busy"},

    onenter = function(inst, target)
      inst.sg.statemem.target = target
      inst.Physics:Stop()
      inst.components.combat:StartAttack()
      inst.AnimState:PlayAnimation("atk_pre")
      inst.AnimState:PushAnimation("atk", false)
    end,

    timeline=
    {
      TimeEvent(5*FRAMES, function(inst) 
          if inst.components.tiletracker.onwater == false then
            inst.SoundEmitter:PlaySound("ia/creatures/crocodog/bark")
          end
        end),
      TimeEvent(18*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/bite") end),
      TimeEvent(20*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
    },

    events=
    {
      EventHandler("animqueueover", function(inst) if math.random() < .1 then inst.components.combat:SetTarget(nil) inst.sg:GoToState("taunt") else inst.sg:GoToState("idle", "atk_pst") end end),
    },
  },

  State{
    name = "eat",
    tags = {"busy"},

    onenter = function(inst, cb)
      inst.Physics:Stop()
      inst.components.combat:StartAttack()
      inst.AnimState:PlayAnimation("atk_pre")
      inst.AnimState:PushAnimation("atk", false)
    end,

    timeline=
    {
      TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/bite") end),
    },

    events=
    {
      EventHandler("animqueueover", function(inst) if inst:PerformBufferedAction() then inst.components.combat:SetTarget(nil) inst.sg:GoToState("taunt") else inst.sg:GoToState("idle", "atk_pst") end end),
    },
  },

  State{
    name = "hit",
    tags = {"busy", "hit"},

    onenter = function(inst, cb)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("hit")
    end,

    timeline=
    {
      TimeEvent(8*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/hit") end),
    },

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
    },
  },


  State{
    name = "taunt",
    tags = {"busy"},

    onenter = function(inst, cb)
      inst.Physics:Stop()
      inst.AnimState:PlayAnimation("taunt")
      inst.SoundEmitter:PlaySound("ia/creatures/crocodog/taunt")

    end,

    timeline=
    {
      TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/taunt") end),
    },

    events=
    {
      EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
    },
  },

  State{
    name = "death",
    tags = {"busy"},

    onenter = function(inst)
      inst.SoundEmitter:PlaySound("ia/creatures/crocodog/death")
      inst.AnimState:PlayAnimation("death")
      inst.Physics:Stop()
      RemovePhysicsColliders(inst)            
      inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))     

      if inst:HasTag("enable_shake") and TheWorld.state.isspring or TheWorld.state.isgreen and 
      TheWorld.state.elapseddaysinseason / (TheWorld.state.elapseddaysinseason+TheWorld.state.remainingdaysinseason) > 0.25 then
        local x,y,z = inst.Transform:GetWorldPosition()
        if TheWorld.components.flooding then
          TheWorld.components.flooding:SetPositionPuddleSource(x,0,z)
        end
      end    
    end,

  },

  State{

    name = "run",
    tags = {"moving", "running", "canrotate"},

    onenter = function(inst) 

      inst.components.locomotor:RunForward()
      inst.AnimState:PlayAnimation("run_loop")
      inst.SoundEmitter:PlaySound("ia/creatures/crocodog/run")

    end,

    timeline=
    {
      TimeEvent(0, function(inst) PlayFootstep(inst) end),
      TimeEvent(3*FRAMES, function(inst) PlayFootstep(inst) end),
      TimeEvent(5*FRAMES, function(inst) PlayFootstep(inst) end),
      TimeEvent(7*FRAMES, function(inst) PlayFootstep(inst) end),
    },

    events=
    {   
      EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),        
    },

  }, 

  State{

    name = "walk",
    tags = {"moving", "canrotate"},

    onenter = function(inst) 
      inst.components.locomotor:WalkForward()
      inst.AnimState:PlayAnimation("run_loop")
      inst.SoundEmitter:PlaySound("ia/creatures/crocodog/bark")
    end,

    timeline=
    {
      TimeEvent(0, function(inst) PlayFootstep(inst) end),
      TimeEvent(3*FRAMES, function(inst) PlayFootstep(inst) end),
      TimeEvent(5*FRAMES, function(inst) PlayFootstep(inst) end),
      TimeEvent(7*FRAMES, function(inst) PlayFootstep(inst) end),
    },

    events=
    {   
      EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
    },
  }
}

CommonStates.AddFrozenStates(states)
CommonStates.AddSleepStates(states,
  {
    sleeptimeline = {
      TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/sleep") end),
      TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/crocodog/sleep") end),
    },
  })

return StateGraph("crocodog", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGdoydoy.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
	ActionHandler(ACTIONS.EAT, "eat_loop"),
	ActionHandler(ACTIONS.PICKUP, "action"),
	ActionHandler(ACTIONS.HARVEST, "action"),
	ActionHandler(ACTIONS.PICK, "action"),
	ActionHandler(ACTIONS.MATE, "mate"),
}

local events=
{
	CommonHandlers.OnSleep(),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnAttacked(),
	CommonHandlers.OnDeath(),

	EventHandler("locomote", function(inst)

		local is_moving = inst.sg:HasStateTag("moving")
		local is_idling = inst.sg:HasStateTag("idle")
		local should_move = inst.components.locomotor:WantsToMoveForward()
		
		if (is_moving and not should_move) then
			inst.sg:GoToState("walk_stop")
		elseif (is_idling and should_move) or (is_moving and should_move ) then
			if not is_moving then
				inst.sg:GoToState("walk_start")
			end
		end
	end),
}

local states=
{   

	State{
		
		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("idle")
			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/idle")
		end,        
	  
		events=
		{
			EventHandler("animover", function(inst)
				if math.random() < 0.25 then
					inst.sg:GoToState("peck")
				else
					inst.sg:GoToState("idle")
				end
			end),
		},
	},

	State{
		name = "action",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PushAnimation("eat_pre", false)
			inst.sg:SetTimeout(math.random()*2+1)
			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/eat_pre")
		end,
		
		timeline=
		{
			-- TimeEvent(7*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/eat") end),
			
			TimeEvent(20*FRAMES, function(inst)
				inst:PerformBufferedAction()
				inst.sg:RemoveStateTag("busy")
				inst.brain:ForceUpdate()
				inst.sg:AddStateTag("wantstoeat")
			end),
		},

		events =
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("eat_pst") end)
		},

		ontimeout = function(inst)
			inst.sg:GoToState("eat_pst") 
		end,
	},

	State{
		name = "eat_loop",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PushAnimation("eat", false)
		end,
		
		timeline = 
		{
			TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/swallow") end),
		},

		events =
		{
			EventHandler("animover", function(inst) 
				inst:PerformBufferedAction()  
			end),

			EventHandler("animqueueover", function(inst) 
				inst.sg:GoToState("eat_pst") 
			end)
		},
	},

	State{
		name = "eat_pst",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("eat_pst")
			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/swallow")
		end,
		
		events =
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "peck",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("peck")

			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/peck")
		end,
		
		timeline = 
		{
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/peck") end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "hatch",
		tags = {"busy"},
		
		onenter = function(inst)
			local angle = math.random()*2*PI
			local speed = GetRandomWithVariance(3, 2)
			inst.Physics:SetMotorVel(speed*math.cos(angle), 0, speed*math.sin(angle))
			inst.AnimState:PlayAnimation("hatch")
		end,

		timeline =
		{
			-- TimeEvent(FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/hatch") end),
			TimeEvent(20*FRAMES, function(inst) inst.Physics:SetMotorVel(0,0,0) end),
			-- TimeEvent(47*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/pop") end)
		},
		
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "mommymate",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("idle", true)
			
			-- inst.sg:SetTimeout(inst.AnimState:GetTotalTime("mate_dance_pre") +
				-- (inst.AnimState:GetTotalTime("mate_dance_loop") * 2) +
				-- inst.AnimState:GetTotalTime("mate_dance_pst") +
				-- inst.AnimState:GetTotalTime("mate_pre") +
				-- (FRAMES*87) +
				-- inst.AnimState:GetTotalTime("mate_pst")
			-- )
		end,
		
		-- ontimeout = function(inst)
			
			-- inst:PerformBufferedAction()
			
			-- inst.sg:GoToState("idle")
		-- end,
		
		events = {
			EventHandler("mateisdone", function(inst)
				inst:PerformBufferedAction()
				inst.sg:GoToState("idle")
			end),
		},
	},

	State{
		name = "mate",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			if not inst.components.mateable.doesdance then
				inst.sg:GoToState("mommymate")
				return
			end

			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("mate_dance_pre")
			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/mate_dance_pre")
		end,
		
		timeline = 
		{
			TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/mating_dance_LP", "mating_dance_LP") end),
		},

		events=
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("dance_loop")
				-- inst:DoTaskInTime(TUNING.DOYDOY_MATING_DANCE_TIME, function (inst)
				-- 	inst.sg:GoToState("dance_pst")
				-- end)
			end),
		},
	},

	State{
		name = "dance_loop",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("mate_dance_loop")
			inst.AnimState:PushAnimation("mate_dance_loop", false)
			-- inst.AnimState:PushAnimation("mate_dance_loop", false)
		end,
		
		events=
		{
			EventHandler("animqueueover", function(inst)
				-- inst.SoundEmitter:KillSound("mating_dance_LP")
				if inst.components.mateable:PartnerValid() then
					-- inst.sg:GoToState("dance_loop")
					inst.sg:GoToState("dance_pst")
				else
					inst.components.mateable:StopMating()
					inst.sg:GoToState("idle")
				end
			end),
		},
	},

	State{
		name = "dance_pst",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("mate_dance_pst")
			inst.SoundEmitter:PlaySound("ia/creatures/doydoy/mate_dance_post")
		end,
		
		
		timeline = 
		{
			TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:KillSound("mating_dance_LP") end),
		},

		events=
		{
			EventHandler("animqueueover", function(inst)
				if inst.components.mateable:PartnerValid() then
					inst.sg:GoToState("jumpin")
				else
					inst.components.mateable:StopMating()
					inst.sg:GoToState("idle")
				end
			end),
		},
	},

	State{
		name = "jumpin",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			inst.Physics:ClearCollisionMask()
			inst.Physics:CollidesWith(COLLISION.WORLD)
			inst.Physics:CollidesWith(COLLISION.OBSTACLES)

			inst.AnimState:PlayAnimation("mate_pre")

			local p1 = inst:GetPosition()
			local p2 = inst.components.mateable:GetPartner():GetPosition()
			local p3 = p1 - p2
			local len = p3:Length()
			p3 = p3:Normalize() * (len/4)
			p3 = p2 + p3
			
			inst.components.locomotor:GoToPoint(p3)

			inst.jumpoutpos = p1
			-- inst.nestpos = p3

			SpawnAt("doydoy_mate_fx", p3)
		end,
		
		events=
		{
			EventHandler("animover", function(inst) 
				inst.sg:GoToState("cloud") 
			end),
		},
	},

	State{
		name = "cloud",
		tags = {"busy", "mating"},
		
		onenter = function(inst)

			inst.components.locomotor:WalkForward()

			inst.entity:Hide()

			inst.sg:SetTimeout(FRAMES*79)
		end,
		
		ontimeout = function(inst)
			inst.sg:GoToState("jumpout")
		end,
	},

	State{
		name = "jumpout",
		tags = {"busy", "mating"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation("mate_pst")
			inst.entity:Show()

			SpawnPrefab("doydoynest").Transform:SetPosition(inst:GetPosition():Get())

			if math.random() < TUNING.DOYDOY_MATING_FEATHER_CHANCE then
				SpawnPrefab("doydoyfeather").Transform:SetPosition(inst:GetPosition():Get())
			end

			inst.components.locomotor:GoToPoint(inst.jumpoutpos)
			inst.components.locomotor:WalkForward()
		end,

		events=
		{
			EventHandler("animover", function(inst) 
				inst.sg:GoToState("idle")
			end),
		},
		
		onexit = function(inst)
			ChangeToCharacterPhysics(inst)

			inst:PerformBufferedAction()
		end,
	},
}

CommonStates.AddFrozenStates(states)
CommonStates.AddWalkStates(states, 
{
	walktimeline =
	{
		TimeEvent(FRAMES, function(inst) PlayFootstep(inst) end),
		TimeEvent(5*FRAMES, function(inst) PlayFootstep(inst) end),
		TimeEvent(10*FRAMES, function(inst) PlayFootstep(inst) end),
	}
})
CommonStates.AddCombatStates(states,
{
	attacktimeline = 
	{
		TimeEvent(20*FRAMES, function(inst)
			inst.components.combat:DoAttack(inst.sg.statemem.target, nil, nil, "electric")
		end),
		-- TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/attack") end),
		TimeEvent(22*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
	},

	deathtimeline = 
	{
		TimeEvent(FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/death") end)
	},
})
CommonStates.AddSleepStates(states, 
{
	starttimeline =
	{
		TimeEvent( 7*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/yawn") end)
	},
	sleeptimeline = 
	{
		TimeEvent(25*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/doydoy/sleep") end)
	},
	waketimeline =
	{
		-- TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/hatch") end)
	}
})
	
return StateGraph("doydoy", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGdoydoybaby.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
	ActionHandler(ACTIONS.EAT, "eat_loop"),
	ActionHandler(ACTIONS.PICKUP, "action"),
	ActionHandler(ACTIONS.HARVEST, "action"),
	ActionHandler(ACTIONS.PICK, "action"),
}

local events=
{
	CommonHandlers.OnSleep(),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnAttacked(),
	CommonHandlers.OnDeath(),
	CommonHandlers.OnLocomote(false,true),
}

local states=
{   

	State{
		
		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("idle")
			if inst.sounds.idle then
				inst.SoundEmitter:PlaySound(inst.sounds.idle)
			end
		end,        
	  
		events=
		{
			EventHandler("animover", function(inst) 
				inst.sg:GoToState("idle") 
			end),
		},
	},

	State{
		name = "action",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("eat", false)
			inst.sg:SetTimeout(math.random()*2+1)
		end,
		
		timeline=
		{
			-- TimeEvent(7*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/eat") end),
			
			TimeEvent(10*FRAMES, function(inst)
				inst:PerformBufferedAction()
				inst.sg:RemoveStateTag("busy")
				inst.brain:ForceUpdate()
				inst.sg:AddStateTag("wantstoeat")
			end),
		},

		events =
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end)
		},

		ontimeout = function(inst)
			inst.sg:GoToState("idle") 
		end,
	},

	State{
		name = "eat_loop",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("eat", false)
		end,

		events =
		{
			EventHandler("animqueueover", function(inst) 
				inst:PerformBufferedAction()  
				inst.sg:GoToState("idle") 
			end)
		},

		timeline = 
		{
			TimeEvent( 1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.eat_pre) end),
			TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.swallow) end),
		},
	},

	State{
		name = "hatch",
		tags = {"busy"},
		
		onenter = function(inst)
			local angle = math.random()*2*PI
			local speed = GetRandomWithVariance(3, 2)
			inst.Physics:SetMotorVel(speed*math.cos(angle), 0, speed*math.sin(angle))
			inst.AnimState:PlayAnimation("hatch")
			inst.SoundEmitter:PlaySound(inst.sounds.hatch)

		end,

		timeline =
		{
			TimeEvent(20*FRAMES, function(inst) inst.Physics:SetMotorVel(0,0,0) end),
		},
		
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},
}

CommonStates.AddFrozenStates(states)
CommonStates.AddWalkStates(states, {
	walktimeline = 
	{ 
		TimeEvent(0*FRAMES, function(inst) 
			if inst:HasTag("baby") then
				-- PlayFootstep(inst)
				-- inst.components.locomotor:WalkForward()
			end
		end),
		TimeEvent(1*FRAMES, function(inst)
			if inst:HasTag("baby") then
				-- inst.components.locomotor:RunForward()
				inst.SoundEmitter:PlaySound(inst.sounds.jump)
			end
		end),
	}
}, nil, true)
CommonStates.AddCombatStates(states,
{
	attacktimeline = 
	{
		TimeEvent(20*FRAMES, function(inst)
			inst.components.combat:DoAttack(inst.sg.statemem.target, nil, nil, "electric")
		end),
		-- TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/attack") end),
		TimeEvent(22*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
	},

	deathtimeline = 
	{
		TimeEvent(FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.death) end)
	},
})
CommonStates.AddSleepStates(states, 
{
	starttimeline =
	{
		-- TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/yawn") end)
	},
	sleeptimeline = 
	{
		-- TimeEvent(25*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/sleep") end)
	},
	waketimeline =
	{
		-- TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/mossling/hatch") end)
	}
})
	
return StateGraph("doydoybaby", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGelephantcactus.lua%%-%%require("stategraphs/commonstates")

local events=
{
	EventHandler("death", function(inst) inst.sg:GoToState("death") end),
	EventHandler("doattack", function(inst) 
		if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then 
			inst.sg:GoToState("attack_pre")
		end
	end),


	EventHandler("attacked", function(inst) 
		if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then
			inst.sg:GoToState("hit") 
		end
	end),

	EventHandler("growspike", function(inst)
		if not inst.components.health:IsDead() then
			inst.sg:GoToState("grow_spike")
		end
	end)
}

local states = {
	State{
		name = "idle",
		tags = {"idle", "canrotate"},

		onenter = function(inst)
			if inst.has_spike then
				inst.AnimState:PlayAnimation("idle_spike")
			else
				inst.AnimState:PlayAnimation("idle")
			end
		end,

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},
	
	State{
		name = "death",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation("death")
			inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
		end,

		timeline = {
			TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/death") end),
		},

		events = {
			EventHandler("animover", function(inst)
				local active = SpawnPrefab("elephantcactus_stump")
				if active then 
					active.Transform:SetPosition(inst.Transform:GetWorldPosition())
					inst:Remove()
				end
			end),
		},
	},
		
	State{
		name = "hit",
		tags = {"hit"},
		
		onenter = function(inst)
			if inst.AnimState:IsCurrentAnimation("idle_spike") then
				inst.AnimState:PlayAnimation("hit_spike")
			else
				inst.AnimState:PlayAnimation("hit")
			end
		end,
		
		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State
	{
		name = "attack_pre",
		tags = {"attack", "canrotate"},
		onenter = function(inst)
			inst.AnimState:PlayAnimation("attack_pre")
		end,

		timeline = {
			TimeEvent(8*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/attack_pre") end),
		},
		
		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("attack") end),
		},
	},

	State
	{
		name = "attack",
		tags = {"attack", "canrotate"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("attack")
			inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/attack")
		end,

		timeline = {
			TimeEvent(2*FRAMES, function(inst) 
				if inst.components.combat then
					inst.components.combat:StartAttack()
					inst.components.combat:DoAttack()
					inst.has_spike = false
					inst.components.timer:StartTimer("SPIKE", TUNING.ELEPHANTCACTUS_REGROW_PERIOD)
				end
			end),
		},

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State
	{
		name = "grow_spike",
		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("grow_spike")
		end,

		timeline = {
			TimeEvent(12*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/grow_pre") end),
			TimeEvent(28*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/grow_spike") end),
		},
		
		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState("idle")
			end),
		},
	},

	State
	{
		name = "dead_to_empty",
		tags = {"busy"},
		onenter = function(inst)
			inst.SoundEmitter:PlaySound("ia/creatures/volcano_cactus/dead_to_empty")
			inst.AnimState:PlayAnimation("dead_to_empty")
		end,
		
		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState("grow_spike")
			end),
		},
	},
}
	
return StateGraph("elephantcactus", states, events, "idle")%%+%%scripts/stategraphs/SGflup.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
    ActionHandler(ACTIONS.GOHOME, "action"),
    ActionHandler(ACTIONS.FLUP_HIDE, "hide_pre"),
}

local function doattackfn(inst, data)
    if not inst.components.health:IsDead() and not inst.sg:HasStateTag("busy") then
        if inst.sg:HasStateTag("ambusher") then
            inst.sg:GoToState("hidden_ambush_attack_pre")
        elseif inst:GetDistanceSqToInst(data.target) > TUNING.FLUP_MELEEATTACK_RANGE*TUNING.FLUP_MELEEATTACK_RANGE then
            inst.sg:GoToState("ambush_attack_pre")
        else
            inst.sg:GoToState("attack")
        end
    end
end

local events=
{
    EventHandler("doattack", doattackfn),

    EventHandler("gotosleep", function(inst)
        if inst.components.health and inst.components.health:GetPercent() > 0 then
            if inst.sg:HasStateTag("ambusher") then
                if inst.sg:HasStateTag("sleeping") then
                    inst.sg:GoToState("sleeping_hidden")
                else
                    inst.sg:GoToState("sleep_hidden")
                end
            else
                if inst.sg:HasStateTag("sleeping") then
                    inst.sg:GoToState("sleeping")
                else
                    inst.sg:GoToState("sleep")
                end
            end
        end
    end),
    CommonHandlers.OnFreeze(),
    CommonHandlers.OnDeath(),
    CommonHandlers.OnAttacked(),

    EventHandler("locomote",
        function(inst)
            if not (inst.sg:HasStateTag("idle") and not
                inst.sg:HasStateTag("moving")) or
                inst.sg:HasStateTag("jumping") then return end

            if not inst.components.locomotor:WantsToMoveForward() then
                if not inst.sg:HasStateTag("idle") then
                    inst.sg:GoToState("idle")
                end
            else
                if not inst.sg:HasStateTag("hopping") then
					if inst.components.locomotor:WantsToRun() then
						inst.sg:GoToState("aggressivehop")
					else
						inst.sg:GoToState("hop")
					end
                end
            end
        end),

    EventHandler("newcombattarget", function(inst, data)
        if inst.sg:HasStateTag("idle") and data.target then
            inst.sg:GoToState("look_pre")
        end
    end)
}

local states=
{
    State{

        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation("idle", true)
            else
                inst.AnimState:PlayAnimation("idle", true)
            end
            inst.sg:SetTimeout(1*math.random()+.5)
        end,

        ontimeout= function(inst)
            if inst.components.locomotor:WantsToMoveForward() then
                inst.sg:GoToState("hop")
            end
        end,
    },

    State{
        name = "action",
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("idle", true)
            inst:PerformBufferedAction()
        end,
        events=
        {
            EventHandler("animover", function (inst)
                inst.sg:GoToState("idle")
            end),
        }
    },

    State{
        name = "aggressivehop",
        tags = {"moving", "canrotate", "hopping", "running"},

        timeline=
        {
            TimeEvent(4*FRAMES, function(inst)
                inst.components.locomotor:RunForward()
                inst.SoundEmitter:PlaySound("ia/creatures/flup/jump")
            end ),
            TimeEvent(15*FRAMES, function(inst)
                inst.Physics:Stop()
                inst.SoundEmitter:PlaySound("ia/creatures/flup/land")
            end ),
        },

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("jump_pre")
            inst.AnimState:PushAnimation("jump")
            inst.AnimState:PushAnimation("jump_pst", false)
        end,

        events=
        {
            EventHandler("animqueueover", function (inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "hop",
        tags = {"moving", "canrotate", "hopping"},


        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("jump_pre")
            inst.AnimState:PushAnimation("jump")
            inst.AnimState:PushAnimation("jump_pst", false)
        end,

        timeline=
        {
            TimeEvent(4*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/flup/jump")
                inst.components.locomotor:WalkForward()
            end ),
            TimeEvent(15*FRAMES, function(inst)
                inst.Physics:Stop()
                inst.SoundEmitter:PlaySound("ia/creatures/flup/land")
            end ),
        },

        events=
        {
            EventHandler("animqueueover", function (inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "attack",
        tags = {"attack"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk_pre")
            inst.AnimState:PushAnimation("atk", false)
        end,

        timeline=
        {
            TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/flup/attack") end),
            TimeEvent(16*FRAMES, function(inst) inst.components.combat:DoAttack() end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "fall",
        tags = {"busy"},
        onenter = function(inst)
			inst.Physics:SetDamping(0)
            inst.Physics:SetMotorVel(0,-20+math.random()*10,0)
            inst.AnimState:PlayAnimation("fall_idle", true)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
        end,

        onupdate = function(inst)
            local pt = Point(inst.Transform:GetWorldPosition())
            if pt.y < 2 then
				inst.Physics:SetMotorVel(0,0,0)
            end

            if pt.y <= .1 then
                pt.y = 0

                inst.Physics:Stop()
				inst.Physics:SetDamping(5)
                inst.Physics:Teleport(pt.x,pt.y,pt.z)
	            inst.DynamicShadow:Enable(true)
                ChangeToCharacterPhysics(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/flup/land")
                inst.sg:GoToState("idle", "jump_pst")
            end
        end,

        onexit = function(inst)
            local pt = inst:GetPosition()
            pt.y = 0
            inst.Transform:SetPosition(pt:Get())
        end,
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/flup/death")
            inst.AnimState:PlayAnimation("death")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,
    },

    State{
        name = "hide_pre",
        tags = {"ambusher", "idle", "canrotate"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hide")
            inst:PerformBufferedAction()
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("hide_loop") end)
        },
    },

    State{
        name = "hide_loop",
        tags = {"idle", "ambusher", "invisible"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst:Hide()
            inst.sg:SetTimeout(math.random() * 5 + 5)
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("ground_pre")
        end,

        onexit = function(inst)
            inst:Show()
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,
    },

    State{
        name = "look_pre",
        tags = {"ambusher", "invisible"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("look_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/flup/eye_ball")
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("look_loop") end)
        },
    },

    State{
        name = "look_loop",

        tags = {"ambusher", "invisible"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            local animnum = 1 --math.random(1,2)
            inst.AnimState:PlayAnimation("look_loop"..animnum, true)

            inst.blinktask = inst:DoTaskInTime(8*FRAMES, function()
                inst.blinktask:Cancel()
                inst.SoundEmitter:PlaySound("ia/creatures/flup/blink")
                inst.blinktask = inst:DoPeriodicTask(59*FRAMES, function()
                    inst.SoundEmitter:PlaySound("ia/creatures/flup/blink")
                end)
            end)
        end,

        onupdate = function(inst)
            if inst.sg.timeinstate > .75 and inst.components.combat:TryAttack() then
                inst.sg:GoToState("hidden_ambush_attack_pre")
            elseif inst.components.combat.target == nil then
                inst.sg:GoToState("look_pst")
            end
        end,

        onexit = function(inst)
            if inst.blinktask then
                inst.blinktask:Cancel()
            end
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,
    },

    State{
        name = "look_pst",
        tags = {"ambusher", "invisible"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("look_pst")
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("hide_loop") end)
        },
    },

    State{
        name = "ground_pre",
        tags = {"ambusher", "invisible", "idle"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("ground_pre")
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("ground_loop") end)
        },
    },

    State{
        name = "ground_loop",
        tags = {"ambusher", "invisible", "idle"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("ground_loop", true)
            inst.sg:SetTimeout(math.random() * 3 + 2)
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("ground_pst")
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,
    },

    State{
        name = "ground_pst",
        tags = {"ambusher", "invisible", "idle"},

        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PushAnimation("ground_pst", false)
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("hide_loop") end)
        },
    },

    State{
        name = "hidden_ambush_attack_pre",
        tags = {"attack", "canrotate", "busy", "jumping"},

        onenter = function(inst, cb)
            inst.DynamicShadow:Enable(false)
            ChangeToInventoryPhysics(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("jump_atk_ground_pre")
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
            ChangeToCharacterPhysics(inst)
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("ambush_attack") end),
        },
    },

    State{
        name = "ambush_attack_pre",
        tags = {"attack", "canrotate", "busy", "jumping"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("jump_atk_pre")
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("ambush_attack") end),
        },
    },

    State{
        name = "ambush_attack",
        tags = {"attack", "canrotate", "busy", "jumping"},

        onenter = function(inst, target)
            inst.components.locomotor:Stop()
            inst.components.locomotor:EnableGroundSpeedMultiplier(false)

            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("jump_atk")
            inst.AnimState:PushAnimation("jump_atk_pst", false)
        end,

        onexit = function(inst)
            inst.components.locomotor:Stop()
            inst.components.locomotor:EnableGroundSpeedMultiplier(true)
        end,

        timeline =
        {
            TimeEvent(0*FRAMES, function(inst) 
                inst.Physics:SetMotorVelOverride(10,0,0)
                inst.SoundEmitter:PlaySound("ia/creatures/flup/jump")
            end),
            TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/flup/attack") end),
            TimeEvent(10*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
            TimeEvent(17*FRAMES,
                function(inst)
                    inst.Physics:ClearMotorVelOverride()
                    inst.components.locomotor:Stop()
                    inst.SoundEmitter:PlaySound("ia/creatures/flup/land")
                end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "hit",
        tags = {"busy", "hit", "canrotate"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hit")
            inst.SoundEmitter:PlaySound("ia/creatures/flup/hurt")
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "sleep_hidden",
        tags = {"ambusher", "busy", "sleeping"},
        
        onenter = function(inst) 
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("look_pst")
            inst.DynamicShadow:Enable(false)
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping_hidden") end ),        
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake_hidden") end),
        },
    },

    State{
            
        name = "sleeping_hidden",
        tags = {"ambusher", "busy", "sleeping"},
        
        onenter = function(inst)
            inst.DynamicShadow:Enable(false)
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
        end,
        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping_hidden") end ),        
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake_hidden") end),
        },
    },       

    State{
            
        name = "wake_hidden",
        tags = {"ambusher", "busy", "waking"},
        
        onenter = function(inst) 
            inst.components.locomotor:StopMoving()
            if inst.components.sleeper and inst.components.sleeper:IsAsleep() then
                inst.components.sleeper:WakeUp()
            end
            inst.DynamicShadow:Enable(false)
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
        end,

        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("ground_pre") end ),        
        },
    },
}

CommonStates.AddSleepStates(states,
{
    sleeptimeline = {TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/flup/sleep") end)},    
})

CommonStates.AddFrozenStates(states)

return StateGraph("flup", states, events, "hide_loop", actionhandlers)%%+%%scripts/stategraphs/SGjellyfish.lua%%-%%local WALK_SPEED = 4
local RUN_SPEED = 7

require("stategraphs/commonstates")

local actionhandlers = 
{
    ActionHandler(ACTIONS.EAT, 'eat'),
    ActionHandler(ACTIONS.GOHOME, 'action'),
}

local events = 
{
    CommonHandlers.OnAttacked(),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),
    EventHandler('death', function(inst) inst.sg:GoToState('death') end),
    EventHandler('locomote',
        function(inst)
            if not inst.sg:HasStateTag('idle') and not inst.sg:HasStateTag('moving') then return end

            if not inst.components.locomotor:WantsToMoveForward() then
                if not inst.sg:HasStateTag('idle') then
                    inst.sg:GoToState('idle')
                end
            else
                if not inst.sg:HasStateTag('moving') then
                    inst.sg:GoToState('swimming')
                end
            end
    end),
}

local states = 
{
    State{
        name = 'idle',
        tags = {'idle', 'canrotate'},

        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
            else
                inst.AnimState:PlayAnimation('idle')
            end
        end,

        events = 
        {
            EventHandler('animqueueover', function(inst)
                if math.random() <= 0.25 then
                    inst.sg:GoToState('shock')
                else
                    inst.sg:GoToState('idle')
                end
            end),
        },
    },

    State{
        name = 'shock',
        tags = { 'idle', 'canrotate'},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation('idle_shock')
            --inst:PlaySound('dontstarve/electric_water')
        end,

        events =
        {
            EventHandler('animover', function(inst) inst.sg:GoToState('idle') end),
        },
    },

    State{
        name = 'swimming',
        tags = {'moving', 'canrotate'},

        onenter = function(inst, skippre)
            if skippre then
                inst.AnimState:PlayAnimation('run')
            else
                inst.AnimState:PlayAnimation('run_pre')
                inst.AnimState:PushAnimation('run')
            end
            inst.components.locomotor:WalkForward()

            if math.random()< 0.5 then
                --inst:PlaySound('something here')
            else
                --inst:PlaySound('a different sound')
            end
        end,

        onupdate = function(inst)
            if not inst.components.locomotor:WantsToMoveForward() then
                inst.sg:GoToState('idle', 'run_pst')
            end
        end,

        events = 
        {
            EventHandler('animover', function(inst)
                inst.sg:GoToState('swimming', true)
            end),

            EventHandler('animqueueover', function(inst)
                inst.sg:GoToState('swimming', true)
            end),
        },
    },

    State{
        name = 'death',
        tags = {'busy'},

        onenter = function(inst)
            --inst:PlaySound('another sound?')
            inst:Hide()
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,
    },

    State{
        name = 'hit',
        tags = {'busy', 'hit'},

        onenter = function(inst, cb)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation('hit')
        end,

        events =
        {
            EventHandler('animover', function(inst) inst.sg:GoToState('idle') end),
        },
    },
}

CommonStates.AddSleepStates(states)
CommonStates.AddFrozenStates(states)

return StateGraph('jellyfish', states, events, 'idle', actionhandlers)
%%+%%scripts/stategraphs/SGknightboat.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = {}

local events =
{
    CommonHandlers.OnLocomote(false, true),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),
    CommonHandlers.OnAttack(),
    CommonHandlers.OnAttacked(),
    CommonHandlers.OnDeath(),
}

local states=
{
    State{
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                -- inst.AnimState:PushAnimation("idle_loop", true)
            else
                inst.AnimState:PlayAnimation("idle_loop", true)
                inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/idle")
            end
        end,
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "taunt",
        tags = {"busy"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
            inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/taunt")
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "walk_start",
        tags = {"moving", "canrotate"},

        onenter = function(inst)
            inst.components.rowboatwakespawner:StartSpawning()
            inst.components.locomotor:WalkForward()
            inst.AnimState:PlayAnimation("walk_pre")
        end,

        onexit = function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        events =
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    },

    State{
        name = "walk",
        tags = {"moving", "canrotate"},

        onenter = function(inst)
            inst.components.rowboatwakespawner:StartSpawning()
            inst.components.locomotor:WalkForward()
            inst.AnimState:PlayAnimation("walk_loop", true)
            inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/move", "walk_loop")
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("walk_loop")
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        -- events =
        -- {   
        --     EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        -- },
    },

    State{
        name = "walk_stop",
        tags = {"canrotate"},

        onenter = function(inst)
            inst.AnimState:PlayAnimation("walk_pst")
            inst.components.locomotor:StopMoving()
            inst.components.rowboatwakespawner:StartSpawning()
        end,

        onexit = function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        events =
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),        
        },
    },
}

CommonStates.AddSleepStates(states,
{
    sleeptimeline = 
    {
        TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/sleep") end),
    }
})
CommonStates.AddFrozenStates(states)
CommonStates.AddCombatStates(states,
{
    attacktimeline = 
    {
        TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/attack") end),
        TimeEvent(11*FRAMES, function(inst) inst.components.combat:DoAttack() end),
        TimeEvent(31*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/cannon") end),
    },
    deathtimeline = 
    {
        TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/death") end),
        TimeEvent(35*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/death_voice") end),
        TimeEvent(72*FRAMES, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/sinking_bubbles")
            inst.SoundEmitter:PlaySound("ia/creatures/knight_steamboat/sinking_parts")
        end),
    },
})


return StateGraph("knightboat", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGlobster.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
	ActionHandler(ACTIONS.EAT, "eat"),
	ActionHandler(ACTIONS.GOHOME, "gohome"),
}

local events=
{
	CommonHandlers.OnSleep(),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnDeath(),
	CommonHandlers.OnAttacked(),
	CommonHandlers.OnLocomote(true, true),
	EventHandler("trapped", function(inst) inst.sg:GoToState("trapped") end),
}

local states=
{
	State{
		
		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			if playanim then
				inst.AnimState:PlayAnimation(playanim)
				inst.AnimState:PushAnimation("idle", true)
			else
				inst.AnimState:PlayAnimation("idle", true)
			end
		end,
	},
	
	State{
		
		name = "gohome",
		tags = {"busy"},
		onenter = function(inst, playanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("burrow")
			inst.components.health:SetInvincible(true)
			inst.SoundEmitter:PlaySound("ia/creatures/lobster/burrow")
		end,
		events=
		{
			EventHandler("animover", function (inst, data) 
				inst:PerformBufferedAction()
				inst.sg:GoToState("idle")
			end),
		},
		onexit = function(inst)
			inst.components.health:SetInvincible(false)
		end,
	},
	
	State{
		name = "eat",
		-- TEMP ART!!!!
		onenter = function(inst)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("sleep_pre", false)
			inst.AnimState:PushAnimation("sleep_loop", true)
			inst.sg:SetTimeout(2+math.random()*4)
		end,
		
		ontimeout= function(inst)
			inst:PerformBufferedAction()
			inst.sg:GoToState("idle", "sleep_pst")
		end,
	},    

	State{
		name = "death",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation("death")
			inst.Physics:Stop()
			RemovePhysicsColliders(inst)
			inst.SoundEmitter:PlaySound("ia/creatures/lobster/death")
		end,

		events =
		{
			EventHandler("animover", function(inst) inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition())) end)
		},

	}, 

	State{
		name = "fall",
		tags = {"busy", "stunned"},
		onenter = function(inst)
			inst.Physics:SetDamping(0)
			inst.Physics:SetMotorVel(0,-20+math.random()*10,0)
			inst.AnimState:PlayAnimation("stunned_loop", true)
			inst:CheckTransformState()
		end,
		
		onupdate = function(inst)
			local pt = Point(inst.Transform:GetWorldPosition())
			if pt.y < 2 then
				inst.Physics:SetMotorVel(0,0,0)
			end
			
			if pt.y <= .1 then
				pt.y = 0

				inst.Physics:Stop()
				inst.Physics:SetDamping(5)
				inst.Physics:Teleport(pt.x,pt.y,pt.z)
				inst.DynamicShadow:Enable(true)
				inst.sg:GoToState("stunned")
			end
		end,

		onexit = function(inst)
			local pt = inst:GetPosition()
			pt.y = 0
			inst.Transform:SetPosition(pt:Get())
		end,
	},    
	
	State{
		name = "stunned",
		tags = {"busy", "stunned"},
		
		onenter = function(inst) 
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("stunned_loop", true)
			if inst.components.inventoryitem then
				inst.components.inventoryitem.canbepickedup = true
			end
		end,
		
		onexit = function(inst)
			if inst.components.inventoryitem then
				inst.components.inventoryitem.canbepickedup = false
			end
		end,
		
		ontimeout = function(inst) inst.sg:GoToState("idle") end,
	},
	
	State{
		name = "trapped",
		tags = {"busy", "trapped"},
		
		onenter = function(inst) 
			inst.Physics:Stop()
			inst:ClearBufferedAction()
			inst.AnimState:PlayAnimation("idle", true)
			inst.sg:SetTimeout(2)
		end,
		
		ontimeout = function(inst) inst.sg:GoToState("idle") end,
	},
	State{
		name = "hit",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation("hit")
			inst.Physics:Stop()            
		end,
		
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
		},        
	},    

}
CommonStates.AddWalkStates(states, {
	starttimeline =
	{
		TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/walk") end)
	},

	walktimeline =
	{
		TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/walk") end),
		TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/walk") end),
		TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/walk") end),
	},

	endtimeline = 
	{
		TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/walk") end)
	},
}, {walk = "walk"})
CommonStates.AddRunStates(states, {
	starttimeline =
	{
		TimeEvent(0, function(inst) 
			inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") 
			inst.SoundEmitter:PlaySound("ia/creatures/lobster/scared") 
		end)
	},

	runtimeline =
	{
		TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") end),
		TimeEvent(2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") end),
		TimeEvent(4*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") end),
		TimeEvent(6*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") end),
	},

	endtimeline = 
	{
		TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/lobster/run") end)
	},
}, {run = "run", stoprun = "idle"})
CommonStates.AddSleepStates(states)
CommonStates.AddFrozenStates(states)

  
return StateGraph("lobster", states, events, "idle", actionhandlers)%%+%%scripts/stategraphs/SGox.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{

}


local events=
{
    CommonHandlers.OnStep(),
    CommonHandlers.OnLocomote(true,true),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),

    EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() then inst.sg:GoToState("attack", data.target) end end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("attacked", function(inst) if inst.components.health:GetPercent() > 0 and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),    
    EventHandler("heardhorn", function(inst, data)
        if inst.components.health:GetPercent() > 0
           and not inst.sg:HasStateTag("attack")
           and data and data.musician then
            inst:FacePoint(Vector3(data.musician.Transform:GetWorldPosition()))
            inst.sg:GoToState("bellow")
        end
    end),    
    EventHandler("loseloyalty", function(inst) if inst.components.health:GetPercent() > 0 and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("shake") end end),    
    
}

local states=
{
    State{
        name = "idle",
        tags = {"idle", "canrotate"},
        
        onenter = function(inst, pushanim)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("idle_loop", true)
            inst.sg:SetTimeout(2 + 2*math.random())
        end,
        
        ontimeout=function(inst)
            local herd = inst.components.herdmember and inst.components.herdmember:GetHerd()
            if not inst:HasTag("baby") and herd and herd.components.mood and herd.components.mood:IsInMood() then
                if math.random() < .5 then
                    inst.sg:GoToState("matingcall")
                else
                    inst.sg:GoToState("tailswish")
                end
            else
                local rand = math.random()
                if rand < .3 then
                    inst.sg:GoToState("graze")
                elseif rand < .6 then
                    inst.sg:GoToState("bellow")
                else
                    inst.sg:GoToState("shake")
                end
            end
        end,
    },
    
    State{
        name = "shake",
        tags = {"canrotate"},
        
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("shake")
        end,
       
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
    
    State{
        name = "bellow",
        tags = {"canrotate"},
        
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("bellow")
            inst.SoundEmitter:PlaySound(inst.sounds.grunt)
        end,
       
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
    
    State{
        name = "matingcall",
        tags = {},
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("mating_taunt1")
            inst.SoundEmitter:PlaySound(inst.sounds.mating_call)
        end,
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
    
    State{
        name = "tailswish",
        tags = {},
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("mating_taunt2")
        end,
        
        timeline=
        {
            TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.tail_swish) end),
            TimeEvent(32*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.tail_swish) end),
        },
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
    
    State{
        name="graze",
        tags = {"idle", "canrotate"},
        
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("graze_loop", true)
            inst.sg:SetTimeout(5+math.random()*5)
        end,
        
        ontimeout= function(inst)
            inst.sg:GoToState("idle")
        end,

    },
    
    State{
        name = "alert",
        tags = {"idle", "canrotate"},
        
        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.SoundEmitter:PlaySound(inst.sounds.curious)
            inst.AnimState:PlayAnimation("alert_pre")
            inst.AnimState:PushAnimation("alert_idle", true)
        end,
    },
    
    State{
        name = "attack",
        tags = {"attack", "busy"},
        
        onenter = function(inst, target)    
			inst.sg.statemem.target = target
            inst.SoundEmitter:PlaySound(inst.sounds.angry)
            inst.components.combat:StartAttack()
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("atk_pre")
            inst.AnimState:PushAnimation("atk", false)
        end,
        
        
        timeline=
        {
            TimeEvent( 6*FRAMES, function(inst)
                inst.components.combat:DoAttack(inst.sg.statemem.target)
                inst.SoundEmitter:PlaySound(inst.sounds.attack_whoosh)
            end),
        },
        
        events=
        {
            EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
        },
    },    
    
    State{
        name = "death",
        tags = {"busy"},
        
        onenter = function(inst)
			inst.SoundEmitter:PlaySound(inst.sounds.death)
            inst.AnimState:PlayAnimation("death")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)            
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
        end,
        
    },

    State{
        name = "emerge",
        tags = {"canrotate", "busy"},
        
        onenter = function(inst)
            -- local is_moving = inst.sg:HasStateTag("moving")
            -- local is_running = inst.sg:HasStateTag("running")
            local should_move = inst.components.locomotor:WantsToMoveForward()
            local should_run = inst.components.locomotor:WantsToRun()
            if should_move then
                inst.components.locomotor:WalkForward()
            elseif should_run then
                inst.components.locomotor:RunForward()
            end

            inst.AnimState:SetBank("ox_water")
            inst.AnimState:PlayAnimation("emerge")
        end,

        timeline=
        {
            TimeEvent( 8*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.emerge) end),
        },
       
        events=
        {
            EventHandler("animover", function(inst) 
                inst.AnimState:PlayAnimation("idle_loop")
                inst.AnimState:SetBank("ox")
                inst.sg:GoToState("idle")
            end),
        },

        onexit = function(inst)
            inst.walksound = inst.sounds.walk_land
        end,
    },

    State{
        name = "submerge",
        tags = {"canrotate", "busy"},
        
        onenter = function(inst)
            local should_move = inst.components.locomotor:WantsToMoveForward()
            local should_run = inst.components.locomotor:WantsToRun()
            if should_move then
                inst.components.locomotor:WalkForward()
            elseif should_run then
                inst.components.locomotor:RunForward()
            end

            inst.AnimState:SetBank("ox_water")
            inst.AnimState:PlayAnimation("submerge")
        end,

        timeline=
        {
            TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.submerge) end),
        },
       
        events=
        {
            EventHandler("animover", function(inst) 
                -- inst.AnimState:SetBank("ox")
                inst.sg:GoToState("idle")
            end),
        },

        onexit = function(inst)
            inst.walksound = inst.sounds.walk_water
        end,
    },
}

CommonStates.AddWalkStates(
    states,
    {
        walktimeline = 
        { 
            TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.walksound) end),
            TimeEvent(40*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.walksound) end),
        }
    })
    
CommonStates.AddRunStates(
    states,
    {
        runtimeline = 
        { 
            TimeEvent( 5*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.walksound) end),
        }
    })

CommonStates.AddSimpleState(states,"hit", "hit")
CommonStates.AddFrozenStates(states)

CommonStates.AddSleepStates(states,
{
    sleeptimeline = 
    {
        TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.sleep) end)
    },
})
    
return StateGraph("ox", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGpackim.lua%%-%%require("stategraphs/commonstates")


local actionhandlers =
{
	ActionHandler(ACTIONS.ATTACK, "fireattack"),
}

local events=
{
	CommonHandlers.OnStep(),
	CommonHandlers.OnSleep(),
	CommonHandlers.OnLocomote(false,true),
	EventHandler("attacked", function(inst)
		if inst.components.health and not inst.components.health:IsDead() then
			inst.sg:GoToState("hit")
			inst.SoundEmitter:PlaySound(inst.sounds.hurt)
		end
	end),
	EventHandler("death", function(inst) inst.sg:GoToState("death") end),

	EventHandler("doattack", function(inst, data)
        if not inst.components.health:IsDead() and not inst.sg:HasStateTag("busy") then
            inst.sg:GoToState("fireattack", data.target)
        end
    end),
}

local states=
{
	State{
		name = "idle",
		tags = {"idle", "canrotate"},

		onenter = function(inst, pushanim)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("idle_loop")
		end,

		timeline=
		{
			TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(19*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			-- TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
			TimeEvent(27*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(35*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
   },


	State{
		name = "death",
		tags = {"busy"},

		onenter = function(inst)
			inst.components.container:Close()
			inst.components.container:DropEverything()
			inst.SoundEmitter:PlaySound(inst.sounds.death)
			inst.AnimState:PlayAnimation("death")
			inst.Physics:Stop()
			RemovePhysicsColliders(inst)
		end,

		timeline=
		{
			TimeEvent( 6*FRAMES, function(inst)
				if inst.PackimState == "FAT" then
					inst.SoundEmitter:PlaySound(inst.sounds.fat_death_spin)
				end
			end),
		},
	},


	State{
		name = "open",
		tags = {"busy", "open"},

		onenter = function(inst)
			inst.Physics:Stop()
			inst.components.sleeper:WakeUp()
			inst.AnimState:PlayAnimation("open")
		end,

		timeline=
		{
			TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.open) end),
			TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("open_idle") end ),
		},
	},

	State{
		name = "open_idle",
		tags = {"busy", "open"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("idle_loop_open")

			if not inst.sg.mem.pant_ducking or inst.sg:InNewState() then
				inst.sg.mem.pant_ducking = 1
			end

		end,

		timeline=
		{
			TimeEvent( 3*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(19*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			-- TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
			TimeEvent(27*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(35*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("open_idle") end ),
		},
	},

	State{
		name = "close",
		tags = {""},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("closed")
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},

		timeline=
		{
			TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.close) end),
			TimeEvent( 5*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},
	},


	State{
		name = "swallow",
		tags = {"busy"},

		onenter = function(inst)
			inst.Physics:Stop()
			inst.components.sleeper:WakeUp()
			inst.AnimState:PlayAnimation("swallow")
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},

		timeline=
		{
			TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.swallow) end),
			TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			-- TimeEvent( 8*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
			TimeEvent( 9*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(28*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(36*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},
	},

	State{
		name = "transform",
		tags = {"busy"},

		onenter = function(inst, swallowed)
			inst.Physics:Stop()
			inst.components.sleeper:WakeUp()
			if swallowed then
				inst.SoundEmitter:PlaySound(inst.sounds.swallow)
				inst.AnimState:PlayAnimation("swallow", false) 
			else
				inst.sg:GoToState("transform_stage2")
			end
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("transform_stage2") end),
		},
	},

	State{
		name = "transform_stage2",
		tags = {"busy"},

		onenter = function(inst)
			inst.Physics:Stop()
			inst.components.sleeper:WakeUp()
			inst.AnimState:PlayAnimation("transform", false) -- 30 fr
			inst.AnimState:PushAnimation("transform_pst", false)
			inst.SoundEmitter:PlaySound(inst.sounds.transform)
			inst.SoundEmitter:PlaySound(inst.sounds.trasnform_stretch)
		end,

		events=
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
		},

		timeline = 
		{
			TimeEvent(30*FRAMES, function(inst)
				if inst.MorphPackim then inst:MorphPackim() end

				inst.SoundEmitter:PlaySound(inst.sounds.transform_pop)
			end)
		},

	},

	State{
		name = "fireattack",
		tags = {"attack", "busy", "canrotate", "throwing"},

		onenter = function(inst)
			if not inst.last_fire_time or (inst.fire_interval and (GetTime() - inst.last_fire_time) > inst.fire_interval) then
				if inst.components.locomotor then
					inst.components.locomotor:StopMoving()
				end
				inst.AnimState:PlayAnimation("fireball")
			else
				inst:ClearBufferedAction()
                inst.sg:GoToState("idle")
			end
		end,

		-- 751
		timeline =
		{
			TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			-- TimeEvent( 3*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
			TimeEvent( 6*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(21*FRAMES, function(inst)
				inst.components.combat:DoAttack()
				inst.fire_interval = math.random(TUNING.PACKIM_FIRE_DELAY_MIN, TUNING.PACKIM_FIRE_DELAY_MAX)
                inst.last_fire_time = GetTime()
			end),
			TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			TimeEvent(30*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
			-- TimeEvent(31*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "hit",
		tags = {"busy"},

		onenter = function(inst)
			if inst.components.locomotor then
				inst.components.locomotor:StopMoving()
			end
			inst.AnimState:PlayAnimation("hit")
		end,

		timeline =
		{
			TimeEvent( 6*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},
}

CommonStates.AddWalkStates(states,
{
	starttimeline = 
	{
		TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
	},
	walktimeline = 
	{
		TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
		TimeEvent( 3*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(18*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
		TimeEvent(19*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(27*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(35*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
	},
	endtimeline = 
	{
		TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
		TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent( 6*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
	},
})

CommonStates.AddSleepStates(states,
{
	starttimeline =
	{
		TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(17*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(32*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
	},
	sleeptimeline =
	{
		TimeEvent( 1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(29*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(45*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		-- TimeEvent(61*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(34*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.sleep) end),
	},
	waketimeline =
	{
		TimeEvent( 1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly_sleep) end),
		TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.bounce) end),
		TimeEvent(23*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(26*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
		TimeEvent(34*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.fly) end),
	},
})

return StateGraph("packim", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGprimeape.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
	ActionHandler(ACTIONS.GOHOME, "action"),
	ActionHandler(ACTIONS.PICKUP, "action"),
	ActionHandler(ACTIONS.STEAL, "action"),
	ActionHandler(ACTIONS.PICK, "action"),
	ActionHandler(ACTIONS.HARVEST, "action"),
	ActionHandler(ACTIONS.ATTACK, "throw"),
	ActionHandler(ACTIONS.EAT, "eat"),
	ActionHandler(ACTIONS.THROW, "kick"),
}

local events=
{
	CommonHandlers.OnLocomote(false, true),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnAttacked(),
	CommonHandlers.OnDeath(),
	CommonHandlers.OnSleep(),
	EventHandler("doattack", function(inst, data)
		if not (inst.components.health:IsDead() or inst.sg:HasStateTag("busy")) then
			--If you're not in melee range throw instead.
			--Maybe do some randomness to throw or not?
			--V2C: gdi. because sg events are queued, ALL data can possibly go invalid >_ <""
			inst.sg:GoToState(
				(not (data.target ~= nil and data.target:IsValid()) and "idle") or
				(inst:GetDistanceSqToInst(data.target) <= TUNING.MONKEY_MELEE_RANGE * TUNING.MONKEY_MELEE_RANGE + 1 and "attack") or
				"throw"
			)
		end
	end),
}

local function clap(inst) inst.SoundEmitter:PlaySound("ia/creatures/monkey_island/clap") end
local function step(inst) PlayFootstep(inst) end

local states =
{
    State{
        
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation("idle_loop", true)
            else
                inst.AnimState:PlayAnimation("idle_loop", true)
            end
			inst.SoundEmitter:PlaySound(inst.soundtype.."/idle")
		end,

		events=
		{
            EventHandler("animover", function(inst) 

                if inst.components.combat.target and
                    inst.components.combat.target:HasTag("player") then

                    if math.random() < 0.05 then
                        inst.sg:GoToState("taunt")
                        return
                    end
				end

				inst.sg:GoToState("idle") 

			end),
		},
	},

    State{
        
        name = "action",
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("interact", true)
            inst.SoundEmitter:PlaySound("dontstarve/wilson/make_trap", "make")
        end,
        onexit = function(inst)
            inst.SoundEmitter:KillSound("make")
        end,
        events=
        {
            EventHandler("animover", function (inst)
                inst:PerformBufferedAction()
                inst.sg:GoToState("idle")
            end),
        }
    }, 

    State{
        
        name = "eat",
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("eat", true)
        end,
        
        onexit = function(inst)
            inst:PerformBufferedAction()
        end,

        timeline = 
        {
            TimeEvent(8*FRAMES, function(inst) 
                local waittime = FRAMES*8
                for i = 0, 3 do
					inst:DoTaskInTime((i * waittime), function() inst.SoundEmitter:PlaySound(inst.soundtype.."/eat") end)
				end
			end)
		},

        events=
        {
            EventHandler("animover", function (inst)
                inst.sg:GoToState("idle")
            end),
        }
    },

    State{
        name = "taunt",
        tags = {"busy"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
        end,

        timeline = 
        {
            TimeEvent(8*FRAMES, function(inst) 
                --12 fist hits
				inst.SoundEmitter:PlaySound(inst.soundtype.."/taunt")
				local waittime = FRAMES*2
				for i = 0, 11 do
					inst:DoTaskInTime((i * waittime), function() inst.SoundEmitter:PlaySound(inst.soundtype.."/chest_pound") end)
				end
			end)
		},

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "throw",
        tags = {"attack", "busy", "canrotate", "throwing"},
        
        onenter = function(inst)
            if not inst.HasAmmo(inst) then
                inst.sg:GoToState("idle")
            end

            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("throw")
        end,

        timeline = 
        {
            TimeEvent(14*FRAMES, function(inst) inst.components.combat:DoAttack()
            inst.SoundEmitter:PlaySound(inst.soundtype.."/throw") end),
        },
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

	State{
		name = "befriend",
		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("befriend")
			inst.components.locomotor:StopMoving()            
		end,

		timeline=
		{
			TimeEvent(14*FRAMES, clap),
			TimeEvent(20*FRAMES, clap),
			TimeEvent(26*FRAMES, clap),
			TimeEvent(31*FRAMES, clap),
			TimeEvent(36*FRAMES, clap),
			TimeEvent(43*FRAMES, clap),
			TimeEvent(51*FRAMES, clap),
			TimeEvent(57*FRAMES, clap),
			TimeEvent(63*FRAMES, clap),
			TimeEvent(68*FRAMES, clap),
			TimeEvent(73*FRAMES, clap),
			TimeEvent(80*FRAMES, clap),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
		},        
	},
}

CommonStates.AddSimpleState(states, "refuse", "refuse", { "busy" })
CommonStates.AddSimpleActionState(states, "kick", "walk_loop", 0 * FRAMES, { "busy", "canrotate" })
CommonStates.AddWalkStates(states,
{
	starttimeline =
	{

	},

	walktimeline = 
	{
		TimeEvent(4*FRAMES, step),
		TimeEvent(5*FRAMES, step),
		TimeEvent(10*FRAMES, function(inst) 
			PlayFootstep(inst)
			if math.random() < 0.1 then
				inst.SoundEmitter:PlaySound(inst.soundtype.."/idle")
			end
		end),
		TimeEvent(11*FRAMES, step),

	},

	endtimeline =
	{

	},
})
CommonStates.AddSleepStates(states,
    {
	starttimeline = 
	{

	},

	sleeptimeline = 
	{
		TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.soundtype.."/sleep") end),
	},

	endtimeline =
	{

	},
})

CommonStates.AddCombatStates(states,
{
	attacktimeline = 
	{
		TimeEvent(17*FRAMES, function(inst)
			inst.components.combat:DoAttack()
			inst.SoundEmitter:PlaySound(inst.soundtype.."/attack")
		end),
	},

	hittimeline =
	{
		TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.soundtype.."/hurt") end),
	},

	deathtimeline =
	{
		TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.soundtype.."/death") end),
	},
})

CommonStates.AddFrozenStates(states)

return StateGraph("primeape", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGrainbowjellyfish.lua%%-%%local WALK_SPEED = 4
local RUN_SPEED = 7

require("stategraphs/commonstates")

local actionhandlers =
{
    ActionHandler(ACTIONS.EAT, "eat"),
    ActionHandler(ACTIONS.GOHOME, "action"),
}

local events =
{
    CommonHandlers.OnAttacked(),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("locomote",
        function(inst)
            if not inst.sg:HasStateTag("idle") and not inst.sg:HasStateTag("moving") then return end

            if not inst.components.locomotor:WantsToMoveForward() then
                if not inst.sg:HasStateTag("idle") then
                        inst.sg:GoToState("idle")
                end
            else
                if not inst.sg:HasStateTag("moving") then
                    inst.sg:GoToState("swimming")
                end

            end
        end),
}

local states =
{

    State{
        name = "idle",
        tags = {"idle", "canrotate"},

        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
            else
                inst.AnimState:PlayAnimation("idle")
            end
        end,

        events=
        {
            EventHandler("animqueueover", function(inst)
                inst.sg:GoToState("idle")
            end),
        },
    },

    State{
        name = "swimming",
        tags = {"moving", "canrotate"},


        onenter = function(inst, skippre)
            if skippre then
                inst.AnimState:PlayAnimation("run")
            else
                inst.AnimState:PlayAnimation("run_pre")
                inst.AnimState:PushAnimation("run")
            end
            inst.components.locomotor:WalkForward()
            --inst.sg:SetTimeout(2*math.random()+.5)
            if math.random() < 0.5 then
                inst.SoundEmitter:PlaySound("ia/creatures/jellyfish/bubble_short")
            else
                inst.SoundEmitter:PlaySound("ia/creatures/jellyfish/bubble_long")
            end
        end,

        onupdate= function(inst)
            if not inst.components.locomotor:WantsToMoveForward() then
                inst.sg:GoToState("idle", "run_pst")
            end
        end,

         events=
        {
             EventHandler("animover", function(inst)
               inst.sg:GoToState("swimming", true)
            end),

             EventHandler("animqueueover", function(inst)
               inst.sg:GoToState("swimming", true)
            end)
        },


    },

     State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/jellyfish/death_murder")
            inst:Hide()
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,

    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("hit")
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
}

CommonStates.AddSleepStates(states)
CommonStates.AddFrozenStates(states)

return StateGraph("rainbowjellyfish", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGseatrap.lua%%-%%local events =
{
    EventHandler("ondropped", function(inst)
        if inst.components.trap then
			if inst:GetIsOnWater() then
				inst.components.trap:Set()
				inst.sg:GoToState("idle")
			else
				inst.sg:GoToState("idle_ground")
            end
        end
    end),
    EventHandler("onpickup", function(inst)
        if inst.components.trap ~= nil then
            inst.components.trap:Disarm()
        end
    end),
    EventHandler("harvesttrap", function(inst, data)
        if inst.components.trap ~= nil then
            inst.components.trap:Disarm(data ~= nil and data.sprung)
        end
    end),
}

local states =
{
	State{
		name = "idle_ground",

		onenter = function(inst)
			inst.AnimState:PlayAnimation("idle")
		end,
	},
	
    State{
        name = "idle",
        onenter = function(inst)
			if inst.components.trap.bait then
				inst.AnimState:PlayAnimation("idle_baited", true)
			else
				inst.AnimState:PlayAnimation("idle_water", true)
			end
        end,

        events =
        {
            EventHandler("springtrap", function(inst, data)
                if data ~= nil and data.loading then
                    inst.sg:GoToState(inst.components.trap.lootprefabs ~= nil and "full" or "empty")
                elseif inst.entity:IsAwake() then
                    inst.sg:GoToState("sprung")
                else
                    inst.components.trap:DoSpring()
                    inst.sg:GoToState(inst.components.trap.lootprefabs ~= nil and "full" or "empty")
                end
            end),
			EventHandler("baited", function(inst)
				inst.AnimState:PlayAnimation("idle_baited", true)
			end),
        },
    },

    State{
        name = "full",
        onenter = function(inst, target)
            inst.AnimState:PlayAnimation("trap_loop", true)
            -- inst.SoundEmitter:PlaySound(inst.sounds.rustle)
        end,

        events =
        {
            EventHandler("harvesttrap", function(inst) inst.sg:GoToState("idle") end),
            -- EventHandler("animover", function(inst) inst.sg:GoToState("full") end),
        },
    },

    State{
        name = "empty",
        onenter = function(inst, target)
            inst.AnimState:PlayAnimation("side", true)
        end,

        events =
        {
            EventHandler("harvesttrap", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "sprung",
        onenter = function(inst, target)
			if inst.components.trap.bait then
				inst.AnimState:PlayAnimation("trap_baited_pre")
			else
				inst.AnimState:PlayAnimation("trap_pre")
			end
        end,
		
		timeline =
		{
			TimeEvent(13*FRAMES, function(inst)
				inst.SoundEmitter:PlaySound("ia/common/sea_trap/drop")
			end),
			TimeEvent(15*FRAMES, function(inst)
				inst.SoundEmitter:PlaySound("ia/common/sea_trap/ground_hit")
			end),
			TimeEvent(17*FRAMES, function(inst)
				inst.SoundEmitter:PlaySound("ia/common/sea_trap/flag")
				inst.components.trap:DoSpring()
			end),
		},

        events =
        {
            EventHandler("animover", function(inst)
                -- inst.SoundEmitter:PlaySound(inst.sounds.close)
                -- inst.components.trap:DoSpring()
                inst.sg:GoToState(inst.components.trap.lootprefabs ~= nil and "full" or "empty")
            end),
        },
    },
}

return StateGraph("seatrap", states, events, "idle")
%%+%%scripts/stategraphs/SGshadowcreature_sea.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = {
    ActionHandler(ACTIONS.GOHOME, "action"),
}

local events = {
    EventHandler("attacked", function(inst)
        if not (inst.sg:HasStateTag("attack") or inst.sg:HasStateTag("hit") or inst.sg:HasStateTag("noattack") or inst.components.health:IsDead()) then
            inst.sg:GoToState("hit")
        end
    end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("doattack", function(inst, data)
        if not (inst.sg:HasStateTag("busy") or inst.components.health:IsDead()) then
            inst.sg:GoToState("attack", data.target)
        end
    end),
    CommonHandlers.OnLocomote(false,true),
}

local function FinishExtendedSound(inst, soundid)
    inst.SoundEmitter:KillSound("sound_"..tostring(soundid))
    inst.sg.mem.soundcache[soundid] = nil
    if inst.sg.statemem.readytoremove and next(inst.sg.mem.soundcache) == nil then
        inst:Remove()
    end
end

local function PlayExtendedSound(inst, soundname)
    if inst.sg.mem.soundcache == nil then
        inst.sg.mem.soundcache = {}
        inst.sg.mem.soundid = 0
    else
        inst.sg.mem.soundid = inst.sg.mem.soundid + 1
    end
    inst.sg.mem.soundcache[inst.sg.mem.soundid] = true
    inst.SoundEmitter:PlaySound(inst.sounds[soundname], "sound_"..tostring(inst.sg.mem.soundid))
    inst:DoTaskInTime(5, FinishExtendedSound, inst.sg.mem.soundid)
end

local function OnAnimOverRemoveAfterSounds(inst)
    if inst.sg.mem.soundcache == nil or next(inst.sg.mem.soundcache) == nil then
        inst:Remove()
    else
        inst:Hide()
        inst.sg.statemem.readytoremove = true
    end
end

local states = {
    State{
        name = "idle",
        tags = {"idle", "canrotate"},

        onenter = function(inst)
            if inst.wantstodespawn then
                local t = GetTime()
                if t > inst.components.combat:GetLastAttackedTime() + 5 then
                    local target = inst.components.combat.target
                    if target == nil or
                        target.components.combat == nil or
                        not target.components.combat:IsRecentTarget(inst) or
                        t > target.components.combat.laststartattacktime + 5 then
                        inst.sg:GoToState("disappear")
                        return
                    end
                end
            end

            inst.components.locomotor:StopMoving()
            if not inst.AnimState:IsCurrentAnimation("idle") then
                inst.AnimState:PlayAnimation("idle", true)
            end
        end,
    },

    State{
        name = "attack",
        tags = {"attack", "busy"},

        onenter = function(inst, target)
            inst.sg.statemem.target = target
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk")
            PlayExtendedSound(inst, "attack_grunt")
        end,

        timeline = {
            TimeEvent(14*FRAMES, function(inst) PlayExtendedSound(inst, "attack") end),
            TimeEvent(16*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
        },

        events = {
            EventHandler("animqueueover", function(inst)
                if math.random() < .333 then
                    inst.components.combat:SetTarget(nil)
                    inst.sg:GoToState("taunt")
                else
                    inst.sg:GoToState("idle")
                end
            end),
        },
    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("disappear")
        end,

        events = {
            EventHandler("animover", function(inst)
                local offset = FindWaterOffset(inst:GetPosition(), 2*math.pi*math.random(), 10, 12)
                local pos = inst:GetPosition()

                if offset then
                    pos = pos + offset
                    inst.Physics:Teleport(pos:Get())
                end

                inst.sg:GoToState("appear")
            end),
        },
    },

    State{
        name = "taunt",
        tags = {"busy"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
            PlayExtendedSound(inst, "taunt")
        end,

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "appear",
        tags = { "busy" },

        onenter = function(inst)
            inst.AnimState:PlayAnimation("appear")
            inst.Physics:Stop()
            PlayExtendedSound(inst, "appear")
        end,

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            PlayExtendedSound(inst, "death")
            inst.AnimState:PlayAnimation("disappear")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(inst:GetPosition())
            inst:AddTag("NOCLICK")
        end,

        events = {
            EventHandler("animover", OnAnimOverRemoveAfterSounds),
        },

        onexit = function(inst)
            inst:RemoveTag("NOCLICK")
        end
    },

    State{
        name = "disappear",
        tags = {"busy"},

        onenter = function(inst)
            PlayExtendedSound(inst, "death")
            inst.AnimState:PlayAnimation("disappear")
            inst.Physics:Stop()
            inst:AddTag("NOCLICK")
        end,

        events = {
            EventHandler("animover", OnAnimOverRemoveAfterSounds),
        },

        onexit = function(inst)
            inst:RemoveTag("NOCLICK")
        end,
    },

    State{

        name = "action",
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            inst:PerformBufferedAction()
        end,

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },
}

CommonStates.AddWalkStates(states)

return StateGraph("shadowcreature_sea", states, events, "appear", actionhandlers)%%+%%scripts/stategraphs/SGsharkitten.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
	ActionHandler(ACTIONS.EAT, "eat"),
    ActionHandler(ACTIONS.GOHOME, "action"),
}

local events=
{
    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then inst.sg:GoToState("attack", data.target) end end),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnLocomote(false,true),
    CommonHandlers.OnFreeze(),
}

local states=
{
    State{
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/idle", "idle")
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation("idle", true)
            else
                inst.AnimState:PlayAnimation("idle", true)
            end
            inst.sg:SetTimeout(2*math.random()+.5)
        end,
        
        onexit = function(inst, playanim)
            inst.SoundEmitter:KillSound("idle")
        end,
    },

    State{
        name = "attack",
        tags = {"attack", "busy"},

        onenter = function(inst, target)
            inst.sg.statemem.target = target
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk_pre")
            inst.AnimState:PushAnimation("atk", false)
        end,

        timeline=
        {

            TimeEvent( 5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/attack_voice") end),
			TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/attack_bite") end),
            TimeEvent(16*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst) if math.random() < .333 then inst.components.combat:SetTarget(nil) inst.sg:GoToState("taunt") else inst.sg:GoToState("idle", "atk_pst") end end),
        },
    },

	State{
        name = "eat",
        tags = {"busy"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("eat_pre")
            inst.AnimState:PushAnimation("eat_loop")
            inst.AnimState:PushAnimation("eat_pst", false)
        end,

		timeline=
        {
            TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/attack_bite") end),
            TimeEvent(11*FRAMES, function(inst) inst:PerformBufferedAction() end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hit")
        end,

        timeline=
        {
            TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/hit_bodyfall") end),
            TimeEvent( 5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/hit_voice") end),
        },

        events=
        {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

	State{
		name = "taunt",
        tags = {"busy"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
        end,

		timeline=
        {
			TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/taunt") end),
			TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/taunt") end),
        },

        events=
        {
            EventHandler("animover", function(inst) if math.random() < .333 then inst.sg:GoToState("taunt") else inst.sg:GoToState("idle") end end),
        },
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/death")
            inst.AnimState:PlayAnimation("death")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,
    },

    State{
        name = "action",
        tags = {"busy"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation('idle')
        end,

        events =
        {
			EventHandler("animover", function(inst) 
                inst:PerformBufferedAction()
                inst.sg:GoToState("idle") 
            end),
        },
    },
}

CommonStates.AddSleepStates(states,
{
	sleeptimeline = {
        TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/sleep_LP") end),
	},
})

CommonStates.AddWalkStates(states,
{
    walktimeline = {
        TimeEvent(5*FRAMES, function(inst) 
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_voice")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_bounce")
        end),
        TimeEvent(20*FRAMES, function(inst) 
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_voice")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_bounce")
        end),
    },    
})

CommonStates.AddRunStates(states,
{
    runtimeline = {
        TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_voice") end),
        TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_bounce") end),
        TimeEvent(16*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_bounce") end),
		TimeEvent(31*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_kitten/walk_bounce") end),
	},
})

CommonStates.AddFrozenStates(states)

return StateGraph("sharkitten", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGsharx.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
	ActionHandler(ACTIONS.EAT, "eat"),
}

local events=
{
    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then inst.sg:GoToState("attack", data.target) end end),
    
    EventHandler("locomote", function(inst)
        local is_moving = inst.sg:HasStateTag("moving")
        local is_running = inst.sg:HasStateTag("running")
        
        local is_idling = inst.sg:HasStateTag("idle")
        local can_run = true 
        local can_walk = true 
        
        local should_move = inst.components.locomotor:WantsToMoveForward()
        local should_run = inst.components.locomotor:WantsToRun()
        if is_moving and not should_move then
            if is_running then
                inst.sg:GoToState("idle")
            else
                inst.sg:GoToState("idle")
            end
        elseif (is_idling and should_move) or (is_moving and should_move and is_running ~= should_run and can_run and can_walk) then
            if can_run and (should_run or not can_walk) then
                inst.sg:GoToState("run")
            elseif can_walk then
                inst.sg:GoToState("walk")
            end
        end
    end),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),
}

local states=
{

    State{
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            -- inst.SoundEmitter:PlaySound("ia/creatures/sharx/panting")
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation("idle", true)
            else
                inst.AnimState:PlayAnimation("idle", true)
            end
            inst.sg:SetTimeout(2*math.random()+.5)
        end,

        timeline=
        {
            TimeEvent(2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/sharx/panting") end),
        },

    },



    State{
        name = "attack",
        tags = {"attack", "busy"},

        onenter = function(inst, target)
            inst.sg.statemem.target = target
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk_pre")
            inst.AnimState:PushAnimation("atk", false)
        end,

        timeline=
        {

			TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/sharx/attack") end),
            TimeEvent(16*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst) if math.random() < .333 then inst.components.combat:SetTarget(nil) inst.sg:GoToState("taunt") else inst.sg:GoToState("idle", "atk_pst") end end),
        },
    },

	State{
        name = "eat",
        tags = {"busy"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk_pre")
            inst.AnimState:PushAnimation("atk", false)
        end,

		timeline=
        {
			TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/sharx/attack") end),
        },

        events=
        {
			EventHandler("animqueueover", function(inst) if inst:PerformBufferedAction() then inst.components.combat:SetTarget(nil) inst.sg:GoToState("taunt") else inst.sg:GoToState("idle", "atk_pst") end end),
        },
    },

	State{
		name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hit")
        end,

        events=
        {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },


    State{
        name = "taunt",
        tags = {"busy"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
            inst.SoundEmitter:PlaySound("ia/creatures/sharx/taunt")

        end,

        timeline=
        {
            TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/sharx/taunt") end),
            TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/sharx/taunt") end),
        },

        events=
        {
            EventHandler("animover", function(inst) if math.random() < .333 then inst.sg:GoToState("taunt") else inst.sg:GoToState("idle") end end),
        },
    },

--[[
	State{
		name = "taunt",
        tags = {"busy"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("taunt")
        end,

		timeline= 
        {
			TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve/creatures/hound/bark") end),
			TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve/creatures/hound/bark") end),
        },

        events=
        {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
]]
    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
			inst.SoundEmitter:PlaySound("ia/creatures/sharx/death")
            inst.AnimState:PlayAnimation("death")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)            
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
        end,

    },

    State{
            
        name = "run",
        tags = {"moving", "running", "canrotate"},
        
        onenter = function(inst) 
            local emergeDist = 7
            local emerge = false 
            if inst.components.combat.target and inst.components.combat.target:IsValid() then 
                if inst:IsNear(inst.components.combat.target, emergeDist) then 
                    emerge = true 
                end 
            end 

            inst.components.locomotor:RunForward()

            if emerge then 
                inst.SoundEmitter:PlaySound("ia/creatures/sharx/growl")
                inst.AnimState:PlayAnimation("run_loop")

            else 
                inst.AnimState:PlayAnimation("run_water_loop")
            end 
        end,
        
        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),        
        },
          
    }, 

     State{
            
        name = "walk",
        tags = {"moving", "canrotate"},
        
        onenter = function(inst) 
            inst.components.locomotor:WalkForward()
            inst.AnimState:PlayAnimation("run_water_loop")
        end,
        
        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    }
}

CommonStates.AddFrozenStates(states)
CommonStates.AddSleepStates(states)

return StateGraph("sharx", states, events, "idle", actionhandlers)

%%+%%scripts/stategraphs/SGslotmachine.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = {}

local events = 
{
	-- EventHandler("lightningstrike", function(inst) 
	--     if not inst.EggHatched then
	--         inst.sg:GoToState("crack")
	--     end
	-- end),
}


local states =
{   
	State{
		name = "idle",
		tags = {"idle"},

		onenter = function(inst)
			-- print('fn1')
			inst.AnimState:PlayAnimation("idle")
		end,
	},

	State{
		name = "spinning",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation("use", false)
		end,

		timeline = 
		{
			TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/slotmachine/coinslot") end),
			TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/slotmachine/leverpull") end),
			TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/slotmachine/jumpup") end),
			TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/slotmachine/spin", "slotspin") end),
		},

		events = 
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("prize_"..inst.prizevalue) end),
		}
	},

	State{
		name = "prize_ok",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation(inst.prizevalue, false)
		end,

		timeline = 
		{
			TimeEvent(29*FRAMES, function(inst) inst.SoundEmitter:KillSound("slotspin") end),
			TimeEvent(30*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds[inst.prizevalue]) end),
		},

		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState("done")
			end),
		}
	},

	State{
		name = "prize_good",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation(inst.prizevalue, false)
		end,

		timeline = 
		{
			TimeEvent(32*FRAMES, function(inst) inst.SoundEmitter:KillSound("slotspin") end),
			TimeEvent(33*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds[inst.prizevalue]) end),
		},

		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState("done")
			end),
		}
	},

	State{
		name = "prize_bad",
		tags = {"busy"},
		
		onenter = function(inst)
			inst.AnimState:PlayAnimation(inst.prizevalue, false)
		end,

		timeline = 
		{
			TimeEvent(31*FRAMES, function(inst) inst.SoundEmitter:KillSound("slotspin") end),
			TimeEvent(32*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds[inst.prizevalue]) end),
		},

		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState("done")
			end),
		}
	},
	
	State{
		name = "done",
		tags = {"idle"},
		
		onenter = function(inst)
			if inst.DoneSpinning then
				inst:DoneSpinning()
			end
		end,
	},
}
	
return StateGraph("slotmachine", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGsnake.lua%%-%%require("stategraphs/commonstates")

local actionhandlers =
{
	ActionHandler(ACTIONS.EAT, "eat"),
--	ActionHandler(ACTIONS.LAVASPIT, "spit"),
	ActionHandler(ACTIONS.GOHOME, "gohome"),
}

local events=
{
	EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
	EventHandler("death", function(inst) inst.sg:GoToState("death") end),
	EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then inst.sg:GoToState("attack", data.target) end end),
	CommonHandlers.OnSleep(),
	CommonHandlers.OnLocomote(true,false),
	CommonHandlers.OnFreeze(),
}

local states=
{

	State{
		name = "gohome",
		tags = {"busy"},
		onenter = function(inst, playanim)
			if inst.components.homeseeker and 
			   inst.components.homeseeker.home and 
			   inst.components.homeseeker.home:IsValid() then

				inst.components.homeseeker.home.AnimState:PlayAnimation("chop", false)
			end
			inst:PerformBufferedAction()
		end,
	},

	State{
		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			inst.SoundEmitter:PlaySound("ia/creatures/snake/idle")
			inst.Physics:Stop()
			if playanim then
				inst.AnimState:PlayAnimation(playanim)
				inst.AnimState:PushAnimation("idle", true)
			else
				inst.AnimState:PlayAnimation("idle", true)
			end
			inst.sg:SetTimeout(2*math.random()+.5)
		end,

	},

	
	State{
		name = "attack",
		tags = {"attack", "busy"},

		onenter = function(inst, target)
			inst.sg.statemem.target = target
			inst.Physics:Stop()
			inst.components.combat:StartAttack()
			inst.SoundEmitter:PlaySound("ia/creatures/snake/preattack")
			inst.AnimState:PlayAnimation("atk_pre")
			inst.AnimState:PushAnimation("atk", false)
			inst.AnimState:PushAnimation("atk_pst", false)
		end,

		timeline=
		{
			TimeEvent(8*FRAMES, function(inst) 
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
				end 
			end),

			TimeEvent(14*FRAMES, function(inst) 
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
				end 
				inst.SoundEmitter:PlaySound("ia/creatures/snake/attack") 
			end),

			TimeEvent(20*FRAMES, function(inst) 
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
				end 
			end),

			TimeEvent(27*FRAMES, function(inst) 
				inst.components.combat:DoAttack(inst.sg.statemem.target) 
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition())
				end 
			end),
		},

		events=
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "eat",
		tags = {"busy"},

		onenter = function(inst, cb)
			inst.Physics:Stop()
			inst.components.combat:StartAttack()
			inst.AnimState:PlayAnimation("atk_pre")
			inst.AnimState:PushAnimation("atk", false)
			inst.AnimState:PushAnimation("atk_pst", false)
		end,

		timeline=
		{
			TimeEvent(14*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/attack") end),
			TimeEvent(24*FRAMES, function(inst) if inst:PerformBufferedAction() then inst.components.combat:SetTarget(nil) end end),
		},

		events=
		{
			EventHandler("animqueueover", function(inst)  inst.sg:GoToState("taunt")  end),
		},
	},

	State{
		name = "spit",
		tags = {"busy"},
		
		onenter = function(inst)
			-- print("snake spit")
			if ((inst.target ~= inst and not inst.target:HasTag("fire")) or inst.target == inst) and not (inst.recently_frozen) then
				if inst.components.locomotor then
					inst.components.locomotor:StopMoving()
				end
				inst.AnimState:PlayAnimation("atk_pre")
				inst.AnimState:PushAnimation("atk", false)
				inst.AnimState:PushAnimation("atk_pst", false)

				inst.components.propagator:StartSpreading()

				--print("vomitfire_fx spawned")
				-- inst.vomitfx = SpawnPrefab("vomitfire_fx")
				-- inst.vomitfx.Transform:SetPosition(inst.Transform:GetWorldPosition())
				-- inst.vomitfx.Transform:SetRotation(inst.Transform:GetRotation())
				--inst.SoundEmitter:PlaySound("dontstarve_DLC001/creatures/dragonfly/vomitrumble", "vomitrumble")
			else
				-- print("no spit")
				inst:ClearBufferedAction()
				inst.sg:GoToState("idle")
			end
		end,

		onexit = function(inst)
			-- print("spit onexit")
			if inst.last_target and inst.last_target ~= inst then
				inst.num_targets_vomited = inst.last_target.components.stackable and inst.num_targets_vomited + inst.last_target.components.stackable:StackSize() or inst.num_targets_vomited + 1
				inst.last_target_spit_time = GetTime()
			end
			--inst.Transform:SetFourFaced()
			-- if inst.vomitfx then 
				-- inst.vomitfx:Remove() 
			-- end
			-- inst.vomitfx = nil
			-- inst.SoundEmitter:KillSound("vomitrumble")

			inst.components.propagator:StopSpreading()
		end,
		
		events=
		{
			EventHandler("animqueueover", function(inst) 
				-- print("spit animqueueover")
				inst.sg:GoToState("idle")
			end),
		},

		timeline=
		{
			TimeEvent(2*FRAMES, function(inst) 
				-- print("spit timeline")
				inst:PerformBufferedAction()
				inst.last_target = inst.target
				inst.target = nil
				inst.spit_interval = math.random(20,30)
				inst.last_spit_time = GetTime()
			end),
		},
	},
	
	State{
		name = "hit",
		tags = {"busy", "hit"},

		onenter = function(inst, cb)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("hit")
			inst.SoundEmitter:PlaySound("ia/creatures/snake/hurt")
		end,

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "taunt",
		tags = {"busy"},

		onenter = function(inst, cb)
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("taunt")
			-- inst.SoundEmitter:PlaySound("ia/creatures/snake/taunt")
		end,

		timeline=
		{
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/taunt") end),
			--TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/taunt") end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
		},
	},

	State{
		name = "death",
		tags = {"busy"},

		onenter = function(inst)
			inst.SoundEmitter:PlaySound("ia/creatures/snake/death")
			inst.AnimState:PlayAnimation("death")
			inst.Physics:Stop()
			RemovePhysicsColliders(inst)            
			inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
		end,

	},
}

CommonStates.AddSleepStates(states,
{
	sleeptimeline = {
		TimeEvent(30*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/sleep") end),
	},
})


CommonStates.AddRunStates(states,
{
	runtimeline = {
		TimeEvent(0, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/move") end),
		TimeEvent(4, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/snake/move") end),
	},
})
CommonStates.AddFrozenStates(states)


return StateGraph("snake", states, events, "taunt", actionhandlers)
%%+%%scripts/stategraphs/SGsolofish.lua%%-%%
require("stategraphs/commonstates")

local actionhandlers = 
{
   -- ActionHandler(ACTIONS.EAT, "eat"),
    --ActionHandler(ACTIONS.GOHOME, "action"),
}

local function GoToLocoState(inst, state)
    if inst:IsLocoState(state) then
        return true
    end
    inst.sg:GoToState("goto"..string.lower(state), {endstate = inst.sg.currentstate.name})
end

local events=
{
    CommonHandlers.OnLocomote(true,true),
    CommonHandlers.OnSleep(),
    CommonHandlers.OnFreeze(),
        
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
}

local states=
{
    

    State{
        name = "gotobelow",
        tags = {"busy"},
        onenter = function(inst, data)

            local splash = SpawnPrefab("splash_water_drop")
            local pos = inst:GetPosition()
            splash.Transform:SetPosition(pos.x, pos.y, pos.z)

            inst.AnimState:PlayAnimation("submerge")
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_med")
            inst.Physics:Stop()
            inst.sg.statemem.endstate = data.endstate
        end,

        onexit = function(inst)
            inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
            inst.Transform:SetNoFaced()
            inst:SetLocoState("below")
        end,

        events=
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState(inst.sg.statemem.endstate)
            end),
        },
    },

    State{
        name = "gotoabove",
        tags = {"busy"},
        onenter = function(inst, data)

            local splash = SpawnPrefab("splash_water_drop")
            local pos = inst:GetPosition()
            splash.Transform:SetPosition(pos.x, pos.y, pos.z)
            
            inst.Physics:Stop()
            inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default)
            inst.Transform:SetFourFaced()
            inst.AnimState:PlayAnimation("emerge")
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_med")
            inst.sg.statemem.endstate = data.endstate

        end,

        onexit = function(inst)
            inst:SetLocoState("above")
        end,

        events=
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState(inst.sg.statemem.endstate)
            end),
        },
    },

    State{
        
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation("shadow", true)
            else
                inst.AnimState:PlayAnimation("shadow", true)
            end                                
        end,
    },

     State{
        name = "eat",
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("shadow_hooked_loop", true)
            inst.sg:SetTimeout(2+math.random()*4)
        end,
        
        ontimeout= function(inst)
            inst:PerformBufferedAction()
            inst.sg:GoToState("idle")
        end,
    },  
    
    State{
        name = "walk_start",
        tags = {"moving", "canrotate", "swimming"},
        
       
        onenter = function(inst) 
            if GoToLocoState(inst, "below") then
                inst.AnimState:PlayAnimation("shadow_flap_loop")
                inst.components.locomotor:WalkForward()
            end
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    },

    State{
        name = "walk",
        tags = {"moving", "canrotate", "swimming"},
        
       
        onenter = function(inst) 
            if GoToLocoState(inst, "below") then
                inst.AnimState:PlayAnimation("shadow_flap_loop")
                inst.components.locomotor:WalkForward()
            end
        end,     

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    },

    State{
        name = "walk_stop",
        tags = {"moving", "canrotate", "swimming"},
        
       
        onenter = function(inst) 
            inst.sg:GoToState("idle")
        end,
    },

    State{
        name = "run_start",
        tags = {"moving", "running", "canrotate"},
        
        onenter = function(inst) 
            if GoToLocoState(inst, "above") then
                inst.AnimState:PlayAnimation("fishmed", true)
                inst.components.locomotor:RunForward()
                if not inst.SoundEmitter:PlayingSound("runsound") then
                    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimemerged_med_LP", "runsound")
                end
            end
        end,
        
        timeline=
        {
            TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_med") end),
            TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Dogfish/emerge") end),
        },
            
        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),        
        },
    },

    State{
        name = "run",
        tags = {"moving", "running", "canrotate"},
        
        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.components.locomotor:RunForward()
                inst.AnimState:PlayAnimation("fishmed")
                if not inst.SoundEmitter:PlayingSound("runsound") then
                    inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimemerged_med_LP", "runsound")
                end
            end
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),
        },

        onexit = function(inst)
            -- inst.SoundEmitter:KillSound("runsound")
        end,
    },

    State{
        name = "run_stop",
        tags = {"moving", "running", "canrotate"},
        
        onenter = function(inst) 
            if GoToLocoState(inst, "below") then
                inst.AnimState:PlayAnimation("shadow_flap_loop")
                inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_med")
                inst.SoundEmitter:KillSound("runsound")
            end
        end,
        
        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),        
        },
    },
    
    State{
        name = "death",
        tags = {"busy"},
        
        onenter = function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/Dogfish/death")
            inst:Hide()
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)        
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
        end,

    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            if GoToLocoState(inst, "above") then
                inst.Physics:Stop()
                inst.AnimState:PlayAnimation("hit")
                inst.SoundEmitter:PlaySound("ia/creatures/Dogfish/hit")
            end
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
}

CommonStates.AddSleepStates(states, 
{
    starttimeline = 
    {
        TimeEvent(0*FRAMES, function(inst)
            GoToLocoState(inst, "above")
        end)
    },
})

CommonStates.AddFrozenStates(states, function(inst)
	inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default)
	inst.Transform:SetFourFaced()
end)
  
return StateGraph("solofish", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGstungray.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = {
	ActionHandler(ACTIONS.GOHOME, "action"),
}

local events = {
	CommonHandlers.OnLocomote(true, true),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnAttack(),
	CommonHandlers.OnAttacked(),
	CommonHandlers.OnDeath(),
	CommonHandlers.OnSleep(),
}

local function GoToLocoState(inst, state)
	if inst:IsLocoState(state) then
		return true
	end
	inst.sg:GoToState("goto"..string.lower(state), {endstate = inst.sg.currentstate.name})
end

local states = {
	State{
		name = "gotoswim",
		tags = {"busy", "swimming"},
		onenter = function(inst, data)
			inst.AnimState:PlayAnimation("submerge")
			inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_sml")
			inst.Physics:Stop()
            inst.sg.statemem.endstate = data.endstate
		end,

		onexit = function(inst)
			inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
			inst.Transform:SetNoFaced()
			inst.DynamicShadow:Enable(false)
			inst:SetLocoState("swim")
		end,

		events = {
			EventHandler("animover", function(inst)
				inst.Transform:SetScale(inst.scale_water, inst.scale_water, inst.scale_water)
				inst.sg:GoToState(inst.sg.statemem.endstate)
			end),
		},
	},

	State{
		name = "gotofly",
		tags = {"busy"},
		onenter = function(inst, data)
			inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default)
			inst.Transform:SetFourFaced()
			inst.Physics:Stop()
			inst.AnimState:PlayAnimation("emerge")
			inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_sml")
	        inst.sg.statemem.endstate = data.endstate
	        inst.DynamicShadow:Enable(true)

	        inst.Transform:SetScale(inst.scale_flying, inst.scale_flying, inst.scale_flying)
		end,

		onexit = function(inst)
			inst:SetLocoState("fly")
		end,

		events = {
			EventHandler("animover", function(inst)
				inst.sg:GoToState(inst.sg.statemem.endstate)
			end),
		},
	},

	State{
		name = "idle",
		tags = {"idle", "canrotate"},
		onenter = function(inst, playanim)
			if GoToLocoState(inst, "fly") then
				inst.Physics:Stop()
				inst.AnimState:PlayAnimation("fly_loop", true)
				inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/idle")
			end
		end,

		timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
		},

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "action",
		onenter = function(inst)
			if GoToLocoState(inst, "fly") then
				inst.Physics:Stop()
				inst.AnimState:PlayAnimation("fly_loop", true)
				inst:PerformBufferedAction()
			end
		end,

		timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
		},

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		}
	},

	State{
		name = "taunt",
		tags = {"busy"},

		onenter = function(inst)
			if GoToLocoState(inst, "fly") then
				inst.Physics:Stop()
				inst.AnimState:PlayAnimation("taunt")
			end
		end,

		timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/taunt") end),
		},

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	 State{ --This state isn't really necessary but I'm including it to make the default "OnLocomote" work
        name = "run_start",
        tags = {"moving", "running", "canrotate"},

        onenter = function(inst)
			if GoToLocoState(inst, "fly") then
				inst.components.locomotor:RunForward()
				inst.AnimState:PlayAnimation("fly_loop")
			end
        end,

        timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
		},

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end),
        },
    },

	State{
		name = "run",
		tags = {"moving", "canrotate", "running"},

		onenter = function(inst)
			if GoToLocoState(inst, "fly") then
				inst.components.locomotor:RunForward()
				inst.AnimState:PlayAnimation("fly_loop")
			end
		end,

		timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
		},

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("run") end),
		},
	},

	State{ --This state isn't really necessary but I'm including it to make the default "OnLocomote" work
        name = "run_stop",
        tags = {"idle"},

        onenter = function(inst)
			if GoToLocoState(inst, "fly") then
				inst.components.locomotor:StopMoving()
				--We don't need to play an animation here because it is the same animation as
				--the "run" state. Just let that one finish playing.
			end
        end,

        timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
		},

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
        },
    },

	State{
		name = "swim_idle",
		tags = {"idle", "canrotate", "swimming"},
		onenter = function(inst)
			if GoToLocoState(inst, "swim") then
				inst.Physics:Stop()
				inst.AnimState:PlayAnimation("shadow", true)
			end
		end,

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("swim_idle") end),
		},
	},

	State{
		name = "walk_start",
		tags = {"moving", "canrotate", "swimming"},

		onenter = function(inst)
			if GoToLocoState(inst, "swim") then
				inst.components.locomotor:WalkForward()
				inst.AnimState:PlayAnimation("shadow")
			end
		end,

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end),
		},
	},

	State{
		name = "walk",
		tags = {"moving", "canrotate", "swimming"},

		onenter = function(inst)
			if GoToLocoState(inst, "swim") then
				inst.components.locomotor:WalkForward()
				inst.AnimState:PlayAnimation("shadow")
			end
		end,

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end),
		},
	},

	State{
		name = "walk_stop",
		tags = {"canrotate", "swimming"},

		onenter = function(inst)
			if GoToLocoState(inst, "swim") then
				inst.components.locomotor:StopMoving()
				inst.AnimState:PlayAnimation("shadow")
			end
		end,

		events = {
			EventHandler("animover", function(inst) inst.sg:GoToState("swim_idle") end),
		},
	},

    State{
        name = "sleep",
        tags = {"busy", "sleeping"},

        onenter = function(inst)
            if GoToLocoState(inst, "fly") then
            	inst.components.locomotor:StopMoving()
            	inst.AnimState:PlayAnimation("sleep_pre")
        	end
        end,

        timeine = {
        	TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/sleep") end),
        },

        events =         {
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping") end ),
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake") end),
        },
    },

    State{
        name = "sleeping",
        tags = {"busy", "sleeping"},

        onenter = function(inst)
            if GoToLocoState(inst, "fly") then
            	inst.AnimState:PlayAnimation("sleep_loop")
            end
        end,

        timeine = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/sleep") end),
        },

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping") end ),
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake") end),
        },
    },

    State{
        name = "wake",
        tags = {"busy", "waking"},

        onenter = function(inst)
            if GoToLocoState(inst, "fly") then
	            inst.components.locomotor:StopMoving()
	            inst.AnimState:PlayAnimation("sleep_pst")
	            if inst.components.sleeper and inst.components.sleeper:IsAsleep() then
	                inst.components.sleeper:WakeUp()
	            end
	        end
        end,

        timeine = {
        	TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
        },

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
        },
    },

    State{
        name = "frozen",
        tags = {"busy", "frozen"},

        onenter = function(inst)
	        if GoToLocoState(inst, "fly") then
	            if inst.components.locomotor then
	                inst.components.locomotor:StopMoving()
	            end
	            inst.AnimState:PlayAnimation("frozen_loop", true)
	            inst.SoundEmitter:PlaySound("dontstarve/common/freezecreature")
	            inst.AnimState:OverrideSymbol("swap_frozen", "frozen", "frozen")
	        end
        end,

        onexit = function(inst)
            inst.AnimState:ClearOverrideSymbol("swap_frozen")
        end,

        events = {
            EventHandler("onthaw", function(inst) inst.sg:GoToState("thaw") end),
        },
    },

    State{
        name = "thaw",
        tags = {"busy", "thawing"},

        onenter = function(inst)
        	if GoToLocoState(inst, "fly") then
	            if inst.components.locomotor then
	                inst.components.locomotor:StopMoving()
	            end
	            inst.AnimState:PlayAnimation("frozen_loop_pst", true)
	            inst.SoundEmitter:PlaySound("dontstarve/common/freezethaw", "thawing")
	            inst.AnimState:OverrideSymbol("swap_frozen", "frozen", "frozen")
	        end
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("thawing")
            inst.AnimState:ClearOverrideSymbol("swap_frozen")
        end,

        events = {
            EventHandler("unfreeze", function(inst)
                if inst.sg.sg.states.hit then
                    inst.sg:GoToState("hit")
                else
                    inst.sg:GoToState("idle")
                end
            end),
        },
    },

    State{
        name = "hit",
        tags = {"hit", "busy"},

        onenter = function(inst)
        	if GoToLocoState(inst, "fly") then
	            inst.components.locomotor:StopMoving()
	            inst.AnimState:PlayAnimation("hit")
	        end
        end,

        timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/hurt") end),
        },

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "attack",
        tags = {"attack", "busy"},

        onenter = function(inst, target)
        	if GoToLocoState(inst, "fly") then
	            inst.components.locomotor:StopMoving()
	            inst.components.combat:StartAttack()
	            inst.AnimState:PlayAnimation("atk")
	        end
        end,

        timeline = {
        	TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
        	TimeEvent(7*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
			TimeEvent(8* FRAMES, function(inst)
				inst.components.combat:DoAttack()
				inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/attack")
			end),
        	TimeEvent(19*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/wingflap") end),
        },

        events = {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
        	if GoToLocoState(inst, "fly") then
	            inst.AnimState:PlayAnimation("death")
                inst.components.locomotor:StopMoving()
				inst.Physics:ClearCollisionMask()
	            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
	        end
        end,

        timeline = {
			TimeEvent(1*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/Stinkray/death") end),
        },
    },

}

return StateGraph("stungray", states, events, "swim_idle", actionhandlers)
%%+%%scripts/stategraphs/SGswordfish.lua%%-%%
require("stategraphs/commonstates")

local actionhandlers = 
{
   -- ActionHandler(ACTIONS.EAT, "eat"),
    --ActionHandler(ACTIONS.GOHOME, "action"),
}


local function GoToLocoState(inst, state)
    if inst:IsLocoState(state) then
        return true
    end
    inst.sg:GoToState("goto"..string.lower(state), {endstate = inst.sg.currentstate.name})
end

local events=
{
   CommonHandlers.OnSleep(),
   CommonHandlers.OnFreeze(),

   EventHandler("locomote", 
        function(inst) 
            if not inst.sg:HasStateTag("idle") and not inst.sg:HasStateTag("moving") then return end
            
            if not inst.components.locomotor:WantsToMoveForward() then
                if not inst.sg:HasStateTag("idle") then
                    if not inst.sg:HasStateTag("running") then
                        inst.sg:GoToState("idle")
                    end
                        inst.sg:GoToState("idle")
                end
            elseif inst.components.locomotor:WantsToRun() then
                if not inst.sg:HasStateTag("running") then
                    inst.sg:GoToState("run")
                end
            else
                if not inst.sg:HasStateTag("swimming") then
                    inst.sg:GoToState("swimming")
                end
            end
        end),

    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
    EventHandler("doattack", function(inst, data) if not inst.components.health:IsDead() and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then inst.sg:GoToState("attack", data.target) end end),
}

local states=
{
    State{
        name = "gotobelow",
        tags = {"busy"},
        onenter = function(inst, data)
            inst.AnimState:PlayAnimation("submerge")
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_med")
            inst.Physics:Stop()
            inst.sg.statemem.endstate = data.endstate
        end,

        onexit = function(inst)
            inst.AnimState:SetOrientation(ANIM_ORIENTATION.OnGround)
            inst.Transform:SetNoFaced()
            inst:SetLocoState("below")
        end,

        events=
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState(inst.sg.statemem.endstate)
            end),
        },
    },

    State{
        name = "gotoabove",
        tags = {"busy"},
        onenter = function(inst, data)
            inst.Physics:Stop()
            inst.AnimState:SetOrientation(ANIM_ORIENTATION.Default)
            inst.Transform:SetFourFaced()
            inst.AnimState:PlayAnimation("emerge")
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_med")
            inst.sg.statemem.endstate = data.endstate

        end,

        onexit = function(inst)
            inst:SetLocoState("above")
        end,

        events=
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState(inst.sg.statemem.endstate)
            end),
        },
    },

    State{       
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            local anim = "shadow"
            if inst.IsLocoState(inst, "above") then
                anim = "fishmed"
            end

            if playanim then
                inst.AnimState:PlayAnimation(playanim)
                inst.AnimState:PushAnimation(anim, true)
            else
                inst.AnimState:PlayAnimation(anim, true)
            end                                
        end,
    },

    State{
        name = "eat",
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("shadow_hooked_loop", true)
            inst.sg:SetTimeout(2+math.random()*4)
        end,
        
        ontimeout = function(inst)
            inst:PerformBufferedAction()
            inst.sg:GoToState("idle")
        end,
    },  
    
    State{
        name = "swimming",
        tags = {"moving", "canrotate", "swimming"},
        
        onenter = function(inst)
            if GoToLocoState(inst, "below") then
                inst.AnimState:PlayAnimation("shadow_flap_loop", true)
                inst.components.locomotor:WalkForward()
            end
        end,
        
        onupdate = function(inst)
            if not inst.components.locomotor:WantsToMoveForward() then
                inst.sg:GoToState("idle")
            end
        end,
    },

    State{
        name = "run",
        tags = {"moving", "running", "canrotate"},
        
        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.AnimState:PlayAnimation("fishmed", true)
                inst.components.locomotor:RunForward()
                inst.SoundEmitter:PlaySound("ia/creatures/swordfish/swim", "run")
            end
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("run")
        end,
    },    
    
    State{
        name = "death",
        tags = {"busy"},
        
        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.SoundEmitter:PlaySound("ia/creatures/swordfish/death")
                inst:Hide()
                inst.Physics:Stop()
                RemovePhysicsColliders(inst)
                inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
            end
        end,

    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            if GoToLocoState(inst, "above") then
                inst.Physics:Stop()
                inst.AnimState:PlayAnimation("hit")
                inst.SoundEmitter:PlaySound("ia/creatures/swordfish/hit")
            end
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "attack",
        tags = {"attack", "busy"},

        onenter = function(inst, target)
            if GoToLocoState(inst, "above") then
                inst.sg.statemem.target = target
                inst.Physics:Stop()
                inst.components.combat:StartAttack()
                inst.AnimState:PlayAnimation("atk_pre")
                inst.AnimState:PushAnimation("atk", false)
            end
        end,

        timeline =
        {
            TimeEvent( 2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/swordfish/attack_pre") end),
            TimeEvent( 6*FRAMES, function(inst)
                if inst.components.combat.target then 
                    inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
                end 
            end),
            TimeEvent(11*FRAMES, function(inst)
                if inst.components.combat.target then 
                    inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
                end 
                inst.SoundEmitter:PlaySound("ia/creatures/swordfish/attack")
                inst.SoundEmitter:PlaySound("ia/common/swordfish_sword")
            end),
            TimeEvent(16*FRAMES, function(inst)
                if inst.components.combat.target then 
                    inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
                end 
                inst.components.combat:DoAttack(inst.sg.statemem.target)
            end),
        },

        events =
        {
            EventHandler("animqueueover",  function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "sleep",
        tags = {"busy", "sleeping"},

        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.components.locomotor:StopMoving()
                inst.AnimState:PlayAnimation("sleep_pre")
            end
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping") end ),
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake") end),
        },
    },

    State{

        name = "sleeping",
        tags = {"busy", "sleeping"},

        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.AnimState:PlayAnimation("sleep_loop")
            end
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("sleeping") end ),
            EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake") end),
        },
    },

    State{
        name = "wake",
        tags = {"busy", "waking"},

        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.components.locomotor:StopMoving()
                inst.AnimState:PlayAnimation("sleep_pst")
                if inst.components.sleeper and inst.components.sleeper:IsAsleep() then
                    inst.components.sleeper:WakeUp()
                end
            end
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
        },
    },

    State{
        name = "frozen",
        tags = {"busy", "frozen"},

        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.components.locomotor:StopMoving()
                inst.AnimState:PlayAnimation("frozen", true)
                inst.SoundEmitter:PlaySound("dontstarve/common/freezecreature")
                inst.AnimState:OverrideSymbol("swap_frozen", "frozen", "frozen")
            end
        end,

        onexit = function(inst)
            inst.AnimState:ClearOverrideSymbol("swap_frozen")
        end,

        events=
        {
            EventHandler("onthaw", function(inst) inst.sg:GoToState("thaw") end ),
        },
    },

    State{
        name = "thaw",
        tags = {"busy", "thawing"},

        onenter = function(inst)
            if GoToLocoState(inst, "above") then
                inst.components.locomotor:StopMoving()
                inst.AnimState:PlayAnimation("frozen_loop_pst", true)
                inst.SoundEmitter:PlaySound("dontstarve/common/freezethaw", "thawing")
                inst.AnimState:OverrideSymbol("swap_frozen", "frozen", "frozen")
            end
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("thawing")
            inst.AnimState:ClearOverrideSymbol("swap_frozen")
        end,

        events =
        {
            EventHandler("unfreeze", function(inst)
                if inst.sg.sg.states.hit then
                    inst.sg:GoToState("hit")
                else
                    inst.sg:GoToState("idle")
                end
            end ),
        },
    },
}

  
return StateGraph("swordfish", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGtigershark_ground.lua%%-%%local JUMP_SPEED = 75
local JUMP_LAND_OFFSET = 3

local actionhandlers =
{
	ActionHandler(ACTIONS.EAT, "eat"),
	ActionHandler(ACTIONS.TIGERSHARK_FEED, "feed"),
}

local events =
{
    CommonHandlers.OnSleep(),
	CommonHandlers.OnDeath(),
	CommonHandlers.OnLocomote(true, true),
	CommonHandlers.OnFreeze(),
	CommonHandlers.OnAttack(),
	CommonHandlers.OnAttacked(),
}

local states =
{
    State{
        name = "idle",
        tags = {"idle", "canrotate"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("idle")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/idle")
        end,

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("idle")
            end)
        },
    },

    State{
    	name = "eat",
    	tags = {"busy", "canrotate"},

    	onenter = function(inst)
            inst.Physics:Stop()
            inst.components.rowboatwakespawner:StopSpawning()
            inst.AnimState:PlayAnimation("eat_pre")
            inst.AnimState:PushAnimation("eat_loop")
            inst.AnimState:PushAnimation("eat_pst", false)
    	end,

        timeline =
        {
            TimeEvent(10*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/eat")
                inst:PerformBufferedAction()
            end)
        },

    	events =
    	{
            EventHandler("animqueueover", function(inst)
                inst.sg:GoToState("idle")
            end)
    	},
	},

    State{
        name = "feed",
        tags = {"busy", "canrotate"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hork")
        end,

        timeline =
        {
            TimeEvent(13*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/meat_hork")
            end),
            TimeEvent(19*FRAMES, function(inst)
                inst:PerformBufferedAction()
            end)
        },

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("idle")
            end)
        },
    },

    -- jump > fallwarn > fall > fallpost

    State{
        name = "jump",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("ground_launch_up_pre")
            inst.AnimState:PushAnimation("ground_launch_up_loop", true)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        timeline = {
            TimeEvent(23*FRAMES, function(inst)
                inst.components.health:SetInvincible(true)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/jump_attack")
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/roar")
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/launch_land")
	            inst.components.locomotor.disable = true
	            inst.Physics:SetMotorVel(0,JUMP_SPEED,0)
    		end),

            TimeEvent(38*FRAMES, function(inst)
                local tar = inst:GetTarget()

                if tar and not inst:GroundTypesMatch(tar) then
                    inst:MakeWater() --GoToWaterState
                end

                inst.sg:GoToState("fallwarn")
            end)
        },
    },

    State{
        name = "fallwarn",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.sg:SetTimeout(34*FRAMES)

            inst.Physics:Stop()
            inst.components.health:SetInvincible(true)

            local tar = inst:GetTarget()
            local pos = tar or inst:GetPosition()

            pos.y = 45
            inst.Transform:SetPosition(pos:Get())

            local shadow = SpawnPrefab("tigersharkshadow")
			if not shadow.Ground_Fall then
				print("ERROR: tigersharkshadow.Ground_Fall is not defined?") --GitLab issue #207
				print("Ground_Fall: ".. tostring(shadow.Ground_Fall))
				print("Water_Jump: ".. tostring(shadow.Water_Jump))
				print("Water_Fall: ".. tostring(shadow.Water_Fall))
				print("TIGERSHARKSHADOW: ".. shadow:GetDebugString())
				print("TIGERSHARK: ".. inst:GetDebugString())
			end
            shadow:Ground_Fall()
            local heading = TheCamera:GetHeading()
            local rotation = 180 - heading

            if inst.AnimState:GetCurrentFacing() == FACING_LEFT then
                rotation = rotation + 180
            end

            if rotation < 0 then
                rotation = rotation + 360
            end

            shadow.Transform:SetRotation(rotation)
            local x,y,z = inst:GetPosition():Get()
            shadow.Transform:SetPosition(x,0,z)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        ontimeout = function(inst)
            inst:Show()

            if inst:GetIsOnWater() then
                inst:MakeWater()
                local pos = inst:GetPosition()
                pos.y = 45
                inst.Transform:SetPosition(pos:Get())
            end

            inst.sg:GoToState("fall")
        end,
    },

    State{
        name = "fall",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.components.health:SetInvincible(true)
            ChangeToCharacterPhysics(inst)
	        inst.components.locomotor.disable = true
            inst.Physics:SetMotorVel(0,-JUMP_SPEED,0)
            inst.AnimState:PlayAnimation("ground_launch_down_loop", true)
            inst.Physics:SetCollides(false)
            inst.sg:SetTimeout(JUMP_SPEED/45 + 0.2)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/dive_attack")
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        timeline =
        {
            TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/roar") end)
        },

        ontimeout = function(inst)
            local pt = Point(inst.Transform:GetWorldPosition())
            local vx, vy, vz = inst.Physics:GetMotorVel()
            if pt.y <= .1 then
                pt.y = 0
                inst.Physics:Stop()
                inst.Physics:Teleport(pt.x,pt.y,pt.z)
                inst.CanFly = false
                inst.Physics:SetCollides(true)
                inst.sg:GoToState("fallpost")
            end
        end,

        onupdate = function(inst)
            inst.Physics:SetMotorVel(0,-JUMP_SPEED,0)
            local pt = Point(inst.Transform:GetWorldPosition())
            if pt.y <= .1 then
                pt.y = 0
                inst.Physics:Stop()
                inst.Physics:Teleport(pt.x,pt.y,pt.z)
                inst.CanFly = false
                inst.Physics:SetCollides(true)
                inst.sg:GoToState("fallpost")
            end
        end,
    },

    State{
        name = "fallpost",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.components.health:SetInvincible(true)
            inst.Physics:Stop()
            inst.components.locomotor.disable = false
            inst.AnimState:PlayAnimation("ground_launch_down_pst")
            inst.components.groundpounder:GroundPound()
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/land_explode")
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
            inst:Show()
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },


    State{
        name = "attack",
        tags = {"busy", "attack"},

        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk")

            inst.CanRun = false
            inst.components.rowboatwakespawner:StopSpawning()
            if not inst.components.timer:TimerExists("Run") then
                inst.components.timer:StartTimer("Run", 10)
            end
        end,

        timeline =
        {
            TimeEvent(4*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/land_attack_rear")
            end),
            TimeEvent(23*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/land_attack")
                inst.components.combat:DoAttack()
            end),
        },

        events =
        {
            EventHandler("animover", function(inst)
                inst.AttackCounter = inst.AttackCounter + 1
                if inst.AttackCounter >= 3 then
                    inst.AttackCounter = 0
                    inst.CanFly = true
                end
                inst.sg:GoToState("idle")
            end),
        },
    },

    State{
        name = "hit",
        tags = {"busy", "hit", "canrotate"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hit")
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        timeline =
        {
            TimeEvent(1*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/land_hit")
            end),
        },

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            inst.AnimState:PlayAnimation("death")
            inst.components.rowboatwakespawner:StopSpawning()
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,

        timeline =
        {
            TimeEvent(1*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/death_land")
            end),
            TimeEvent(33*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/death_land_body_fall")
            end),
        },

    },

    State{
    	name = "taunt",
    	tags = {"busy"},

    	onenter = function(inst)
    		inst.Physics:Stop()
    		inst.AnimState:PlayAnimation("taunt")
    	end,

        timeline =
        {
            TimeEvent(10*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/taunt_land")
            end),
        },

    	events =
    	{
    		EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
    	},
	},
}

CommonStates.AddFrozenStates(states)
CommonStates.AddSleepStates(states,
{
    sleeptimeline = {TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/sleep") end)},
})
CommonStates.AddWalkStates(states,
{
    starttimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("jump")
            end
        end),
    },
    walktimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("jump")
            end
        end),
        TimeEvent(0*FRAMES, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/footstep")
        end),
        TimeEvent(20*FRAMES, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/footstep")
        end),
    },
    endtimeline =
    {
        TimeEvent(0, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/footstep")
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("jump")
            end
        end),
    },
})
CommonStates.AddRunStates(states,
{
    starttimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target then
                local dist = inst:GetPosition():Dist(target)
                if (dist > 15 and inst.CanFly) or not inst:GroundTypesMatch(target) then
                    inst.sg:GoToState("jump")
                end
            end
        end),
    },
    runtimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("jump")
            end
        end),
        TimeEvent(4*FRAMES, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/land_run")
        end),
        TimeEvent(12*FRAMES, function(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/footstep_run")
        end),
    },
    endtimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("jump")
            end
        end),
    },
},
{
    run = "run",
})

return StateGraph("tigershark_ground", states, events, "idle", actionhandlers)
%%+%%scripts/stategraphs/SGtigershark_water.lua%%-%%local JUMP_SPEED = 50
local JUMP_LAND_OFFSET = 3

local function onattackfn(inst)
    if inst.components.health and not inst.components.health:IsDead()
    and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then
        if inst.sg:HasStateTag("running") then
            inst.sg:GoToState("attack")
        else
            inst.sg:GoToState("attack_pre")
        end
    end
end

local function onattackedfn(inst)
    if not inst.components.health:IsDead() and not
    inst.sg:HasStateTag("attack") and not
    inst.sg:HasStateTag("noattack") then
        inst.sg:GoToState("hit")
    end
end

local actionhandlers =
{
    ActionHandler(ACTIONS.EAT, "eat"),
}

local events =
{
    CommonHandlers.OnLocomote(true, true),
    CommonHandlers.OnDeath(),
    CommonHandlers.OnFreeze(),
    EventHandler("doattack", onattackfn),
    EventHandler("attacked", onattackedfn),
    CommonHandlers.OnSleep(),
}

local states =
{
    State{
        name = "idle",
        tags = {"idle", "canrotate"},

        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("water_idle")
        end,

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("idle")
            end)
        },
    },

    State{
        name = "eat",
        tags = {"busy", "canrotate"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.components.rowboatwakespawner:StopSpawning()
            inst.AnimState:PlayAnimation("water_eat_pre")
            inst.AnimState:PushAnimation("water_eat_pst", false)
        end,

        timeline =
        {

            TimeEvent(0*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_emerge_lrg")
            end),

            TimeEvent(14*FRAMES, function(inst)
                inst:PerformBufferedAction()
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/eat")
            end),

            TimeEvent(31*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_submerge_lrg")
            end),
        },

        events =
        {
            EventHandler("animqueueover", function(inst)
                inst.sg:GoToState("idle")
            end)
        },
    },

    -- dive > jumpwarn > jump > fallwarn > fall > fallpost

    State{
        name = "dive",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            inst.AnimState:PlayAnimation("submerge")
            inst.Physics:Stop()
            inst.components.health:SetInvincible(true)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        events = {
            EventHandler("animover", function(inst) inst:Hide() end),
        },

        timeline = {
            TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_submerge_lrg") end),
            TimeEvent(30*FRAMES, function(inst) inst.sg:GoToState("jumpwarn") end),
        },
    },

    State{
        name = "jumpwarn",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.Physics:Stop()

            inst.components.health:SetInvincible(true)

            ChangeToUnderwaterCharacterPhysics(inst)

            local old_pt = inst:GetPosition()

            local tar = inst:GetTarget()
            if tar and inst:GroundTypesMatch(tar) then
                inst.Transform:SetPosition(tar:Get())
            end

            local shadow = SpawnPrefab("tigersharkshadow")
            shadow:Water_Jump()
            shadow.Transform:SetPosition(inst:GetPosition():Get())
        end,

        onexit = function(inst)
            inst:Show()
            inst.components.health:SetInvincible(false)
        end,

        timeline = {
            TimeEvent(90*FRAMES, function(inst) 
                inst.sg:GoToState("jump") 
            end),
        },
    },

    State{
        name = "jump",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.components.health:SetInvincible(true)

            inst.components.locomotor.disable = true

            local splash = SpawnPrefab("splash_water")
            local pos = inst:GetPosition()
            splash.Transform:SetPosition(pos.x, pos.y, pos.z)
            
            inst:Show()

            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/jump_attack")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_emerge_lrg")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/roar")

            inst.AnimState:PlayAnimation("launch_up_pre")
            inst.AnimState:PushAnimation("launch_up_loop", true)
            inst.components.combat:DoAreaAttack(inst, TUNING.TIGERSHARK_SPLASH_RADIUS)

            SpawnWaves(inst, 9, 360)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        timeline = {
            TimeEvent(3*FRAMES, function(inst)
                inst.Physics:SetMotorVel(0,JUMP_SPEED,0)
            end),

            TimeEvent(15*FRAMES, function(inst)
                local tar = inst:GetTarget()

                if tar and not inst:GroundTypesMatch(tar) then
                    inst:MakeGround() --GoToGroundState
                end

                inst.sg:GoToState("fallwarn")
            end)
        },
    },

    State{
        name = "fallwarn",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.components.health:SetInvincible(true)

            local tar = inst:GetTarget()
            local pos = tar or inst:GetPosition()

            pos.y = 45
            inst.Transform:SetPosition(pos:Get())

            local shadow = SpawnPrefab("tigersharkshadow")
            shadow:Water_Fall()
            local heading = TheCamera:GetHeading()
            local rotation = 180 - heading
            if inst.AnimState:GetCurrentFacing() == FACING_LEFT then
                rotation = rotation + 180
            end
            if rotation < 0 then
                rotation = rotation + 360
            end
            shadow.Transform:SetRotation(rotation)
            local x,y,z = inst:GetPosition():Get()
            shadow.Transform:SetPosition(x,0,z)

            inst.sg:SetTimeout(25*FRAMES)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        ontimeout = function(inst)
            inst:Show()
            --Double check that you're landing on the correct tile type.
            if not inst:GetIsOnWater() then
                inst:MakeGround()
                local pos = inst:GetPosition()
                pos.y = 45
                inst.Transform:SetPosition(pos:Get())
            end

            inst.sg:GoToState("fall")
        end,
    },

    State{
        name = "fall",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.components.health:SetInvincible(true)
            inst.components.locomotor.disable = true
            inst.Physics:SetMotorVel(0,-JUMP_SPEED,0)
            inst.AnimState:PlayAnimation("launch_down_loop", true)
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/breach_attack")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/dive_attack")
            inst.sg:SetTimeout(JUMP_SPEED/45 + 0.2)
        end,

        onexit = function(inst)
            inst.components.health:SetInvincible(false)
        end,

        timeline = {
            TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/roar") end)
        },

        ontimeout = function(inst)
            local pt = Point(inst.Transform:GetWorldPosition())
            pt.y = 0
            inst.Physics:Stop()
            inst.Physics:Teleport(pt.x,pt.y,pt.z)
            inst.CanFly = false
            inst.Physics:SetCollides(true)
            inst.sg:GoToState("fallpost")
        end,

        onupdate= function(inst)
            inst.Physics:SetMotorVel(0,-JUMP_SPEED,0)
            local pt = Point(inst.Transform:GetWorldPosition())
            if pt.y <= 1 then
                pt.y = 0
                inst.Physics:Stop()
                inst.Physics:Teleport(pt.x,pt.y,pt.z)
                inst.CanFly = false
                inst.Physics:SetCollides(true)
                inst.sg:GoToState("fallpost")
            end
        end,
    },

    State{
        name = "fallpost",
        tags = {"busy", "noattack"},

        onenter = function(inst)
            inst.components.health:SetInvincible(true)
            inst.Physics:Stop()
            inst.components.locomotor.disable = false
            inst.AnimState:PlayAnimation("launch_down_pst")
            inst.components.combat:DoAreaAttack(inst, TUNING.TIGERSHARK_SPLASH_RADIUS)
            SpawnWaves(inst, 9, 360)
            inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/splash_explode")
        end,

         onexit = function(inst)
            local splash = SpawnPrefab("splash_water")
            local pos = inst:GetPosition()
            splash.Transform:SetPosition(pos.x, pos.y, pos.z)
            inst.components.health:SetInvincible(false)
            inst:Show()
            ChangeToCharacterPhysics(inst)
        end,

        events=
        {
            EventHandler("animover", function(inst) inst:Hide() end),
        },

        timeline=
        {
            TimeEvent(60*FRAMES, function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "attack_pre",
        tags = {"attack", "busy", "canrotate"},

        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.CanRun = false

            inst.components.rowboatwakespawner:StopSpawning()
            inst.AnimState:PlayAnimation("water_atk_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("attack") end),
        },
    },

    State{
        name = "attack",
        tags = {"busy", "attack"},

        onenter = function(inst)
            inst.components.locomotor:StopMoving()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("water_atk")
            inst.AnimState:PushAnimation("water_atk_pst", false)
            inst.CanRun = false
            inst.components.rowboatwakespawner:StopSpawning()
            if not inst.components.timer:TimerExists("Run") then
                inst.components.timer:StartTimer("Run", 10)
            end
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/roar")
        end,

        timeline =
        {
            TimeEvent(15*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_attack")
                inst.components.combat:DoAttack()
                SpawnWaves(inst, 5, 110)
            end),

            TimeEvent(27*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_submerge_lrg")
            end),
        },

        events =
        {
            EventHandler("animqueueover", function(inst)
                inst.AttackCounter = inst.AttackCounter + 1
                if inst.AttackCounter >= 3 then
                    inst.AttackCounter = 0
                    inst.CanFly = true
                    inst.sg:GoToState("dive")
                else
                    inst.sg:GoToState("idle")
                end
            end),
        },
    },

    State{
        name = "hit",
        tags = {"busy", "hit"},

        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("water_hit")
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        timeline =
        {
            TimeEvent(1*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_hit")
            end),
        },

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "death",
        tags = {"busy"},

        onenter = function(inst)
            inst.AnimState:PlayAnimation("water_death")
            inst.components.rowboatwakespawner:StopSpawning()
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
        end,

        timeline =
        {
            TimeEvent(1*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_lrg")
            end),
            TimeEvent(11*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/death_sea")
                inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large")
            end),
        },

    },

    State{
        name = "taunt",
        tags = {"busy"},

        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("water_taunt")
            inst.components.rowboatwakespawner:StopSpawning()
        end,

        timeline =
        {
            TimeEvent(6*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_emerge_lrg")
            end),
            TimeEvent(0*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/taunt_sea")
            end),
            TimeEvent(33*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/taunt_sea")
            end),
            TimeEvent(60*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_submerge_lrg")
            end),
        },

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        },
    },

    State{
        name = "walk_start",
        tags = {"moving", "canrotate"},

        onenter = function(inst) 
            inst.components.locomotor:WalkForward()
            inst.AnimState:PlayAnimation("water_run")
        end,

        events =
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },

        timeline =
        {
            TimeEvent(0, function(inst)
                inst.components.rowboatwakespawner:StopSpawning()
                local target = inst:GetTarget()
                if target and not inst:GroundTypesMatch(target) then
                    inst.sg:GoToState("dive")
                end
            end),
            TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/run_down") end),
        },
    },
        
    State{
            
        name = "walk",
        tags = {"moving", "canrotate"},
        
        onenter = function(inst) 
            inst.components.locomotor:WalkForward()
            inst.AnimState:PlayAnimation("water_run")
            inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_swimemerged_lrg_LP", "walk_loop")
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("walk_loop")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end),
        },

        timeline = 
        {
            TimeEvent(0, function(inst)
                local target = inst:GetTarget()
                if target and not inst:GroundTypesMatch(target) then
                    inst.sg:GoToState("dive")
                end
            end),
        },
    },      
    
    State{
        name = "walk_stop",
        tags = {"canrotate"},
        
        onenter = function(inst) 
            inst.components.locomotor:StopMoving()
            inst.sg:GoToState("idle")
        end,

        timeline =
        {
            TimeEvent(0, function(inst)
                inst.components.rowboatwakespawner:StopSpawning()
                local target = inst:GetTarget()
                if target and not inst:GroundTypesMatch(target) then
                    inst.sg:GoToState("dive")
                end
            end),
        },
    },

}

CommonStates.AddFrozenStates(states, nil, {frozen = "water_frozen", frozen_pst = "water_frozen_loop_pst"})
CommonStates.AddSleepStates(states,
{
    starttimeline = {TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_emerge_lrg") end)},
    sleeptimeline = {TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/sleep") end)},
    waketimeline = {TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/water_submerge_lrg") end)},
}, nil, {sleep_pre = "water_sleep_pre", sleep_loop = "water_sleep_loop", sleep_pst = "water_sleep_pst"})

CommonStates.AddRunStates(states,
{
    starttimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("dive")
            end
        end),
        TimeEvent(0, function(inst) SpawnWaves(inst, 2, 160) end),
        TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/run_down") end),
    },
    runtimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("dive")
            end
        end),
        TimeEvent(0, function(inst) SpawnWaves(inst, 2, 160) end),
        TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/tiger_shark/run_down") end),
    },
    endtimeline =
    {
        TimeEvent(0, function(inst)
            inst.components.rowboatwakespawner:StopSpawning()
            local target = inst:GetTarget()
            if target and not inst:GroundTypesMatch(target) then
                inst.sg:GoToState("dive")
            end
        end),
    },
},
{
    startrun = "water_charge_pre",
    run = "water_charge",
    stoprun = "water_charge_pst",
})

return StateGraph("tigershark_water", states, events, "idle", actionhandlers)%%+%%scripts/stategraphs/SGtreeguard.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
}

local function onattack(inst, data)
    if inst.components.health:GetPercent() > 0 and
    (inst.sg:HasStateTag("hit") or not
    inst.sg:HasStateTag("busy")) then
        local dist = inst:GetDistanceSqToInst(data.target)

        if dist > TUNING.PALMTREEGUARD_MELEE * TUNING.PALMTREEGUARD_MELEE then
            --Throw
            inst:SetRange()
            inst.sg:GoToState("throw_pre", data.target)
        else
            --Melee
            inst:SetMelee()
            inst.sg:GoToState("attack", data.target) 
        end
    end
end

local events=
{
    CommonHandlers.OnStep(),
    CommonHandlers.OnLocomote(false,true),
    CommonHandlers.OnFreeze(),
    EventHandler("doattack", onattack),
    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() and not
        inst.sg:HasStateTag("attack") and not
        inst.sg:HasStateTag("waking") and not
        inst.sg:HasStateTag("sleeping") and 
        (not inst.sg:HasStateTag("busy") or inst.sg:HasStateTag("frozen")) then
            inst.sg:GoToState("hit") 
        end
    end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("death", function(inst) inst.sg:GoToState("death") end),
    EventHandler("gotosleep", function(inst) inst.sg:GoToState("sleeping") end),
    EventHandler("onwakeup", function(inst) inst.sg:GoToState("wake") end),

    EventHandler("onignite", function(inst) inst.sg:GoToState("panic") end),
}

local states=
{
    State{
        name = "death",
        tags = {"busy"},
        
        onenter = function(inst)
            inst.AnimState:PlayAnimation("death")
            inst.Physics:Stop()
            RemovePhysicsColliders(inst)
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/death")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/death_drop")
            inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))            
        end,
        
    },
    
    State{
        name = "tree",
        onenter = function(inst)
            inst.AnimState:PlayAnimation("tree_idle", true)
        end,
    },   

    State{
        name = "panic",
        tags = {"busy"},
        onenter = function(inst)
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("panic_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("panic_loop") end),
            EventHandler("onextinguish", function(inst) inst.sg:GoToState("panic_pst") end),
        }
    },

    State{
        name = "panic_loop",
        tags = {"busy"},

        onenter = function(inst)
            inst.AnimState:PlayAnimation("panic_loop")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/panic")
        end,

        timeline = {
            TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(9*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(18*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
        },

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("panic") end),
            EventHandler("onextinguish", function(inst) inst.sg:GoToState("panic_pst") end),
        },
    },

    State{
        name = "panic_pst",
        tags = {"busy"},
        onenter = function(inst)
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("panic_post")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end)
        }
    },
    
	State{
        name = "attack",
        tags = {"attack", "busy"},
        
        onenter = function(inst, target)
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk")
            inst.sg.statemem.target = target
        end,
        
        timeline=
        {
			TimeEvent(0*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack") end),
            TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack_swipe") end),
			TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(25*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
            TimeEvent(26*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
        },
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "throw_pre",
        tags = {"attack", "busy"},
        
        onenter = function(inst, target)
            inst.Physics:Stop()
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("pluck")
            inst.sg.statemem.target = target
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/pluck")
        end,

        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("throw", inst.sg.statemem.target) end),
        },
    },

    State{
        name = "throw",
        tags = {"attack", "busy"},
        
        onenter = function(inst, target)
            inst.Physics:Stop()
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("throw_pre")
            inst.AnimState:PushAnimation("throw", false)
            inst.sg.statemem.target = target
        end,
        
        timeline=
        {
            TimeEvent(25*FRAMES, function(inst) inst.components.combat:DoAttack(inst.sg.statemem.target) end),
            TimeEvent(26*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),

            TimeEvent(00*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(05*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack") end),
            TimeEvent(12*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack_swipe") end),
            TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(25*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/coconut_throw") end),
        },
        
        events=
        {
            EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
        },
    },  
    
    
	State{
        name = "hit",
        tags = {"hit", "busy"},
        
        onenter = function(inst, cb)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("hit")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/hit")
        end,
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
        
        timeline=
        {
            TimeEvent(5*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
        },
        
    },      
    
    State{
        name = "sleeping",
        tags = {"sleeping", "busy"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("transform_tree", false)
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/transform_out")
            inst.DynamicShadow:Enable(false)
        end,

        onexit = function(inst)
            inst.DynamicShadow:Enable(true)
        end,

        events=
        {
		    EventHandler("attacked", function(inst) if not inst.components.health:IsDead() then inst.sg:GoToState("wake") end end),
        },
        
        timeline=
        {
            TimeEvent(17*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(31*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
        },
        
    },
    
    State{
        name = "spawn",
        tags = {"waking", "busy"},
        
        onenter = function(inst, start_anim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("transform_ent")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/transform_in")
        end,
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },

        timeline=
        {
            TimeEvent(8*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(25*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(41*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(49*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(53*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/transform_VO") end),
        },
        
    },
    
    State{
        name = "wake",
        tags = {"waking", "busy"},
        
        onenter = function(inst, start_anim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("transform_ent_mad")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/transform_in")
        end,
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },

        timeline=
        {
            TimeEvent(8*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(25*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(26*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/coconut_throw") end),
            TimeEvent(33*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack") end),
            TimeEvent(41*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(46*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/attack") end),
            TimeEvent(49*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(53*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/transform_VO") end),
        },
        
    },

    State{
        name = "idle",
        tags = {"idle", "canrotate"},
        onenter = function(inst, playanim)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("idle_loop")
            inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/idle")
        end,
        
        events=
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },
}

CommonStates.AddWalkStates(
    states,
    {
		starttimeline =
		{
            TimeEvent(0*FRAMES, function(inst) inst.Physics:Stop() end),
            TimeEvent(11*FRAMES, function(inst) inst.components.locomotor:WalkForward() end),
            TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(17*FRAMES, function(inst) inst.Physics:Stop() end),
		},
        walktimeline = 
        { 
            TimeEvent(10*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/walk_VO") end),
            TimeEvent(18*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(17*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
            TimeEvent(51*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(52*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
        },
        endtimeline=
        {
            TimeEvent(2*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/tree_movement") end),
            TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/palm_tree_guard/footstep") end),
        },
    })

CommonStates.AddFrozenStates(states)

return StateGraph("treeguard", states, events, "idle", actionhandlers)%%+%%scripts/stategraphs/SGtwister.lua%%-%%require("stategraphs/commonstates")

local function onattackedfn(inst, data)
    if inst.components.health and not inst.components.health:IsDead()
    and (not inst.sg:HasStateTag("busy") or inst.sg:HasStateTag("frozen")) then
       inst.sg:GoToState("hit")
    end
end

local function onattackfn(inst)
    if inst.components.health and not inst.components.health:IsDead()
    and (inst.sg:HasStateTag("hit") or not inst.sg:HasStateTag("busy")) then

        if not inst.CanCharge and not inst.components.timer:TimerExists("Charge") then
            inst.components.timer:StartTimer("Charge", TUNING.TWISTER_CHARGE_COOLDOWN)
        end

        inst.sg:GoToState("attack")
    end
end

local actionhandlers = {}

local events=
{
    CommonHandlers.OnLocomote(true, true),
    CommonHandlers.OnDeath(),
    EventHandler("doattack", onattackfn),
    EventHandler("attacked", onattackedfn),
}

local states=
{

    State{
        name = "idle",
        tags = {"idle"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("idle_loop")
            inst.components.vacuum:SpitItem()
            
            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end

        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

----------------------COMBAT------------------------

    State{
        name = "hit",
        tags = {"hit", "busy"},
        
        onenter = function(inst, cb)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("hit")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/hit")
        end,
        
        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "attack",
        tags = {"attack", "busy", "canrotate"},
        
        onenter = function(inst)
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 1)

            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.components.combat:StartAttack()
            inst.AnimState:PlayAnimation("atk")
        end,

        onexit = function(inst)
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 0)
        end,

        timeline =
        {
            TimeEvent(4*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/attack_pre")
            end),

            TimeEvent(31*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/attack_swipe")
            end),

            TimeEvent(33*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/attack_hit")
                inst.components.combat:DoAttack()
            end),
        },

        events=
        {
            EventHandler("animover", function(inst) 
                if inst.CanVacuum then
                    if not inst:GetIsOnWater() then 
                        inst.sg:GoToState("vacuum_antic_pre") 
                    else
                        inst.sg:GoToState("waves_antic_pre")
                    end 
                else 
                    inst.sg:GoToState("idle")  
                end 
            end),
        },
    },

    State{
        name = "vacuum_antic_pre",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            TheMixer:PushMix("twister")
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 1)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_antic_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_antic_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("vacuum_antic_loop") end),
        },
    },

    State{
        name = "vacuum_antic_loop",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_antic_loop", true)
            
            inst.sg:SetTimeout(TUNING.TWISTER_VACUUM_ANTIC_TIME)

            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_antic_LP", "vacuum_antic_loop")
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("vacuum_antic_loop")
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("vacuum_pre")
        end,
    },

    State{
        name = "vacuum_pre",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("vacuum_loop") end),
        },
    },

    State{
        name = "vacuum_loop",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end

            inst.CanVacuum = false
            inst.AnimState:PlayAnimation("vacuum_loop", true)


            inst.components.vacuum.vacuumradius = TUNING.TWISTER_PLAYER_VACUUM_DISTANCE
            inst.components.vacuum.ignoreplayer = false
            inst.sg:SetTimeout(TUNING.TWISTER_VACUUM_TIME)

            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_hit")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_LP", "vacuum_loop")
        end,

        onexit = function(inst)
            if not inst.components.timer:TimerExists("Vacuum") then
                inst.components.timer:StartTimer("Vacuum", TUNING.TWISTER_VACUUM_COOLDOWN)
            end

            inst.components.vacuum.spitplayer = true 
            inst.components.vacuum.vacuumradius = TUNING.TWISTER_VACUUM_DISTANCE
            inst.components.vacuum.ignoreplayer = true

            inst.SoundEmitter:KillSound("vacuum_loop")
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("vacuum_pst")
        end,
    },

    State{
        name = "vacuum_pst",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            TheMixer:PopMix("twister")
        
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 0)

            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_pst")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "waves_antic_pre",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            TheMixer:PushMix("twister")
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 1)

            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_antic_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_antic_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("waves_antic_loop") end),
        },
    },

    State{
        name = "waves_antic_loop",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_antic_loop", true)
            inst.sg:SetTimeout(TUNING.TWISTER_WAVES_ANTIC_TIME)
            
            inst.sg.statemem.maxwaves = 4
            inst.sg.statemem.waves = 1
            inst.sg.statemem.wavetime = FRAMES*30
            inst.sg.statemem.wavetimer = FRAMES*30

            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_antic_LP", "vacuum_antic_loop")

        end,

        onupdate = function(inst, dt)
            inst.sg.statemem.wavetimer = inst.sg.statemem.wavetimer + dt
            if inst.sg.statemem.wavetimer >= inst.sg.statemem.wavetime and inst.sg.statemem.waves <= inst.sg.statemem.maxwaves then
                SpawnWaves(inst, math.random(10, 15), 360, 6, "wave_ripple", -25, 1.5)
                inst.sg.statemem.waves = inst.sg.statemem.waves + 1
                inst.sg.statemem.wavetimer = 0
            end
        end,

        onexit = function(inst)
            inst.SoundEmitter:KillSound("vacuum_antic_loop")
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("waves_pre")
        end,
    },

    State{
        name = "waves_pre",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("waves_loop") end),
        },
    },

    State{
        name = "waves_loop",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end

            inst.AnimState:PlayAnimation("vacuum_loop", true)

            inst.CanVacuum = false

            inst.sg.statemem.wavetime = FRAMES*24
            inst.sg.statemem.wavetimer = FRAMES*24

            inst.sg:SetTimeout(TUNING.TWISTER_WAVES_TIME)


            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_hit")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/vacuum_LP", "vacuum_loop")

        end,

        onexit = function(inst)
            if not inst.components.timer:TimerExists("Vacuum") then
                inst.components.timer:StartTimer("Vacuum", TUNING.TWISTER_VACUUM_COOLDOWN)
            end

            inst.SoundEmitter:KillSound("vacuum_loop")
        end,

        onupdate = function(inst, dt)
            inst.sg.statemem.wavetimer = inst.sg.statemem.wavetimer + dt
            if inst.sg.statemem.wavetimer >= inst.sg.statemem.wavetime then
                SpawnWaves(inst, math.random(11, 12), 360, 12, nil, 3, nil, true)
                inst.sg.statemem.wavetimer = 0
            end
        end,

        ontimeout = function(inst)
            inst.sg:GoToState("waves_pst")
        end,
    },

    State{
        name = "waves_pst",
        tags = {"attack", "busy"},
        
        onenter = function(inst)
            TheMixer:PopMix("twister")

            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 0)

            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
            end
            inst.AnimState:PlayAnimation("vacuum_pst")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "death",  
        tags = {"busy"},
        
        onenter = function(inst)
            TheMixer:PopMix("twister")
            if inst.components.locomotor then
                inst.components.locomotor:StopMoving()
                inst.components.vacuum:TurnOff()
            end

            if inst:GetIsOnWater() then
                inst.AnimState:PlayAnimation("death_water")
            else
                inst.AnimState:PlayAnimation("death")
            end

            inst.SoundEmitter:PlaySound("ia/creatures/twister/death")
        end,

        timeline =
        {
            TimeEvent(4*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/fly")
            end),

            TimeEvent(40*FRAMES, function(inst)
                inst.components.inventory:DropEverything(true, true)
                inst.components.lootdropper:DropLoot()
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/groundhit")
            end),

            TimeEvent(25*FRAMES, function(inst)
            end),

            TimeEvent(50*FRAMES, function(inst)
                local seal = SpawnPrefab("twister_seal")
                seal.Transform:SetPosition(inst:GetPosition():Get())
                seal.sg:GoToState("dizzy")
                inst:Remove()
            end),
        },
    },

----------------WALKING---------------

    State{
        name = "walk_start",
        tags = {"moving", "canrotate"},

        onenter = function(inst) 
            inst.AnimState:PlayAnimation("walk_pre")


            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end

        end,

        events =
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    },
        
    State{            
        name = "walk",
        tags = {"moving", "canrotate"},
        
        onenter = function(inst)
            inst.AnimState:PlayAnimation("walk_loop")
            inst.components.locomotor:WalkForward()
            inst.components.vacuum:SpitItem()


            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end
        end,

        timeline = 
        {
            TimeEvent(24*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/twister/walk") end)
        },

        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),        
        },
    },
    
    State{            
        name = "walk_stop",
        tags = {"canrotate"},

        onenter = function(inst) 
            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("walk_pst")


            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end
        end,

        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),        
        },
    },

    State{
        name = "run_start",
        tags = {"moving", "running", "atk_pre", "canrotate"},

        onenter = function(inst)
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 1)

            inst.CanCharge = false
            inst.components.locomotor:RunForward()
            inst.AnimState:PlayAnimation("charge_pre")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/charge_roar")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/run_charge_up")


            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end

        end,

        events =
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),        
        },
    },

    State{
        name = "run",
        tags = {"moving", "running"},
        
        onenter = function(inst) 
            inst.components.locomotor:RunForward()
            inst.AnimState:PlayAnimation("charge_roar_loop")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/run_charge_up")
            inst.SoundEmitter:PlaySound("ia/creatures/twister/charge_roar")

            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end
        end,
       
        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("run") end ),        
        },
    },        
    
    State{
        name = "run_stop",
        tags = {"canrotate"},
        
        onenter = function(inst) 
            inst.SoundEmitter:SetParameter("wind_loop", "intensity", 0)

            inst.components.locomotor:StopMoving()
            inst.AnimState:PlayAnimation("charge_pst")


            if inst:GetIsOnWater() then
                inst.AnimState:Show("twister_water_fx")
            else
                inst.AnimState:Hide("twister_water_fx")
            end

        end,

        events=
        {   
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),        
        },
    },
}

return StateGraph("twister", states, events, "idle", actionhandlers)%%+%%scripts/stategraphs/SGtwister_seal.lua%%-%%require("stategraphs/commonstates")

local events = {
    CommonHandlers.OnAttacked(),
    CommonHandlers.OnDeath(),
}

local states =
{
    State{
        name = "dizzy",
        tags = {"idle"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            local anim = (inst:GetIsOnWater() and "seal_idle_water") or "seal_idle"
            inst.AnimState:PlayAnimation(anim, true)
            inst.sg:SetTimeout(5)
        end,

        timeline = 
        {
            TimeEvent(1*FRAMES, function(inst)
                local anim = (inst:GetIsOnWater() and "seal_idle_water") or "seal_idle"
                if not inst.AnimState:IsCurrentAnimation(anim) then
                    inst.AnimState:PlayAnimation(anim, true)
                end
            end),
        },

        ontimeout = function(inst)
            inst.sg:GoToState("dizzy_pst")
        end,
    },

    State{
        name = "dizzy_pst",
        tags = {"idle"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            local anim = (inst:GetIsOnWater() and "seal_idle_pst_water") or "seal_idle_pst"
            inst.AnimState:PlayAnimation(anim)
        end,

        timeline =
        {
            TimeEvent(13*FRAMES, function(inst) 
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/headshake") 
            end)
        },

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("cower")
            end)
        }
    },

    State{
        name = "cower",
        tags = {"idle", "canrotate"},

        onenter = function(inst)
            inst.Physics:Stop()
            local anim = (inst:GetIsOnWater() and "seal_cower_water") or "seal_cower"
            inst.AnimState:PlayAnimation(anim)
        end,

        timeline = 
        {
            TimeEvent(1*FRAMES, function(inst)
                local anim = (inst:GetIsOnWater() and "seal_cower_water") or "seal_cower"
                if not inst.AnimState:IsCurrentAnimation(anim) then
                    inst.AnimState:PlayAnimation(anim, true)
                end
            end),

            TimeEvent(4*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/cower")
            end),
            TimeEvent(27*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/cower")
            end),
            TimeEvent(32*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/cower")
            end),
            TimeEvent(67*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/cower")
            end),
        },

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("cower") end)
        },

    },

    State{
        name = "hit",
        tags = {"hit", "busy"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            local anim = (inst:GetIsOnWater() and "seal_hit_water") or "seal_hit"
            inst.AnimState:PlayAnimation(anim)
            inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/hit")
        end,

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("cower")
            end)
        },
    },

    State{
        name = "death",
        tags = {"busy"},
        
        onenter = function(inst)
            inst.Physics:Stop()
            local on_water = inst:GetIsOnWater()
            if on_water then
                inst.AnimState:PlayAnimation("seal_death_water")
                inst.AnimState:PushAnimation("seal_death_water_loop", true)
            else
                inst.AnimState:PlayAnimation("seal_death")
            end
            inst.SoundEmitter:PlaySound("ia/creatures/twister/seal/death")
            inst.components.lootdropper:DropLoot()
        end,
    },
}

return StateGraph("twister_seal", states, events, "cower")%%+%%scripts/stategraphs/SGvolcano.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{

}

local events=
{
	--EventHandler("OnVolcanoEruptionBegin", function(inst) inst.sg:GoToState("erupt") end),
}

local states=
{
	State{
		name = "active",

		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("active_idle_pre")
			inst.AnimState:PushAnimation("active_idle", true)
			inst.SoundEmitter:SetParameter("volcano", "volcano_state", 1.0)
		end,
		
		events =
		{
			--EventHandler("animover", function(inst) inst.sg:GoToState("active_pst") end)
		},

		timeline =
		{

		},
	},

	State{
		name = "active_pst",
		
		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("active_idle_pst")
		end,

		onexit = function(inst)

		end,

		events =
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("dormant") end)
		},

		timeline =
		{

		},
	},

	State{
		name = "dormant",

		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("dormant_idle_pre")
			inst.AnimState:PushAnimation("dormant_idle", true)
			inst.SoundEmitter:SetParameter("volcano", "volcano_state", 0.0)
		end,
		
		events =
		{
			--EventHandler("animover", function(inst) inst.sg:GoToState("dormant_pst") end)
		},

		timeline =
		{
		
		},
	},

	State{
		name = "dormant_pst",
		
		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("dormant_idle_pst")
		end,

		onexit = function(inst)

		end,

		events =
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("active") end)
		},

		timeline =
		{

		},
	},

	State{
		name = "erupt",

		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("rumble")
		end,
		
		timeline =
		{
		
		},
		
		events =
		{
			--EventHandler("OnVolcanoEruptionEnd", function(inst) inst.sg:GoToState("rumble") end)
			EventHandler("animover", function(inst) inst.sg:GoToState("erupt_loop") end)
		},
	},

	State{
		name = "erupt_loop",

		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("erupt")
		end,
		
		timeline =
        {
        	-- TimeEvent(0*FRAMES, function(inst) GetWorld().SoundEmitter:SetParameter("earthquake", "intensity", 0.1) end),

            TimeEvent(48*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/volcano_erupt_charge") end),
            TimeEvent(63*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/volcano_erupt") end),
        	-- TimeEvent(64*FRAMES, function(inst) GetWorld().SoundEmitter:SetParameter("earthquake", "intensity", 0.06) end),
            TimeEvent(72*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/volcano_erupt_sizzle") end),
        },

        events =
		{
			--EventHandler("OnVolcanoEruptionEnd", function(inst) inst.sg:GoToState("rumble") end)
			EventHandler("animover", function(inst) inst.sg:GoToState("erupt_loop") end)
		},
	},

	State{
		name = "rumble",
		
		tags = {"busy"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("rumble")
			-- inst.AnimState:PushAnimation("rumble")
			-- inst.AnimState:PushAnimation("rumble")
			-- inst.AnimState:PushAnimation("rumble")
			-- inst.AnimState:PushAnimation("rumble")
			-- inst.AnimState:PushAnimation("rumble")
		end,

		onexit = function(inst)

		end,

		events =
		{
			EventHandler("animqueueover", function(inst)
				if TheWorld.state.issummer then
					inst.sg:GoToState("active")
				else
					inst.sg:GoToState("dormant")
				end
			end)
		},

		timeline =
		{

		},
	},
}

return StateGraph("volcano", states, events, "dormant", actionhandlers)
%%+%%scripts/stategraphs/SGvolcanoaltar.lua%%-%%require("stategraphs/commonstates")

local actionhandlers = 
{
}

local events=
{
}

local states=
{
    State{
        name = "open",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("open")
        end,

        timeline=
        {
            TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/altar/slide_open") end),
            TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/altar/open") end)
        },

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("opened") end)
        },
    },

    State{
        name = "opened",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("idle_open", true)
        end,
    },

    State{
        name = "close",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("close")
        end,

        timeline=
        {
            TimeEvent(12*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/altar/slide_close") end),
            TimeEvent(22*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/volcano/altar/close") end)
        },

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("closed") end)
        },
    },

    State{
        name = "closed",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("idle_close", true)
        end,
    },

    State{
        name = "appeased",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("appeased_pre")
            inst.AnimState:PushAnimation("appeased")
            inst.AnimState:PushAnimation("appeased_pst", false)
            inst.SoundEmitter:PlaySound("ia/common/volcano/altar/splash")
            inst.SoundEmitter:PlaySound("ia/common/volcano/altar/appeased")
        end,

        events =
        {
            EventHandler("animqueueover", function(inst)
                if inst:FullAppeased() then
                    inst.sg:GoToState("close")
                else
                    inst.sg:GoToState("opened")
                end
            end)
        },
    },

    State{
        name = "unappeased",

        onenter = function(inst)
            inst.AnimState:PlayAnimation("unappeased", false)
            inst.SoundEmitter:PlaySound("ia/common/volcano/altar/splash")
            inst.SoundEmitter:PlaySound("ia/common/volcano/altar/unappeased")
        end,

        events =
        {
            EventHandler("animover", function(inst)
                inst.sg:GoToState("opened")
            end)
        },
    },
}

return StateGraph("volcanoaltar", states, events, "closed", actionhandlers)
%%+%%scripts/stategraphs/SGwave.lua%%-%%require("stategraphs/commonstates")

local events = {}

local states=
{

	State
	{
		name = "rise",
		tags = {"rising"},

		onenter = function(inst)
			inst.AnimState:PlayAnimation("appear")
		end,

        timeline=
        {
            TimeEvent(5*FRAMES, function(inst)
            	if inst.soundrise then inst.SoundEmitter:PlaySound(inst.soundrise) end
            	if inst.soundloop then inst.SoundEmitter:PlaySound(inst.soundloop, inst.soundloop) end
            end),
        },

		events =
		{
			EventHandler("animover", function(inst)
				inst.sg:GoToState("idle")
			end)
		},
	},

	State
	{
		name = "idle",
		tags = {"idle"},

		onenter = function(inst)
			inst:activate_collision()
			inst.AnimState:PlayAnimation("idle", false)
			inst.sg:SetTimeout(inst.idle_time or 5)
		end,

		events =
		{
			EventHandler("animover", function(inst)
				
				if inst.waitingtolower then 
					inst.sg:GoToState("lower")
				else
					inst.AnimState:PlayAnimation("idle", false)
				end 
			end)
		},

		ontimeout = function(inst)
			--inst.sg:GoToState("lower")
			inst.waitingtolower = true 
		end,
	},

	State
	{
		name = "lower",
		tags = {"lowering"},

		onenter = function(inst)
			inst.AnimState:Resume()
			inst.AnimState:PlayAnimation("disappear")

			if inst.soundloop then
				inst.SoundEmitter:KillSound(inst.soundloop)
			end
		end,

		events = 
		{
			EventHandler("animover", function(inst) 
				inst:Remove() 
			end)
		},
	},
}

return StateGraph("wave", states, events, "rise")
%%+%%scripts/stategraphs/SGwhale.lua%%-%%require("stategraphs/commonstates")

local events=
{
	CommonHandlers.OnStep(),
	CommonHandlers.OnLocomote(false,true),
	CommonHandlers.OnSleep(),
	CommonHandlers.OnFreeze(),

	EventHandler("doattack", function(inst) if not inst.components.health:IsDead() then inst.sg:GoToState("attack") end end),
	EventHandler("death", function(inst) inst.sg:GoToState("death") end),
	EventHandler("attacked", function(inst) if inst.components.health:GetPercent() > 0 and not inst.sg:HasStateTag("attack") then inst.sg:GoToState("hit") end end),
}

local states=
{
	State{
		name = "idle",
		tags = {"idle", "canrotate"},

		onenter = function(inst, pushanim)
			inst.components.locomotor:StopMoving()
			inst.AnimState:PlayAnimation("idle", true)
			inst.sg:SetTimeout(2 + 2*math.random())
		end,

		events=
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle_loop") end),
		},
	},

	State{
		name = "idle_loop",
		tags = {"idle", "canrotate"},

		onenter = function(inst)
			
		end,


		timeline=
		{
			TimeEvent( 0*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.idle) end),
			TimeEvent(35*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.idle) end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle_loop") end),
		},
	},

	State{
		name = "attack",
		tags = {"busy", "attack", "canrotate"},

		onenter = function(inst)
			inst.components.combat:StartAttack()
			inst.components.locomotor:StopMoving()
			inst.AnimState:PlayAnimation("atk_pre")
			inst.AnimState:PushAnimation("atk", false)
		end,


		timeline=
		{
			TimeEvent(11*FRAMES, function(inst)
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
				end
				inst.SoundEmitter:PlaySound(inst.sounds.mouth_open)
			end),
			TimeEvent(25*FRAMES, function(inst)
				if inst.components.combat.target then 
					inst:ForceFacePoint(inst.components.combat.target:GetPosition()) 
				end
				SpawnWaves(inst, 2, 20, nil, nil, nil, nil, true)
				inst.components.combat:DoAttack()
				inst.SoundEmitter:PlaySound(inst.sounds.bite_chomp)
				inst.SoundEmitter:PlaySound(inst.sounds.bite)
			end),
		},

		events=
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("idle") end),
		},
	},

	State{
		name = "death",
		tags = {"busy"},

		onenter = function(inst)
			inst.SoundEmitter:PlaySound(inst.sounds.death)
			inst.AnimState:PlayAnimation("death")
			inst.components.locomotor:StopMoving()
			--inst.components.lootdropper:DropLoot(Vector3(inst.Transform:GetWorldPosition()))
		end,

		events=
		{
			EventHandler("animqueueover", function(inst) SpawnAt(inst.carcass, inst) end),
		},
	},

	State{
		name = "walk_start",
		tags = {"moving", "canrotate"},

		onenter = function(inst)
			inst.components.locomotor:StopMoving()
			inst.AnimState:PlayAnimation("walk_pre")
		end,

		timeline =
		{

			TimeEvent(12*FRAMES, function(inst)	inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large") end),
			-- TimeEvent(21*FRAMES, function(inst)	inst.components.locomotor:RunForward() end),
		},

		events =
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),
		},
	},

	State{
		name = "walk",
		tags = {"moving", "canrotate"},

		onenter = function(inst)
			inst.components.locomotor:RunForward()
			inst.AnimState:PlayAnimation("walk_loop")
		end,
		timeline =
		{
			TimeEvent(15*FRAMES, function(inst)
				inst.components.locomotor:WalkForward()
				inst.SoundEmitter:PlaySound(inst.sounds.breach_swim)
				inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimbreach_lrg")
			end ),
		},
		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("walk") end ),
		},
	},

	State{
		name = "walk_stop",
		tags = {"canrotate"},

		onenter = function(inst)
			inst.components.locomotor:StopMoving()
		end,

		timeline =
		{
			TimeEvent(15*FRAMES, function(inst)
				inst.SoundEmitter:PlaySound(inst.sounds.breach_swim)
				inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_swimbreach_lrg")
			end ),
		},

		events=
		{
			EventHandler("animqueueover", function(inst) inst.sg:GoToState("walk_stop_emerge") end ),
		},
	},

	State{
		name = "walk_stop_emerge",
		tags = {"canrotate"},

		onenter = function(inst)
			inst.components.locomotor:StopMoving()
			inst.AnimState:PlayAnimation("walk_pst", false)
		end,

		timeline=
		{
			TimeEvent(11*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/water_emerge_lrg") end),
			TimeEvent(15*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/creatures/seacreature_movement/splash_large") end),
		},

		events=
		{
			EventHandler("animover", function(inst) inst.sg:GoToState("idle") end ),
		},
	},
}

CommonStates.AddSimpleState(states,"hit", "hit")

CommonStates.AddSleepStates(states,
{
	sleeptimeline =
	{
		TimeEvent(30*FRAMES, function(inst) inst.SoundEmitter:PlaySound(inst.sounds.sleep) end)
	},
})
CommonStates.AddFrozenStates(states)

return StateGraph("whale", states, events, "idle")
%%+%%scripts/widgets/boatbadge.lua%%-%%local Badge = require "widgets/badge"
local UIAnim = require "widgets/uianim"

local BoatBadge = Class(Badge, function(self, owner)
    Badge._ctor(self, "boat_health", owner)

    self.boatarrow = self.underNumber:AddChild(UIAnim())
    self.boatarrow:GetAnimState():SetBank("sanity_arrow")
    self.boatarrow:GetAnimState():SetBuild("sanity_arrow")
    self.boatarrow:GetAnimState():PlayAnimation("neutral")
    self.boatarrow:SetClickable(false)

    self.num:SetSize(40)

    self:SetScale(1.3)

    self:StartUpdating()

    local COMBINEDSTATUS = KnownModIndex:IsModEnabled("workshop-376333686")
    local RPGHUD = false
    for _, moddir in ipairs(TheSim:GetModDirectoryNames()) do
        if string.match(KnownModIndex:GetModInfo(moddir).name or "", "RPG HUD") then
            RPGHUD = KnownModIndex:IsModEnabled(moddir)
            break
        end
    end
    if COMBINEDSTATUS then
        local SHOWSTATNUMBERS = GetModConfigData("SHOWSTATNUMBERS", "workshop-376333686")
        if SHOWSTATNUMBERS then
            local nudge = RPGHUD and 75 or 12.5
            self.bg:SetPosition(-.5, nudge-40)
            
            self.num:SetFont(NUMBERFONT)
            self.num:SetSize(28)
            self.num:SetPosition(3.5, nudge-40.5)
            self.num:SetScale(1,.78,1)
            self.num:MoveToFront()
            self.num:Show() 
        end
    end
end)

function BoatBadge:OnUpdate(dt)	
    -- local down = self.owner.components.temperature:IsOverheating() or self.owner.components.temperature:IsFreezing() or self.owner.components.hunger:IsStarving() or self.owner.components.health.takingfiredamage
    -- local poison = self.owner.components.poisonable:IsPoisoned()

    -- local anim = poison and "arrow_loop_decrease_more" or "neutral"
    -- anim = down and "arrow_loop_decrease_most" or anim

    local anim = "neutral"
    if anim and self.arrowdir ~= anim then
        self.arrowdir = anim
        self.boatarrow:GetAnimState():PlayAnimation(anim, true)
    end	
end

return BoatBadge%%+%%scripts/widgets/boatequipslot.lua%%-%%local ItemSlot = require "widgets/itemslot"

local BoatEquipSlot = Class(ItemSlot, function(self, equipslot, atlas, bgim, owner)
    ItemSlot._ctor(self, atlas, bgim, owner)
    self.owner = owner
    self.equipslot = equipslot
    self.highlight = false

    self.inst:ListenForEvent("newactiveitem", function(owner, data)
        if data.item ~= nil and
            data.item.replica.equippable ~= nil and
            equipslot == data.item.replica.equippable:BoatEquipSlot() then
            self:ScaleTo(self.base_scale, self.highlight_scale, 0.125)
            self.highlight = true
        elseif self.highlight then
            self.highlight = false
            self:ScaleTo(self.highlight_scale, self.base_scale, 0.125)
        end
    end, owner)
end)

function BoatEquipSlot:Click()
    self:OnControl(CONTROL_ACCEPT, true)
end

function BoatEquipSlot:OnControl(control, down)
    if down then
        local inventory = self.owner.replica.inventory
        local container = self.parent.container.replica.container
        if control == CONTROL_ACCEPT then
            local active_item = inventory:GetActiveItem()
            if active_item ~= nil then
                if active_item.replica.equippable ~= nil and
                    self.equipslot == active_item.replica.equippable:BoatEquipSlot() then
                    if self.tile ~= nil and self.tile.item ~= nil then
                        container:SwapBoatEquipWithActiveItem()
                    else
                        container:BoatEquipActiveItem()
                    end
                end
            elseif self.tile ~= nil and self.tile.item ~= nil and inventory:GetNumSlots() > 0 then
                container:TakeActiveItemFromBoatEquipSlot(self.equipslot)
            end
            return true
        elseif control == CONTROL_SECONDARY and self.tile and self.tile.item then
            inventory:UseItemFromInvTile(self.tile.item)
            return true
        end
    end
end

return BoatEquipSlot%%+%%scripts/widgets/boatover.lua%%-%%local Widget = require "widgets/widget"
local Image = require "widgets/image"

local BoatOver =  Class(Widget, function(self, owner)

    self.owner = owner
    Widget._ctor(self, "BoatOver")

    self:SetClickable(false)

    self.bg = self:AddChild(Image("images/overlays/fx3.xml", "boat_over.tex"))
    self.bg:SetVRegPoint(ANCHOR_MIDDLE)
    self.bg:SetHRegPoint(ANCHOR_MIDDLE)
    self.bg:SetVAnchor(ANCHOR_MIDDLE)
    self.bg:SetHAnchor(ANCHOR_MIDDLE)
    self.bg:SetScaleMode(SCALEMODE_FILLSCREEN)


    self:Hide()
    self.base_level = 0
    self.level = 0
    self.k = 1
    self:UpdateState()
    self.time_since_pulse = 0 
    self.pulse_period = 1

    self.inst:ListenForEvent("boatattacked", function(inst, data) return self:Flash() end, owner)
  end)

function BoatOver:UpdateState()
  -- print("update state")
  self:TurnOff()
end

function BoatOver:TurnOn()

  --TheInputProxy:AddVibration(VIBRATION_BLOOD_FLASH, .2, .7, true)    

  self:StartUpdating()
  self.base_level = .5
  self.k = 5
  self.time_since_pulse = 0
end

function BoatOver:TurnOff()
  -- print("turn off")
  self.base_level = 0
  self.k = 5
  self:OnUpdate(0)
end

function BoatOver:OnUpdate(dt)
  -- ignore abnormally large intervals as they will destabilize the math in here
  if dt > 0.1 then return end
  local delta = self.base_level - self.level

  if math.abs(delta) < .025 then
    self.level = self.base_level
  else
    self.level = self.level + delta*dt*self.k
  end

  if self.base_level > 0 and not IsPaused() then
    self.time_since_pulse = self.time_since_pulse + dt
    if self.time_since_pulse > self.pulse_period then
      self.time_since_pulse = 0

      if not self.owner.components.health:IsDead() then
        TheInputProxy:AddVibration(VIBRATION_BLOOD_OVER, .2, .3, false)  
      end
    end
  end

  if self.level > 0 then
    self:Show()
    self.bg:SetTint(1,1,1,self.level)
  else
    self:StopUpdating()
    self:Hide()
  end
end

function BoatOver:Flash()

  TheInputProxy:AddVibration(VIBRATION_BLOOD_FLASH, .2, .7, false)

  self:StartUpdating()
  self.level = 1
  self.k = 5 --larger # = quicker fade.
end

return BoatOver%%+%%postinit/any.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

---------------------------------------------------------------------------------------------------------------------------------------------

local LIGHT = "LIGHT"
local MEDIUM = "MEDIUM"
local HEAVY = "HEAVY"

local addBlowInWind = {
	acorn = MEDIUM,
	balloon = LIGHT,
	butterflywings = LIGHT,
	charcoal = LIGHT,
	cutgrass = LIGHT,
	cutreeds = LIGHT,
	egg = MEDIUM,
	featherfan = LIGHT,
	feather_crow = LIGHT,
	feather_robin = LIGHT,
	feather_robin_winter = LIGHT,
	feather_canary = LIGHT,
	flint = MEDIUM,
	fish = MEDIUM,
	flint = HEAVY,
	froglegs = MEDIUM,
	gears = HEAVY,
	goldnugget = MEDIUM, --SW says log is heavier than goldnugget
	goose_feather = LIGHT,
	heatrock = HEAVY,
	rocks = HEAVY,
	ice = MEDIUM,
	livinglog = HEAVY,
	log = HEAVY,
	lureplantbulb = HEAVY,
	meat = MEDIUM,
	cookedmeat = MEDIUM,
	meat_dried = MEDIUM,
	smallmeat = LIGHT,
	cookedsmallmeat = LIGHT,
	smallmeat_dried = LIGHT,
	monstermeat = MEDIUM,
	cookedmonstermeat = MEDIUM,
	monstermeat_dried = MEDIUM,
	green_cap = LIGHT,
	green_cap_cooked = LIGHT,
	red_cap = LIGHT,
	red_cap_cooked = LIGHT,
	blue_cap = LIGHT,
	blue_cap_cooked = LIGHT,
	nightmarefuel = LIGHT,
	nitre = MEDIUM,
	papyrus = LIGHT,
	petals = LIGHT,
	petals_evil = LIGHT,
	pinecone = LIGHT,
	poop = MEDIUM,
	rope = LIGHT,
	seeds = LIGHT,
	silk = LIGHT,
	spidergland = MEDIUM,
	spoiledfood = MEDIUM,
	stinger = LIGHT,
	torch = MEDIUM,
	transistor = MEDIUM,
	twigs = LIGHT,
	umbrella = LIGHT,
	--screw typing out all the vegetables TODO make a loop similiar to their prefab file
}

local neveronwater = {
	walrus_camp = true,
	evergreen = true,
	pinecone_sapling = true,
	evergreen_sparse = true,
	lumpy_sapling = true,
	twiggytree = true,
	twiggy_nut_sapling = true,
	deciduoustree = true,
	acorn_sapling = true,
	livingtree_sapling = true,
	sapling = true,
	grass = true,
}
local function RemoveOnWater(inst)
	if IsOnWater(inst) then
		inst:Remove()
	end
end

---------------------------------------------------------------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
---------------------------------------------------------------------------------------------------------------------------------------------

IAENV.AddPrefabPostInitAny(function(inst)


if inst and TheWorld.ismastersim then
    --if this list gets larger we can modify this a bit.
    if (inst.prefab == "wx78" or inst.prefab == "abigail"
	or inst:HasTag("shadow") or inst:HasTag("chess") )
	and inst.poisonimmune ~= false then inst.poisonimmune = true end

    if inst.components and inst.components.combat and inst.components.health and not inst.poisonimmune and not inst.components.poisonable then
        if inst:HasTag("player") then
            MakePoisonableCharacter(inst, nil, nil, "player", 0, 0, 1)
            inst.components.poisonable.duration = TUNING.TOTAL_DAY_TIME * 3
            inst.components.poisonable.transfer_poison_on_attack = false
        else
            MakePoisonableCharacter(inst)
        end
    end
	
	if addBlowInWind[inst.prefab] then
		MakeBlowInHurricane(inst, TUNING.WINDBLOWN_SCALE_MIN[addBlowInWind[inst.prefab]], TUNING.WINDBLOWN_SCALE_MAX[addBlowInWind[inst.prefab]])
	end

	if neveronwater[inst.prefab] then
		inst:DoTaskInTime(0,RemoveOnWater)
	end

    if inst.prefab == "fish" or inst.prefab == "fish_cooked" then
        inst:AddTag("packimfood")
    end
    if inst.prefab == "tornado" then
        inst:AddTag("amphibious")
    end

    if inst:HasTag("SnowCovered") then
        if not inst.components.climatetracker then
			inst:AddComponent("climatetracker")
		end

        --objects that move between climates now properly update being snow covered.
        inst:ListenForEvent("climatechange", function(inst, data)
            if not IsInIAClimate(inst) and TheWorld.state.issnowcovered then
                inst.AnimState:Show("snow")
            else
                inst.AnimState:Hide("snow")
            end
        end)
    end

end

if inst then
    if inst:HasTag("bird") then
        inst:AddTag("amphibious")
    end
end

end)
%%+%%postinit/player.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function blockPoison(inst, data)
	if inst.components.poisonable then
		inst.components.poisonable:SetBlockAll(true)
	end
end
local function unblockPoison(inst, data)
	if inst.components.poisonable and not inst:HasTag("beaver") then
		inst.components.poisonable:SetBlockAll(true)
	end
end

----------------------------------------------------------------------------------------

--Attempt autodisembarking
--basically a copy of controller disembarking from postinit/components/playercontroller.lua
local function hitcoastline(inst)
	-- If the player is the host and he doesn't want autodisembark, then don't
	if not IA_CONFIG.autodisembark or inst.noautodisembark then return end

	--Ignore if the player is any of this
	if inst.sg:HasStateTag("busy") or inst:IsAmphibious() or
		(inst.components.health and inst.components.health:IsDead()) then
		return
	end
	
	if inst.components.sailor and inst.components.sailor:IsSailing() then
		--Check if the player is close to land and facing towards it
		local angle = inst.Transform:GetRotation() * DEGREES
		local dir = Vector3(math.cos(angle), 0, -math.sin(angle))
		dir = dir:GetNormalized()

		local myPos = inst:GetPosition()
		local step = 0.4
		local numSteps = 8 
		local landingPos = nil 

		for i = 1, numSteps, 1 do 
			local testPos = myPos + dir * step * i 
			local testTile = TheWorld.Map:GetTileAtPoint(testPos.x , testPos.y, testPos.z) 
			if not IsWater(testTile) then 
				landingPos = testPos
				break
			end 
		end 
		if landingPos then 
			landingPos.x, landingPos.y, landingPos.z = TheWorld.Map:GetTileCenterPoint(landingPos.x, 0, landingPos.z)
			inst:PushBufferedAction(BufferedAction(inst, nil, ACTIONS.DISEMBARK, nil, landingPos))
		end
	end
end

----------------------------------------------------------------------------------------

local function beachresurrect(inst)
	local oldpos = inst:GetPosition()
	--Step 1: find position
	local testwaterfn = function(offset)
		local test_point = oldpos + offset
		local tile = TheWorld.Map:GetTileAtPoint(test_point:Get())
		if IsWater(tile) or tile == GROUND.INVALID or tile == GROUND.IMPASSABLE then
			return false
		end
		
		local waterPos = FindValidPositionByFan(0, 12, 6, function(offset)
			return IsOnWater(test_point + offset)
		end)
		if waterPos == nil then
			return false
		end
		
		-- print("should be good... just checking for dangers now.")
		
		--TODO this is not Webber-friendly
		if #TheSim:FindEntities(oldpos.x, oldpos.y, oldpos.z, 12, nil, nil, {"fire", "hostile"}) > 0 then
			return false
		end
		
		return true
	end
	
	
	local pt
	for radius = 8, 508, 10 do
		local result_offset = FindValidPositionByFan(0, radius, 4 + 14 * math.floor(radius/508), testwaterfn)
		if result_offset then
			--we got a winner, stop the loop
			-- print("WE GOT A POINT AT RADIUS..."..radius)
			pt = oldpos + result_offset
			break
		end
	end
	if not pt then
		--try again, but farther
		for radius = 520, 3020, 25 do
			local result_offset = FindValidPositionByFan(0, radius, 16 + 16 * math.floor(radius/3020), testwaterfn)
			if result_offset then
				--we got a winner, stop the loop
				-- print("WE GOT A POINT AT RADIUS..."..radius)
				pt = oldpos + result_offset
				break
			end
		end
	end
	if not pt then
		--find a multiplayer_portal of any kind, those are safe
		for guid, ent in pairs(Ents) do
			if ent:IsValid() and ent.prefab and string.gsub(ent.prefab, 0, 18) == "multiplayer_portal" then
				pt = ent:GetPosition()
				break
			end
		end
	end
	if not pt then
		--failsafe to killing the player
		print("FATAL: Not able to beachresurrect "..tostring(inst)..". Kill them with \"drowning\" instead.")
		inst.components.health:DoDelta(-inst.components.health.currenthealth, false, "drowning", false, nil, true)
		return
	end
	
	--Step 2: put player there
	local crafting = GetValidRecipe("boat_lograft")
	if crafting and crafting.ingredients then
		for _, v in pairs(crafting.ingredients) do
			for i = 1, v.amount do
				local offset = FindValidPositionByFan(math.random()*2*PI, math.random()*2+2, 8, function(pos)
					return not IsOnWater(pos + pt)
				end)
				local item = SpawnPrefab(v.type)
				if offset then
					item.Transform:SetPosition((pt+offset):Get())
				else
					item.Transform:SetPosition(pt:Get())
				end
				item:Hide()
				item:DoTaskInTime(math.random()*3, function()
					item:Show()
					SpawnAt("sand_puff", item)
				end)
			end
		end
	end
	
			
	-- inst.components.hunger:Pause()
	inst:ScreenFade(false, .4, false)
	
	inst:DoTaskInTime(3, function()
		inst.Transform:SetPosition(pt:Get())
		SpawnAt("collapse_small", inst)
	end)
	
	inst:DoTaskInTime(3.4, function()
		
		inst:ScreenFade(true, .4, false)
		
		inst.sg:GoToState("wakeup")
		
		-- inst.components.hunger:Resume()
		
		if inst.components.health then
			inst.components.health:SetInvincible(false)
		end
		
		if inst.components.moisture then
			inst.components.moisture:SetPercent(1)
		end
		
		if not TheWorld.state.isday then
			SpawnAt("spawnlight_multiplayer", inst)
		end
	end)
	
end

----------------------------------------------------------------------------------------

local function newstate(inst, data)
	--data.statename
	if inst:HasTag("idle") then
		if inst._embarkingboat and inst._embarkingboat:IsValid() then
			inst.components.sailor:Embark(inst._embarkingboat)
			inst._embarkingboat = nil
		end
		inst:RemoveEventCallback("newstate", newstate)
	end
end

local function stop(inst)
	if inst.Physics then
		inst.Physics:Stop()
	end
end

local function ms_respawnedfromghost(inst, data)
	if IsOnWater(inst) and inst.components.sailor then
		local boat = FindEntity(inst, 5, nil, {"sailable"}, {"INLIMBO", "fire", "NOCLICK"})
		if boat then
			boat.components.sailable.isembarking = true
			inst._embarkingboat = boat
			--Move there!
			inst:ForceFacePoint(boat:GetPosition():Get())
			local dist = inst:GetPosition():Dist(boat:GetPosition())
			inst.Physics:SetMotorVelOverride(dist / .8, 0, 0)
			inst:DoTaskInTime(.8, stop)
			--Drowning immunity appears to be not needed. -M
			inst:ListenForEvent("newstate", newstate)
		end
	end
end

----------------------------------------------------------------------------------------

local function gotnewitem(inst,data)
	if (data.slot ~= nil or data.eslot ~= nil)
	and TheFocalPoint --just a small failsafe
	and IsOnWater(inst) then
		-- This might sound weird since the normal sound also plays
		TheFocalPoint.SoundEmitter:PlaySound("ia/common/water_collect_resource")
	end
end

----------------------------------------------------------------------------------------

local sailface = {
wilson = {
	wilson_none = "wilson_none",
	wilson_ice = "wilson_ice",
	wilson_magma = "wilson_magma",
	wilson_pigguard = "wilson_pigguard", --Event version
	wilson_pigguard_d = "wilson_pigguard", --"real" version
	wilson_shadow = "wilson_shadow",
	wilson_survivor = "wilson_survivor",
	wilson_victorian = "wilson_victorian",
},
willow = {
	willow_none = "willow_none",
	willow_ice = "willow_ice",
	willow_magma = "willow_magma",
	willow_victorian = "willow_victorian",
},
wolfgang = {
	wolfgang_none = {
		wimpy = "wolfgang_none_wimpy",
		normal = "wolfgang_none_normal",
		mighty = "wolfgang_none_mighty",
	},
	wolfgang_combatant = {
		wimpy = "wolfgang_combatant_wimpy",
		normal = "wolfgang_combatant",
		mighty = "wolfgang_combatant_mighty",
	},
	wolfgang_formal = {
		wimpy = "wolfgang_none_wimpy", --formal wimpy is normal wimpy
		normal = "wolfgang_formal",
		mighty = "wolfgang_formal_mighty",
	},
	wolfgang_gladiator = {
		wimpy = "wolfgang_gladiator_wimpy",
		normal = "wolfgang_gladiator",
		mighty = "wolfgang_gladiator_mighty",
	},
	wolfgang_ice = {
		wimpy = "wolfgang_ice_wimpy",
		normal = "wolfgang_ice",
		mighty = "wolfgang_ice_mighty",
	},
	wolfgang_magma = {
		wimpy = "wolfgang_magma_wimpy",
		normal = "wolfgang_magma",
		mighty = "wolfgang_magma_mighty",
	},
	wolfgang_rose = {
		wimpy = "wolfgang_rose_wimpy",
		normal = "wolfgang_rose",
		mighty = "wolfgang_rose_mighty",
	},
	wolfgang_shadow = {
		wimpy = "wolfgang_shadow_wimpy",
		normal = "wolfgang_shadow",
		mighty = "wolfgang_shadow_mighty",
	},
	wolfgang_survivor = {
		wimpy = "wolfgang_survivor_wimpy",
		normal = "wolfgang_survivor",
		mighty = "wolfgang_survivor_mighty",
	},
	wolfgang_victorian = {
		wimpy = "wolfgang_victorian_wimpy",
		normal = "wolfgang_victorian",
		mighty = "wolfgang_victorian_mighty",
	},
	wolfgang_walrus = { --Event version
		wimpy = "wolfgang_walrus_wimpy",
		normal = "wolfgang_walrus",
		mighty = "wolfgang_walrus_mighty",
	},
	wolfgang_walrus_d = { --"real" version
		wimpy = "wolfgang_walrus_wimpy",
		normal = "wolfgang_walrus",
		mighty = "wolfgang_walrus_mighty",
	},
	wolfgang_wrestler = {
		wimpy = "wolfgang_wrestler_wimpy",
		normal = "wolfgang_wrestler",
		mighty = "wolfgang_wrestler_mighty",
	},
},
wendy = {
	wendy_none = "wendy_none",
	wendy_formal = "wendy_formal",
	wendy_ice = "wendy_ice",
	wendy_magma = "wendy_magma",
},
wx78 = {
	wx78_none = "wx78_none",
	wx78_formal = "wx78_formal",
	wx78_gladiator = "wx78_gladiator",
	wx78_magma = "wx78_magma",
	wx78_nature = "wx78_nature",
	wx78_rhinorook = "wx78_rhinorook", --Event version
	wx78_rhinorook_d = "wx78_rhinorook", --"real" version
	wx78_victorian = "wx78_victorian",
	wx78_wip = "wx78_wip",
},
wickerbottom = {
	wickerbottom_none = "wickerbottom_none",
	wickerbottom_combatant = "wickerbottom_combatant",
	wickerbottom_formal = "wickerbottom_formal",
	wickerbottom_gladiator = "wickerbottom_gladiator",
	wickerbottom_ice = "wickerbottom_ice",
	wickerbottom_lightninggoat = "wickerbottom_lightninggoat", --Event version
	wickerbottom_lightninggoat_d = "wickerbottom_lightninggoat", --"real" version
	wickerbottom_magma = "wickerbottom_magma",
	wickerbottom_rose = "wickerbottom_rose",
	wickerbottom_shadow = "wickerbottom_shadow",
	wickerbottom_survivor = "wickerbottom_survivor",
	wickerbottom_victorian = "wickerbottom_victorian",
},
woodie = {
	woodie_none = "woodie_none",
	woodie_combatant = "woodie_combatant",
	woodie_gladiator = "woodie_gladiator",
	-- woodie_magma = "woodie_magma",
	woodie_survivor = "woodie_survivor",
},
wes = {
	wes_none = "wes_none",
	wes_combatant = "wes_combatant",
	wes_gladiator = "wes_gladiator",
	wes_magma = "wes_magma",
	wes_mandrake = "wes_mandrake", --Event version
	wes_mandrake_d = "wes_mandrake", --"real" version
	wes_nature = "wes_nature",
	wes_rose = "wes_rose",
	wes_shadow = "wes_shadow",
	wes_survivor = "wes_survivor",
	wes_victorian = "wes_victorian",
	wes_wrestler = "wes_wrestler",
},
waxwell = {
	waxwell_none = "waxwell_none",
	waxwell_combatant = "waxwell_combatant",
	waxwell_formal = "waxwell_formal",
	waxwell_gladiator = "waxwell_gladiator",
	waxwell_krampus = "waxwell_krampus", --Event version
	waxwell_krampus_d = "waxwell_krampus", --"real" version
	waxwell_magma = "waxwell_magma",
	waxwell_nature = "waxwell_nature",
	waxwell_survivor = "waxwell_survivor",
	waxwell_unshadow = "waxwell_unshadow",
	waxwell_victorian = "waxwell_victorian",
},
wathgrithr = {
	wathgrithr_none = "wathgrithr_none",
	wathgrithr_combatant = "wathgrithr_combatant",
	wathgrithr_cook = "wathgrithr_cook",
	wathgrithr_deerclops = "wathgrithr_deerclops", --Event version
	wathgrithr_deerclops_d = "wathgrithr_deerclops", --"real" version
	wathgrithr_gladiator = "wathgrithr_gladiator",
	wathgrithr_nature = "wathgrithr_nature",
	wathgrithr_survivor = "wathgrithr_survivor",
	wathgrithr_wrestler = "wathgrithr_wrestler",
},
webber = {
	webber_none = "webber_none",
	webber_bat = "webber_bat", --Event version
	webber_bat_d = "webber_bat", --"real" version
	webber_ice = "webber_ice",
	webber_magma = "webber_magma",
	webber_victorian = "webber_victorian",
},
winona = {
	winona_none = "winona_none",
	winona_combatant = "winona_combatant",
	winona_formal = "winona_formal", --Heirloom version
	winona_formalp = "winona_formal", --"real" version
	winona_gladiator = "winona_gladiator",
	winona_grassgecko = "winona_grassgecko", --Event version
	winona_grassgecko_d = "winona_grassgecko", --"real" version
	winona_magma = "winona_magma",
	winona_rose = "winona_rose", --Heirloom version
	winona_rosep = "winona_rose", --"real" version
	winona_shadow = "winona_shadow", --Heirloom version
	winona_shadowp = "winona_shadow", --"real" version
	winona_survivor = "winona_survivor", --Heirloom version
	winona_survivorp = "winona_survivor", --"real" version
	winona_victorian = "winona_victorian",
},
wortox = {
	wortox_none = "wortox_none",
	wortox_minotaur = "wortox_minotaur",
	wortox_original = "wortox_original",
	wortox_survivor = "wortox_survivor",
},
wormwood = {
	wormwood_none = "wormwood_none",
},
warly = {
	warly_none = "warly_none",
},
}

local Skinner = require("components/skinner")

local _SetSkinMode = Skinner.SetSkinMode
function Skinner:SetSkinMode(...)
	_SetSkinMode(self, ...)
    if not sailface[self.inst.prefab] then return end

    local skinname = self.skin_name
    local skin_type = self.skintype or ""

    if not skinname or skinname == "" then skinname = self.inst.prefab .."_none" end

    local face = sailface[self.inst.prefab][skinname] or sailface[self.inst.prefab][self.inst.prefab .."_none"]

    if self.inst.prefab == "wolfgang" then face = face[skin_type:find("wimpy") and "wimpy" or skin_type:find("mighty") and "mighty" or "normal"] end

    -- print("SETTING SAILFACE", skinname, self.skin_name, face)
    self.inst.AnimState:OverrideSymbol("face_sail", "swap_sailface", face)
end

--for debug testing, enable this code:
-- local char_prefab = nil
-- _G.sface = "wilson_none" --set this via console
-- IAENV.AddClassPostConstruct("widgets/skinspuppet", function(inst)
	-- local SetSkins_old = inst.SetSkins
	-- function inst:SetSkins(character, ...)
		-- char_prefab = character
		-- SetSkins_old(self, character, ...)
	-- end
	
	-- function inst:DoEmote()
		-- self.animstate:SetBank("wilson")
		-- self.animstate:OverrideSymbol("face_sail", "swap_sailface", _G.sface)
		-- self.animstate:PlayAnimation("sail_pre", false)
		-- self.animstate:PushAnimation("sail_loop", false)
		-- self.animstate:PushAnimation("sail_loop", false)
		-- self.animstate:PushAnimation("sail_loop", false)
		-- self.animstate:PushAnimation("sail_pst", false)
		-- -- self.looping = true
	-- end
-- end)

local function WaterFailsafe(inst)
	local my_x, my_y, my_z = inst.Transform:GetWorldPosition()
	if not TheWorld.Map:IsPassableAtPoint(my_x, my_y, my_z)
	and not inst:HasTag("aquatic") then
	for k,v in pairs(Ents) do
			if v:IsValid() and v:HasTag("multiplayer_portal") then
				inst.Transform:SetPosition(v.Transform:GetWorldPosition())
				inst:SnapCamera()
			end
		end
	end
end

local OnLoad_old
local function OnLoad(inst, data, ...)
	local pendingtasks = {}
	for per, _ in pairs(inst.pendingtasks) do
		pendingtasks[per] = true
	end
	OnLoad_old(inst, data, ...)
	local newtasks = {}
	for per, _ in pairs(inst.pendingtasks) do
		if not pendingtasks[per] and per.period == 0 and per.limit == 1 then
			table.insert(newtasks, per)
		end
	end
	if #newtasks == 1 then
		newtasks[1]:Cancel()
		--recreate with appropriate fn
		inst:DoTaskInTime(0, WaterFailsafe)
	end
end

local OnNewSpawn
local function OnNewSpawn_ia(inst, ...)
	-- if IA_CONFIG.newplayerboats then --made it not wrap if the config is not set to begin with -M
		if inst.components.builder then
			-- inst.components.builder:BufferBuild("boat_lograft")
			inst.components.builder:UnlockRecipe("boat_lograft")
			inst.components.builder.buffered_builds["boat_lograft"] = 0
			inst.replica.builder:SetIsBuildBuffered("boat_lograft", true)
		end
	-- end
	return OnNewSpawn(inst, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInitAny(function(inst)
if not inst:HasTag("player") then return end


inst.Physics:CollidesWith(COLLISION.WAVES)


if TheWorld.ismastersim then	
	if not inst.components.climatetracker then
		inst:AddComponent("climatetracker")
	end
    inst.components.climatetracker.period = 2
    inst:AddComponent("sailor")
    inst:AddComponent("keeponland")
    inst:AddComponent("ballphinfriend")
	if TheWorld:HasTag("island") then
		inst:AddComponent("mapwrapper")
	end

    inst:ListenForEvent("death", blockPoison)
    inst:ListenForEvent("respawnfromghost", unblockPoison)
    inst:ListenForEvent("hitcoastline", hitcoastline)
	inst:ListenForEvent("beachresurrect", beachresurrect)
	inst:ListenForEvent("ms_respawnedfromghost", ms_respawnedfromghost)

	if inst.OnLoad then
		OnLoad_old = inst.OnLoad
		inst.OnLoad = OnLoad
	end
	if inst.OnNewSpawn and IA_CONFIG.newplayerboats then
		OnNewSpawn = inst.OnNewSpawn
		inst.OnNewSpawn = OnNewSpawn_ia
	end
end

if not TheNet:IsDedicated() then
	inst:DoTaskInTime(0, function()
		if inst == TheLocalPlayer then --only do this for the local player character
			inst:AddComponent("windvisuals")
			-- inst.components.windvisuals:SetRate(1.0)
			inst:AddComponent("watervisuals")
			inst.components.watervisuals:SetWaveSettings(0.8)
            inst:AddComponent("sailor_client")
			-- player_common prefers to only set callbacks like this in "SetOwner", as the character owner can theoretically change
			inst:ListenForEvent("gotnewitem", gotnewitem)
		end
	end)
end


end)
%%+%%postinit/sim.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)
IAENV.AddSimPostInit(function()

--Map is not a proper component, so we edit it here instead.

local function IsWaterAny(tile)
	return IsWater(tile) or (tile >= GROUND.OCEAN_START and tile <= GROUND.OCEAN_END)
end

local function quantizepos(pt)
	local x, y, z = TheWorld.Map:GetTileCenterPoint(pt:Get())

	if pt.x > x then
		x = x + 1
	else
		x = x - 1
	end

	if pt.z > z then
		z = z + 1
	else
		z = z - 1
	end

	return Vector3(x,y,z)
end

local CanDeployAtPoint = Map.CanDeployAtPoint
function Map:CanDeployAtPoint(pt, inst, ...)
	if inst.prefab == "tar" then
		pt = quantizepos(pt)
		return CanDeployAtPoint(self, pt, inst, ...) and not IsOnWater(pt, nil, nil, nil, .4) --extra shore spacing
	end
	return CanDeployAtPoint(self, pt, inst, ...)
end

-- Placing on ocean or not
local _CanDeployRecipeAtPoint = Map.CanDeployRecipeAtPoint
function Map:CanDeployRecipeAtPoint(pt, recipe, rot, player)
    local candeploy = _CanDeployRecipeAtPoint(self, pt, recipe, rot, player)
	local test_valid = (not recipe.testfn or recipe.testfn(pt, rot)) and Map:IsDeployPointClear(pt, nil, recipe.min_spacing or 3.2)
    if not test_valid or (not candeploy and not recipe.aquatic) then return false end

    local tile = GROUND.GRASS
    local map = TheWorld.Map;
    tile = map:GetTileAtPoint(pt:Get())

    --how the heck do i figure this out?
    local boating = player ~= nil and IsOnWater(player)

    if tile == GROUND.IMPASSABLE or (boating and not recipe.aquatic) then
        return false
    end

    if recipe.aquatic then
		local x, y, z = pt:Get()
        if boating then
            local minBuffer = 2
            return IsWaterAny(tile) and
                IsWaterAny(map:GetTileAtPoint(x + minBuffer, y, z)) and
                IsWaterAny(map:GetTileAtPoint(x - minBuffer, y, z)) and
                IsWaterAny(map:GetTileAtPoint(x , y, z + minBuffer)) and
                IsWaterAny(map:GetTileAtPoint(x , y, z - minBuffer))
        else 
            if not IsShore(GetVisualTileType(x, y, z)) then return false end

            local maxBuffer = 2

            if not ((not IsWaterAny(GetVisualTileType(x + maxBuffer, y, z))) or
            (not IsWaterAny(GetVisualTileType(x - maxBuffer, y, z))) or
            (not IsWaterAny(GetVisualTileType(x , y, z + maxBuffer))) or
            (not IsWaterAny(GetVisualTileType(x , y, z - maxBuffer))) or
            (not IsWaterAny(GetVisualTileType(x + maxBuffer, y, z + maxBuffer))) or
            (not IsWaterAny(GetVisualTileType(x - maxBuffer, y, z + maxBuffer))) or
            (not IsWaterAny(GetVisualTileType(x + maxBuffer , y, z - maxBuffer))) or
            (not IsWaterAny(GetVisualTileType(x - maxBuffer , y, z - maxBuffer)))) then 
                return false 
            end

            local minBuffer = 0.5
            if recipe.name == "ballphinhouse" then --TODO this is not only hacky, but seems misplaced too -M
                minBuffer = 100
            end

            if ((not IsWaterAny(GetVisualTileType(x + minBuffer, y, z))) or
            (not IsWaterAny(GetVisualTileType(x - minBuffer, y, z))) or
            (not IsWaterAny(GetVisualTileType(x , y, z + minBuffer))) or
            (not IsWaterAny(GetVisualTileType(x , y, z - minBuffer))) or
            (not IsWaterAny(GetVisualTileType(x + minBuffer, y, z + minBuffer))) or
            (not IsWaterAny(GetVisualTileType(x - minBuffer, y, z + minBuffer))) or
            (not IsWaterAny(GetVisualTileType(x + minBuffer , y, z - minBuffer))) or
            (not IsWaterAny(GetVisualTileType(x - minBuffer , y, z - minBuffer)))) then
                return false
            end  

            return true
        end
    end

    return candeploy
end


function Map:CanVolcanoPlantAtPoint(x, y, z)
    local tile = self:GetTileAtPoint(x, y, z)
    return tile == GROUND.MAGMAFIELD or tile == GROUND.ASH or tile == GROUND.VOLCANO
end

local _CanDeployPlantAtPoint = Map.CanDeployPlantAtPoint
function Map:CanDeployPlantAtPoint(pt, inst, ...)
    if inst:HasTag("volcanicplant") then
        return self:CanVolcanoPlantAtPoint(pt:Get())
            and self:IsDeployPointClear(pt, inst, inst.replica.inventoryitem ~= nil and inst.replica.inventoryitem:DeploySpacingRadius() or DEPLOYSPACING_RADIUS[DEPLOYSPACING.DEFAULT])
    else
        return _CanDeployPlantAtPoint(self, pt, inst, ...)
    end
end

local _CanDeployWallAtPoint = Map.CanDeployWallAtPoint
function Map:CanDeployWallAtPoint(pt, inst, ...)

	for i, v in ipairs(TheSim:FindEntities(pt.x, 0, pt.z, 2, {"sandbag"})) do
        if v ~= inst and
            v.entity:IsVisible() and
            v.components.placer == nil and
            v.entity:GetParent() == nil then
			local opt = v:GetPosition()
			--important to remove sign in order to calculate accuracte distance
			if math.abs(math.abs(opt.x) - math.abs(pt.x)) < 1 and math.abs(math.abs(opt.z) - math.abs(pt.z)) < 1 then
				return false
			end
        end
    end

    return _CanDeployWallAtPoint(self, pt, inst, ...)
end

---------------------------------------------------------------------------------------------------------------------------------------------

for k, v in pairs(IA_VEGGIES) do
    table.insert(Prefabs.plant_normal.assets, Asset("ANIM", "anim/"..k))
    table.insert(Prefabs.plant_normal.deps, k)
    table.insert(Prefabs.seeds.deps, k)
    VEGGIES[k] = v
	if v.seed_weight then
		TUNING.BURNED_LOOT_OVERRIDES[k .."_seeds"] = "seeds_cooked"
	end
end

----------------------------------------------------------------------------------------------------------------------------------------

function RunAway:GetRunAngle(pt, hp)
  if self.avoid_angle ~= nil then
    local avoid_time = GetTime() - self.avoid_time
    if avoid_time < 1 then
      return self.avoid_angle
    else
      self.avoid_time = nil
      self.avoid_angle = nil
    end
  end

  local angle = self.inst:GetAngleToPoint(hp) + 180 -- + math.random(30)-15
  if angle > 360 then
    angle = angle - 360
  end

  --print(string.format("RunAway:GetRunAngle me: %s, hunter: %s, run: %2.2f", tostring(pt), tostring(hp), angle))

  local radius = 6

  local result_offset, result_angle, deflected = FindWalkableOffset(pt, angle*DEGREES, radius, 8, true, false, IsPositionValidForEnt(self.inst, 2)) -- try avoiding walls
  if result_angle == nil then
    result_offset, result_angle, deflected = FindWalkableOffset(pt, angle*DEGREES, radius, 8, true, true, IsPositionValidForEnt(self.inst, 2)) -- ok don't try to avoid walls, but at least avoid water
    if result_angle == nil then
      return angle -- ok whatever, just run
    end
  end

  result_angle = result_angle / DEGREES
  if deflected then
    self.avoid_time = GetTime()
    self.avoid_angle = result_angle
  end
  return result_angle
end

function Wander:PickNewDirection()
  self.far_from_home = self:IsFarFromHome()

  self.walking = true

  if self.far_from_home then
    --print("Far from home, going back")
    --print(self.inst, Point(self.inst.Transform:GetWorldPosition()), "FAR FROM HOME", self:GetHomePos())
    self.inst.components.locomotor:GoToPoint(self:GetHomePos())
  else
    local pt = Point(self.inst.Transform:GetWorldPosition())
    local angle = (self.getdirectionFn and self.getdirectionFn(self.inst)) 
    -- print("got angle ", angle) 
    if not angle then 
      angle = math.random()*2*PI
      --print("no angle, picked", angle, self.setdirectionFn)
      if self.setdirectionFn then
        --print("set angle to ", angle) 
        self.setdirectionFn(self.inst, angle)
      end
    end

    local radius = 12
    local attempts = 8
    local offset, check_angle, deflected = FindWalkableOffset(pt, angle, radius, attempts, true, false, IsPositionValidForEnt(self.inst, 2)) -- try to avoid walls
    if not check_angle then
      --print(self.inst, "no los wander, fallback to ignoring walls")
      offset, check_angle, deflected = FindWalkableOffset(pt, angle, radius, attempts, true, true, IsPositionValidForEnt(self.inst, 2)) -- if we can't avoid walls, at least avoid water
    end
    if check_angle then
      angle = check_angle
      if self.setdirectionFn then
        --print("(second case) reset angle to ", angle) 
        self.setdirectionFn(self.inst, angle)
      end
    else
      -- guess we don't have a better direction, just go whereever
      --print(self.inst, "no walkable wander, fall back to random")
    end
    --print(self.inst, pt, string.format("wander to %s @ %2.2f %s", tostring(offset), angle/DEGREES, deflected and "(deflected)" or ""))
    if offset then
      self.inst.components.locomotor:GoToPoint(self.inst:GetPosition() + offset)
    else
      self.inst.components.locomotor:WalkInDirection(angle/DEGREES)
    end
  end

  self:Wait(self.times.minwalktime+math.random()*self.times.randwalktime)
end

-------------------------- RANDOM TESTS ----------------------------------------

--CurrentFnToDebug = nil
--currentDebugLocals = nil
--currentDebugUpvals = nil

--mydebuggetstatus = "waiting"

--function SetFnToDebug(fn, base)
--  CurrentFnToDebug = base and getmetatable(base).__index.fn or fn
--  if CurrentFnToDebug ~= nil then
--    mydebuggetstatus = "ready"
--  end
--end

--function MyDebugGetLocal()
--  if mydebuggetstatus == "paused" then
--    return
--  end

--  local funcInf = debug.getinfo(2)

----  print("------------------HOOK------------------")
----  for k, v in pairs(funcInf) do
----    print(k,"=",v)
----  end

----  print("Hook fn for ", funcInf.func, "/ Currently tracked function:", CurrentFnToDebug)

--  currentDebugLocals = nil
--  currentDebugUpvals = nil

--  if CurrentFnToDebug ~= nil and funcInf.func == CurrentFnToDebug then
--    currentDebugLocals={}    
--    local i = 1
--    while true do
--      local n, v = debug.getlocal(2, i)
--      if not n then break end
----      print(tostring(n).." = "..tostring(v))
--      table.insert(currentDebugLocals, {name = n, value = v})
--      i = i + 1
--    end

--    currentDebugUpvals={}
--    i = 1
--    while true do
--      local n, v = debug.getupvalue (funcInf.func, i)
--      if not n then break end
----      print(tostring(n).." = "..tostring(v))
--      table.insert(currentDebugUpvals, {name = n, value = v})
--      i = i + 1
--    end

--    mydebuggetstatus = "paused"
--  end
--end

--debug.sethook(MyDebugGetLocal, "c")

end)
%%+%%postinit/components/ambientsound.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("ambientsound", function(cmp)


local AMBIENT_SOUNDS = UpvalueHacker.GetUpvalue(cmp.OnUpdate, "AMBIENT_SOUNDS")
local SEASON_SOUND_KEY = UpvalueHacker.GetUpvalue(cmp.OnUpdate, "SEASON_SOUND_KEY")

AMBIENT_SOUNDS[ GROUND.JUNGLE ] = {
	sound = "ia/amb/mild/jungleAMB", 
	wintersound = "ia/amb/wet/jungleAMB", 
	springsound = "ia/amb/green/jungleAMB", 
	summersound = "ia/amb/dry/jungleAMB", 
	rainsound = "ia/amb/rain/jungleAMB", 
	hurricanesound = "ia/amb/hurricane/jungleAMB",
}
AMBIENT_SOUNDS[ GROUND.BEACH ] = {
	sound = "ia/amb/mild/beachAMB", 
	wintersound = "ia/amb/wet/beachAMB", 
	springsound = "ia/amb/green/beachAMB", 
	summersound = "ia/amb/dry/beachAMB", 
	rainsound = "ia/amb/rain/beachAMB", 
	hurricanesound = "ia/amb/hurricane/beachAMB",
}
-- AMBIENT_SOUNDS[ GROUND.SWAMP ] = {
	-- sound = "ia/amb/mild/marshAMB", 
	-- wintersound = "ia/amb/wet/marshAMB", 
	-- springsound = "ia/amb/green/marshAMB", 
	-- summersound = "ia/amb/dry/marshAMB", 
	-- rainsound = "ia/amb/rain/marshAMB", 
	-- hurricanesound = "ia/amb/hurricane/marshAMB",
-- }
AMBIENT_SOUNDS[ GROUND.MAGMAFIELD ] = {
	sound = "ia/amb/mild/rockyAMB", 
	wintersound = "ia/amb/wet/rockyAMB", 
	springsound = "ia/amb/green/rockyAMB", 
	summersound = "ia/amb/dry/rockyAMB", 
	rainsound = "ia/amb/rain/rockyAMB", 
	hurricanesound = "ia/amb/hurricane/rockyAMB",
}
AMBIENT_SOUNDS[ GROUND.TIDALMARSH ] = {
	sound = "ia/amb/mild/marshAMB", 
	wintersound = "ia/amb/wet/marshAMB", 
	springsound = "ia/amb/green/marshAMB", 
	summersound = "ia/amb/dry/marshAMB", 
	rainsound = "ia/amb/rain/marshAMB", 
	hurricanesound = "ia/amb/hurricane/marshAMB",
}
AMBIENT_SOUNDS[ GROUND.MEADOW ] = {
	sound = "ia/amb/mild/grasslandAMB", 
	wintersound = "ia/amb/wet/grasslandAMB", 
	springsound = "ia/amb/green/grasslandAMB", 
	summersound = "ia/amb/dry/grasslandAMB", 
	rainsound = "ia/amb/rain/grasslandAMB", 
	hurricanesound = "ia/amb/hurricane/grasslandAMB",
}
AMBIENT_SOUNDS[ GROUND.OCEAN_SHALLOW ] = {
	sound = "ia/amb/mild/ocean_shallow", 
	wintersound = "ia/amb/wet/ocean_shallowAMB", 
	springsound = "ia/amb/green/ocean_shallowAMB", 
	summersound = "ia/amb/dry/ocean_shallow", 
	rainsound = "ia/amb/rain/ocean_shallowAMB", 
	hurricanesound = "ia/amb/hurricane/ocean_shallowAMB",
}
AMBIENT_SOUNDS[ GROUND.OCEAN_MEDIUM ] = {
	sound = "ia/amb/mild/ocean_shallow", 
	wintersound = "ia/amb/wet/ocean_shallowAMB", 
	springsound = "ia/amb/green/ocean_shallowAMB", 
	summersound = "ia/amb/dry/ocean_shallow", 
	rainsound = "ia/amb/rain/ocean_shallowAMB", 
	hurricanesound = "ia/amb/hurricane/ocean_shallowAMB",
}
AMBIENT_SOUNDS[ GROUND.OCEAN_DEEP ] = {
	sound = "ia/amb/mild/ocean_deep", 
	wintersound = "ia/amb/wet/ocean_deepAMB", 
	springsound = "ia/amb/green/ocean_deepAMB", 
	summersound = "ia/amb/dry/ocean_deep", 
	rainsound = "ia/amb/rain/ocean_deepAMB", 
	hurricanesound = "ia/amb/hurricane/ocean_deepAMB",
}
AMBIENT_SOUNDS[ GROUND.OCEAN_SHIPGRAVEYARD ] = {
	sound = "ia/amb/mild/ocean_deep", 
	wintersound = "ia/amb/wet/ocean_deepAMB", 
	springsound = "ia/amb/green/ocean_deepAMB", 
	summersound = "ia/amb/dry/ocean_deep", 
	rainsound = "ia/amb/rain/ocean_deepAMB", 
	hurricanesound = "ia/amb/hurricane/ocean_deepAMB",
}
-- AMBIENT_SOUNDS[ GROUND.OCEAN_SHORE ] = {
	-- sound = "ia/amb/mild/waves", 
	-- wintersound = "ia/amb/wet/waves", 
	-- springsound = "ia/amb/green/waves", 
	-- summersound = "ia/amb/dry/waves", 
	-- rainsound = "ia/amb/rain/waves", 
	-- hurricanesound = "ia/amb/hurricane/waves",
-- }
AMBIENT_SOUNDS[ GROUND.OCEAN_CORAL ] = {
	sound = "ia/amb/mild/coral_reef", 
	wintersound = "ia/amb/wet/coral_reef", 
	springsound = "ia/amb/green/coral_reef", 
	summersound = "ia/amb/dry/coral_reef", 
	rainsound = "ia/amb/rain/coral_reef", 
	hurricanesound = "ia/amb/hurricane/coral_reef",
}
AMBIENT_SOUNDS[ GROUND.MANGROVE ] = {
	sound = "ia/amb/mild/mangrove", 
	wintersound = "ia/amb/wet/mangrove", 
	springsound = "ia/amb/green/mangrove", 
	summersound = "ia/amb/dry/mangrove", 
	rainsound = "ia/amb/rain/mangrove", 
	hurricanesound = "ia/amb/hurricane/mangrove",
}
AMBIENT_SOUNDS[ GROUND.RIVER ] = {
	sound = "ia/amb/mild/waves", 
	wintersound = "ia/amb/wet/waves", 
	springsound = "ia/amb/green/waves", 
	summersound = "ia/amb/dry/waves", 
	rainsound = "ia/amb/rain/waves", 
	hurricanesound = "ia/amb/hurricane/waves",
}
AMBIENT_SOUNDS[ GROUND.VOLCANO ] = {
	sound = "ia/amb/volcano/ground_ash", 
	dormantsound = "ia/amb/volcano/dormant", 
	activesound = "ia/amb/volcano/active",
}
AMBIENT_SOUNDS[ GROUND.VOLCANO_ROCK ] = {
	sound = "ia/amb/volcano/ground_ash", 
	dormantsound = "ia/amb/volcano/dormant", 
	activesound = "ia/amb/volcano/active",
}
-- AMBIENT_SOUNDS[ GROUND.VOLCANO_LAVA ] = { --TODO re-enable
	-- sound = "ia/amb/volcano/lava",
-- }
AMBIENT_SOUNDS[ GROUND.ASH ] = {
	sound = "ia/amb/volcano/ground_ash", 
	dormantsound = "ia/amb/volcano/dormant", 
	activesound = "ia/amb/volcano/active",
}

SEASON_SOUND_KEY["mild"] = "sound"
SEASON_SOUND_KEY["wet"] = "wintersound"
SEASON_SOUND_KEY["green"] = "springsound"
SEASON_SOUND_KEY["dry"] = "summersound"


end)
%%+%%postinit/components/areaaware.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function embark(inst)
	if inst.components.areaaware then
		inst.components.areaaware:UpdatePosition(inst.Transform:GetWorldPosition())
	end
end

local _OnRemoveFromEntity
local function OnRemoveFromEntity(self, ...)
	self.inst:RemoveEventCallback("embark", embark)
	return _OnRemoveFromEntity(self, ...)
end

local _UpdatePosition
local function UpdatePosition(self, x, y, z, ...)
	if IsOnWater(x, y, z) then
		--the game doesn't even clear the last room, but ocean has no rooms
		--clear so we don't drag rooms like sandstorm desert along forever
		--Update: as of RoT, the game clears if on RoT water only...
		if self.current_area_data ~= nil then
			self.current_area = -1
			self.current_area_data = nil
			self.inst:PushEvent("changearea")
		end
		return true
	end
	return _UpdatePosition(self, x, y, z, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("areaaware", function(cmp)


_OnRemoveFromEntity = cmp.OnRemoveFromEntity
cmp.OnRemoveFromEntity = OnRemoveFromEntity
_UpdatePosition = cmp.UpdatePosition
cmp.UpdatePosition = UpdatePosition

--Not using this event makes the whole thing a bit less precise,
--sometimes requiring people to sail a bit for the effects to stop.
cmp.inst:ListenForEvent("embark", embark)


end)
%%+%%postinit/components/birdspawner.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("birdspawner", function(cmp)


-- Birds shall not land on water

--local _SpawnBird = self.SpawnBird
--function self:SpawnBird(spawnpoint, ...)
--  if not IsOnWater(spawnpoint:Get()) then
--    _SpawnBird(self, spawnpoint, ...)
--  end
--end

-- local _GetSpawnPoint = self.GetSpawnPoint
-- function self:GetSpawnPoint(pt)
  -- local target = _GetSpawnPoint(self, pt)
  -- if target and not IsOnWater(target:Get()) then
    -- return target
  -- end
-- end

local birdvstile = {
	[GROUND.DIRT] = "toucan",
	[GROUND.ROCKY] = "toucan",
	[GROUND.SAVANNA] = {"parrot","toucan"},
	[GROUND.GRASS] = "parrot",
	[GROUND.FOREST] = {"toucan","parrot"},
	[GROUND.MARSH] = "toucan",

	[GROUND.SNAKESKIN] = {"toucan","parrot"},

	[GROUND.MEADOW] = "toucan",
	[GROUND.BEACH] = "toucan",
	[GROUND.JUNGLE] = "parrot",
	[GROUND.SWAMP] = "toucan",
	-- [GROUND.MANGROVE] = "seagull",
	-- [GROUND.MAGMAFIELD] = "toucan",
	-- [GROUND.TIDALMARSH] = "toucan",
}

local function IsDangerNearby(x, y, z)
  local ents = TheSim:FindEntities(x, y, z, 8, { "scarytoprey" })
  return next(ents) ~= nil
end

local SpawnBirdOld = cmp.SpawnBird

local RelevantSpawnBird = function(self, bird_prefab, spawnpoint, ignorebait)
  local isonwater = IsOnWater(spawnpoint:Get())
  
  local bird = SpawnPrefab(bird_prefab)
  if math.random() < .5 then
    bird.Transform:SetRotation(180)
  end
  if bird:HasTag("bird") then
    spawnpoint.y = 15
  end 
  
  if bird.components.eater and not ignorebait then
    local bait = TheSim:FindEntities(spawnpoint.x, 0, spawnpoint.z, 15)
    for k, v in pairs(bait) do
      local x, y, z = v.Transform:GetWorldPosition()
      if bird.components.eater:CanEat(v) and
      v.components.bait and
      not (v.components.inventoryitem and v.components.inventoryitem:IsHeld()) and
      not IsDangerNearby(x, y, z) and
	  (isonwater or not IsOnWater(x,y,z)) then --do not spawn land birds on water
        spawnpoint.x, spawnpoint.z = x, z
        bird.bufferedaction = BufferedAction(bird, v, ACTIONS.EAT)
        break
      elseif v.components.trap and
      v.components.trap.isset and
      (not v.components.trap.targettag or bird:HasTag(v.components.trap.targettag)) and
      not v.components.trap.issprung and
      math.random() < TUNING.BIRD_TRAP_CHANCE and
      not IsDangerNearby(x, y, z) and
	  (isonwater or not IsOnWater(x,y,z)) then
        spawnpoint.x, spawnpoint.z = x, z
        break
      end
    end
  end

  bird.Physics:Teleport(spawnpoint:Get())

  return bird
end

function cmp:SpawnBird(spawnpoint, ignorebait)
  local tile = TheWorld.Map:GetTileAtPoint(spawnpoint:Get())
  local bird_prefab = nil

  if IsOnWater(spawnpoint:Get()) then
	if math.random() < TUNING.CORMORANT_CHANCE then
		bird_prefab = "cormorant"
	else
		bird_prefab = "seagull"
	end

  elseif IsInIAClimate(spawnpoint) then
    if tile == GROUND.BEACH and TheWorld.state.iswinter then
      bird_prefab = "seagull"

    elseif birdvstile[tile] ~= nil then
      if type(birdvstile[tile]) == "table" then
        bird_prefab = GetRandomItem(birdvstile[tile])
      else
        bird_prefab = birdvstile[tile]
      end

      if bird_prefab == "parrot" and math.random() < TUNING.PARROT_PIRATE_CHANCE then
        bird_prefab = "parrot_pirate"
      end

    else
      return --SW explicitly does not spawn birds on undefined turfs
    end

  else
    return SpawnBirdOld(self, spawnpoint, ignorebait)
  end

  return RelevantSpawnBird(self, bird_prefab, spawnpoint, ignorebait)
end


end)
%%+%%postinit/components/builder.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("builder", function(cmp)


local function onjellybrainhat(self, jellybrainhat)
    self.inst.replica.builder:SetIsJellyBrainHat(jellybrainhat)
end

addsetter(cmp, "jellybrainhat", onjellybrainhat)

cmp.jellybrainhat = false

--Zarklord: blindly replace this function, since idk what else to do...
function cmp:MakeRecipeAtPoint(recipe, pt, rot, skin)
    if recipe.placer ~= nil and
        self:KnowsRecipe(recipe.name) and
        self:IsBuildBuffered(recipe.name) and
        TheWorld.Map:CanDeployRecipeAtPoint(pt, recipe, rot, self.inst) then
        self:MakeRecipe(recipe, pt, rot, skin)
    end
end

local _KnowsRecipe = cmp.KnowsRecipe
function cmp:KnowsRecipe(recname, ...)
    local knows = _KnowsRecipe(self, recname, ...)
    if not knows and self.jellybrainhat then
        local recipe = GetValidRecipe(recname)
        if recipe == nil then
            return false
        end
        local valid_tech = true
        for techname, level in pairs(recipe.level) do
            if level ~= 0 and (TECH.LOST[techname] or 0) == 0 then
                valid_tech = false
                break
            end
        end
        for i, v in ipairs(recipe.tech_ingredients) do
            if not self:HasTechIngredient(v) then
                valid_tech = false
                break
            end
        end
        knows = valid_tech and (recipe.builder_tag == nil or self.inst:HasTag(recipe.builder_tag))
    end
    return knows
end

local _BufferBuild = cmp.BufferBuild
function cmp:BufferBuild(recname, ...)
    local recipe = GetValidRecipe(recname)
    local shouldevent = recipe ~= nil and recipe.placer ~= nil and not self:IsBuildBuffered(recname) and self:CanBuild(recname)
    _BufferBuild(self, recname, ...)
    if shouldevent then
        self.inst:PushEvent("bufferbuild", {recipe = recipe})
    end
end

local _isloading = false

local _AddRecipe = cmp.AddRecipe
function cmp:AddRecipe(recname, ...)
    if not self.jellybrainhat or _isloading then
        return _AddRecipe(self, recname, ...)
    end
    return
end

local _OnLoad = cmp.OnLoad
function cmp:OnLoad(data, ...)
    _isloading = true
    _OnLoad(self, data, ...)
    _isloading = false
end

local _OnUpdate = cmp.OnUpdate
function cmp:OnUpdate(dt, ...)
    _OnUpdate(self, dt, ...)
    self:EvaluateAutoFixers()
end

function cmp:EvaluateAutoFixers()
    local pos = self.inst:GetPosition()
    local ents = TheSim:FindEntities(pos.x, pos.y, pos.z, TUNING.RESEARCH_MACHINE_DIST, { "autofixer" }, self.exclude_tags)

    local old_fixer = self.current_fixer
    self.current_fixer = nil

    local fixer_active = false
    for k, v in pairs(ents) do
        if v.components.autofixer then
            if not fixer_active and v.components.autofixer:CanAutoFixUser(self.inst) then
                --activate the first machine in the list. This will be the one you're closest to.
                v.components.autofixer:TurnOn(self.inst)
                fixer_active = true
                self.current_fixer = v

            else
                --you've already activated a machine. Turn all the other machines off.
                v.components.autofixer:TurnOff(self.inst)
            end
        end
    end

    if old_fixer ~= nil and
        old_fixer ~= self.current_fixer and
        old_fixer.components.autofixer ~= nil and
        old_fixer.entity:IsValid() then
        old_fixer.components.autofixer:TurnOff(self.inst)
    end
end

-- ignore flooded prototypers
table.insert(cmp.exclude_tags, "flooded")


end)
%%+%%postinit/components/builder_replica.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

--Zarklord: blindly replace this function, since idk what else to do...
local function CanBuildAtPoint(self, pt, recipe, rot)
    return TheWorld.Map:CanDeployRecipeAtPoint(pt, recipe, rot, self.inst)
end

local function SetIsJellyBrainHat(self, isjellybrainhat)
    if self.classified ~= nil then
        self.classified.isjellybrainhat:set(isjellybrainhat)
    end
end

local _KnowsRecipe
local function KnowsRecipe(self, recipename, ...)
    if self.inst.components.builder ~= nil then
        return _KnowsRecipe(self, recipename, ...)
    elseif self.classified ~= nil then
        local knows = _KnowsRecipe(self, recipename, ...)
        if not knows and self.classified.isjellybrainhat:value() then
            local recipe = GetValidRecipe(recipename)
            if recipe ~= nil then
                local valid_tech = true
                for techname, level in pairs(recipe.level) do
                    if level ~= 0 and (TECH.LOST[techname] or 0) == 0 then
                        valid_tech = false
                        break
                    end
                end
                for i, v in ipairs(recipe.tech_ingredients) do
                    if not self:HasTechIngredient(v) then
                        valid_tech = false
                        break
                    end
                end
                knows = valid_tech and (recipe.builder_tag == nil or self.inst:HasTag(recipe.builder_tag))
            end
        end
        return knows
    end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("components/builder_replica", function(cmp)


cmp.CanBuildAtPoint = CanBuildAtPoint
cmp.SetIsJellyBrainHat = SetIsJellyBrainHat
_KnowsRecipe = cmp.KnowsRecipe
cmp.KnowsRecipe = KnowsRecipe


end)
%%+%%postinit/components/burnable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _SpawnFX
local function SpawnFX(self, ...)
    if self.nofx then
        return
    end
    return _SpawnFX(self, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("burnable", function(cmp)


_SpawnFX = cmp.SpawnFX
cmp.SpawnFX = SpawnFX


end)
%%+%%postinit/components/childspawner.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _DoSpawnChild
local function DoSpawnChild(self, target, prefab, radius, ...)
    if self.inst.prefab == "spiderden" and (prefab == "spider_warrior" or self.childname == "spider_warrior") and IsInIAClimate(self.inst) then
        local _childname = rawget(self, "childname")
        self.childname = "tropical_spider_warrior"
        local child = _DoSpawnChild(self, target, "tropical_spider_warrior", radius, ...)
        self.childname = _childname
        return child
    end
    return _DoSpawnChild(self, target, prefab, radius, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("childspawner", function(cmp)


_DoSpawnChild = cmp.DoSpawnChild
cmp.DoSpawnChild = DoSpawnChild


end)
%%+%%postinit/components/colourcube.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("colourcube", function(cmp)


local OnOverrideCCPhaseFn
-- local OnPlayerActivated_old
for i, v in ipairs(cmp.inst.event_listening["playeractivated"][TheWorld]) do
	OnOverrideCCPhaseFn = UpvalueHacker.GetUpvalue(v, "OnOverrideCCPhaseFn")
	if OnOverrideCCPhaseFn then
		-- OnPlayerActivated_old = v
		break
	end
end
if not OnOverrideCCPhaseFn then return end

local OnPlayerActivated_old = UpvalueHacker.GetUpvalue(OnOverrideCCPhaseFn, "OnPlayerActivated")
local UpdateAmbientCCTable_old = UpvalueHacker.GetUpvalue(OnOverrideCCPhaseFn, "UpdateAmbientCCTable")
-- local Blend_old = UpvalueHacker.GetUpvalue(UpdateAmbientCCTable_old, "Blend")
local SEASON_COLOURCUBES_old = UpvalueHacker.GetUpvalue(UpdateAmbientCCTable_old, "SEASON_COLOURCUBES")

local SEASON_COLOURCUBES_IA = {
	autumn = {	
		day = resolvefilepath("images/colour_cubes/sw_mild_day_cc.tex"),
		dusk = resolvefilepath("images/colour_cubes/SW_mild_dusk_cc.tex"),
		night = resolvefilepath("images/colour_cubes/SW_mild_dusk_cc.tex"),
		full_moon = resolvefilepath("images/colour_cubes/purple_moon_cc.tex"),
	},
	winter = {
		day = resolvefilepath("images/colour_cubes/SW_wet_day_cc.tex"),
		dusk = resolvefilepath("images/colour_cubes/SW_wet_dusk_cc.tex"),
		night = resolvefilepath("images/colour_cubes/SW_wet_dusk_cc.tex"),
		full_moon = resolvefilepath("images/colour_cubes/purple_moon_cc.tex"),
	},
	spring = {
		day = resolvefilepath("images/colour_cubes/sw_green_day_cc.tex"),
		dusk = resolvefilepath("images/colour_cubes/sw_green_dusk_cc.tex"),
		night = resolvefilepath("images/colour_cubes/sw_green_dusk_cc.tex"),
		full_moon = resolvefilepath("images/colour_cubes/purple_moon_cc.tex"),
	},
	summer = {
		day = resolvefilepath("images/colour_cubes/SW_dry_day_cc.tex"),
		dusk = resolvefilepath("images/colour_cubes/SW_dry_dusk_cc.tex"),
		night = resolvefilepath("images/colour_cubes/SW_dry_dusk_cc.tex"),
		full_moon = resolvefilepath("images/colour_cubes/purple_moon_cc.tex"),
	},
}

local _activatedplayer
local _showsIAcc = false
local function UpdateAmbientCCTable(blendtime)
	
	local climate = GetClimate(_activatedplayer) --Shouldn't this be IsInIAClimate? -Z
    if climate == CLIMATE_IDS.island then
		if not _showsIAcc then
			_showsIAcc = true
			UpvalueHacker.SetUpvalue(UpdateAmbientCCTable_old, SEASON_COLOURCUBES_IA, "SEASON_COLOURCUBES")
		end
	elseif climate == CLIMATE_IDS.forest and _showsIAcc then
		_showsIAcc = false
		UpvalueHacker.SetUpvalue(UpdateAmbientCCTable_old, SEASON_COLOURCUBES_old, "SEASON_COLOURCUBES")
	end
	
	return UpdateAmbientCCTable_old(blendtime)
end

UpvalueHacker.SetUpvalue(OnOverrideCCPhaseFn, UpdateAmbientCCTable, "UpdateAmbientCCTable")

local function onClimateDirty()
	UpdateAmbientCCTable(10)
end
cmp.inst:ListenForEvent("playeractivated", function(src, player)
	if player and _activatedplayer ~= player then
		player:ListenForEvent("climatechange", onClimateDirty)
		player:DoTaskInTime(0, function() UpdateAmbientCCTable(.01) end) --initialise
	end
	_activatedplayer = player
end)
cmp.inst:ListenForEvent("playerdeactivated", function(src, player)
	if player then
		player:RemoveEventCallback("climatechange", onClimateDirty)
		if _activatedplayer == player then
			_activatedplayer = nil
		end
	end
end)


end)
%%+%%postinit/components/combat.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onnotags(self, notags)
    self.inst.replica.combat.notags = notags
end

local function AddDamageModifier(self, key, mod)
    self.attack_damage_modifiers[key] = mod
end
local function RemoveDamageModifier(self, key)
    self.attack_damage_modifiers[key] = nil
end
local function GetDamageModifier(self)
    local mod = 1
    for k,v in pairs(self.attack_damage_modifiers) do
        mod = mod + v
    end
    return mod
end

local function AddPeriodModifier(self, key, mod)
    self.attack_period_modifiers[key] = { mod = mod, effective = self.min_attack_period * mod }
    self:SetAttackPeriod(self.min_attack_period * (1+mod))
end
local function RemovePeriodModifier(self, key)
    if not self.attack_damage_modifiers[key] then return end
    self:SetAttackPeriod(self.min_attack_period - self.attack_period_modifiers[key].effective)
    self.attack_period_modifiers[key] = nil
end

local function GetIsAttackPoison(self, attacker)
    local poisonAttack = false 
    local poisonGasAttack = false 

    if self.inst:HasTag("poisonable") and attacker then 
        if (attacker.components.combat and attacker.components.combat.poisonous) or 
        ((attacker.components.poisonable and attacker.components.poisonable:IsPoisoned() and attacker.components.poisonable.transfer_poison_on_attack) 
        and (attacker.components.combat and not attacker.components.combat:GetWeapon())) then

            poisonAttack = true 

            if (attacker.components.combat and attacker.components.combat.poisonous and attacker.components.combat.gasattack) then 
                poisonGasAttack = true 
            end 
        end 
    end   

    return poisonAttack, poisonGasAttack
end


local _GetAttacked
local function GetAttacked(self, attacker, damage, weapon, stimuli, ...)
    local poisonAttack, poisonGasAttack = self:GetIsAttackPoison(attacker)

    if poisonGasAttack and self.inst.components.poisonable then 
        self.inst.components.poisonable:Poison(true)
        return
    end

    local blocked = false

    if TUNING.DO_SEA_DAMAGE_TO_BOAT and damage and (self.inst.components.sailor and self.inst.components.sailor.boat and self.inst.components.sailor.boat.components.boathealth) then
        local boathealth = self.inst.components.sailor.boat.components.boathealth
        if damage > 0 and not boathealth:IsInvincible() then
            boathealth:DoDelta(-damage, "combat", attacker and attacker.prefab or "NIL")
        else
            blocked = true
        end

        if not blocked then
            self.inst:PushEvent("boatattacked", {attacker = attacker, damage = damage, weapon = weapon, stimuli = stimuli, redirected=false})

            if self.onhitfn then
                self.onhitfn(self.inst, attacker, damage)
            end

            if attacker then
                attacker:PushEvent("onhitother", {target = self.inst, damage = damage, stimuli = stimuli, redirected=false})
                if attacker.components.combat and attacker.components.combat.onhitotherfn then
                    attacker.components.combat.onhitotherfn(attacker, self.inst, damage, stimuli)
                end
            end
        else
            self.inst:PushEvent("blocked", {attacker = attacker})
        end

        return not blocked
    end

    local notblocked = _GetAttacked(self, attacker, damage, weapon, stimuli, ...)

    if notblocked and attacker and poisonAttack and self.inst.components and self.inst.components.poisonable then
        self.inst.components.poisonable:Poison()
    end
end

local _CalcDamage
local function CalcDamage(self, target, weapon, multiplier, ...)
    local dmg = _CalcDamage(self, target, weapon, multiplier, ...)
    local bonus = self.damagebonus or 0 --not affected by multipliers

    return (dmg-bonus) * self:GetDamageModifier() + bonus
end

local _CanAttack
local function CanAttack(self, target, ...)
    local canattack, idk = _CanAttack(self, target, ...)
    if canattack then
        for i, v in ipairs(self.notags or {}) do
            if target:HasTag(v) then
                return false, nil
            end
        end
        return canattack, idk
    end
    return canattack, idk
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("combat", function(cmp)


cmp.poisonstrength = 1

cmp.poisonous = nil
cmp.gasattack = nil

cmp.attack_damage_modifiers = {} -- % modifiers on cmp:CalcDamage()
cmp.attack_period_modifiers = {} -- % modifiers on cmp.min_attack_period

addsetter(cmp, "notags", onnotags)

cmp.AddDamageModifier = AddDamageModifier
cmp.RemoveDamageModifier = RemoveDamageModifier
cmp.GetDamageModifier = GetDamageModifier
cmp.AddPeriodModifier = AddPeriodModifier
cmp.RemovePeriodModifier = RemovePeriodModifier
cmp.GetIsAttackPoison = GetIsAttackPoison

_GetAttacked = cmp.GetAttacked
cmp.GetAttacked = GetAttacked

_CalcDamage = cmp.CalcDamage
cmp.CalcDamage = CalcDamage

_CanAttack = cmp.CanAttack
cmp.CanAttack = CanAttack


end)
%%+%%postinit/components/combat_replica.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _IsValidTarget
local function IsValidTarget(self, target, ...)
    local isvalidtarget = _IsValidTarget(self, target, ...)
    if isvalidtarget then
        for i, v in ipairs(self.notags or {}) do
            if target:HasTag(v) then
                return false
            end
        end
        return isvalidtarget
    end
    return false
end

local _CanAttack
local function CanAttack(self, target, ...)
    local canattack, idk = _CanAttack(self, target, ...)
    if canattack then
        for i, v in ipairs(self.notags or {}) do
            if target:HasTag(v) then
                return false, nil
            end
        end
        return canattack, idk
    end
    return canattack, idk
end

local _CanBeAttacked
local function CanBeAttacked(self, attacker, ...)
    if self.canbeattackedfn and not self.canbeattackedfn(self.inst, attacker) then
        return false
    end
    return _CanBeAttacked(self, attacker, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("components/combat_replica", function(cmp)


_IsValidTarget = cmp.IsValidTarget
cmp.IsValidTarget = IsValidTarget
_CanAttack = cmp.CanAttack
cmp.CanAttack = CanAttack
_CanBeAttacked = cmp.CanBeAttacked
cmp.CanBeAttacked = CanBeAttacked


end)
%%+%%postinit/components/cookable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local Cook_old
local function Cook(self, ...)
    local prod = Cook_old(self, ...)

	if prod.components.visualvariant then
		prod.components.visualvariant:CopyOf(self.inst)
	end

	return prod
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("cookable", function(cmp)


Cook_old = cmp.Cook
cmp.Cook = Cook


end)
%%+%%postinit/components/crop.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local DAYLIGHT_SEARCH_RANGE = 30

local Fertilize_old
local function Fertilize(self, fertilizer, doer, ...)
    if IsInIAClimate(self.inst) then
		if self.inst.components.burnable ~= nil then
			self.inst.components.burnable:StopSmoldering()
		end

		if not (TheWorld.state.iswinter and TheWorld.state.islandtemperature <= 0) then --This is one of two lines we needed to change for temperature
			if fertilizer.components.fertilizer ~= nil then
				if doer ~= nil and
					doer.SoundEmitter ~= nil and
					fertilizer.components.fertilizer.fertilize_sound ~= nil then
					doer.SoundEmitter:PlaySound(fertilizer.components.fertilizer.fertilize_sound)
				end
				self.growthpercent = self.growthpercent + fertilizer.components.fertilizer.fertilizervalue * self.rate
			end
			self.inst.AnimState:SetPercent("grow", self.growthpercent)
			if self.growthpercent >= 1 then
				self.inst.AnimState:PlayAnimation("grow_pst")
				self:Mature()
				self.task:Cancel()
				self.task = nil
			end
			if fertilizer.components.finiteuses ~= nil then
				fertilizer.components.finiteuses:Use()
			else
				fertilizer.components.stackable:Get():Remove()
			end
			return true
		end
	else
		return Fertilize_old( self, fertilizer, doer, ...)
	end
end

local DoGrow_old
local function DoGrow(self, dt, nowither, ...)
    if IsInIAClimate(self.inst) then
		if not self.inst:HasTag("withered") then 
			self.inst.AnimState:SetPercent("grow", self.growthpercent)

			local shouldgrow = nowither or not TheWorld.state.isnight
			if not shouldgrow then
				local x,y,z = self.inst.Transform:GetWorldPosition()
				local ents = TheSim:FindEntities(x,0,z, DAYLIGHT_SEARCH_RANGE, { "daylight", "lightsource" })
				for i,v in ipairs(ents) do
					local lightrad = v.Light:GetCalculatedRadius() * .7
					if v:GetDistanceSqToPoint(x,y,z) < lightrad * lightrad then
						shouldgrow = true
						break
					end
				end
			end
			if shouldgrow then
				local temp_rate =
					(TheWorld.state.islandtemperature < TUNING.MIN_CROP_GROW_TEMP and 0) or --This is one of two lines we needed to change for temperature
					(TheWorld.state.israining and 1 + TUNING.CROP_RAIN_BONUS * TheWorld.state.precipitationrate) or
					(TheWorld.state.isspring and 1 + TUNING.SPRING_GROWTH_MODIFIER / 3) or
					1
				self.growthpercent = self.growthpercent + dt * self.rate * temp_rate
				self.cantgrowtime = 0
			else
				self.cantgrowtime = self.cantgrowtime + dt
				if self.cantgrowtime > TUNING.CROP_DARK_WITHER_TIME
					and self.inst.components.witherable then
					self.inst.components.witherable:ForceWither()
				end
			end

			if self.growthpercent >= 1 then
				self.inst.AnimState:PlayAnimation("grow_pst")
				self:Mature()
				if self.task ~= nil then
					self.task:Cancel()
					self.task = nil
				end
			end
		end
	else
		return DoGrow_old( self, dt, nowither, ...)
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("crop", function(cmp)


Fertilize_old = cmp.Fertilize
cmp.Fertilize = Fertilize

DoGrow_old = cmp.DoGrow
cmp.DoGrow = DoGrow



end)
%%+%%postinit/components/deployable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function ondeployatrange(self, deployatrange)
    if self.inst.replica.inventoryitem ~= nil and self.inst.replica.inventoryitem.classified ~= nil then
        self.inst.replica.inventoryitem.classified.deployatrange:set(deployatrange)
    end
end

local function oncandeployonland(self, candeployonland)
    if self.inst.replica.inventoryitem ~= nil and self.inst.replica.inventoryitem.classified ~= nil then
        self.inst.replica.inventoryitem.classified.candeployonland:set(candeployonland)
    end
end

local function oncandeployonshallowocean(self, candeployonshallowocean)
    if self.inst.replica.inventoryitem ~= nil and self.inst.replica.inventoryitem.classified ~= nil then
        self.inst.replica.inventoryitem.classified.candeployonshallowocean:set(candeployonshallowocean)
    end
end

local function oncandeployonbuildableocean(self, candeployonbuildableocean)
    if self.inst.replica.inventoryitem ~= nil and self.inst.replica.inventoryitem.classified ~= nil then
        self.inst.replica.inventoryitem.classified.candeployonbuildableocean:set(candeployonbuildableocean)
    end
end

local function oncandeployonunbuildableocean(self, candeployonunbuildableocean)
    if self.inst.replica.inventoryitem ~= nil and self.inst.replica.inventoryitem.classified ~= nil then
        self.inst.replica.inventoryitem.classified.candeployonunbuildableocean:set(candeployonunbuildableocean)
    end
end

local function SetQuantizeFunction(self, fn) 
    self.quantizefn = fn 
end 

local function GetQuantizedPosition(self, pt)
    if self.quantizefn then 
        return self.quantizefn(pt)
    end 
    return pt
end

local function DeployAtRange(self)
    return self.deployatrange
end

local _CanDeploy
local function CanDeploy(self, pt, mouseover, deployer, ...)
	local result = _CanDeploy(self, pt, mouseover, deployer, ...)

	if result then
		local tile = GetVisualTileType(pt.x, pt.y, pt.z, 0.375)
		local tileinfo = GetTileInfo(tile)
        local isbuildable, island, iswater = tileinfo.buildable or false, tileinfo.land ~= false, tileinfo.water or false

        if (self.candeployonland and island) or
        (self.candeployonshallowocean and tile == GROUND.OCEAN_SHALLOW) or
        (iswater and
        ((self.candeployonbuildableocean and isbuildable) or
        (self.candeployonunbuildableocean and not isbuildable))) then
			return result
		else
			return false
		end
	end

	return result
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("deployable", function(cmp)


cmp.quantizefn = nil
cmp.SetQuantizeFunction = SetQuantizeFunction
cmp.GetQuantizedPosition = GetQuantizedPosition
cmp.DeployAtRange = DeployAtRange

_CanDeploy = cmp.CanDeploy
cmp.CanDeploy = CanDeploy

addsetter(cmp, "deployatrange", ondeployatrange)
addsetter(cmp, "candeployonland", oncandeployonland)
addsetter(cmp, "candeployonshallowocean", oncandeployonshallowocean)
addsetter(cmp, "candeployonbuildableocean", oncandeployonbuildableocean)
addsetter(cmp, "candeployonunbuildableocean", oncandeployonunbuildableocean)

cmp.deployatrange = false
cmp.candeployonland = true
cmp.candeployonshallowocean = false
cmp.candeployonbuildableocean = false
cmp.candeployonunbuildableocean = false


end)
%%+%%postinit/components/drownable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local ShouldDrown
local function ShouldDrown_IA(self, ...)
	return ShouldDrown(self, ...)
		and not (self.inst.components.sailor and self.inst.components.sailor:IsSailing())
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("drownable", function(cmp)


ShouldDrown = cmp.ShouldDrown
cmp.ShouldDrown = ShouldDrown_IA


end)
%%+%%postinit/components/dryer.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function OnIsRaining(self, israining)
    if israining then
        self:Pause()
    else
        self:Resume()
    end
end

local StartWatchingRain
local function StartWatchingRain_IA(self, ...)
	if IsInIAClimate(self.inst) then
		if not self.watchingrain then
			self.watchingrain = true
			self:WatchWorldState("islandisraining", OnIsRaining)
		end
	else
		return StartWatchingRain(self, ...)
	end
end

local StopWatchingRain
local function StopWatchingRain_IA(self, ...)
	self:StopWatchingWorldState("islandisraining", OnIsRaining)
	return StopWatchingRain(self, ...)
end

local StartDrying
local function StartDrying_IA(self, ...)
	local ret = StartDrying(self, ...)

    if not self.task and IsInIAClimate(self.inst) and not (TheWorld.state.islandisraining or self.protectedfromrain) then
        self:Resume()
    end
	
	return ret
end

local LongUpdate
local function LongUpdate_IA(self, ...)
	local ret = LongUpdate(self, ...)

    if self:IsDrying() and not self.task
	and IsInIAClimate(self.inst) and not (TheWorld.state.islandisraining or self.protectedfromrain) then
		self:Resume()
	end
	
	return ret
end

local OnLoad
local function OnLoad_IA(self, ...)
	local ret = OnLoad(self, ...)

    if self:IsDrying() and not self.task
	and IsInIAClimate(self.inst) and not (TheWorld.state.islandisraining or self.protectedfromrain) then
		self:Resume()
	end
	
	return ret
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("dryer", function(cmp)


-- if cmp.inst and cmp.inst.worldstatewatching and cmp.inst.worldstatewatching.israining then
	-- for i, v in ipairs(cmp.inst.worldstatewatching.israining) do

--only wrap the upvalue once, so we don't add our code twice -M
if not StartWatchingRain then
	StartWatchingRain = UpvalueHacker.GetUpvalue(cmp.LongUpdate, "StartWatchingRain")
	if StartWatchingRain then
		UpvalueHacker.SetUpvalue(cmp.LongUpdate, StartWatchingRain_IA, "StartWatchingRain")
	else
		StartWatchingRain = UpvalueHacker.GetUpvalue(cmp.OnLoad, "StartWatchingRain")
		if StartWatchingRain then
			UpvalueHacker.SetUpvalue(cmp.OnLoad, StartWatchingRain_IA, "StartWatchingRain")
		end
	end
end

--failsafe failsafe failsafe failsafe -M
if not StopWatchingRain then
	StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.OnRemoveFromEntity, "StopWatchingRain")
	if StopWatchingRain then
		UpvalueHacker.SetUpvalue(cmp.OnRemoveFromEntity, StopWatchingRain_IA, "StopWatchingRain")
	else
		StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.OnLoad, "StopWatchingRain")
		if StopWatchingRain then
			UpvalueHacker.SetUpvalue(cmp.OnLoad, StopWatchingRain_IA, "StopWatchingRain")
		else
			StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.StartDrying, "StopWatchingRain")
			if StopWatchingRain then
				UpvalueHacker.SetUpvalue(cmp.StartDrying, StopWatchingRain_IA, "StopWatchingRain")
			else
				StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.StopDrying, "StopWatchingRain")
				if StopWatchingRain then
					UpvalueHacker.SetUpvalue(cmp.StopDrying, StopWatchingRain_IA, "StopWatchingRain")
				else
					StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.DropItem, "StopWatchingRain")
					if StopWatchingRain then
						UpvalueHacker.SetUpvalue(cmp.DropItem, StopWatchingRain_IA, "StopWatchingRain")
					else
						StopWatchingRain = UpvalueHacker.GetUpvalue(cmp.Harvest, "StopWatchingRain")
						if StopWatchingRain then
							UpvalueHacker.SetUpvalue(cmp.Harvest, StopWatchingRain_IA, "StopWatchingRain")
						end
					end
				end
			end
		end
	end
end

StartDrying = cmp.StartDrying
cmp.StartDrying = StartDrying_IA
LongUpdate = cmp.LongUpdate
cmp.LongUpdate = LongUpdate_IA
OnLoad = cmp.OnLoad
cmp.OnLoad = OnLoad_IA

end)
%%+%%postinit/components/dynamicmusic.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("dynamicmusic", function(cmp)


if IA_CONFIG.dynamicmusic == false then return end


local StartPlayerListeners
for i, v in ipairs(cmp.inst.event_listening["playeractivated"][TheWorld]) do
	if UpvalueHacker.GetUpvalue(v, "StartPlayerListeners") then
		StartPlayerListeners = UpvalueHacker.GetUpvalue(v, "StartPlayerListeners")
		break
	end
end
if not StartPlayerListeners then return end

local StartBusy = UpvalueHacker.GetUpvalue(StartPlayerListeners, "StartBusy")
if not StartBusy then return end


local _playsIAmusic = false

local soundAlias = {
	--busy
	["dontstarve/music/music_work"] = "ia/music/music_work_season_1",
	["dontstarve/music/music_work_winter"] = "ia/music/music_work_season_2",
	["dontstarve_DLC001/music/music_work_spring"] = "ia/music/music_work_season_3",
	["dontstarve_DLC001/music/music_work_summer"] = "ia/music/music_work_season_4",
	--combat
	["dontstarve/music/music_danger"] = "ia/music/music_danger_season_1",
	["dontstarve/music/music_danger_winter"] = "ia/music/music_danger_season_2",
	["dontstarve_DLC001/music/music_danger_spring"] = "ia/music/music_danger_season_3",
	["dontstarve_DLC001/music/music_danger_summer"] = "ia/music/music_danger_season_4",
	--epic
	["dontstarve/music/music_epicfight"] = "ia/music/music_epicfight_season_1",
	["dontstarve/music/music_epicfight_winter"] = "ia/music/music_epicfight_season_2",
	["dontstarve_DLC001/music/music_epicfight_spring"] = "ia/music/music_epicfight_season_3",
	["dontstarve_DLC001/music/music_epicfight_summer"] = "ia/music/music_epicfight_season_4",
	--stinger
	["dontstarve/music/music_dawn_stinger"] = "ia/music/music_dawn_stinger",
	["dontstarve/music/music_dusk_stinger"] = "ia/music/music_dusk_stinger",
}

cmp.iamusictask = cmp.inst:DoPeriodicTask(1, function()
	if not (ThePlayer and ThePlayer:IsValid()) then return end
	if IsInIAClimate(ThePlayer) then
		if not _playsIAmusic then
			-- print("CHANGETO IA MUSIC")
			for k, v in pairs(soundAlias) do
				SetSoundAlias(k,v)
			end
			
			_playsIAmusic = true
			UpvalueHacker.SetUpvalue(StartBusy, true, "_isbusydirty")
		end
	elseif _playsIAmusic then
		-- print("CHANGETO ANR MUSIC")
		for k, v in pairs(soundAlias) do
			SetSoundAlias(k,nil)
		end
		
		_playsIAmusic = false
		UpvalueHacker.SetUpvalue(StartBusy, true, "_isbusydirty")
	end
end)


--Note: We'd have to edit StartBusy, StartDanger, etc. to shut the sailing songs up,
--We'd have to edit StartPlayerListeners/StopPlayerListeners to set the hooks
--We'd have to copy the _soundemitter and stuff
--Really, I want to stop using UpvalueHacker for this, it doesn't solve problems anymore.
--Overriding the whole component seems as feasible. -M

-- function DynamicMusic:StopPlayingBoating()
    -- self.inst.SoundEmitter:SetParameter( "boating", "intensity", 0 )
    -- self.is_boating = false
-- end

-- function DynamicMusic:StartPlayingBoating(surfing)
	-- local sound = "ia/music/music_".. (surfing and "surfing" or "sailing") .."_".. (TheWorld.state.isday and "day" or "night")
	
	-- if self.inst.SoundEmitter:PlayingSound("boating") and _sailingsound ~= sound then
		-- self:StopPlayingBoating()
	-- end
	
	-- self.inst.SoundEmitter:PlaySound( sound, "boating")
    -- self.inst.SoundEmitter:SetParameter( "boating", "intensity", 0 )
-- end

-- function DynamicMusic:OnStartBoating()
    -- if not self.enabled then return end

    -- self:StartPlayingBoating()

    -- if not self.inst.SoundEmitter:PlayingSound("dawn") then
        -- self.boating_timeout = 75
        
        -- if not self.is_boating then
            -- self.is_boating = true
            -- if not self.playing_danger and not self.inst.SoundEmitter:PlayingSound("erupt") then
                -- self:StopPlayingBusy()
                -- self.inst.SoundEmitter:SetParameter( "boating", "intensity", 1 )
            -- end
        -- end
    -- end
-- end

    -- inst:ListenForEvent("mountboat", function(it, data)
        -- if data and data.boat and data.boat.prefab == "surfboard" then
            -- self:OnStartSurfing()
        -- else
            -- self:OnStartBoating()
        -- end
    -- end)
    -- inst:ListenForEvent("dismountboat", function(it, data)
        -- self:StopPlayingBoating()
        -- self:StopPlayingSurfing()
    -- end)


end)
%%+%%postinit/components/eater.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local Eat_old
local function Eat(self, food, feeder, ...)
	-- self.inst:PushEvent("oneatpre", {food=food, feeder=feeder})
	if self.inst.components.foodmemory then
		self.inst.components.foodmemory.foodinst = food
	end
	local ret = Eat_old(self, food, feeder, ...)
	if self.inst.components.foodmemory then
		self.inst.components.foodmemory.foodinst = nil
	end
	return ret
end

local function SetCarnivore(self, human)
    if human then
        self.inst.components.eater:SetDiet({ FOODGROUP.OMNI }, { FOODTYPE.MEAT, FOODTYPE.GOODIES })
    else
        self.inst.components.eater:SetDiet({ FOODTYPE.MEAT }, { FOODTYPE.MEAT })
    end
end

local function SetVegetarian(self, human)
    if human then
        self.inst.components.eater:SetDiet({ FOODGROUP.OMNI }, { FOODTYPE.VEGGIE })
    else
        self.inst.components.eater:SetDiet({ FOODTYPE.VEGGIE }, { FOODTYPE.VEGGIE })
    end
end

local function SetInsectivore(self)
    self.inst.components.eater:SetDiet({ FOODTYPE.INSECT }, { FOODTYPE.INSECT })
end

local function SetBird(self)
    self.inst.components.eater:SetDiet({ FOODTYPE.SEEDS }, { FOODTYPE.SEEDS })
end

local function SetBeaver(self)
    self.inst.components.eater:SetDiet({ FOODTYPE.WOOD }, { FOODTYPE.WOOD })
end

local function SetElemental(self, human)
    if human then
        self.inst.components.eater:SetDiet({ FOODTYPE.MEAT, FOODTYPE.VEGGIE, FOODTYPE.INSECT, FOODTYPE.SEEDS, FOODTYPE.GENERIC, FOODTYPE.ELEMENTAL }, { FOODTYPE.ELEMENTAL })
    else
        self.inst.components.eater:SetDiet({ FOODTYPE.ELEMENTAL }, { FOODTYPE.ELEMENTAL })
    end
end

local function SetOmnivore(self)
    self.inst.components.eater:SetDiet({ FOODGROUP.OMNI }, { FOODGROUP.OMNI })
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("eater", function(cmp)

Eat_old = cmp.Eat
cmp.Eat = Eat

cmp.SetCarnivore = SetCarnivore
cmp.SetVegetarian = SetVegetarian
cmp.SetInsectivore = SetInsectivore
cmp.SetBird = SetBird
cmp.SetBeaver = SetBeaver
cmp.SetElemental = SetElemental
cmp.SetOmnivore = SetOmnivore

end)
%%+%%postinit/components/edible.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _OnEaten
local function OnEaten(self, eater, ...)
    -- Food is an implicit speed booster if it has caffeine
    if self.caffeinedelta ~= 0 and self.caffeineduration ~= 0 and eater and eater.components.locomotor then
        eater.components.locomotor:SetExternalSpeedAdder(eater, "CAFFEINE", self.caffeinedelta, self.caffeineduration)
    end

    -- Other food based speed modifiers
    if self.surferdelta ~= 0 and self.surferduration ~= 0 and eater and eater.components.locomotor then
        eater.components.locomotor:SetExternalSpeedAdder(eater, "SURF", self.surferdelta, self.surferduration)
    end
    if self.autodrydelta ~= 0 and self.autodryduration ~= 0 and eater and eater.components.locomotor then
        eater.components.locomotor:SetExternalSpeedAdder(eater, "AUTODRY", self.autodrydelta, self.autodryduration)
    end

    if self.autocooldelta ~= 0 and eater and eater.components.temperature then
        local current_temp = eater.components.temperature:GetCurrent()
        local new_temp = math.max(current_temp - self.autocooldelta, TUNING.STARTING_TEMP)
        eater.components.temperature:SetTemperature(new_temp)
    end
	
	if self.naughtyvalue > 0 and TheWorld.components.kramped then
		TheWorld.components.kramped:OnNaughtyAction(self.naughtyvalue, eater)
	end

    _OnEaten(self, eater, ...)
end

local function GetNaughtiness(self, eater)
    return self.naughtyvalue
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("edible", function(cmp)


cmp.caffeineduration = 0
cmp.caffeinedelta = 0
cmp.surferduration = 0
cmp.surferdelta = 0
cmp.autodryduration = 0
cmp.autodrydelta = 0
cmp.autocooldelta = 0
cmp.naughtyvalue = 0

_OnEaten = cmp.OnEaten
cmp.OnEaten = OnEaten

cmp.GetNaughtiness = GetNaughtiness


end)
%%+%%postinit/components/equippable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onboatequipslot(self, boatequipslot)
    self.inst.replica.equippable:SetBoatEquipSlot(boatequipslot)
end

local function ontoggled(self, toggled)
    if toggled then
        self.inst:AddTag("toggled")
    else
        self.inst:RemoveTag("toggled")
    end
end

local function ontogglable(self, togglable)
    if togglable then
        self.inst:AddTag("togglable")
    else
        self.inst:RemoveTag("togglable")
    end
end

local function IsPoisonBlocker(self)
    return self.poisonblocker or false
end

local function IsPoisonGasBlocker(self)
    return self.poisongasblocker or false
end

local function ToggleOn(self)
    self.toggled = true 
    if self.toggledonfn then 
        self.toggledonfn(self.inst)
    end 
end

local function ToggleOff(self)
    self.toggled = false 
    if self.toggledofffn then 
        self.toggledofffn(self.inst)
    end 
end  

local function IsToggledOn(self)
    return self.toggled 
end 

local function OnSave(self)
    local data = {}
    data.togglable = self.togglable
    data.toggled = self.toggled
    return data
end   


local function LoadPostPass(self, ents, data)
    if data and data.togglable then 
        self.togglable = data.togglable
        self.toggled = data.toggled
        if self.toggledon then 
            self:ToggleOn()
        else
            self:ToggleOff()
        end 

    end 
end   

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("equippable", function(cmp)


addsetter(cmp, "boatequipslot", onboatequipslot)
addsetter(cmp, "toggled", ontoggled)
addsetter(cmp, "togglable", ontogglable)

cmp.boatequipslot = nil
cmp.toggled = false
cmp.togglable = false
cmp.toggledonfn = nil 
cmp.toggledofffn = nil 

cmp.IsPoisonBlocker = IsPoisonBlocker 
cmp.IsPoisonGasBlocker = IsPoisonGasBlocker 
cmp.ToggleOn = ToggleOn 
cmp.ToggleOff = ToggleOff 
cmp.IsToggledOn = IsToggledOn 
cmp.OnSave = OnSave 
cmp.LoadPostPass = LoadPostPass 


end)
%%+%%postinit/components/equippable_replica.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local EquipSlot = require("equipslotutil")

----------------------------------------------------------------------------------------

local function SetBoatEquipSlot(self, eslot)
    self._boatequipslot:set(EquipSlot.BoatToID(eslot))
end

local function BoatEquipSlot(self)
    return EquipSlot.BoatFromID(self._boatequipslot:value())
end

local _IsEquipped
local function IsEquipped(self, container)
    local isequipped = _IsEquipped(self)
    local isboatequipped = false
    if not self.inst.components.equippable then
        local inventoryitem = self.inst.replica.inventoryitem
        local parent = self.inst.entity:GetParent()
        isboatequipped = inventoryitem ~= nil and inventoryitem:IsHeld() and
            parent and parent:HasTag("boatcontainer") and parent.replica.container:GetItemInBoatSlot(self:BoatEquipSlot()) == self.inst
    end
    return isequipped or isboatequipped
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("components/equippable_replica", function(cmp)


cmp._boatequipslot = EquipSlot.BoatCount() <= 7 and net_tinybyte(cmp.inst.GUID, "equippable._boatequipslot") or net_smallbyte(cmp.inst.GUID, "equippable._boatequipslot")

cmp.SetBoatEquipSlot = SetBoatEquipSlot
cmp.BoatEquipSlot = BoatEquipSlot
_IsEquipped = cmp.IsEquipped
cmp.IsEquipped = IsEquipped


end)%%+%%postinit/components/explosive.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

-- install extra function calls
local function SetOnIgniteFn(self, fn)
	self.onignitefn = fn
end

local OnIgnite_old
local function OnIgnite(self)
	OnIgnite_old(self)
	if self.onignitefn then
		self.onignitefn(self.inst)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("explosive", function(cmp)


if TheWorld.ismastersim then

cmp.SetOnIgniteFn = SetOnIgniteFn

OnIgnite_old = cmp.OnIgnite
cmp.OnIgnite = OnIgnite
	
end


end)
%%+%%postinit/components/fertilizer.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function MakeNormal(self)
    self.inst:RemoveTag("fertilizer_volcanic")
    self.inst:RemoveTag("fertilizer_oceanic")
end

local function MakeVolcanic(self)
    self.inst:AddTag("fertilizer_volcanic")
    self.inst:RemoveTag("fertilizer_oceanic")
end

local function MakeOceanic(self)
    self.inst:RemoveTag("fertilizer_volcanic")
    self.inst:AddTag("fertilizer_oceanic")
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("fertilizer", function(cmp)


cmp.MakeNormal = MakeNormal
cmp.MakeVolcanic = MakeVolcanic
cmp.MakeOceanic = MakeOceanic


end)
%%+%%postinit/components/fishingrod.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

--completely override to get rid of equippable condition
local function OnUpdate(self)
	if self:IsFishing() then
		if not self.fisherman:IsValid()
		or (not self.fisherman.sg:HasStateTag("fishing") and not self.fisherman.sg:HasStateTag("catchfish") )
		or (self.inst.components.equippable and not self.inst.components.equippable.isequipped) then
            self:StopFishing()
		end
	end
end

local _Collect
local function Collect(self)

    if self.caughtfish and self.fisherman and self.fisherman:GetIsOnWater() then 
		--print("bargle, I'm boating!")

        if self.caughtfish.Physics ~= nil then
            self.caughtfish.Physics:SetActive(true)
        end
        self.caughtfish.entity:Show()
        if self.caughtfish.DynamicShadow ~= nil then
            self.caughtfish.DynamicShadow:Enable(true)
        end
		-- print("CAUGHT FISH",self.caughtfish,self.caughtfish.components.inventoryitem)
		self.fisherman.components.inventory:GiveItem(self.caughtfish, nil, self.fisherman:GetPosition())
		
        self.caughtfish.persists = true
        self.inst:PushEvent("fishingcollect", {fish = self.caughtfish} )
        self.fisherman:PushEvent("fishingcollect", {fish = self.caughtfish} )
        self:StopFishing()
    else
		return _Collect(self)
	end
end

local _StartFishing
local function StartFishing(self, target, fisherman, ...)
	_StartFishing(self, target, fisherman, ...)
    if target and target.components.workable
	and target.components.workable:GetWorkAction() == ACTIONS.FISH
	and target.components.workable:CanBeWorked() then
        self.target = target
        self.fisherman = fisherman
        -- self.inst:StartUpdatingComponent(self)
    end
end

local function Retrieve(self)
    local numworks = 1
    if self.fisherman and self.fisherman.components.worker then
        numworks = self.fisherman.components.worker:GetEffectiveness(ACTIONS.FISH)
    end
    if self.target and self.target.components.workable then
        self.target.components.workable:WorkedBy(self.fisherman, numworks)
        self.inst:PushEvent("retrievecollect")
        self.target:PushEvent("retrievecollect")
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("fishingrod", function(cmp)


_StartFishing = cmp.StartFishing
cmp.StartFishing = StartFishing
_Collect = cmp.Collect
cmp.Collect = Collect
cmp.OnUpdate = OnUpdate

cmp.Retrieve = Retrieve


end)
%%+%%postinit/components/floater.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function UpdateAnimations(self, water_anim, land_anim)
    self.wateranim = water_anim or self.wateranim
    self.landanim = land_anim or self.landanim

    if self.showing_effect then
        self:PlayWaterAnim()
    else
        self:PlayLandAnim()
    end
end

local function PlayLandAnim(self)
    local anim = self.landanim
    if anim and type(anim) == "function" then
        anim = self.landanim(self.inst)
    end

	if anim and not self.inst.AnimState:IsCurrentAnimation(anim) then
        -- self.showing_effect = false
        self.inst.AnimState:PlayAnimation(anim, true)
    end

	self.inst.AnimState:SetLayer(LAYER_WORLD)
	self.inst.AnimState:SetSortOrder(0)
    self.inst.AnimState:OverrideSymbol("water_ripple", "ripple_build", "water_ripple")
    self.inst.AnimState:OverrideSymbol("water_shadow", "ripple_build", "water_shadow")
end

local function PlayWaterAnim(self)
    local anim = self.wateranim
    if anim and type(anim) == "function" then
        anim = self.wateranim(self.inst)
    end

	if anim and not self.inst.AnimState:IsCurrentAnimation(anim) then
        -- self.showing_effect = true 
        self.inst.AnimState:PlayAnimation(anim, true)
        self.inst.AnimState:SetTime(math.random())
    end

	self.inst.AnimState:SetLayer(LAYER_WORLD_BACKGROUND)
	self.inst.AnimState:SetSortOrder( 3 )
    self.inst.AnimState:OverrideSymbol("water_ripple", "ripple_build", "water_ripple")
    self.inst.AnimState:OverrideSymbol("water_shadow", "ripple_build", "water_shadow")
end  

local function PlayThrowAnim(self)
    if self.showing_effect then --IsOnWater(self.inst) then
        self:PlayWaterAnim()
    else
        self:PlayLandAnim()
    end

    self.inst.AnimState:ClearOverrideSymbol("water_ripple")
    self.inst.AnimState:ClearOverrideSymbol("water_shadow")
end

----------------------------------------------------------------------------------------

local function OnHitLand(inst)
	if inst.components.floater and inst.components.floater.landanim then
		inst.components.floater:PlayLandAnim()
	end
end

local function OnHitWater(inst)
	if inst.components.floater and inst.components.floater.wateranim then
		inst.components.floater:PlayWaterAnim()
	end
	
	local isheld = inst.components.inventoryitem and inst.components.inventoryitem:IsHeld()
	--don't do this if onload or if held (in the latter case, the floater cmp is being stupid and we should probably fix the excess callbacks)
	if GetTime() > 1 and not isheld then
		--don't forget to reject all the sharx drops here
		if inst.prefab ~= "shark_fin" and not inst:HasTag("monstermeat") and inst.components.edible and inst.components.edible.foodtype == "MEAT" then 		
			local roll = math.random()
			local chance = TUNING.SHARKBAIT_CROCODOG_SPAWN_MULT * inst.components.edible.hungervalue
			print(inst, "Testing for crocodog/sharx:", tostring(roll) .." < ".. tostring(chance), roll<chance)
			if roll < chance then 
				if math.random() < TUNING.SHARKBAIT_SHARX_CHANCE then
					TheWorld.components.hounded:SummonSpecialSpawn(inst:GetPosition(), "sharx", math.random(TUNING.SHARKBAIT_SHARX_MIN,TUNING.SHARKBAIT_SHARX_MAX))
				else
					TheWorld.components.hounded:SummonSpecialSpawn(inst:GetPosition(), "crocodog")
				end	
			end
		end
	end
end

local ShouldShowEffect_old
local function ShouldShowEffect(self, ...)
	--as of right now, the effect only runs if not on a land tile, and IA water is land to the game...
	return ShouldShowEffect_old(self, ...) or IsOnWater(self.inst)
end

local OnLandedClient_old
local function OnLandedClient(self, ...)
	if not self.wateranim then
		return OnLandedClient_old(self, ...)
	end
end

--The floater component is incredibly dumb. -M
local IsFloating_old
local function IsFloating(self, ...)
	return IsFloating_old(self, ...) and not (self.inst.replica.inventoryitem and self.inst.replica.inventoryitem:IsHeld())
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("floater", function(cmp)


ShouldShowEffect_old = cmp.ShouldShowEffect
cmp.ShouldShowEffect = ShouldShowEffect
OnLandedClient_old = cmp.OnLandedClient
cmp.OnLandedClient = OnLandedClient
IsFloating_old = cmp.IsFloating
cmp.IsFloating = IsFloating

cmp.UpdateAnimations = UpdateAnimations
cmp.PlayLandAnim = PlayLandAnim
cmp.PlayWaterAnim = PlayWaterAnim
cmp.PlayThrowAnim = PlayThrowAnim

--Maybe explicitly only install the cb on master? -M
cmp.inst:ListenForEvent("floater_startfloating", OnHitWater)
cmp.inst:ListenForEvent("floater_stopfloating", OnHitLand)


end)
%%+%%postinit/components/follower.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _SetLeader
local function SetLeader(self, inst)
  self.previousleader = self.leader
  _SetLeader(self, inst)
end

local function HibernateLeader(self, hibernate)
  if hibernate == false then

    self.leader = self.hibernatedleader
    self.hibernatedleader = nil

    if self.leader and (self.leader:HasTag("player") or self.leader:HasTag("follower_leash")) then 
      self:StartLeashing()
    end
  elseif self.hibernatedleader ~= nil then
    print("!!ERROR: Leader Already Hibernated")
  elseif hibernate then
    self.hibernatedleader = self.leader
    self.leader = nil
    self:StopLeashing()
  end
end

local function SetFollowExitDestinations(self, exit_list)
  self.exit_destinations = exit_list
end

local function CanFollowLeaderThroughExit(self, exit_destination)
  local canFollow = false
  for k,v in ipairs(self.exit_destinations) do
    if v == exit_destination then
      canFollow = true
    end
  end
  return canFollow
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("follower", function(cmp)


cmp.previousleader = nil
cmp.hibernatedleader = nil
cmp.exit_destinations = { EXIT_DESTINATION.LAND }

_SetLeader = cmp.SetLeader
cmp.SetLeader = SetLeader

cmp.HibernateLeader = HibernateLeader
cmp.SetFollowExitDestinations = SetFollowExitDestinations
cmp.CanFollowLeaderThroughExit = CanFollowLeaderThroughExit


end)
%%+%%postinit/components/foodmemory.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local GetBaseFood_old
local function GetBaseFood(self, prefab, ...)
	if prefab:sub(-8) == "_gourmet" then --maybe find the char index instead in case something else is appended
		prefab = prefab:sub(1, -9)
	end
	return GetBaseFood_old(self, prefab, ...)
end

--Note: foodinst is set in postinit/eater.lua
local RememberFood_old
local function RememberFood(self, ...)
	if not self.restricttag or not self.foodinst or self.foodinst:HasTag(self.restricttag) then
		return RememberFood_old(self, ...)
	end
end

local GetFoodMultiplier_old
local function GetFoodMultiplier(self, prefab, ...)
	if not self.restricttag or not self.foodinst or self.foodinst:HasTag(self.restricttag) then
		return GetFoodMultiplier_old(self, prefab, ...)
	elseif self.cookedmult and string.find(prefab, "cooked") then
		return self.cookedmult
	elseif self.driedmult and string.find(prefab, "dried") then
		return self.driedmult
	end
	return self.rawmult or 1
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("foodmemory", function(cmp)


GetBaseFood_old = cmp.GetBaseFood
cmp.GetBaseFood = GetBaseFood
RememberFood_old = cmp.RememberFood
cmp.RememberFood = RememberFood
GetFoodMultiplier_old = cmp.GetFoodMultiplier
cmp.GetFoodMultiplier = GetFoodMultiplier


end)
%%+%%postinit/components/frograin.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("frograin", function(cmp)


local SpawnFrogForPlayer_old = UpvalueHacker.GetUpvalue(cmp.SetSpawnTimes, "ToggleUpdate", "ScheduleSpawn", "SpawnFrogForPlayer")
local _scheduledtasks = UpvalueHacker.GetUpvalue(SpawnFrogForPlayer_old, "_scheduledtasks")

local function SpawnFrogForPlayer(player, reschedule)
	--There is no poisonfrograin... yet >:)  -M
	if not IA_CONFIG.poisonfrograin and IsInIAClimate(player) then
		_scheduledtasks[player] = nil
		return reschedule(player)
	end
	SpawnFrogForPlayer_old(player, reschedule)
end

UpvalueHacker.SetUpvalue(cmp.SetSpawnTimes, SpawnFrogForPlayer, "ToggleUpdate", "ScheduleSpawn", "SpawnFrogForPlayer")


end)
%%+%%postinit/components/frostybreather.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

--This is, strictly speaking, very improper and inaccurate, but since this is just negligible fx, it should be fine -M
local OnTemperatureChanged_old
local function OnTemperatureChanged(self, temperature)
    if IsInIAClimate(self.inst) then
		temperature = TheWorld.state.islandtemperature
	end
	return OnTemperatureChanged_old(self, temperature)
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("frostybreather", function(cmp)


OnTemperatureChanged_old = cmp.OnTemperatureChanged
cmp.OnTemperatureChanged = OnTemperatureChanged

--refresh that hook
cmp:StopWatchingWorldState("temperature", OnTemperatureChanged_old)
cmp:WatchWorldState("temperature", cmp.OnTemperatureChanged)


end)
%%+%%postinit/components/fuel.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onsecondaryfueltype(self, secondaryfueltype, old_secondaryfueltype)
    if old_secondaryfueltype ~= nil then
        self.inst:RemoveTag(old_secondaryfueltype.."_secondaryfuel")
    end
    if secondaryfueltype ~= nil then
        self.inst:AddTag(secondaryfueltype.."_secondaryfuel")
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("fuel", function(cmp)


addsetter(cmp, "secondaryfueltype", onsecondaryfueltype)
cmp.secondaryfueltype = nil


end)
%%+%%postinit/components/fueled.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _CanAcceptFuelItem
local function CanAcceptFuelItem(self, item, ...)
    return _CanAcceptFuelItem(self, item, ...) or (self.accepting and item and item.components.fuel and (item.components.fuel.secondaryfueltype == self.fueltype or item.components.fuel.secondaryfueltype == self.secondaryfueltype))
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("fueled", function(cmp)


_CanAcceptFuelItem = cmp.CanAcceptFuelItem
cmp.CanAcceptFuelItem = CanAcceptFuelItem


end)
%%+%%postinit/components/growable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function SetOnGrowthFn(self, fn)
	self.ongrowthfn = fn
end

local _doGrowth
local function DoGrowth(self)

	_doGrowth(self)
	
	local stage = self:GetNextStage()
	local lastStage = self.stage

	if self.ongrowthfn then
		self.ongrowthfn(self.inst, lastStage, stage)
	end
end
	
----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("growable", function(cmp)


if TheWorld.ismastersim then
	
	-- install extra function calls
	cmp.SetOnGrowthFn = SetOnGrowthFn
	
	_doGrowth = cmp.DoGrowth
	cmp.DoGrowth = DoGrowth
	
end


end)
%%+%%postinit/components/health.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function DoPoisonDamage(self, amount, doer)
  if not self.invincible and self.vulnerabletopoisondamage and self.poison_damage_scale > 0 then
    if amount > 0 then
      self:DoDelta(-amount*self.poison_damage_scale, false, "poison")
    end
  end
end

local function Drown(self)
	local rescueitem = nil --the thing that tells us not to drown this person
	local handled = false --something handles things for us (indication to break loops!)
	
	if self.cantdrown then
		--Werebeaver
		rescueitem = self.inst
		if type(self.cantdrown) == "function" then
			handled = self.cantdrown(self.inst)
		end
	end
	if not handled and self.inst.components.leader and self.inst.components.leader:CountFollowers() > 0 then
		--Ballphins
		for item,_ in pairs(self.inst.components.leader.followers) do
			if (item.components.follower.preventdrowningtest
			and item.components.follower.preventdrowningtest(item, self.inst))
			or (not item.components.follower.preventdrowningtest
			and item.components.follower.preventdrowning) then
				rescueitem = rescueitem or item
				if type(item.components.follower.preventdrowning) == "function" and not handled then
					handled = item.components.follower.preventdrowning(item, self.inst)
					rescueitem = item
					break
				end
			end
		end
	end
	if not handled and self.inst.components.inventory then
		--Life Jacket
		for slot, item in pairs(self.inst.components.inventory.equipslots) do
			if (item.components.equippable.preventdrowningtest
			and item.components.equippable.preventdrowningtest(item, self.inst))
			or (not item.components.equippable.preventdrowningtest
			and item.components.equippable.preventdrowning) then
				rescueitem = rescueitem or item
				if type(item.components.equippable.preventdrowning) == "function" and not handled then
					handled = item.components.equippable.preventdrowning(item, self.inst)
					rescueitem = item
					break
				end
			end
		end
	end
	
	if rescueitem then
		if not handled then
			self.inst:PushEvent("drown_fake", {rescueitem = rescueitem}) --The stategraph knows what to do from here
		end
		return false
	elseif CHEATS_ENABLED and self.inst.components.sailor then
		local boat = SpawnPrefab("boat_row")
		boat.Transform:SetPosition(self.inst:GetPosition():Get())
		self.inst.components.sailor:Embark(boat)
	else
		self.inst.components.health:DoDelta(-self.inst.components.health.currenthealth, false, "drowning", false, nil, true)
		return true
	end
end

local function DryDrown(self)
    --THIS IS NOT FUNCTIONAL YET -Z
    local rescueitem = nil --the thing that tells us not to drown this person
    local handled = false --something handles things for us (indication to break loops!)
    
    if self.cantdrown then
        --Werebeaver
        rescueitem = self.inst
        if type(self.cantdrown) == "function" then
            handled = self.cantdrown(self.inst)
        end
    end
    if not handled and self.inst.components.leader and self.inst.components.leader:CountFollowers() > 0 then
        --Ballphins
        for item,_ in pairs(self.inst.components.leader.followers) do
            if (item.components.follower.preventdrowningtest
            and item.components.follower.preventdrowningtest(item, self.inst))
            or (not item.components.follower.preventdrowningtest
            and item.components.follower.preventdrowning) then
                rescueitem = rescueitem or item
                if type(item.components.follower.preventdrowning) == "function" and not handled then
                    handled = item.components.follower.preventdrowning(item, self.inst)
                    rescueitem = item
                    break
                end
            end
        end
    end
    if not handled and self.inst.components.inventory then
        --Life Jacket
        for slot, item in pairs(self.inst.components.inventory.equipslots) do
            if (item.components.equippable.preventdrowningtest
            and item.components.equippable.preventdrowningtest(item, self.inst))
            or (not item.components.equippable.preventdrowningtest
            and item.components.equippable.preventdrowning) then
                rescueitem = rescueitem or item
                if type(item.components.equippable.preventdrowning) == "function" and not handled then
                    handled = item.components.equippable.preventdrowning(item, self.inst)
                    rescueitem = item
                    break
                end
            end
        end
    end
    
    if rescueitem then
        if not handled then
            self.inst:PushEvent("drown_fake", {rescueitem = rescueitem}) --The stategraph knows what to do from here
        end
        return false
    else
        self.inst.components.health:DoDelta(-self.inst.components.health.currenthealth, false, "drowning", false, nil, true)
        return true
    end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("health", function(cmp)


cmp.vulnerabletopoisondamage = true
cmp.poison_damage_scale = 1

cmp.DoPoisonDamage = DoPoisonDamage
cmp.Drown = Drown
cmp.DryDrown = DryDrown


end)
%%+%%postinit/components/hounded.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("hounded", function(cmp)


local SuperHoundWaves = false
local SummonSpawn_old = UpvalueHacker.GetUpvalue(cmp.SummonSpawn, "SummonSpawn")
if not SummonSpawn_old then -- Super Hound Waves, probably
	SummonSpawn_old = UpvalueHacker.GetUpvalue(cmp.SummonSpawn, "OriginalSummonSpawn")
	if SummonSpawn_old then
		SuperHoundWaves = true
	end
end
local GetSpawnPoint_old = UpvalueHacker.GetUpvalue(SummonSpawn_old, "GetSpawnPoint")
local GetSpecialSpawnChance_old = UpvalueHacker.GetUpvalue(SummonSpawn_old, "GetSpecialSpawnChance")
local SPAWN_DIST = UpvalueHacker.GetUpvalue(GetSpawnPoint_old, "SPAWN_DIST") or 30

local function GroundTestCroc(pt)
	return IsInIAClimate(pt)
end

local function NoHolesCroc(pt)
	return GroundTestCroc(pt) and not TheWorld.Map:IsPointNearHole(pt)
end
local function NoHolesHound(pt)
	return not GroundTestCroc(pt) and not TheWorld.Map:IsPointNearHole(pt)
end

local function GetSpawnPointCroc(pt)
    if not TheWorld.Map:IsAboveGroundAtPoint(pt:Get()) then
        pt = FindNearbyLand(pt, 1) or pt
    end
    local offset = FindWalkableOffset(pt, math.random() * 2 * PI, SPAWN_DIST, 12, true, true, NoHolesCroc)
    if offset ~= nil then
        offset.x = offset.x + pt.x
        offset.z = offset.z + pt.z
        return offset
    end
end

local function GetSpawnPoint(pt)
    if not TheWorld.Map:IsAboveGroundAtPoint(pt:Get()) then
        pt = FindNearbyLand(pt, 1) or pt
    end
    local offset = FindWalkableOffset(pt, math.random() * 2 * PI, SPAWN_DIST, 12, true, true, NoHolesHound)
    if offset ~= nil then
        offset.x = offset.x + pt.x
        offset.z = offset.z + pt.z
		print("FOUND HOUND SPAWNPOINT",TheWorld.Map:GetTileAtPoint(offset.x, 0, offset.z))
        return offset
    end
end

local function GetSpecialCrocChance()
	-- same as hound chance, except we undo the season modifier
    local chance = GetSpecialSpawnChance_old()
    return TheWorld.state.issummer and chance * 2/3 or chance
end

local function SummonSpawn(pt, overrideprefab)
	if GroundTestCroc(pt) or overrideprefab then
		local spawn_pt = GetSpawnPointCroc(pt)
		if spawn_pt ~= nil then
			local spawn = SpawnPrefab(
				overrideprefab
				or	math.random() < GetSpecialCrocChance() 
					and ((TheWorld.state.isspring and "watercrocodog")
						or (TheWorld.state.issummer and "poisoncrocodog"))
				or "crocodog"
			)
			if spawn ~= nil then
				spawn.Physics:Teleport(spawn_pt:Get())
				spawn:FacePoint(pt)
				if spawn.components.spawnfader ~= nil then
					spawn.components.spawnfader:FadeIn()
				end
				return spawn
			end
		end
	else
		return SummonSpawn_old(pt) -- regular spawn behaviour, except we still edit GetSpawnPoint
	end
end

-- Note: always set the deepest value first, or else we'd need to upvalue our own modifications
UpvalueHacker.SetUpvalue(SummonSpawn_old, GetSpawnPoint, "GetSpawnPoint")
if SuperHoundWaves then
	UpvalueHacker.SetUpvalue(cmp.SummonSpawn, SummonSpawn, "OriginalSummonSpawn")
else
	UpvalueHacker.SetUpvalue(cmp.SummonSpawn, SummonSpawn, "SummonSpawn")
end

cmp.SummonSpecialSpawn = function(self, pt, prefab, num)
	if pt == nil or prefab == nil then return end
	for i = 1, (num and math.max(num, 1) or 1), 1 do
		SummonSpawn(pt, prefab)
	end
end


end)
%%+%%postinit/components/inspectable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local GetStatus_old
local function GetStatus(self, viewer, ...)
	return GetStatus_old(self, viewer, ...) or self.inst ~= viewer and self.inst:HasTag("flooded") and "FLOODED" or nil
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("inspectable", function(cmp)

GetStatus_old = cmp.GetStatus
cmp.GetStatus = GetStatus


end)
%%+%%postinit/components/inventory.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _GetEquippedItem
local function GetEquippedItem(self, eslot)
    if eslot == nil then
        return false
    else
        return _GetEquippedItem(self, eslot)
    end
end

local _Equip
local function Equip(self, item, ...)
	if item == nil or item.components.equippable == nil or item.components.equippable.equipslot == nil then
        return false
    else
        return _Equip(self, item, ...)
    end
end

local function GetWindproofness(self, slot)
    local windproofness = 0
    if slot then
        local item = self:GetItemSlot(slot)
        if item and item.components.windproofer then
            windproofness = windproofness + item.components.windproofer.GetEffectiveness()
        end
    else
        for k,v in pairs(self.equipslots) do
            if v and v.components.windproofer then
                windproofness = windproofness + v.components.windproofer:GetEffectiveness()  
            end
        end
    end
    return windproofness
end

local function DropItemBySlot(self, slot)
    local item = self:RemoveItemBySlot(slot)
    if item ~= nil then
        item.Transform:SetPosition(self.inst.Transform:GetWorldPosition())
        if item.components.inventoryitem ~= nil then
            item.components.inventoryitem:OnDropped(true)
        end
        item.prevcontainer = nil
        item.prevslot = nil
        self.inst:PushEvent("dropitem", { item = item })
    end
end

local function IsWindproof(self)
    return self:GetWindproofness() >= 1
end

local function InvSpaceChanged(inst)
    inst:PushEvent("invspacechange", {percent = inst.components.inventory:NumItems() / inst.components.inventory.maxslots})
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("inventory", function(cmp)


_GetEquippedItem = cmp.GetEquippedItem
cmp.GetEquippedItem = GetEquippedItem
_Equip = cmp.Equip
cmp.Equip = Equip

cmp.GetWindproofness = GetWindproofness
cmp.DropItemBySlot = DropItemBySlot
cmp.IsWindproof = IsWindproof

cmp.inst:ListenForEvent("itemget", InvSpaceChanged)
cmp.inst:ListenForEvent("itemlose", InvSpaceChanged)
cmp.inst:ListenForEvent("dropitem", InvSpaceChanged)


end)
%%+%%postinit/components/inventoryitem.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

--copy with our stuff
local function sink_item(item)
    if not item:IsValid() or item:CanOnWater() then
        return
    end

    local px, py, pz = 0, 0, 0
    if item.Transform ~= nil then
        px, py, pz = item.Transform:GetWorldPosition()
    end

    local fx = SpawnPrefab("splash_water_sink")
    -- local fx = SpawnPrefab("splash_sink")
    fx.Transform:SetPosition(px, py, pz)
	if item.SoundEmitter then
		item.SoundEmitter:PlaySound("ia/common/item_sink")
	end

    -- If the item is irreplaceable, respawn it at the player
    if item:HasTag("irreplaceable") then
        if TheWorld.components.playerspawner ~= nil then
            item.Transform:SetPosition(TheWorld.components.playerspawner:GetAnySpawnPoint())
        else
            -- Our reasonable cases are out... so let's loop to find the portal and respawn there.
            for k, v in pairs(Ents) do
                if v:IsValid() and v:HasTag("multiplayer_portal") then
                    item.Transform:SetPosition(v.Transform:GetWorldPosition())
                end
            end
        end
    else
        local tile = TheWorld.Map:GetTileAtPoint(px, py, pz)

        if (item:HasTag("irreplaceable") or tile ~= GROUND.OCEAN_DEEP)
        and item.components.inventoryitem
        and item.components.inventoryitem.cangoincontainer
        and item.persists
        and not item.nosunkenprefab then
            SpawnPrefab("sunkenprefab"):Initialize(item)
		end
        item:Remove()
    end
end

local function TryToSink(self)
    if self:ShouldSink() then
        self.inst:DoTaskInTime(0, sink_item)
    end
end

local ShouldSink_old
local function ShouldSink(self, ...)
	--as of right now, the effect only runs if not on a land tile, and IA water is land to the game...
	return ShouldSink_old(self, ...) or (self.sinks and not self:IsHeld() and IsOnWater(self.inst))
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("inventoryitem", function(cmp)


	cmp.TryToSink = TryToSink
	ShouldSink_old = cmp.ShouldSink
	cmp.ShouldSink = ShouldSink


end)
%%+%%postinit/components/inventoryitemmoisture.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _GetTargetMoisture
local function GetTargetMoisture(self, ...)
	-- if GetTime() <= (self.inst.spawntime or 0) then return 0 end

	local isheld = self.inst.components.inventoryitem:IsHeld()
    -- local owner = self.inst.components.inventoryitem.owner

	--Hack to counter floater not giving a damn about inventory
	if isheld and self.inst.components.floater and self.inst.components.floater:IsFloating() then
		return 0 --could use owner moisture as cap?
    elseif not isheld and not TheWorld.state.israining then
        if self.inst.Transform then
            local x, y, z = self.inst.Transform:GetWorldPosition()
            if x and y and z then
                if IsOnFlood(x, y, z) then
                    return TUNING.MOISTURE_MAX_WETNESS
                end
            end
        end
    end
	return _GetTargetMoisture(self, ...)
end

local _UpdateMoisture
local function UpdateMoisture(self, ...)
    local t = GetTime()
    local dt = t - self.lastUpdate
    if dt <= 0 then
        return _UpdateMoisture(self, ...)
    end

    if self.inst:IsValid() and not self.inst.components.inventoryitem:IsHeld() and self.inst.components.floater and self.inst.components.floater:IsFloating() then
        self.lastUpdate = t
        if self.moisture < TUNING.MOISTURE_MAX_WETNESS then
            self:SetMoisture(TUNING.MOISTURE_MAX_WETNESS)
        end
    else
        if not self.inst.components.inventoryitem:IsHeld() then
            if self.inst.Transform then
                local x, y, z = self.inst.Transform:GetWorldPosition()
                if x and y and z then
					if IsOnFlood(x, y, z) then
                        local moisture = math.max(self.moisture, TUNING.MOISTURE_FLOOD_WETNESS)
                        if self.moisture < moisture then
                            self:SetMoisture(moisture)
                        end
                    end
                end
            end
        end
        return _UpdateMoisture(self, ...)
    end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("inventoryitemmoisture", function(cmp)


_GetTargetMoisture = cmp.GetTargetMoisture
cmp.GetTargetMoisture = GetTargetMoisture

_UpdateMoisture = cmp.UpdateMoisture
cmp.UpdateMoisture = UpdateMoisture


end)
%%+%%postinit/components/inventoryitem_replica.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _CanDeploy
local function CanDeploy(self, pt, ...)
	local result = _CanDeploy(self, pt, ...)
	
	if result and self.inst.components.deployable == nil then
		--The item is deployable, but we still need to check for ocean
		--This is client-side by the way
		local tile = GetVisualTileType(pt.x, pt.y, pt.z, 0.375)
		local tileinfo = GetTileInfo(tile)
        local isbuildable, island, iswater = tileinfo.buildable or false, tileinfo.land ~= false, tileinfo.water or false

		if (self.classified.candeployonland:value() and island) or
		(self.classified.candeployonshallowocean:value() and tile == GROUND.OCEAN_SHALLOW) or
		(iswater and
        ((self.classified.candeployonbuildableocean:value() and isbuildable) or
        (self.classified.candeployonunbuildableocean:value() and not isbuildable))) then
			return result
		else
			return false
		end
	end
	
	return result
end

local function DeployAtRange(self)
    if self.inst.components.deployable then
        self.inst.components.deployable:DeployAtRange()
    end
    return self.classified ~= nil and self.classified.deployatrange:value() or false
end

local _SerializeUsage
local function SerializeUsage(self, ...)
    _SerializeUsage(self, ...)
    if self.inst.components.obsidiantool then
        local charge, maxcharge = self.inst.components.obsidiantool:GetCharge()
        self.classified:SerializeObsidianCharge(charge / maxcharge)
    else
        self.classified:SerializeObsidianCharge(nil)
    end

    if self.inst.components.inventory then
        self.classified:SerializeInvSpace(self.inst.components.inventory:NumItems() / self.inst.components.inventory.maxslots)
    else
        self.classified:SerializeInvSpace(nil)
    end
end

local _DeserializeUsage
local function DeserializeUsage(self, ...)
    _DeserializeUsage(self, ...)
    if self.classified ~= nil then
        self.classified:DeserializeObsidianCharge()
        self.classified:DeserializeInvSpace()
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("components/inventoryitem_replica", function(cmp)


if TheWorld.ismastersim then
    cmp.inst:ListenForEvent("obsidianchargechange", function(inst, data)
		cmp.classified:SerializeObsidianCharge(data.percent)
	end)
    cmp.inst:ListenForEvent("invspacechange", function(inst, data)
		cmp.classified:SerializeInvSpace(data.percent)
	end)

	local deployable = cmp.inst.components.deployable
	if deployable ~= nil then
		cmp.classified.deployatrange:set(deployable.deployatrange)
		cmp.classified.candeployonland:set(deployable.candeployonland)
		cmp.classified.candeployonshallowocean:set(deployable.candeployonshallowocean)
		cmp.classified.candeployonbuildableocean:set(deployable.candeployonbuildableocean)
		cmp.classified.candeployonunbuildableocean:set(deployable.candeployonunbuildableocean)
	end
end

_CanDeploy = cmp.CanDeploy
cmp.CanDeploy = CanDeploy
cmp.DeployAtRange = DeployAtRange
_SerializeUsage = cmp.SerializeUsage
cmp.SerializeUsage = SerializeUsage
_DeserializeUsage = cmp.DeserializeUsage
cmp.DeserializeUsage = DeserializeUsage


end)%%+%%postinit/components/leader.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function HibernateFollower(self, follower, hibernate)
  if follower.components.follower then
    follower.components.follower:HibernateLeader(hibernate)
  end
end 

local function HibernateLandFollowers(self, hibernate)
  for k,v in pairs(self.followers) do
    if not k:CanOnWater() then
      self:HibernateFollower(k, hibernate)
    end
  end
end 

local function HibernateWaterFollowers(self, hibernate)
  for k,v in pairs(self.followers) do
    if not CanOnLand(k) then
      self:HibernateFollower(k, hibernate)
    end
  end
end 
----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("leader", function(cmp)


cmp.HibernateFollower = HibernateFollower
cmp.HibernateLandFollowers = HibernateLandFollowers
cmp.HibernateWaterFollowers = HibernateWaterFollowers


end)
%%+%%postinit/components/locomotor.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local SPEED_MOD_TIMER_DT = FRAMES

local _GetSpeedMultiplier

----------------------------------------------------------------------------------------
--These functions have a server variant and a client variant

local function onhasmomentum_ms(self, hasmomentum)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.hasmomentum:set(hasmomentum)
	end
end

local function ondisable_ms(self, disable)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.disable:set(disable)
	end
end

local function onexternalspeedadder_ms(self, externalspeedadder)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.externalspeedadder:set(externalspeedadder)
	end
end

local function onexternalaccelerationadder_ms(self, externalaccelerationadder)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.externalaccelerationadder:set(externalaccelerationadder)
	end
end

local function onexternalaccelerationmultiplier_ms(self, externalaccelerationmultiplier)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.externalaccelerationmultiplier:set(externalaccelerationmultiplier)
	end
end

local function onexternaldecelerationadder_ms(self, externaldecelerationadder)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.externaldecelerationadder:set(externaldecelerationadder)
	end
end

local function onexternaldecelerationmultiplier_ms(self, externaldecelerationmultiplier)
	if self.inst.player_classified ~= nil then
		self.inst.player_classified.externaldecelerationmultiplier:set(externaldecelerationmultiplier)
	end
end

local function HasMomentum_ms(self)
	return self.hasmomentum
end

local function IsDisabled_ms(self)
	return self.disable
end

local function ExternalSpeedAdder_ms(self)
	return self.externalspeedadder
end

local function GetSpeedAdder_ms(self)
	local add = self:ExternalSpeedAdder()
	return add
end

local function ExternalAccelerationAdder_ms(self)
	return self.externalaccelerationadder
end

local function GetAccelerationAdder_ms(self)
	local add = self:ExternalAccelerationAdder()
	return add
end

local function ExternalAccelerationMultiplier_ms(self)
	return self.externalaccelerationmultiplier
end

local function GetAccelerationMultiplier_ms(self)
	local mult = self:ExternalAccelerationMultiplier()
	return mult
end

local function ExternalDecelerationAdder_ms(self)
	return self.externaldecelerationadder
end

local function GetDecelerationAdder_ms(self)
	local add = self:ExternalDecelerationAdder()
	return add
end

local function ExternalDecelerationMultiplier_ms(self)
	return self.externaldecelerationmultiplier
end

local function GetDecelerationMultiplier_ms(self)
	local mult = self:ExternalDecelerationMultiplier()
	return mult
end

local function GetSpeedMultiplier_ms(self)
	local windmult = 1
	
	if TheWorld.state.hurricane and IsInIAClimate(self.inst) then
		local windangle = self.inst.Transform:GetRotation() - TheWorld.state.gustangle
		local windspeed = TheWorld.state.gustspeed
		local windproofness = 1.0
		if not self.inst.components.sailor or not self.inst.components.sailor:IsSailing() then 
			if self.inst.components.inventory then
				windproofness = 1.0 - self.inst.components.inventory:GetWindproofness()
			end
		end 
		local windfactor = TUNING.WIND_PUSH_MULTIPLIER * windproofness * windspeed * math.cos(windangle * DEGREES) + 1.0
		windmult = math.max(0.1, windfactor)
		-- if self.inst:HasTag("player") then
			-- print(string.format("Loco wind angle %4.2f, factor %4.2f (%4.2f), %s\n", windangle, windfactor, math.cos(windangle * DEGREES) + 1.0, self.inst.prefab))
		-- end
	end
	if self.inst.player_classified ~= nil then
		--TODO This would probably be a lot easier on the network if we just send the windproofness -M
		self.inst.player_classified.windspeedmult:set(windmult)
	end

    local tarmult = 1
    if self.inst.slowing_objects and next(self.inst.slowing_objects) then
        tarmult = TUNING.SLOWING_OBJECT_SLOWDOWN
    end

	local floodmult = 1
	if TheWorld.components.flooding and TheWorld.components.flooding:IsPointOnFlood(self.inst:GetPosition():Get()) then
		floodmult = TUNING.FLOOD_SPEED_MULTIPLIER
	end

	return _GetSpeedMultiplier(self) * windmult * floodmult * tarmult
end

----------------------------------------------------------------------------------------

-- if not TheNet:IsDedicated() then
--dedicated implies server, so we can safely skip these on dedicated
--well, we could, if we declare the local variables outside, but I'm too lazy for that -M


local function HasMomentum_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.hasmomentum:value() or self.hasmomentum
end

local function IsDisabled_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.disable:value() or self.disable
end

local function ExternalSpeedAdder_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.externalspeedadder:value() or self.externalspeedadder
end

local function GetSpeedAdder_client(self)
	local add = self:ExternalSpeedAdder()
	return add
end

local function ExternalAccelerationAdder_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.externalaccelerationadder:value() or self.externalaccelerationadder
end

local function GetAccelerationAdder_client(self)
	local add = self:ExternalAccelerationAdder()
	return add
end

local function ExternalAccelerationMultiplier_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.externalaccelerationmultiplier:value() or self.externalaccelerationmultiplier
end

local function GetAccelerationMultiplier_client(self)
	local mult = self:ExternalAccelerationMultiplier()
	return mult
end

local function ExternalDecelerationAdder_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.externaldecelerationadder:value() or self.externaldecelerationadder
end

local function GetDecelerationAdder_client(self)
	local add = self:ExternalDecelerationAdder()
	return add
end

local function ExternalDecelerationMultiplier_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.externaldecelerationmultiplier:value() or self.externaldecelerationmultiplier
end

local function GetDecelerationMultiplier_client(self)
	local mult = self:ExternalDecelerationMultiplier()
	return mult
end

local function GetWindMult_client(self)
	return self.inst.player_classified ~= nil and self.inst.player_classified.windspeedmult:value() or nil
end

local function GetSpeedMultiplier_client(self)
	local windmult = self:GetWindMult()
	
	if windmult == nil then
		windmult = 1
		if TheWorld.state.hurricane and IsInIAClimate(self.inst) then
			local windangle = self.inst.Transform:GetRotation() - TheWorld.state.gustangle
			local windspeed = TheWorld.state.gustspeed
			local windproofness = 1.0
			--Client does not have these components, but at least we can calculate the angle -M
			-- if not self.inst.components.sailor or not self.inst.components.sailor:IsSailing() then 
				-- if self.inst.components.inventory then
					-- windproofness = 1.0 - self.inst.components.inventory:GetWindproofness()
				-- end
			-- end
			local windfactor = TUNING.WIND_PUSH_MULTIPLIER * windproofness * windspeed * math.cos(windangle * DEGREES) + 1.0
			windmult = math.max(0.1, windfactor)
		end
	end

    local tarmult = 1
    if self.inst.slowing_objects and next(self.inst.slowing_objects) then
        tarmult = TUNING.SLOWING_OBJECT_SLOWDOWN
    end

	local floodmult = 1
	if TheWorld.components.flooding and TheWorld.components.flooding:IsPointOnFlood(self.inst:GetPosition():Get()) then
		floodmult = TUNING.FLOOD_SPEED_MULTIPLIER
	end
	
	return _GetSpeedMultiplier(self) * windmult * floodmult
end


-- end

----------------------------------------------------------------------------------------

local _StopMoving
local function StopMoving(self)
    self.slowing = false
    _StopMoving(self)
end

local function SetExternalAccelerationAdder(self, source, key, a)
    if key == nil then
        return
    elseif a == nil or a == 0 then
        self:RemoveExternalAccelerationAdder(source, key)
        return
    end
    local src_params = self._externalaccelerationadders[source]
    if src_params == nil then
        self._externalaccelerationadders[source] = {
            adders = {[key] = a},
            onremove = function(source)
                self._externalaccelerationadders[source] = nil
                self.externalaccelerationadder = self:RecalculateExternalAccelerationAdder(self._externalaccelerationadders)
            end,}
        self.inst:ListenForEvent("onremove", self._externalaccelerationadders[source].onremove, source)
        self.externalaccelerationadder = self:RecalculateExternalAccelerationAdder(self._externalaccelerationadders)
    elseif src_params.adders[key] ~= a then
        src_params.adders[key] = a
        self.externalaccelerationadder = self:RecalculateExternalAccelerationAdder(self._externalaccelerationadders)
    end
end

local function RemoveExternalAccelerationAdder(self, source, key)
    local src_params = self._externalaccelerationadders[source]
    if src_params == nil then
        return
    elseif key ~= nil then
        src_params.adders[key] = nil
        if next(src_params.adders) ~= nil then
            --this source still has other keys
            self.externalaccelerationadder = self:RecalculateExternalAccelerationAdder(self._externalaccelerationadders)
            return
        end
    end
    --remove the entire source
    self.inst:RemoveEventCallback("onremove", src_params.onremove, source)
    self._externalaccelerationadders[source] = nil
    self.externalaccelerationadder = self:RecalculateExternalAccelerationAdder(self._externalaccelerationadders)
end

local function RecalculateExternalAccelerationAdder(self, sources)
    local a = 0
    for source, src_params in pairs(sources) do
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
    end
    return a
end

local function GetExternalAccelerationAdder(self, source, key)
    local src_params = self._externalaccelerationadders[source]
    if src_params == nil then
        return 0
    elseif key == nil then
        local a = 0
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
        return a
    end
    return src_params.adders[key] or 0
end

local function SetExternalAccelerationMultiplier(self, source, key, m)
    if key == nil then
        return
    elseif m == nil or m == 1 then
        self:RemoveExternalAccelerationMultiplier(source, key)
        return
    end
    local src_params = self._externalaccelerationmultipliers[source]
    if src_params == nil then
        self._externalaccelerationmultipliers[source] = {
            multipliers = {[key] = m},
            onremove = function(source)
                self._externalaccelerationmultipliers[source] = nil
                self.externalaccelerationmultiplier = self:RecalculateExternalAccelerationMultiplier(self._externalaccelerationmultipliers)
            end,}
        self.inst:ListenForEvent("onremove", self._externalaccelerationmultipliers[source].onremove, source)
        self.externalaccelerationmultiplier = self:RecalculateExternalAccelerationMultiplier(self._externalaccelerationmultipliers)
    elseif src_params.multipliers[key] ~= m then
        src_params.multipliers[key] = m
        self.externalaccelerationmultiplier = self:RecalculateExternalAccelerationMultiplier(self._externalaccelerationmultipliers)
    end
end

local function RemoveExternalAccelerationMultiplier(self, source, key)
    local src_params = self._externalaccelerationmultipliers[source]
    if src_params == nil then
        return
    elseif key ~= nil then
        src_params.multipliers[key] = nil
        if next(src_params.multipliers) ~= nil then
            --this source still has other keys
            self.externalaccelerationmultiplier = self:RecalculateExternalAccelerationMultiplier(self._externalaccelerationmultipliers)
            return
        end
    end
    --remove the entire source
    self.inst:RemoveEventCallback("onremove", src_params.onremove, source)
    self._externalaccelerationmultipliers[source] = nil
    self.externalaccelerationmultiplier = self:RecalculateExternalAccelerationMultiplier(self._externalaccelerationmultipliers)
end

local function RecalculateExternalAccelerationMultiplier(self, sources)
    local m = 1
    for source, src_params in pairs(sources) do
        for k, v in pairs(src_params.multipliers) do
            m = m * v
        end
    end
    return m
end

local function GetExternalAccelerationMultiplier(self, source, key)
    local src_params = self._externalaccelerationmultipliers[source]
    if src_params == nil then
        return 1
    elseif key == nil then
        local m = 1
        for k, v in pairs(src_params.multipliers) do
            m = m * v
        end
        return m
    end
    return src_params.multipliers[key] or 1
end

local function SetExternalDecelerationAdder(self, source, key, a)
    if key == nil then
        return
    elseif a == nil or a == 0 then
        self:RemoveExternalDecelerationAdder(source, key)
        return
    end
    local src_params = self._externaldecelerationadders[source]
    if src_params == nil then
        self._externaldecelerationadders[source] = {
            adders = {[key] = a},
            onremove = function(source)
                self._externaldecelerationadders[source] = nil
                self.externaldecelerationadder = self:RecalculateExternalDecelerationAdder(self._externaldecelerationadders)
            end,}
        self.inst:ListenForEvent("onremove", self._externaldecelerationadders[source].onremove, source)
        self.externaldecelerationadder = self:RecalculateExternalDecelerationAdder(self._externaldecelerationadders)
    elseif src_params.adders[key] ~= a then
        src_params.adders[key] = a
        self.externaldecelerationadder = self:RecalculateExternalDecelerationAdder(self._externaldecelerationadders)
    end
end

local function RemoveExternalDecelerationAdder(self, source, key)
    local src_params = self._externaldecelerationadders[source]
    if src_params == nil then
        return
    elseif key ~= nil then
        src_params.adders[key] = nil
        if next(src_params.adders) ~= nil then
            --this source still has other keys
            self.externaldecelerationadder = self:RecalculateExternalDecelerationAdder(self._externaldecelerationadders)
            return
        end
    end
    --remove the entire source
    self.inst:RemoveEventCallback("onremove", src_params.onremove, source)
    self._externaldecelerationadders[source] = nil
    self.externaldecelerationadder = self:RecalculateExternalDecelerationAdder(self._externaldecelerationadders)
end

local function RecalculateExternalDecelerationAdder(self, sources)
    local a = 0
    for source, src_params in pairs(sources) do
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
    end
    return a
end

local function GetExternalDecelerationAdder(self, source, key)
    local src_params = self._externaldecelerationadders[source]
    if src_params == nil then
        return 0
    elseif key == nil then
        local a = 0
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
        return a
    end
    return src_params.adders[key] or 0
end

local function SetExternalDecelerationMultiplier(self, source, key, m)
    if key == nil then
        return
    elseif m == nil or m == 1 then
        self:RemoveExternalDecelerationMultiplier(source, key)
        return
    end
    local src_params = self._externaldecelerationmultipliers[source]
    if src_params == nil then
        self._externaldecelerationmultipliers[source] = {
            multipliers = {[key] = m},
            onremove = function(source)
                self._externaldecelerationmultipliers[source] = nil
                self.externaldecelerationmultiplier = self:RecalculateExternalDecelerationMultiplier(self._externaldecelerationmultipliers)
            end,}
        self.inst:ListenForEvent("onremove", self._externaldecelerationmultipliers[source].onremove, source)
        self.externaldecelerationmultiplier = self:RecalculateExternalDecelerationMultiplier(self._externaldecelerationmultipliers)
    elseif src_params.multipliers[key] ~= m then
        src_params.multipliers[key] = m
        self.externaldecelerationmultiplier = self:RecalculateExternalDecelerationMultiplier(self._externaldecelerationmultipliers)
    end
end

local function RemoveExternalDecelerationMultiplier(self, source, key)
    local src_params = self._externaldecelerationmultipliers[source]
    if src_params == nil then
        return
    elseif key ~= nil then
        src_params.multipliers[key] = nil
        if next(src_params.multipliers) ~= nil then
            --this source still has other keys
            self.externaldecelerationmultiplier = self:RecalculateExternalDecelerationMultiplier(self._externaldecelerationmultipliers)
            return
        end
    end
    --remove the entire source
    self.inst:RemoveEventCallback("onremove", src_params.onremove, source)
    self._externaldecelerationmultipliers[source] = nil
    self.externaldecelerationmultiplier = self:RecalculateExternalDecelerationMultiplier(self._externaldecelerationmultipliers)
end

local function RecalculateExternalDecelerationMultiplier(self, sources)
    local m = 1
    for source, src_params in pairs(sources) do
        for k, v in pairs(src_params.multipliers) do
            m = m * v
        end
    end
    return m
end

local function GetExternalDecelerationMultiplier(self, source, key)
    local src_params = self._externaldecelerationmultipliers[source]
    if src_params == nil then
        return 1
    elseif key == nil then
        local m = 1
        for k, v in pairs(src_params.multipliers) do
            m = m * v
        end
        return m
    end
    return src_params.multipliers[key] or 1
end

local function GetDeceleration(self)
    local add = self:GetDecelerationAdder()
    local mult = self:GetDecelerationMultiplier()
    return (self.deceleration + add) * mult
end

local function GetAcceleration(self)
    local add = self:GetAccelerationAdder()
    local mult = self:GetAccelerationMultiplier()
    return (self.acceleration + add) * mult
end

local _Stop
local function Stop(self, sgparams, stopmomentum)
    if self:HasMomentum() and not stopmomentum then
        self.slowing = true
    elseif (not self:HasMomentum()) or stopmomentum then
        self.momentumvelocity = nil
        _Stop(self, sgparams)
    end
end

local _SetExternalSpeedMultiplier
local function SetExternalSpeedMultiplier(self, source, key, m, timer)
    if key == nil then
        return
    elseif m == nil or m == 1 then
        self:RemoveExternalSpeedMultiplier(source, key)
        return
    end
    _SetExternalSpeedMultiplier(self, source, key, m)
    if timer then
        local externaltimers = self.externalspeedmultipliers_timer[source]
        if externaltimers == nil then
            self.externalspeedmultipliers_timer[source] = {
                timers = {[key] = timer},
                onremove = function(source)
                    self.externalspeedmultipliers_timer[source] = nil
                end,}
                self.inst:ListenForEvent("onremove", self.externalspeedmultipliers_timer[source].onremove, source)
            else
                externaltimers.timers[key] = timer
            end

            if not self.updating_mods_task then
            self.updating_mods_task = self.inst:DoPeriodicTask(SPEED_MOD_TIMER_DT, function() self:UpdateSpeedModifierTimers(SPEED_MOD_TIMER_DT) end)
        end
    end
end
local _RemoveExternalSpeedMultiplier
local function RemoveExternalSpeedMultiplier(self, source, key)
    local src_params = self._externalspeedmultipliers[source]
    if src_params == nil then
        return
    end
    if key == nil then
        if self.externalspeedmultipliers_timer[source] then
            self.inst:RemoveEventCallback("onremove", self.externalspeedmultipliers_timer[source].onremove, source)
            self.externalspeedmultipliers_timer[source] = nil
        end
    end
    if key ~= nil then
        if self.externalspeedmultipliers_timer[source] and self.externalspeedmultipliers_timer[source].timers[key] then
            self.externalspeedmultipliers_timer[source].timers[key] = nil
        end
    end
    _RemoveExternalSpeedMultiplier(self, source, key)
end

local function SetExternalSpeedAdder(self, source, key, a, timer)
    if key == nil then
        return
    elseif a == nil or a == 0 then
        self:RemoveExternalSpeedAdder(source, key)
        return
    end
    local src_params = self._externalspeedadders[source]
    if src_params == nil then
        self._externalspeedadders[source] = {
            adders = {[key] = a},
            onremove = function(source)
                self._externalspeedadders[source] = nil
                self.externalspeedadder = self:RecalculateExternalSpeedAdder(self._externalspeedadders)
            end,}
        self.inst:ListenForEvent("onremove", self._externalspeedadders[source].onremove, source)
        self.externalspeedadder = self:RecalculateExternalSpeedAdder(self._externalspeedadders)
    elseif src_params.adders[key] ~= a then
        src_params.adders[key] = a
        self.externalspeedadder = self:RecalculateExternalSpeedAdder(self._externalspeedadders)
    end

    if timer then
        local externaltimers = self.externalspeedadder_timer[source]
        if externaltimers == nil then
            self.externalspeedadder_timer[source] = {
                timers = {[key] = timer},
                onremove = function(source)
                    self.externalspeedadder_timer[source] = nil
                end,}
            self.inst:ListenForEvent("onremove", self.externalspeedadder_timer[source].onremove, source)
        else
            externaltimers.timers[key] = timer
        end

        if not self.updating_mods_task then
            self.updating_mods_task = self.inst:DoPeriodicTask(SPEED_MOD_TIMER_DT, function() self:UpdateSpeedModifierTimers(SPEED_MOD_TIMER_DT) end)
        end
    end
end

local function RemoveExternalSpeedAdder(self, source, key)
    local src_params = self._externalspeedadders[source]
    if src_params == nil then
        return
    elseif key ~= nil then
        src_params.adders[key] = nil
        if self.externalspeedadder_timer[source] and self.externalspeedadder_timer[source].timers[key] then
            self.externalspeedadder_timer[source].timers[key] = nil
        end
        if next(src_params.adders) ~= nil then
			--this source still has other keys
			self.externalspeedadder = self:RecalculateExternalSpeedAdder(self._externalspeedadders)
			return
        end
    end
    --remove the entire source
    self.inst:RemoveEventCallback("onremove", src_params.onremove, source)
    if self.externalspeedadder_timer[source] then
        self.inst:RemoveEventCallback("onremove", self.externalspeedadder_timer[source].onremove, source)
        self.externalspeedadder_timer[source] = nil
    end
    self._externalspeedadders[source] = nil
    self.externalspeedadder = self:RecalculateExternalSpeedAdder(self._externalspeedadders)
end

local function GetExternalSpeedAdder(self, source, key)
    local src_params = self._externalspeedadders[source]
    if src_params == nil then
        return 0
    elseif key == nil then
        local a = 0
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
        return a
    end
    return src_params.adders[key] or 0
end

local function RecalculateExternalSpeedAdder(self, sources)
    local a = 0
    for source, src_params in pairs(sources) do
        for k, v in pairs(src_params.adders) do
            a = a + v
        end
    end
    return a
end

local function UpdateSpeedModifierTimers(self, dt)
    local function CheckForRemainingTimers()
        for k, source in pairs(self.externalspeedadder_timer) do
            for key, time in pairs(source.timers) do
                if time > 0 then
                    return true
                end
            end
        end

        for k, source in pairs(self.externalspeedmultipliers_timer) do
            for key, time in pairs(source.timers) do
                if time > 0 then
                    return true
                end
            end
        end

        return false
    end

    for k, source in pairs(self.externalspeedadder_timer) do
        for key, time in pairs(source.timers) do
            source.timers[key] = time - dt
            if source.timers[key] <= 0 then
                self:RemoveExternalSpeedAdder(k, key)
                if not CheckForRemainingTimers() then
                    return
                end
            end
        end
    end

    for k, source in pairs(self.externalspeedmultipliers_timer) do
        for key, time in pairs(source.timers) do
            source.timers[key] = time - dt
            if source.timers[key] <= 0 then
                self:RemoveExternalSpeedMultiplier(k, key)
                if not CheckForRemainingTimers() then
                    return
                end
            end
        end
    end

    if not CheckForRemainingTimers() then
		--Why is this only done here and not in the above returns too? -M
        self.updating_mods_task:Cancel()
        self.updating_mods_task = nil
    end
end

local function OnSave(self)
    return {
        _externalspeedmultipliers = self._externalspeedmultipliers[self.inst] and self._externalspeedmultipliers[self.inst].multipliers or nil,
        externalspeedmultipliers_timer = self.externalspeedmultipliers_timer[self.inst] and self.externalspeedmultipliers_timer[self.inst].timers or nil,
        
        _externalspeedadders = self._externalspeedadders[self.inst] and self._externalspeedadders[self.inst].adders or nil,
        externalspeedadder_timer = self.externalspeedadder_timer[self.inst] and self.externalspeedadder_timer[self.inst].timers or nil,
    }
end

local function OnLoad(self, data)
    if data._externalspeedmultipliers then
        for key, mult in pairs(data._externalspeedmultipliers) do
            local timer = data.externalspeedmultipliers_timer and data.externalspeedmultipliers_timer[key] or nil
            --we only want to load speed values that have a timer.
            if timer then
                self:SetExternalSpeedMultiplier(self.inst, key, mult, timer)
            end
        end
    end

    if data._externalspeedadders then
        for key, add in pairs(data._externalspeedadders) do
            local timer = data.externalspeedadder_timer and data.externalspeedadder_timer[key] or nil
            --we only want to load speed values that have a timer.
            if timer then
                self:SetExternalSpeedAdder(self.inst, key, add, timer)
            end
        end
    end
end

local function LongUpdate(self, dt)
    if self.updating_mods_task then
        self:UpdateSpeedModifierTimers(dt)
    end
end

local function GetWalkSpeed(self)
    return (self.walkspeed + self:GetSpeedAdder()) * self:GetSpeedMultiplier()
end

local function GetRunSpeed(self)
    return (self:RunSpeed() + self:GetSpeedAdder()) * self:GetSpeedMultiplier()
end

local _PreviewAction
local function PreviewAction(self, bufferedaction, run, try_instant)
    _PreviewAction(self, bufferedaction, run, try_instant)

    if bufferedaction.action == ACTIONS.LOOKAT and
    self.inst.sg ~= nil and
    self.inst.components.playercontroller ~= nil and
    not self.inst.components.playercontroller.directwalking and bufferedaction.target ~= nil then
        local boat = nil

        if self.inst.replica.sailor then
            boat = self.inst.replica.sailor:GetBoat()
        end

        if boat and not boat.replica.sailable:HasSailor() then
            boat.Transform:SetRotation(self.inst.Transform:GetRotation())
        end
    end
end

local function HandleDisembark(inst)
    if TheWorld.ismastersim then
        inst:PushEvent("hitcoastline")
    elseif inst:HasTag("player") and IA_CONFIG.autodisembark ~= false then
        SendModRPCToServer(MOD_RPC["Island Adventure"]["ClientRequestDisembark"])
    end
end

local function TryGetNewDest(inst, radius, tolerance)
    local tryRadius = radius or (inst.trygetawayfromshore and 2) or 4
    local tryAngle = GetProperAngle(inst.Transform:GetRotation() + 90)
    local pt = inst:GetPosition()

    tolerance = tolerance or tryRadius/3

    local result_offset, result_angle, deflected = FindWalkableOffset(pt, tryAngle*DEGREES, tryRadius, 8, true, false, IsPositionValidForEnt(inst, tolerance))

    if result_offset then
        local destPoint = pt + result_offset

        if not inst.trygetawayfromshore then
            inst.components.locomotor:GoToPoint(destPoint)
            inst.trygetawayfromshore = true
            return true
        else
            inst.components.locomotor:Stop()
            if inst.Physics then
                inst.Physics:Teleport(destPoint:Get())
            else
                inst.Transform:SetPosition(destPoint:Get())
            end

            inst.trygetawayfromshore = nil

            inst.takeabreak = true
            inst:DoTaskInTime(1, function() inst.takeabreak = nil end)
            return true
        end
    elseif not inst.trygetawayfromshore then
        inst.trygetawayfromshore = true
        return false
    elseif not inst.takeabreak then
        --we dont want to spam the log a ton with followers we can't kill.
        if inst.components.follower == nil or inst.components.follower.leader == nil then
            print(tostring(inst).." is stuck! HELP!")
        end

        inst.takeabreak = true

        inst:DoTaskInTime(5, function()
            if TryGetNewDest(inst, 4, 1) then
                inst.trygetawayfromshore = nil
                inst:DoTaskInTime(1, function() inst.takeabreak = nil end)
            else
                if inst.components.follower == nil or inst.components.follower.leader == nil then
                    print("Attempting to teleport "..tostring(inst).." to safety...")
                end
                --TODO: handle stuff needing to teleport to water instead of land.
                local radius = 3
                local testwaterfn = function(offset)
                    local test_point = pt + offset
                    if IsOnWater(test_point.x, test_point.y, test_point.z) then
                        return false
                    end
                    return true 
                end
                local result_offset = FindValidPositionByFan(0, radius, 12, testwaterfn)
                --try again with wider radii, just to be sure
                if not result_offset then
                    for radius = 8, 20, 4 do
                        result_offset = FindValidPositionByFan(0, radius, 12, testwaterfn)
                        --we got a winner, stop the loop
                        if result_offset then
                            break
                        end
                    end
                end

                --save or drown
                if result_offset then
                    --small visual FX so players recognise this as failsafe
                    SpawnAt("sand_puff", inst)
                    inst.Transform:SetPosition((result_offset + pt):Get())
                    inst.components.locomotor:Stop()
                    inst:DoTaskInTime(1, function() inst.takeabreak = nil end)
                elseif inst.components.follower == nil or inst.components.follower.leader == nil then
                    print("Not able to rescue "..tostring(inst).."... RIP...")
                    --hopefully nobody tries trawling this guy -M
                    SpawnAt("splash_water_sink", inst)
                    inst:DoTaskInTime(0.5, function() inst:Remove() end)
                else
                    inst.components.locomotor:Stop()
                    inst:DoTaskInTime(5, function() inst.takeabreak = nil end)
                end
            end
        end)

    return false
    end
end

local _WantsToMoveForward
local function WantsToMoveForward(self)
    if self.inst.takeabreak then
        return false
    end

    if TheWorld.ismastersim and not TryMoveOnTile(self.inst, GetVisualTileType(self.inst.Transform:GetWorldPosition())) and not self.inst:HasTag("player") then
        self.inst:PushEvent("hitcoastline")

        return TryGetNewDest(self.inst)
    end

    if self.inst.trygetawayfromshore then
        self.inst.trygetawayfromshore = nil
    end

    return _WantsToMoveForward(self)
end

local _OnUpdate
local function OnUpdate(self, dt)
    if self:IsDisabled() then return end
    --all these return _OnUpdate(self, dt) are basicaly a way to prevent execution from reaching our momentum code if it shouldnt...
    if not self.inst:IsValid() then
        return _OnUpdate(self, dt)
    end
    local dsq = 0 --distance to target, squared 
    if self.dest then
        --Print(VERBOSITY.DEBUG, "    w dest")
        if not self.dest:IsValid() or (self.bufferedaction and not self.bufferedaction:IsValid()) then
            return _OnUpdate(self, dt)
        end

        if self.inst.components.health and self.inst.components.health:IsDead() then
            return _OnUpdate(self, dt)
        end

        local destpos_x, destpos_y, destpos_z = self.dest:GetPoint()
        local mypos_x, mypos_y, mypos_z = self.inst.Transform:GetWorldPosition()
        dsq = distsq(destpos_x, destpos_z, mypos_x, mypos_z)
    end

    --OKAY SO:
    --we make GetMotorSpeed return 0, so that a if block inside _OnUpdate never executes
    --lastly make make self:Stop() always get called with a true to stopmomentum inside the update loop.
    local _GetMotorSpeed = Physics.GetMotorSpeed
    function Physics.GetMotorSpeed(physics, ...)
        if physics == self.inst.Physics then
            return 0
        end
        return _GetMotorSpeed(physics, ...)
    end
    
    local _RealStop = self.Stop
    function self:Stop(sgparams)
        _RealStop(self, sgparams, true)
    end

    _OnUpdate(self, dt)

    Physics.GetMotorSpeed = _GetMotorSpeed
    
    self.Stop = _RealStop

    local cur_speed = self:HasMomentum() and self.momentumvelocity or self.inst.Physics:GetMotorSpeed()
    self.momentumvelocity = nil

    --wave boosting, only works with momentum...
    if self.boost then
        cur_speed = cur_speed + self.boost
        self.boost = nil
    end
    
    if self:HasMomentum() then
        local currentSpeed = cur_speed 
        if self.wantstomoveforward then 

            local targetSpeed = self.isrunning and self:GetRunSpeed() or self:GetWalkSpeed()

            --print("runspeed is ", self.runspeed)
            --print("multiplied speed is ", targetSpeed)
            local dist = math.sqrt(dsq)

            local deceleration = self:GetDeceleration()
            local acceleration = self:GetAcceleration()

            local stopdistance = math.pow(currentSpeed, 2)/(deceleration * 2.0)
            
            if(stopdistance >= dist and dist > 0) then 
                targetSpeed = currentSpeed - deceleration * GetTickTime()
            end 

            if self.slowing then 
                targetSpeed = 0 
            end 

            if(targetSpeed > currentSpeed) then 
                currentSpeed = currentSpeed + acceleration * GetTickTime()
                --I don't think we have to clamp the speed here, it gets done down below 
                if(currentSpeed > targetSpeed) then 
                    currentSpeed = targetSpeed
                end 
            elseif (targetSpeed < currentSpeed or targetSpeed == 0) then 
                currentSpeed = currentSpeed - deceleration * GetTickTime()
                if(currentSpeed <= 0) then 
                    currentSpeed = 0
                    self:Stop(nil, true)
                end 
            end
        end
        currentSpeed = math.min(currentSpeed, (self.maxSpeed + self:GetSpeedAdder()) * self:GetSpeedMultiplier())
        if DoShoreMovement(self.inst, {x = currentSpeed}, function() self.inst.Physics:SetMotorVel(currentSpeed, 0, 0) end) then
            self.momentumvelocity = currentSpeed
            if self.inst.replica.sailor then
                HandleDisembark(self.inst)
            end
        end

    elseif cur_speed > 0 then
        if self.allow_platform_hopping and (self.bufferedaction == nil or not self.bufferedaction.action.disable_platform_hopping) then

            local mypos_x, mypos_y, mypos_z = self.inst.Transform:GetWorldPosition()

            local destpos_x, destpos_y, destpos_z
            destpos_y = 0

            local rotation = self.inst.Transform:GetRotation() * DEGREES
            local forward_x, forward_z = math.cos(rotation), -math.sin(rotation)                

            local dest_dot_forward = 0

            local map = TheWorld.Map
            local my_platform = map:GetPlatformAtPoint(mypos_x, mypos_z)            

            if self.dest and self.dest:IsValid() then
                destpos_x, destpos_y, destpos_z = self.dest:GetPoint()
                local dest_dir_x, dest_dir_z = VecUtil_Normalize(destpos_x - mypos_x, destpos_z - mypos_z)                
                dest_dot_forward = VecUtil_Dot(dest_dir_x, dest_dir_z, forward_x, forward_z)                
                local dist = VecUtil_Length(destpos_x - mypos_x, destpos_z - mypos_z)
                if dist <= 1.5 then
                    local other_platform = map:GetPlatformAtPoint(destpos_x, destpos_z)
                    if my_platform == other_platform then
                        dest_dot_forward = 1
                    end
                end

            end 

            local forward_angle_span = 0.1
            if dest_dot_forward <= 1 - forward_angle_span then
                destpos_x, destpos_z = forward_x * self.hop_distance + mypos_x, forward_z * self.hop_distance + mypos_z
            end

            local other_platform = map:GetPlatformAtPoint(destpos_x, destpos_z)

            local can_hop = false
			local hop_x, hop_z, target_platform, blocked
            local too_early_top_hop = self.time_before_next_hop_is_allowed > 0
			if my_platform ~= other_platform and not too_early_top_hop
				    and (self.inst.replica.inventory == nil or not self.inst.replica.inventory:IsHeavyLifting())
				    and (self.inst.replica.rider == nil or not self.inst.replica.rider:IsRiding())
				then

				can_hop, hop_x, hop_z, target_platform, blocked = self:ScanForPlatform(my_platform, destpos_x, destpos_z)
			end

            if not blocked then
                if can_hop then
                    self.last_platform_visited = my_platform

                    self:StartHopping(hop_x, hop_z, target_platform)
                elseif self.inst.components.amphibiouscreature ~= nil and other_platform == nil and not self.inst.sg:HasStateTag("jumping") then
                    local dist = self.inst:GetPhysicsRadius(0) + 2.5
                    local _x, _z = forward_x * dist + mypos_x, forward_z * dist + mypos_z
                    if my_platform ~= nil then
                        local temp_x, temp_z, temp_platform = nil, nil, nil
                        can_hop, temp_x, temp_z, temp_platform, blocked = self:ScanForPlatform(nil, _x, _z)
                    end

                    if not can_hop and self.inst.components.amphibiouscreature:ShouldTransition(_x, _z) then
                        -- If my_platform ~= nil, we already ran the "is blocked" test as part of ScanForPlatform.
                        -- Otherwise, run one now.
                        if (my_platform ~= nil and not blocked) or 
                                not self:TestForBlocked(mypos_x, mypos_z, forward_x, forward_z, self.inst:GetPhysicsRadius(0), dist * 1.41421) then -- ~sqrt(2); _x,_z are a dist right triangle so sqrt(dist^2 + dist^2)
                            self.inst:PushEvent("onhop", {x = _x, z = _z})
                        end
                    end
                end
            end

			if (not can_hop and my_platform == nil and target_platform == nil and not self.inst.sg:HasStateTag("jumping")) and self.inst.components.drownable ~= nil and self.inst.components.drownable:ShouldDrown() then
				self.inst:PushEvent("onsink")
			end

        else
			local speed_mult = self:GetSpeedMultiplier()
			local desired_speed = (self.isrunning and self:RunSpeed() or self.walkspeed) + self:GetSpeedAdder()
			if self.dest and self.dest:IsValid() then
				local destpos_x, destpos_y, destpos_z = self.dest:GetPoint()
				local mypos_x, mypos_y, mypos_z = self.inst.Transform:GetWorldPosition()
				local dsq = distsq(destpos_x, destpos_z, mypos_x, mypos_z)
				if dsq <= .25 then
					speed_mult = math.max(.33, math.sqrt(dsq))
				end
			end

			DoShoreMovement(self.inst, {x = desired_speed * speed_mult}, function() self.inst.Physics:SetMotorVel(desired_speed * speed_mult, 0, 0) end)
		end
    end
end

local _WalkForward
local function WalkForward(self, direct, ...)
    DoShoreMovement(self.inst, {x = self:GetWalkSpeed()}, _WalkForward, self, direct, ...)
end

local _RunForward
local function RunForward(self, direct, ...)
    if self:HasMomentum() then
        self.isrunning = true
        if direct then self.wantstomoveforward = true end
        self:StartUpdatingInternal()
    else
        DoShoreMovement(self.inst, {x = self:GetRunSpeed()}, _RunForward, self, direct, ...)
    end
end

local _WalkInDirection
local function WalkInDirection(self, direct)
    if self.inst.replica and self.inst.replica.sailor then
        self.inst.replica.sailor:AlignBoat(direction)
    end
    _WalkInDirection(self, direct)
    self.slowing = false
end

local _RunInDirection
local function RunInDirection(self, direction, throttle)
    if self.inst.replica and self.inst.replica.sailor then
        self.inst.replica.sailor:AlignBoat(direction)
    end
    _RunInDirection(self, direction, throttle)
    self.slowing = false
end

local _GoToEntity
local function GoToEntity(self, inst, bufferedaction, run)
    self.slowing = false
    return _GoToEntity(self, inst, bufferedaction, run)
end

local _GoToPoint
local function GoToPoint(self, pt, bufferedaction, run, overridedest)
    self.slowing = false
    return _GoToPoint(self, pt, bufferedaction, run, overridedest)
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("locomotor", function(cmp)


cmp._externalspeedadders = {}
cmp.externalspeedadder = 0

cmp.externalspeedadder_timer = {}
cmp.externalspeedmultipliers_timer = {}

cmp._externalaccelerationadders = {}
cmp.externalaccelerationadder = 0

cmp._externalaccelerationmultipliers = {}
cmp.externalaccelerationmultiplier = 1

cmp._externaldecelerationadders = {}
cmp.externaldecelerationadder = 0

cmp._externaldecelerationmultipliers = {}
cmp.externaldecelerationmultiplier = 1

cmp.hasmomentum = false

cmp.disable = false

cmp.acceleration = 6
cmp.deceleration = 6
cmp.currentSpeed = 0 
cmp.abruptdeceleration = 8
cmp.abruptAngleThreshold = 120 
cmp.maxSpeed = 12
cmp.slowing = false


if TheWorld.ismastersim then
	
	cmp.HasMomentum = HasMomentum_ms
	cmp.IsDisabled = IsDisabled_ms
	cmp.ExternalSpeedAdder = ExternalSpeedAdder_ms
	cmp.GetSpeedAdder = GetSpeedAdder_ms
	cmp.ExternalAccelerationAdder = ExternalAccelerationAdder_ms
	cmp.GetAccelerationAdder = GetAccelerationAdder_ms
	cmp.ExternalAccelerationMultiplier = ExternalAccelerationMultiplier_ms
	cmp.GetAccelerationMultiplier = GetAccelerationMultiplier_ms
	cmp.ExternalDecelerationAdder = ExternalDecelerationAdder_ms
	cmp.GetDecelerationAdder = GetDecelerationAdder_ms
	cmp.ExternalDecelerationMultiplier = ExternalDecelerationMultiplier_ms
	cmp.GetDecelerationMultiplier = GetDecelerationMultiplier_ms
	_GetSpeedMultiplier = cmp.GetSpeedMultiplier
	cmp.GetSpeedMultiplier = GetSpeedMultiplier_ms
	
    addsetter(cmp, "hasmomentum", onhasmomentum_ms)
    addsetter(cmp, "disable", ondisable_ms)
    addsetter(cmp, "externalspeedadder", onexternalspeedadder_ms)
    addsetter(cmp, "externalaccelerationadder", onexternalaccelerationadder_ms)
    addsetter(cmp, "externalaccelerationmultiplier", onexternalaccelerationmultiplier_ms)
    addsetter(cmp, "externaldecelerationadder", onexternaldecelerationadder_ms)
    addsetter(cmp, "externaldecelerationmultiplier", onexternaldecelerationmultiplier_ms)
	
else
	
	cmp.HasMomentum = HasMomentum_client
	cmp.IsDisabled = IsDisabled_client
	cmp.ExternalSpeedAdder = ExternalSpeedAdder_client
	cmp.GetSpeedAdder = GetSpeedAdder_client
	cmp.ExternalAccelerationAdder = ExternalAccelerationAdder_client
	cmp.GetAccelerationAdder = GetAccelerationAdder_client
	cmp.ExternalAccelerationMultiplier = ExternalAccelerationMultiplier_client
	cmp.GetAccelerationMultiplier = GetAccelerationMultiplier_client
	cmp.ExternalDecelerationAdder = ExternalDecelerationAdder_client
	cmp.GetDecelerationAdder = GetDecelerationAdder_client
	cmp.ExternalDecelerationMultiplier = ExternalDecelerationMultiplier_client
	cmp.GetDecelerationMultiplier = GetDecelerationMultiplier_client
	cmp.GetWindMult = GetWindMult_client
	_GetSpeedMultiplier = cmp.GetSpeedMultiplier
	cmp.GetSpeedMultiplier = GetSpeedMultiplier_client

end

_StopMoving = cmp.StopMoving
cmp.StopMoving = StopMoving
cmp.SetExternalAccelerationAdder = SetExternalAccelerationAdder
cmp.RemoveExternalAccelerationAdder = RemoveExternalAccelerationAdder
cmp.RecalculateExternalAccelerationAdder = RecalculateExternalAccelerationAdder
cmp.GetExternalAccelerationAdder = GetExternalAccelerationAdder
cmp.SetExternalAccelerationMultiplier = SetExternalAccelerationMultiplier
cmp.RemoveExternalAccelerationMultiplier = RemoveExternalAccelerationMultiplier
cmp.RecalculateExternalAccelerationMultiplier = RecalculateExternalAccelerationMultiplier
cmp.GetExternalAccelerationMultiplier = GetExternalAccelerationMultiplier
cmp.SetExternalDecelerationAdder = SetExternalDecelerationAdder
cmp.RemoveExternalDecelerationAdder = RemoveExternalDecelerationAdder
cmp.RecalculateExternalDecelerationAdder = RecalculateExternalDecelerationAdder
cmp.GetExternalDecelerationAdder = GetExternalDecelerationAdder
cmp.SetExternalDecelerationMultiplier = SetExternalDecelerationMultiplier
cmp.RemoveExternalDecelerationMultiplier = RemoveExternalDecelerationMultiplier
cmp.RecalculateExternalDecelerationMultiplier = RecalculateExternalDecelerationMultiplier
cmp.GetExternalDecelerationMultiplier = GetExternalDecelerationMultiplier
cmp.GetDeceleration = GetDeceleration
cmp.GetAcceleration = GetAcceleration
_Stop = cmp.Stop
cmp.Stop = Stop
_SetExternalSpeedMultiplier = cmp.SetExternalSpeedMultiplier
cmp.SetExternalSpeedMultiplier = SetExternalSpeedMultiplier
_RemoveExternalSpeedMultiplier = cmp.RemoveExternalSpeedMultiplier
cmp._RemoveExternalSpeedMultiplier = RemoveExternalSpeedMultiplier
cmp.SetExternalSpeedAdder = SetExternalSpeedAdder
cmp.RemoveExternalSpeedAdder = RemoveExternalSpeedAdder
cmp.RecalculateExternalSpeedAdder = RecalculateExternalSpeedAdder
cmp.GetExternalSpeedAdder = GetExternalSpeedAdder
cmp.UpdateSpeedModifierTimers = UpdateSpeedModifierTimers
cmp.OnSave = OnSave
cmp.OnLoad = OnLoad
cmp.LongUpdate = LongUpdate
cmp.GetWalkSpeed = GetWalkSpeed
cmp.GetRunSpeed = GetRunSpeed
_PreviewAction = cmp.PreviewAction
cmp.PreviewAction = PreviewAction
_WantsToMoveForward = cmp.WantsToMoveForward
cmp.WantsToMoveForward = WantsToMoveForward
_OnUpdate = cmp.OnUpdate
cmp.OnUpdate = OnUpdate
_WalkForward = cmp.WalkForward
cmp.WalkForward = WalkForward
_RunForward = cmp.RunForward
cmp.RunForward = RunForward
_WalkInDirection = cmp.WalkInDirection
cmp.WalkInDirection = WalkInDirection
_RunInDirection = cmp.RunInDirection
cmp.RunInDirection = RunInDirection
_GoToEntity = cmp.GoToEntity
cmp.GoToEntity = GoToEntity
_GoToPoint = cmp.GoToPoint
cmp.GoToPoint = GoToPoint


end)
%%+%%postinit/components/lootdropper.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function CheckPrefabValidity(prefabs)
    if type(prefabs) == "string" then
        PrefabExists(prefabs)
    elseif type(prefabs) == "table" then
        for k, v in pairs(prefabs) do
            if not PrefabExists(v) then return false end
        end
        return true
    else
        return false
    end
end

local _SpawnLootPrefab
local function SpawnLootPrefab(self, loot, pt, ...)
    if self.inst.prefab == "spiderqueen" and loot == "spider_warrior" and IsInIAClimate(self.inst) then
        loot = "tropical_spider_warrior"
    end
    local item = _SpawnLootPrefab(self, loot, pt, ...)

	--This should never happen, but failsafe regardless.
	if not item then return end

    if self.inst.components.poisonable and self.inst.components.poisonable:IsPoisoned() and item.components.perishable then
        item.components.perishable:ReducePercent(TUNING.POISON_PERISH_PENALTY)
    end
	
	if item.components.visualvariant then
		item.components.visualvariant:CopyOf(self.inst)
	end
	
	return item
end

local function GetBaseName(prefab)
  local cookedAfter = prefab.."_cooked"
  local cookedBefore = "cooked"..prefab
  if PrefabExists(cookedAfter) then
    return cookedAfter
  elseif PrefabExists(cookedBefore) then
    return cookedBefore
  else
    return "ash"
  end
end

local function CheckBurnable(self, prefabs)
  -- check burnable
  if not self.inst.components.fueled and self.inst.components.burnable and self.inst.components.burnable:IsBurning() then
    if type(prefabs) == "string" then
      return GetBaseName(prefabs)
    elseif type(prefabs) == "table" then
      for k,v in pairs(prefabs) do
        prefabs[k] = GetBaseName(v)
      end
    end
  end	
  return prefabs
end

local _DropLoot
local function DropLoot(self, pt, force_loot)
  if (type(force_loot) == "string" or type(force_loot) == "table") and CheckPrefabValidity(force_loot) then
    local prefabs = force_loot
    prefabs = self:CheckBurnable(prefabs)

    if type(prefabs) == "string" then
      self:SpawnLootPrefab(prefabs, pt)
    else
      for k,v in pairs(prefabs) do
        self:SpawnLootPrefab(v, pt)
      end
    end
  else
    _DropLoot(self, pt)
  end
end

local function ExplodeLoot(self, pt, speed, loots)
  local prefabs = loots
  if prefabs == nil then
    prefabs = self:GenerateLoot()
  end
  self:CheckBurnable(prefabs)
  self.speed = speed or 1
  for k,v in pairs(prefabs) do
    local newprefab = self:SpawnLootPrefab(v, pt)
    local vx, vy, vz = newprefab.Physics:GetVelocity()
    newprefab.Physics:SetVel(vx, 35, vz)
  end

  self.speed = 1
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("lootdropper", function(cmp)


_SpawnLootPrefab = cmp.SpawnLootPrefab
cmp.SpawnLootPrefab = SpawnLootPrefab
_DropLoot = cmp.DropLoot
cmp.DropLoot = DropLoot
cmp.ExplodeLoot = ExplodeLoot
cmp.CheckBurnable = CheckBurnable


end)
%%+%%postinit/components/moisture.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local easing = require("easing")

----------------------------------------------------------------------------------------


local _GetMoistureRate
local function GetMoistureRate(self)
	
	local waterproofmult_basic = 
		(   self.inst.components.inventory ~= nil and
		    self.inst.components.inventory:GetWaterproofness() or 0
		) +
		self.inherentWaterproofness or 0
	
	if waterproofmult_basic < 1 and TheWorld.components.flooding and TheWorld.components.flooding:IsPointOnFlood(self.inst:GetPosition():Get()) then
		return 1 - (waterproofmult_basic or 0)
		-- return 1 - (self.inherentWaterproofness or 0)
	end
	
	local boat = self.inst.components.sailor and self.inst.components.sailor:GetBoat() or nil
	if boat and boat.components.boathealth and boat.components.boathealth:IsLeaking() then
		return 1 - waterproofmult_basic
	end
	
	if IsInIAClimate(self.inst) then
		if TheWorld.state.islandisraining then
			
			--Klei should've made that a separate function at this point...
			local waterproofmult =
				(   self.inst.components.sheltered ~= nil and
					self.inst.components.sheltered.sheltered and
					self.inst.components.sheltered.waterproofness or 0
				) +
				waterproofmult_basic
			if waterproofmult >= 1 then
				return 0
			end
			
			local rate = easing.inSine(TheWorld.state.islandprecipitationrate, self.minMoistureRate, self.maxMoistureRate, 1)
			return rate * (1 - waterproofmult)
			
		end
		return 0
	else
		return _GetMoistureRate(self)
	end
end

local GetDryingRate_old
local function GetDryingRate(self, moisturerate, ...)
	local rate = 0

	if TheWorld.components.flooding and TheWorld.components.flooding:IsPointOnFlood(self.inst:GetPosition():Get()) then
		return rate
	end

	--need to entirely recalculate to exclude mainland rain from this
    if IsInIAClimate(self.inst) then
		-- Don't dry if it's raining
		if (moisturerate or self:GetMoistureRate()) <= 0 then
		 
			local heaterPower = self.inst.components.temperature ~= nil and math.clamp(self.inst.components.temperature.externalheaterpower, 0, 1) or 0

			rate = self.baseDryingRate
				+ easing.linear(heaterPower, self.minPlayerTempDrying, self:GetSegs() < 3 and 2 or 5, 1)
				+ easing.linear(TheWorld.state.islandtemperature, self.minDryingRate, self.maxDryingRate, self.optimalDryingTemp) --THIS is the ONE line we needed to change for temperature
				+ easing.inExpo(self:GetMoisture(), 0, 1, self.maxmoisture)

			rate = math.clamp(rate, 0, self.maxDryingRate + self.maxPlayerTempDrying)
		end
	else
		--on the mainland
		rate = GetDryingRate_old(self, moisturerate, ...)
	end

	if self.inst.components.locomotor and self.inst.components.locomotor:GetExternalSpeedAdder(self.inst, "AUTODRY")
	and self.inst.components.locomotor:GetExternalSpeedAdder(self.inst, "AUTODRY") > 0 then
		rate = rate + TUNING.HYDRO_FOOD_BONUS_DRY_RATE
	end

	return rate
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("moisture", function(cmp)


_GetMoistureRate = cmp.GetMoistureRate
cmp.GetMoistureRate = GetMoistureRate
GetDryingRate_old = cmp.GetDryingRate
cmp.GetDryingRate = GetDryingRate


end)
%%+%%postinit/components/penguinspawner.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)


IAENV.AddComponentPostInit("penguinspawner", function(cmp)


--all of these functions are to be overridden in TryToSpawnFlockForPlayer -> TryToSpawnFlock -> periodic task
local TryToSpawnFlock
for per, _ in pairs(cmp.inst.pendingtasks) do
	TryToSpawnFlock = UpvalueHacker.GetUpvalue(per.fn, "TryToSpawnFlock")
	if TryToSpawnFlock then
		break
	end
end
local TryToSpawnFlockForPlayer
if TryToSpawnFlock then
	TryToSpawnFlockForPlayer = UpvalueHacker.GetUpvalue(TryToSpawnFlock, "TryToSpawnFlockForPlayer")
end
if not TryToSpawnFlockForPlayer then
	return print("Failed to edit penguinspawner",TryToSpawnFlock,TryToSpawnFlockForPlayer)
end
local EstablishColony_old = UpvalueHacker.GetUpvalue(TryToSpawnFlockForPlayer, "EstablishColony")
local SpawnFlock_old = UpvalueHacker.GetUpvalue(TryToSpawnFlockForPlayer, "SpawnFlock")
local SpawnPenguin = UpvalueHacker.GetUpvalue(SpawnFlock_old, "SpawnPenguin")


local FLOCK_SIZE = 9
local LAND_CHECK_RADIUS = 6
local WATER_CHECK_RADIUS = 2

local MIN_DIST_FROM_STRUCTURES = 20

local SEARCH_RADIUS = 50
local SEARCH_RADIUS2 = SEARCH_RADIUS*SEARCH_RADIUS

local _colonies
local _maxColonySize
local _numBoulders
local _flockSize
local _spacing


local function FindLandNextToWater( playerpos, waterpos )
    --print("FindGroundOffset:")
    local ignore_walls = true 
    local radius = WATER_CHECK_RADIUS
    local ground = TheWorld

    local test = function(offset)
        local run_point = waterpos + offset

        return ground.Map:IsAboveGroundAtPoint(run_point:Get()) and
			not IsOnWater(run_point) and
            ground.Pathfinder:IsClear(
                playerpos.x, playerpos.y, playerpos.z,
                run_point.x, run_point.y, run_point.z,
                { ignorewalls = ignore_walls, ignorecreep = true })
    end

    -- FindValidPositionByFan(start_angle, radius, attempts, test_fn)
    -- returns offset, check_angle, deflected
    local loc,landAngle,deflected = FindValidPositionByFan(0, radius, 8, test)
    if loc then
        --print("Fan angle=",landAngle)
        return waterpos+loc,landAngle,deflected
    end
end


local function FindSpawnLocationForPlayer(player)
	if IsInIAClimate(player) then return end --no penguins in tropical lands!
    local playerPos = Vector3(player.Transform:GetWorldPosition())

    local radius = LAND_CHECK_RADIUS
    local landPos
    local tmpAng
    local map = TheWorld.Map

    local test = function(offset)
        local run_point = playerPos + offset
        -- Above ground, this should be water
        if not map:IsAboveGroundAtPoint(run_point:Get()) or IsOnWater(run_point) then
            local loc, ang, def= FindLandNextToWater(playerPos, run_point)
            if loc ~= nil then
                landPos = loc
                tmpAng = ang
                --print("true angle",ang,ang/DEGREES)
                return true
            end
        end
        return false
    end

    local cang = (math.random() * 360) * DEGREES
    --print("cang:",cang)
    local loc, landAngle, deflected = FindValidPositionByFan(cang, radius, 7, test)
    if loc ~= nil then
        return landPos, tmpAng, deflected
    end
end

local function SpawnFlock(colonyNum,loc,check_angle)

	_flockSize = UpvalueHacker.GetUpvalue(SpawnFlock_old, "_flockSize")
	
    local map = TheWorld.Map
    local flock = GetRandomWithVariance(_flockSize,3)
    local spawned = 0
    local i = 0
    local pang = check_angle/DEGREES
    while spawned < flock and i < flock + 7 do
        local spawnPos = loc + Vector3(GetRandomWithVariance(0,0.5),0.0,GetRandomWithVariance(0,0.5))
        i = i + 1
        if map:IsAboveGroundAtPoint(spawnPos:Get()) and not IsOnWater(spawnPos) then
            spawned = spawned + 1
            --print(TheCamera:GetHeading()%360,"Spawn flock at:",spawnPos,(check_angle/DEGREES),"degrees"," c_off=",c_off)
            --print(TheCamera:GetHeading()," spawnPenguin at",pos,"angle:",angle)
            cmp.inst:DoTaskInTime(GetRandomWithVariance(1,1), SpawnPenguin, cmp, colonyNum, spawnPos,(check_angle/DEGREES))
        end
    end
end

local function EstablishColony(loc)
	
	_colonies = UpvalueHacker.GetUpvalue(EstablishColony_old, "_colonies")
	_maxColonySize = UpvalueHacker.GetUpvalue(EstablishColony_old, "_maxColonySize")
	_numBoulders = UpvalueHacker.GetUpvalue(EstablishColony_old, "_numBoulders")
	_spacing = UpvalueHacker.GetUpvalue(EstablishColony_old, "_spacing")
	
    local radius = SEARCH_RADIUS
    local pos
    local ignore_walls = false
    local check_los = true
    local colonies = _colonies
    local ground = TheWorld

     local testfn = function(offset)
        local run_point = loc + offset
        if not ground.Map:IsAboveGroundAtPoint(run_point:Get()) or IsOnWater(run_point) then
			--print("not above ground")
            return false
        end

		if IsInIAClimate(run_point) then
			return false
		end

        local NearWaterTest = function(offset)
            local test_point = run_point + offset
            return not ground.Map:IsAboveGroundAtPoint(test_point:Get()) or IsOnWater(test_point)
        end

        --  FindValidPositionByFan(start_angle, radius, attempts, test_fn)
        if check_los and
            not ground.Pathfinder:IsClear(loc.x, loc.y, loc.z,
                                                         run_point.x, run_point.y, run_point.z,
                                                         {ignorewalls = ignore_walls, ignorecreep = true}) then 
			--print("no path or los")
            return false
        end
        
        if FindValidPositionByFan(0, 6, 16, NearWaterTest) then
            --print("colony too near water")
            return false
        end
		
        if #(TheSim:FindEntities(run_point.x, run_point.y, run_point.z, MIN_DIST_FROM_STRUCTURES, {"structure"})) > 0 then
            --print("colony too close to structures")
			return false
        end

		-- Now check that the rookeries are not too close together
        local found = true
        for i,v in ipairs(colonies) do
            local pos = v.rookery
            -- What about penninsula effects? May have a long march
            if pos and distsq(run_point,pos) < _spacing*_spacing then
				--print("too close to another rookery")
                found = false
            end
        end
        return found
    end

    -- Look for any nearby colonies with enough room
    -- return the colony if you find it
    for i,v in ipairs(_colonies) do
        if GetTableSize(v.members) <= (_maxColonySize-(FLOCK_SIZE*.8)) then
            pos = v.rookery
            if pos and distsq(loc,pos) < SEARCH_RADIUS2+60 and
                ground.Pathfinder:IsClear(loc.x, loc.y, loc.z,                    -- check for interposing water
                                         pos.x, pos.y, pos.z,
                                         {ignorewalls = false, ignorecreep = true}) then 
                --print("************* Found existing colony")
                return i
            end
        end
    end
    
    -- Make a new colony
    local newFlock = { members={} }

    -- Find good spot far enough away from the other colonies
    radius = SEARCH_RADIUS
    while not newFlock.rookery and radius>30 do
        newFlock.rookery = FindValidPositionByFan(math.random()*PI*2.0, radius, 32, testfn)
        radius = radius - 10
    end
    
    if newFlock.rookery then
        for i, node in ipairs(TheWorld.topology.nodes) do
            if TheSim:WorldPointInPoly(loc.x, loc.z, node.poly) then
                if node.tags ~= nil and table.contains(node.tags, "moonhunt") then
                    newFlock.is_mutated = true
                end
                break
            end
        end

        newFlock.rookery = newFlock.rookery + loc
        newFlock.ice = SpawnPrefab("penguin_ice")
        newFlock.ice.Transform:SetPosition(newFlock.rookery:Get())
        newFlock.ice.spawner = cmp
		if newFlock.is_mutated then
		    newFlock.ice.MiniMapEntity:SetIcon("mutated_penguin.png")
		end

        local numboulders = math.random(math.floor(_numBoulders/2), _numBoulders)
        local sectorsize = 360 / numboulders
        local numattempts = 50
        while numboulders > 0 and numattempts > 0 do
            local foundvalidplacement = false
            local placement_attempts = 0
            while not foundvalidplacement do
                local minang = (sectorsize * (numboulders - 1)) >= 0 and (sectorsize * (numboulders - 1)) or 0
                local maxang = (sectorsize * numboulders) <= 360 and (sectorsize * numboulders) or 360
                local angle = math.random(minang, maxang)
                local pos = newFlock.ice:GetPosition()
                local offset = FindGroundOffset(pos, angle*DEGREES, math.random(5,15), 120, false, false)
                if offset then 
                    local ents = TheSim:FindEntities(pos.x + offset.x, pos.y + offset.y, pos.z + offset.z, 1.2)
                    if #ents == 0 then
                        foundvalidplacement = true
                        numboulders = numboulders - 1
                        
                        local icerock = SpawnPrefab("rock_ice")
                        icerock.Transform:SetPosition(pos.x + offset.x, pos.y + offset.y, pos.z + offset.z)
                        icerock.remove_on_dryup = true
                    end
                end
                placement_attempts = placement_attempts + 1
                --print("placement_attempts:", placement_attempts)
                if placement_attempts > 10 then break end
            end
            numattempts = numattempts - 1
        end
    else
        return false
    end

    _colonies[#_colonies+1] = newFlock
    return #_colonies

end

UpvalueHacker.SetUpvalue(TryToSpawnFlockForPlayer, FindSpawnLocationForPlayer, "FindSpawnLocationForPlayer")
UpvalueHacker.SetUpvalue(TryToSpawnFlockForPlayer, SpawnFlock, "SpawnFlock")
UpvalueHacker.SetUpvalue(TryToSpawnFlockForPlayer, EstablishColony, "EstablishColony")


end)
%%+%%postinit/components/perishable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local Update_old

--have to copy the entire function because of several temperature checks
local function Update_IA(inst, dt)
	if not IsInIAClimate(inst) then
		Update_old(inst, dt)
	else
		if inst.components.perishable then
			
			local modifier = 1
			local owner = inst.components.inventoryitem and inst.components.inventoryitem.owner or nil
			if not owner and inst.components.occupier then
				owner = inst.components.occupier:GetOwner()
			end

			if owner then
				if owner:HasTag("fridge") then
					if inst:HasTag("frozen") and not owner:HasTag("nocool") and not owner:HasTag("lowcool") then
						modifier = TUNING.PERISH_COLD_FROZEN_MULT
					else
						modifier = TUNING.PERISH_FRIDGE_MULT
					end
				elseif owner:HasTag("spoiler") then
					modifier = TUNING.PERISH_GROUND_MULT 
				elseif owner:HasTag("cage") and inst:HasTag("small_livestock") then
					modifier = TUNING.PERISH_CAGE_MULT
				end
			else
				modifier = TUNING.PERISH_GROUND_MULT 
			end

			if inst:GetIsWet() then
				modifier = modifier * TUNING.PERISH_WET_MULT
			end

			
			if TheWorld.state.islandtemperature < 0 then
				if inst:HasTag("frozen") and not inst.components.perishable.frozenfiremult then
					modifier = TUNING.PERISH_COLD_FROZEN_MULT
				else
					modifier = modifier * TUNING.PERISH_WINTER_MULT
				end
			end

			if inst.components.perishable.frozenfiremult then
				modifier = modifier * TUNING.PERISH_FROZEN_FIRE_MULT
			end

			if TheWorld.state.islandtemperature > TUNING.OVERHEAT_TEMP then
				modifier = modifier * TUNING.PERISH_SUMMER_MULT
			end

			modifier = modifier * inst.components.perishable.localPerishMultiplyer

			modifier = modifier * TUNING.PERISH_GLOBAL_MULT
			
			local old_val = inst.components.perishable.perishremainingtime
			local delta = dt or (10 + math.random()*FRAMES*8)
			if inst.components.perishable.perishremainingtime then 
				inst.components.perishable.perishremainingtime = inst.components.perishable.perishremainingtime - delta*modifier
				if math.floor(old_val*100) ~= math.floor(inst.components.perishable.perishremainingtime*100) then
					inst:PushEvent("perishchange", {percent = inst.components.perishable:GetPercent()})
				end
			end

			-- Cool off hot foods over time (faster if in a fridge)
			if inst.components.edible and inst.components.edible.temperaturedelta and inst.components.edible.temperaturedelta > 0 then
				if owner and owner:HasTag("fridge") then
					if not owner:HasTag("nocool") then
						inst.components.edible.temperatureduration = inst.components.edible.temperatureduration - 1
					end
				elseif TheWorld.state.islandtemperature < TUNING.OVERHEAT_TEMP - 5 then
					inst.components.edible.temperatureduration = inst.components.edible.temperatureduration - .25
				end
				if inst.components.edible.temperatureduration < 0 then inst.components.edible.temperatureduration = 0 end
			end
			
			--trigger the next callback
			if inst.components.perishable.perishremainingtime and inst.components.perishable.perishremainingtime <= 0 then
				inst.components.perishable:Perish()
			end
		end
    end
end

local LongUpdate_old
local function LongUpdate(self, dt)
	if IsInIAClimate(self.inst) then
		if self.updatetask ~= nil then
			Update_IA(self.inst, dt or 0)
		end
	else
		LongUpdate_old(self, dt)
	end
end

local StartPerishing_old
local function StartPerishing(self, ...)
	StartPerishing_old(self, ...)
	Update_old = self.updatetask.fn or Update_old
	self.updatetask.fn = Update_IA
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("perishable", function(cmp)


LongUpdate_old = cmp.LongUpdate
cmp.LongUpdate = LongUpdate
StartPerishing_old = cmp.StartPerishing
cmp.StartPerishing = StartPerishing


end)
%%+%%postinit/components/pickable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function picked(inst, data)
	if data and data.loot and data.loot.components.visualvariant then
		data.loot.components.visualvariant:CopyOf(data.plant or inst)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("pickable", function(cmp)


cmp.inst:ListenForEvent("picked", picked)


end)
%%+%%postinit/components/playeractionpicker.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

--replacing the function twice, so logic doesnt need to get copy pasted
local _GetLeftClickActions
local function __GetLeftClickActions(self, position, target, ...)
    if self.leftclickoverride ~= nil then
        local actions, usedefault = self.leftclickoverride(self.inst, target, position)
        if not usedefault or (actions ~= nil and #actions > 0) then
            return _GetLeftClickActions(self, position, target, ...)
        end
    end

    local actions = nil
    local useitem = self.inst.replica.inventory:GetActiveItem()
    local equipitem = self.inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
    local boatitem = self.inst.replica.sailor and self.inst.replica.sailor:GetBoat() and self.inst.replica.sailor:GetBoat().replica.container and self.inst.replica.sailor:GetBoat().replica.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_LAMP)
    local ispassable = self.map:IsPassableAtPoint(position:Get())

	self.disable_right_click = false

	local steering_actions = self:GetSteeringActions(self.inst, position)
	if steering_actions ~= nil then
		self.disable_right_click = true
		return steering_actions
	end

    --if we're specifically using an item, see if we can use it on the target entity
    if useitem ~= nil then
        return _GetLeftClickActions(self, position, target, ...)
    elseif target ~= nil and target ~= self.inst then
        --if we're clicking on a scene entity, see if we can use our equipped object on it, or just use it
        if self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_INSPECT) and
            target:HasTag("inspectable") and
            (self.inst.CanExamine == nil or self.inst:CanExamine()) and
            (self.inst.sg == nil or self.inst.sg:HasStateTag("moving") or self.inst.sg:HasStateTag("idle") or self.inst.sg:HasStateTag("channeling")) and
            (self.inst:HasTag("moving") or self.inst:HasTag("idle") or self.inst:HasTag("channeling")) then
            return _GetLeftClickActions(self, position, target, ...)
        elseif self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) and target.replica.combat ~= nil and self.inst.replica.combat:CanTarget(target) then
            return _GetLeftClickActions(self, position, target, ...)
        elseif equipitem ~= nil and equipitem:IsValid() and not boatitem then
            return _GetLeftClickActions(self, position, target, ...)
        elseif boatitem ~= nil and boatitem:IsValid() and not equipitem then
            actions = self:GetEquippedItemActions(target, boatitem)
        elseif equipitem ~= nil and equipitem:IsValid() and boatitem ~= nil and boatitem:IsValid() then
            local equip_act = self:GetEquippedItemActions(target, equipitem)

            if self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) or GetTableSize(equip_act) == 0 then
                actions = self:GetEquippedItemActions(target, boatitem)
            end

            if not actions or (not self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) and GetTableSize(equip_act) > 0) then
                return _GetLeftClickActions(self, position, target, ...)
            end
        end

        if actions == nil or #actions == 0 then
            return _GetLeftClickActions(self, position, target, ...)
        end
    end

    if actions == nil and target == nil and ispassable then
        if equipitem ~= nil and equipitem:IsValid() and not boatitem then
            return _GetLeftClickActions(self, position, target, ...)
        elseif boatitem ~= nil and boatitem:IsValid() and not equipitem then
            actions = self:GetPointActions(position, boatitem)
        elseif equipitem ~= nil and equipitem:IsValid() and boatitem ~= nil and boatitem:IsValid() then
            local equip_act = self:GetPointActions(position, equipitem)

            if self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) or GetTableSize(equip_act) == 0 then
                actions = self:GetPointActions(position, boatitem)
            end

            if not actions or (not self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) and GetTableSize(equip_act) > 0) then
                return _GetLeftClickActions(self, position, target, ...)
            end
        end
        --this is to make it so you don't auto-drop equipped items when you left click the ground. kinda ugly.
        if actions ~= nil then
            for i, v in ipairs(actions) do
                if v.action == ACTIONS.DROP then
                    table.remove(actions, i)
                    break
                end
            end
        end
        if actions == nil or #actions <= 0 then
            return _GetLeftClickActions(self, position, target, ...)
        end
    end

    return actions or {}
end

local _GetRightClickActions
local function __GetRightClickActions(self, position, target, ...)
	if self.disable_right_click then
		return _GetRightClickActions(self, position, target, ...)
	end
    if self.rightclickoverride ~= nil then
        local actions, usedefault = self.rightclickoverride(self.inst, target, position)
        if not usedefault or (actions ~= nil and #actions > 0) then
            return _GetRightClickActions(self, position, target, ...)
        end
    end

    local actions = nil
    local useitem = self.inst.replica.inventory:GetActiveItem()
    local equipitem = self.inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
    local boatitem = self.inst.replica.sailor and self.inst.replica.sailor:GetBoat() and self.inst.replica.sailor:GetBoat().replica.container and self.inst.replica.sailor:GetBoat().replica.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_LAMP)
    local ispassable = self.map:IsPassableAtPoint(position:Get())

    if target ~= nil and self.containers[target] then
        return _GetRightClickActions(self, position, target, ...)
    elseif useitem ~= nil then
        return _GetRightClickActions(self, position, target, ...)
    elseif target ~= nil and not target:HasTag("walkableplatform") then

        if equipitem ~= nil and equipitem:IsValid() and not boatitem then
            return _GetRightClickActions(self, position, target, ...)
        elseif boatitem ~= nil and boatitem:IsValid() and not equipitem then
            actions = self:GetEquippedItemActions(target, boatitem, true)

            --strip out all other actions for weapons with right click special attacks
            if boatitem.components.aoetargeting ~= nil then
                return (#actions <= 0 or actions[1].action == ACTIONS.CASTAOE) and actions or {}
            end
        elseif equipitem ~= nil and equipitem:IsValid() and boatitem ~= nil and boatitem:IsValid() then
            local equip_act = self:GetEquippedItemActions(target, equipitem, true)

            if self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) or GetTableSize(equip_act) == 0 then
                actions = self:GetEquippedItemActions(target, boatitem, true)
                --strip out all other actions for weapons with right click special attacks
                if boatitem.components.aoetargeting ~= nil then
                    return (#actions <= 0 or actions[1].action == ACTIONS.CASTAOE) and actions or {}
                end
            end

            if not actions or (not self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) and GetTableSize(equip_act) > 0) then
                return _GetRightClickActions(self, position, target, ...)
            end
        end

        if actions == nil or #actions == 0 then
            return _GetRightClickActions(self, position, target, ...)
        end
    elseif ((equipitem ~= nil and equipitem:IsValid()) or (boatitem ~= nil and boatitem:IsValid())) and (ispassable or (equipitem and equipitem:HasTag("allow_action_on_impassable")) or 
        ((equipitem ~= nil and equipitem.components.aoetargeting ~= nil and equipitem.components.aoetargeting.alwaysvalid and equipitem.components.aoetargeting:IsEnabled()) or
        (boatitem ~= nil and boatitem.components.aoetargeting ~= nil and boatitem.components.aoetargeting.alwaysvalid and boatitem.components.aoetargeting:IsEnabled()))) then
        --can we use our equipped item at the point?

        if (equipitem and equipitem:IsValid()) and not boatitem then
            return _GetRightClickActions(self, position, target, ...)
        elseif (boatitem and boatitem:IsValid()) and not equipitem then
            actions = self:GetPointActions(position, boatitem, true)
        elseif (equipitem and equipitem:IsValid()) and (boatitem and boatitem:IsValid()) then
            local equip_act = self:GetPointActions(position, equipitem, true)

            if self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) or GetTableSize(equip_act) == 0 then
                actions = self:GetPointActions(position, boatitem, true)
            end

            if not actions or (not self.inst.components.playercontroller:IsControlPressed(CONTROL_FORCE_ATTACK) and GetTableSize(equip_act) > 0) then
                return _GetRightClickActions(self, position, target, ...)
            end
        end
    end
    if (actions == nil or #actions <= 0) and (target == nil or target:HasTag("walkableplatform")) and ispassable then
        actions = self:GetPointSpecialActions(position, useitem, true)
    end

    if (actions == nil or #actions <= 0) and target == nil and ispassable then
        return _GetRightClickActions(self, position, target, ...)
    end

    return actions or {}
end

local function IsWaterAny(tile)
	return IsWater(tile) or (tile >= GROUND.OCEAN_START and tile <= GROUND.OCEAN_END)
end
local function IsLandRoT(tile)
	return IsLand(tile) and not (tile >= GROUND.OCEAN_START and tile <= GROUND.OCEAN_END)
end

local function GetLeftClickActions(self, position, target, ...)
    local actions = __GetLeftClickActions(self, position, target, ...)

    local x, y, z = self.inst.Transform:GetWorldPosition()
    --lenient player check for water/land, also force the player to be "on land"(if they are technically on water) or "on water"(if they are technically on land) if they have the sailor component.
    local IsWaterBased = IsWaterAny(GetVisualTileType(x, y, z, 1.25 / 4)) and (not self.inst:HasTag("_sailor") or self.inst:HasTag("sailing"))
    local IsLandBased = IsLandRoT(GetVisualTileType(x, y, z, 0.25 / 4)) and (not self.inst:HasTag("_sailor") or not self.inst:HasTag("sailing"))
    --tight cursor check for water/land
    local IsCursorWet = IsWaterAny(GetVisualTileType(position.x, position.y, position.z, 0.001 / 4))
    local IsCursorDry = IsLandRoT(GetVisualTileType(position.x, position.y, position.z, 1.5 / 4))

    if IsWaterBased and not IsCursorWet and not TheInput:ControllerAttached() and (target == nil or not target:CanOnWater()) then 
        if not actions or #actions == 0 or (#actions > 0 and not actions[1].action.instant and not actions[1].action.crosseswaterboundaries) then
            if self.inst:HasTag("_sailor") and self.inst:HasTag("sailing") then
                --Find the landing position, where water meets the land
                local landingPos = nil--position 

                local myPos = self.inst:GetPosition()
                local dir = (position - myPos):GetNormalized()
                local dist = (position - myPos):Length()
                local step = 0.25
                local numSteps = dist/step

                for i = 0, numSteps, 1 do 
                    local testPos = myPos + dir * step * i 
                    local testTile = TheWorld.Map:GetTileAtPoint(testPos.x , testPos.y, testPos.z) 
                    if not IsWaterAny(testTile) then 
                        landingPos = testPos
                        break
                    end 
                end
                if landingPos then 
                    landingPos.x, landingPos.y, landingPos.z = TheWorld.Map:GetTileCenterPoint(landingPos.x, 0, landingPos.z)
                    local action = BufferedAction(self.inst, nil, ACTIONS.DISEMBARK, nil, landingPos)
                    actions = {action}
                end
            else
                actions = nil
            end
        end  
    elseif IsLandBased and not IsCursorDry and not TheInput:ControllerAttached() and (target == nil or not target:CanOnLand()) then 
        if not actions or #actions == 0 or (#actions > 0 and not actions[1].action.instant and not actions[1].action.crosseswaterboundaries) then
            actions = nil
        end 
    end

    return actions or {}
end

local function GetRightClickActions(self, position, target, ...)
    local actions = __GetRightClickActions(self, position, target, ...)

    local x, y, z = self.inst.Transform:GetWorldPosition()
    --lenient player check for water/land, also force the player to be "on land"(if they are technically on water) or "on water"(if they are technically on land) if they have the sailor component.
    local IsWaterBased = IsWater(GetVisualTileType(x, y, z, 1.25 / 4)) and (not self.inst:HasTag("_sailor") or self.inst:HasTag("sailing"))
    local IsLandBased = IsLand(GetVisualTileType(x, y, z, 0.25 / 4)) and (not self.inst:HasTag("_sailor") or not self.inst:HasTag("sailing"))
    --tight cursor check for water/land
    local IsCursorWet = IsWater(GetVisualTileType(position.x, position.y, position.z, 0.001 / 4))
    local IsCursorDry = IsLand(GetVisualTileType(position.x, position.y, position.z, 1.5 / 4))

    if IsWaterBased and not IsCursorWet and not TheInput:ControllerAttached() and (target == nil or not target:CanOnWater()) then 
        if not actions or #actions == 0 or (#actions > 0 and not actions[1].action.instant and not actions[1].action.crosseswaterboundaries) then
            actions = nil
        end  
    elseif IsLandBased and not IsCursorDry and not TheInput:ControllerAttached() and (target == nil or not target:CanOnLand()) then 
        if not actions or #actions == 0 or (#actions > 0 and not actions[1].action.instant and not actions[1].action.crosseswaterboundaries) then
            actions = nil
        end 
    end

    return actions or {}
end

local _SortActionList
local function SortActionList(self, actions, target, useitem)
    local ret = _SortActionList(self, actions, target, useitem)

    if TheWorld.ismastersim then
        for i, action in ipairs(ret) do
            if action.action == ACTIONS.DEPLOY and action.invobject.components.deployable then
				--Why are we doing this anyways? -M
				local pos = action.invobject.components.deployable:GetQuantizedPosition(target)
				action:SetActionPoint(pos)
                return ret
            end
        end
    end

    return ret
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("playeractionpicker", function(cmp)


_GetLeftClickActions = cmp.GetLeftClickActions
cmp.GetLeftClickActions = GetLeftClickActions
_GetRightClickActions = cmp.GetRightClickActions
cmp.GetRightClickActions = GetRightClickActions
_SortActionList = cmp.SortActionList
cmp.SortActionList = SortActionList


end)
%%+%%postinit/components/playercontroller.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _DoControllerUseItemOnSceneFromInvTile
local function DoControllerUseItemOnSceneFromInvTile(self, item)
    local is_equipped = item ~= nil and item:IsValid() and item.replica.equippable and item.replica.equippable:IsEquipped()
    if is_equipped then
        self.inst.replica.inventory:ControllerUseItemOnSceneFromInvTile(item)
    else
        _DoControllerUseItemOnSceneFromInvTile(self, item)
    end
end

local _GetGroundUseAction
local function GetGroundUseAction(self, position)
    if self.inst:HasTag("_sailor") and self.inst:HasTag("sailing") then
        if position ~= nil then
            local landingPos = Vector3(TheWorld.Map:GetTileCenterPoint(position.x, 0, position.z))
            if landingPos.x == position.x and landingPos.z == position.z then
                local l = nil
                local r = BufferedAction(self.inst, nil, ACTIONS.DISEMBARK, nil, landingPos)
                return l, r
            end
        else
            --Check if the player is close to land and facing towards it
            local angle = self.inst.Transform:GetRotation() * DEGREES
            local dir = Vector3(math.cos(angle), 0, -math.sin(angle))
            dir = dir:GetNormalized()

            local myPos = self.inst:GetPosition()
            local step = 0.4
            local numSteps = 8 
            local landingPos = nil 

            for i = 0, numSteps, 1 do 
                local testPos = myPos + dir * step * i 
                local testTile = TheWorld.Map:GetTileAtPoint(testPos.x , testPos.y, testPos.z) 
                if not IsWater(testTile) then 
                    landingPos = testPos
                    break
                end 
            end 
            if landingPos then 
                landingPos.x, landingPos.y, landingPos.z = TheWorld.Map:GetTileCenterPoint(landingPos.x, 0, landingPos.z)
                local l = nil
                local r = BufferedAction(self.inst, nil, ACTIONS.DISEMBARK, nil, landingPos)
                return l, r
            end
        end
    end
    return _GetGroundUseAction(self, position)
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("playercontroller", function(cmp)


_DoControllerUseItemOnSceneFromInvTile = cmp.DoControllerUseItemOnSceneFromInvTile
cmp.DoControllerUseItemOnSceneFromInvTile = DoControllerUseItemOnSceneFromInvTile
_GetGroundUseAction = cmp.GetGroundUseAction
cmp.GetGroundUseAction = GetGroundUseAction


if not TheNet:IsDedicated() then
    local _IsVisible = Entity.IsVisible
    local function NO(self)
        return not IsLocalNOCLICKed(self) and _IsVisible(self)
    end

    local _UpdateControllerInteractionTarget = UpvalueHacker.GetUpvalue(cmp.UpdateControllerTargets, "UpdateControllerInteractionTarget")
    UpvalueHacker.SetUpvalue(cmp.UpdateControllerTargets, function(self, dt, x, y, z, dirx, dirz)
        Entity.IsVisible = NO
        _UpdateControllerInteractionTarget(self, dt, x, y, z, dirx, dirz)
        Entity.IsVisible = _IsVisible
    end, "UpdateControllerInteractionTarget")

    --YEAH YEAH, this isn't a player controller post init, but it fits the theme of preventing selection of a entity on the client. -Z
    local TheSimIndex = getmetatable(TheSim).__index
    local _GetEntitiesAtScreenPoint = TheSimIndex.GetEntitiesAtScreenPoint
    function TheSimIndex:GetEntitiesAtScreenPoint(...)
        local entlist = {}
        for i, ent in ipairs(_GetEntitiesAtScreenPoint(self, ...)) do
            if not IsLocalNOCLICKed(ent) then
                entlist[#entlist + 1] = ent
            end
        end
        return entlist
    end
end


end)
%%+%%postinit/components/regrowthmanager.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("regrowthmanager", function(cmp)


local _worldstate = TheWorld.state

cmp:SetRegrowthForType("sweet_potato_planted", TUNING.CARROT_REGROWTH_TIME, "sweet_potato_planted", function()
    return not (_worldstate.isnight or _worldstate.iswinter or _worldstate.snowlevel > 0) and 1 or 0
end)


end)
%%+%%postinit/components/repairable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _NeedsRepairs
local function NeedsRepairs(self)
    local need = _NeedsRepairs(self)

    if not need and self.inst.components.boathealth then
        return self.inst.components.boathealth:GetPercent() < 1
    end

    return need
end

local _Repair
local function Repair(self, doer, repair_item)
    if self.inst.components.boathealth then
        if repair_item.components.repairer == nil or self.repairmaterial ~= repair_item.components.repairer.repairmaterial then
            --wrong material
            return false
        elseif self.checkmaterialfn ~= nil then
            local success, reason = self.checkmaterialfn(self.inst, repair_item)
            if not success then
                return false, reason
            end
        end

        if self.inst.components.boathealth:GetPercent() >= 1 then
            return false
        end
        self.inst.components.boathealth:DoDelta(repair_item.components.repairer.healthrepairvalue, "repair", repair_item, true)

        if repair_item.components.stackable then
            repair_item.components.stackable:Get():Remove()
        elseif repair_item.components.finiteuses then
            repair_item.components.finiteuses:Use(1)
        else
            repair_item:Remove()
        end

        if self.onrepaired then
            self.onrepaired(self.inst, doer, repair_item)
        end
        return true
    end

    return _Repair(self, doer, repair_item)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("repairable", function(cmp)


_NeedsRepairs = cmp.NeedsRepairs
cmp.NeedsRepairs = NeedsRepairs
_Repair = cmp.Repair
cmp.Repair = Repair


end)
%%+%%postinit/components/shadowcreaturespawner.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("shadowcreaturespawner", function(cmp)


local StartSpawn
for i, v in ipairs(cmp.inst.event_listening["ms_playerjoined"][TheWorld]) do
	if UpvalueHacker.GetUpvalue(v, "OnInducedInsanity") then
        StartSpawn =  UpvalueHacker.GetUpvalue(v, "Start", "UpdatePopulation", "StartSpawn")
		break
	end
end
if not StartSpawn then return end

local _UpdateSpawn =  UpvalueHacker.GetUpvalue(StartSpawn, "UpdateSpawn")
local SPAWN_INTERVAL =  UpvalueHacker.GetUpvalue(_UpdateSpawn, "SPAWN_INTERVAL")
local SPAWN_VARIANCE =  UpvalueHacker.GetUpvalue(_UpdateSpawn, "SPAWN_VARIANCE")
local _StartTracking =  UpvalueHacker.GetUpvalue(_UpdateSpawn, "StartTracking")

--No need to set this upvalue, it isn't used anywhere but in our UpdateSpawn edit.
local function StartTracking(player, params, ent, ...)
    ent:ListenForEvent("embarkboat", function()
        if not ent:CanOnWater() then
			ent.spawnedforplayer = nil
			ent.persists = false
			ent.wantstodespawn = true
		end
    end, player)
    ent:ListenForEvent("disembarkboat", function()
        if not ent:CanOnLand() then
			ent.spawnedforplayer = nil
			ent.persists = false
			ent.wantstodespawn = true
		end
    end, player)
	return _StartTracking(player, params, ent, ...)
end

local function UpdateSpawn(player, params, ...)
    if IsLand(GetVisualTileType(player.Transform:GetWorldPosition())) and params.targetpop > #params.ents then
        local playerpos = player:GetPosition()
        local offset = FindGroundOffset(playerpos, 2*math.pi*math.random(), 15, 12)
        if offset then
            offset = offset + playerpos
            local ent = SpawnPrefab(
                player.components.sanity:GetPercent() < .1 and
                math.random() < .5 and
                "terrorbeak" or
                "crawlinghorror"
            )
            ent.Transform:SetPosition(offset:Get())
            StartTracking(player, params, ent)
        end
        --Reschedule spawning if we haven't reached our target population
        params.spawntask =
            params.targetpop ~= #params.ents
            and player:DoTaskInTime(SPAWN_INTERVAL + SPAWN_VARIANCE * math.random(), UpdateSpawn, params)
            or nil
        return
    elseif IsWater(GetVisualTileType(player.Transform:GetWorldPosition())) and params.targetpop > #params.ents then
        local playerpos = player:GetPosition()
        local offset = FindWaterOffset(playerpos, 2*math.pi*math.random(), 15, 12)
        if offset then
            offset = offset + playerpos
            local ent = SpawnPrefab("swimminghorror")
            ent.Transform:SetPosition(offset:Get())
            StartTracking(player, params, ent)
        end
        --Reschedule spawning if we haven't reached our target population
        params.spawntask =
            params.targetpop ~= #params.ents
            and player:DoTaskInTime(SPAWN_INTERVAL + SPAWN_VARIANCE * math.random(), UpdateSpawn, params)
            or nil
        return
    end
    return _UpdateSpawn(player, params, ...)
end

UpvalueHacker.SetUpvalue(StartSpawn, UpdateSpawn, "UpdateSpawn")


end)%%+%%postinit/components/sheltered.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _OnUpdate
local function OnUpdate(self, dt)
	_OnUpdate(self, dt)
	--handle palmleaf huts
    local x, y, z = self.inst.Transform:GetWorldPosition()
    local ents = TheSim:FindEntities(x, y, z, 2, { "dryshelter" }, { "FX", "NOCLICK", "DECOR", "INLIMBO", "stump", "burnt" })
	if #ents > 0 then
		self:SetSheltered(true, true)
	end
end

local _SetSheltered
local function SetSheltered(self, shelter, dryshelter)
	--exception for the announcement
    if shelter and self.presheltered
    and not self.sheltered and self.inst.replica.sheltered:IsSheltered()
	and IsInIAClimate(self.inst) then
        self.sheltered = true
        self.inst:PushEvent("sheltered", true)
        if self.announcecooldown <= 0 and (TheWorld.state.islandisraining or TheWorld.state.islandtemperature >= TUNING.OVERHEAT_TEMP - 5) then
            self.inst.components.talker:Say(GetString(self.inst, "ANNOUNCE_SHELTER"))
            self.announcecooldown = TUNING.TOTAL_DAY_TIME
        end
	else
		_SetSheltered(self, shelter)
	end
	--handle palmleaf huts
    if dryshelter and not self.waterproofness_nodryshelter then
	-- and self.inst.replica.sheltered and self.inst.replica.sheltered:IsSheltered()
		self.waterproofness_nodryshelter = self.waterproofness
		self.waterproofness = TUNING.WATERPROOFNESS_ABSOLUTE
	elseif self.waterproofness_nodryshelter then -- only do this once so we don't interfere with dynamic char stats more than necessary
		self.waterproofness = self.waterproofness_nodryshelter
		self.waterproofness_nodryshelter = nil
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("sheltered", function(cmp)


_OnUpdate = cmp.OnUpdate
cmp.OnUpdate = OnUpdate
_SetSheltered = cmp.SetSheltered
cmp.SetSheltered = SetSheltered


end)
%%+%%postinit/components/stewer.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local Harvest_old
local function Harvest(self, ...)
    if IA_CONFIG.oldwarly and self.done and self.gourmetcook and self.product ~= nil and PrefabExists(self.product .."_gourmet") then
		self.product = self.product .."_gourmet"
	end
	self.gourmetcook = nil
	local ret = Harvest_old(self, ...)
	if self.inst.components.container ~= nil and self.inst:HasTag("flooded") then      
		self.inst.components.container.canbeopened = false
	end
	return ret
end

local StopCooking_old
local function StopCooking(self, ...)
    if IA_CONFIG.oldwarly and self.gourmetcook and self.product ~= nil and PrefabExists(self.product .."_gourmet") then
		self.product = self.product .."_gourmet"
	end
	self.gourmetcook = nil
	return StopCooking_old(self, ...)
end

local OnSave_old
local function OnSave(self, ...)
    local data, refs = OnSave_old(self, ...)
	data.gourmetcook = self.gourmetcook
	return data, refs
end

local OnLoad_old
local function OnLoad(self, data, ...)
	OnLoad_old(self, data, ...)
	self.gourmetcook = data.gourmetcook
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("stewer", function(cmp)


Harvest_old = cmp.Harvest
cmp.Harvest = Harvest
StopCooking_old = cmp.StopCooking
cmp.StopCooking = StopCooking
OnSave_old = cmp.OnSave
cmp.OnSave = OnSave
OnLoad_old = cmp.OnLoad
cmp.OnLoad = OnLoad


end)
%%+%%postinit/components/teamleader.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function SetKeepThreatFn(self, fn)
  self.keepthreatfn = fn
end

local function KeepThreat(self)
  if self.threat and self.keepthreatfn then
    return self.keepthreatfn(self.inst, self.threat)
  else
    return true
  end
end

local _OnUpdate
local function OnUpdate(self, dt)
  _OnUpdate(self, dt)

  if self.inst and self.inst:IsValid() then
    if self.threat and not self:KeepThreat() then
      self:DisbandTeam()
    end
  end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("teamleader", function(cmp)


-- cmp.keepthreatfn = nil

cmp.SetKeepThreatFn = SetKeepThreatFn
cmp.KeepThreat = KeepThreat
_OnUpdate = cmp.OnUpdate
cmp.OnUpdate = OnUpdate


end)
%%+%%postinit/components/temperature.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local ZERO_DISTANCE = 10
local ZERO_DISTSQ = ZERO_DISTANCE * ZERO_DISTANCE

local OnUpdate_old
local function OnUpdate(self, dt, applyhealthdelta, ...)
    if IsInIAClimate(self.inst) then
		
		--if this edit causes conflicts, it's probably best to add the other mods changes to this edit -M
		
		self.externalheaterpower = 0
		self.delta = 0
		self.rate = 0

		if self.settemp ~= nil or
			self.inst.is_teleporting or
			(self.inst.components.health ~= nil and self.inst.components.health.invincible) then
			return
		end

		-- Can override range, e.g. in special containers
		local mintemp = self.mintemp
		local maxtemp = self.maxtemp
		local ambient_temperature = TheWorld.state.islandtemperature --THIS is the ONE line we needed to change

		local owner = self.inst.components.inventoryitem ~= nil and self.inst.components.inventoryitem.owner or nil
		if owner ~= nil and owner:HasTag("fridge") and not owner:HasTag("nocool") then
			-- Inside a fridge, excluding icepack ("nocool")
			-- Don't cool it below freezing unless ambient temperature is below freezing
			mintemp = math.max(mintemp, math.min(0, ambient_temperature))
			self.rate = owner:HasTag("lowcool") and -.5 * TUNING.WARM_DEGREES_PER_SEC or -TUNING.WARM_DEGREES_PER_SEC
		else
			-- Prepare to figure out the temperature where we are standing
			local x, y, z = self.inst.Transform:GetWorldPosition()
			local ents = self.usespawnlight and
				TheSim:FindEntities(x, y, z, ZERO_DISTANCE, nil, self.ignoreheatertags, { "HASHEATER", "spawnlight" }) or
				TheSim:FindEntities(x, y, z, ZERO_DISTANCE, { "HASHEATER" }, self.ignoreheatertags)
			if self.usespawnlight and #ents > 0 then
				for i, v in ipairs(ents) do
					if v.components.heater == nil and v:HasTag("spawnlight") then
						ambient_temperature = math.clamp(ambient_temperature, 10, TUNING.OVERHEAT_TEMP - 20)
						table.remove(ents, i)
						break
					end
				end
			end

			--print(ambient_temperature, "ambient_temperature")
			self.delta = (ambient_temperature + self.totalmodifiers + self:GetMoisturePenalty()) - self.current
			--print(self.delta + self.current, "initial target")

			if self.inst.components.inventory ~= nil then
				for k, v in pairs(self.inst.components.inventory.equipslots) do
					if v.components.heater ~= nil then
						local heat = v.components.heater:GetEquippedHeat()
						if heat ~= nil and
							((heat > self.current and v.components.heater:IsExothermic()) or
							(heat < self.current and v.components.heater:IsEndothermic())) then
							self.delta = self.delta + heat - self.current
						end
					end
				end
				for k, v in pairs(self.inst.components.inventory.itemslots) do
					if v.components.heater ~= nil then
						local heat, carriedmult = v.components.heater:GetCarriedHeat()
						if heat ~= nil and
							((heat > self.current and v.components.heater:IsExothermic()) or
							(heat < self.current and v.components.heater:IsEndothermic())) then
							self.delta = self.delta + (heat - self.current) * carriedmult
						end
					end
				end
				local overflow = self.inst.components.inventory:GetOverflowContainer()
				if overflow ~= nil then
					for k, v in pairs(overflow.slots) do
						if v.components.heater ~= nil then
							local heat, carriedmult = v.components.heater:GetCarriedHeat()
							if heat ~= nil and
								((heat > self.current and v.components.heater:IsExothermic()) or
								(heat < self.current and v.components.heater:IsEndothermic())) then
								self.delta = self.delta + (heat - self.current) * carriedmult
							end
						end
					end
				end
			end

			--print(self.delta + self.current, "after carried/equipped")

			-- Recently eaten temperatured food is inherently equipped heat/cold
			if self.bellytemperaturedelta ~= nil then
				self.delta = self.delta + self.bellytemperaturedelta
			end

			--print(self.delta + self.current, "after belly")

			-- If very hot (basically only when have overheating screen effect showing) and under shelter, cool slightly
			if self.sheltered and self.current > TUNING.TREE_SHADE_COOLING_THRESHOLD then
				self.delta = self.delta - (self.current - TUNING.TREE_SHADE_COOLER)
			end

			--print(self.delta + self.current, "after shelter")

			for i, v in ipairs(ents) do 
				if v ~= self.inst and
					not v:IsInLimbo() and
					v.components.heater ~= nil and
					(v.components.heater:IsExothermic() or v.components.heater:IsEndothermic()) then

					local heat = v.components.heater:GetHeat(self.inst)
					if heat ~= nil then
						-- This produces a gentle falloff from 1 to zero.
						local heatfactor = 1 - self.inst:GetDistanceSqToInst(v) / ZERO_DISTSQ
						if self.inst:GetIsWet() then
							heatfactor = heatfactor * TUNING.WET_HEAT_FACTOR_PENALTY
						end

						if v.components.heater:IsExothermic() then
							-- heating heatfactor is relative to 0 (freezing)
							local warmingtemp = heat * heatfactor
							if warmingtemp > self.current then
								self.delta = self.delta + warmingtemp - self.current
							end
							self.externalheaterpower = self.externalheaterpower + warmingtemp
						else--if v.components.heater:IsEndothermic() then
							-- cooling heatfactor is relative to overheattemp
							local coolingtemp = (heat - self.overheattemp) * heatfactor + self.overheattemp
							if coolingtemp < self.current then
								self.delta = self.delta + coolingtemp - self.current
							end
						end
					end
				end
			end

			--print(self.delta + self.current, "after heaters")

			-- Winter insulation only affects you when it's cold out, summer insulation only helps when it's warm
			if ambient_temperature >= TUNING.STARTING_TEMP then
				-- it's warm out
				if self.delta > 0 then
					-- If the player is heating up, defend using insulation.
					local winterInsulation, summerInsulation = self:GetInsulation()
					self.rate = math.min(self.delta, TUNING.SEG_TIME / (TUNING.SEG_TIME + summerInsulation))
				else
					-- If they are cooling, do it at full speed, and faster if they're overheated
					self.rate = math.max(self.delta, self.current >= self.overheattemp and -TUNING.THAW_DEGREES_PER_SEC or -TUNING.WARM_DEGREES_PER_SEC)
				end
			-- it's cold out
			elseif self.delta < 0 then
				-- If the player is cooling, defend using insulation.
				local winterInsulation, summerInsulation = self:GetInsulation()
				self.rate = math.max(self.delta, -TUNING.SEG_TIME / (TUNING.SEG_TIME + winterInsulation))
			else
				-- If they are heating up, do it at full speed, and faster if they're freezing
				self.rate = math.min(self.delta, self.current <= 0 and TUNING.THAW_DEGREES_PER_SEC or TUNING.WARM_DEGREES_PER_SEC)
			end

			--print(self.delta + self.current, "after insulation")
			--print(self.rate, "final rate\n\n")
		end

		self:SetTemperature(math.clamp(self.current + self.rate * dt, mintemp, maxtemp))

		--applyhealthdelta nil defaults to true
		if applyhealthdelta ~= false and self.inst.components.health ~= nil then
			if self.current < 0 then
				self.inst.components.health:DoDelta(-self.hurtrate * dt, true, "cold")
			elseif self.current > self.overheattemp then
				self.inst.components.health:DoDelta(-self.hurtrate * dt, true, "hot")
			end
		end
		
		
	else
		OnUpdate_old(self, dt, applyhealthdelta, ...)
	end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("temperature", function(cmp)


OnUpdate_old = cmp.OnUpdate
cmp.OnUpdate = OnUpdate


end)
%%+%%postinit/components/thief.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function SetCanOpenContainers(self, canopen)
	self.canopencontainers = canopen
end

local StealItemOld
local function StealItem(self, victim, itemtosteal, attack)
	if not (victim.components.inventory and not victim.components.inventory.nosteal) and victim.components.container and not self.canopencontainers then
		return
	else
		StealItemOld(self, victim, itemtosteal, attack)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("thief", function(cmp)


cmp.canopencontainers = true

StealItemOld = cmp.StealItem
cmp.StealItem = StealItem
cmp.SetCanOpenContainers = SetCanOpenContainers


end)
%%+%%postinit/components/trap.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _OnUpdate
local function OnUpdate(self, dt, ...)
	if (not self.water and IsOnLand(self.inst)) or (self.water and IsOnWater(self.inst)) then
		return _OnUpdate(self, dt, ...)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("trap", function(cmp)


cmp.water = false

_OnUpdate = cmp.OnUpdate
cmp.OnUpdate = OnUpdate


end)
%%+%%postinit/components/uianim.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local ShakeDeltas =
{
    --------------------------------------------------------------------------
    --     4
    --  7     1
    -- 2   S   6
    --  5     3
    --     0
    --------------------------------------------------------------------------
    Vector3( 0,-1):GetNormalized(),
    Vector3( 1, 1):GetNormalized(),
    Vector3(-1, 0):GetNormalized(),
    Vector3( 1,-1):GetNormalized(),
    Vector3( 0, 1):GetNormalized(),
    Vector3(-1,-1):GetNormalized(),
    Vector3( 1, 0):GetNormalized(),
    Vector3(-1, 1):GetNormalized(),
}

local function Shake(self, duration, speed, scale)
    if self.shaking then return end
    self.shake_pos_start = Vector3(self.inst.UITransform:GetLocalPosition())
    self.shake_scale_start = self.inst.UITransform:GetScale()

    self.shake_timer = 0
    self.shake_speed = speed
    self.shake_duration = duration
    self.shake_scale = scale
    self.shaking = true

    self.inst:StartWallUpdatingComponent(self)
end

local old_OnWallUpdate
local function OnWallUpdate(self, dt)
    if self.shaking then
        self.shake_duration = self.shake_duration - dt
        if self.shake_duration > 0 then
            self.shake_timer = self.shake_timer + dt
            if self.shake_timer > self.shake_speed then

                local scale = GetRandomWithVariance(1, 0.1)
                self:MoveTo(Vector3(self.inst.UITransform:GetLocalPosition()), (self.shake_pos_start + (ShakeDeltas[math.random(#ShakeDeltas)] * self.shake_scale)), self.shake_speed)
                self:ScaleTo(self.inst.UITransform:GetScale(), self.shake_scale_start * scale, self.shake_speed)
                self.shake_timer = 0
            end
        else
            --Stop shaking...
            self:MoveTo(Vector3(self.inst.UITransform:GetLocalPosition()), self.shake_pos_start, self.shake_speed)
            self:ScaleTo(self.inst.UITransform:GetScale(), self.shake_scale_start, self.shake_speed)
            self.shaking = false
        end
    end
    old_OnWallUpdate(self, dt)

    if not self.scale_t and not self.pos_t and not self.tint_t and not self.rot_t and not self.shaking then
        self.inst:StopWallUpdatingComponent(self)
    else
        self.inst:StartWallUpdatingComponent(self)
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("uianim", function(cmp)


cmp.Shake = Shake
old_OnWallUpdate = cmp.OnWallUpdate
cmp.OnWallUpdate = OnWallUpdate


end)
%%+%%postinit/components/watercolor.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("watercolor", function(cmp)


local COLORS = UpvalueHacker.GetUpvalue(cmp.Initialize, "COLORS") or UpvalueHacker.GetUpvalue(cmp.OnPhaseChanged, "COLORS")

local Initialize_old = cmp.Initialize
function cmp:Initialize(...)
	if self.inst and self.inst:HasTag("island") then
		COLORS.default.color = {.5, .5, .4, 1} --gentle fog colour, not too bright
	end
	return Initialize_old(self, ...)
end


end)
%%+%%postinit/components/weapon.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function SetPoisonous(self) 
    self.stimuli = "poisonous" 
end

local _OnAttack
local function OnAttack(self, attacker, target, ...)
    _OnAttack(self, attacker, target, ...)
    
    if self.inst.components.obsidiantool then
        self.inst.components.obsidiantool:Use(attacker, target)
    end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("weapon", function(cmp)


cmp.SetPoisonous = SetPoisonous
_OnAttack = cmp.OnAttack
cmp.OnAttack = OnAttack


end)
%%+%%postinit/components/weather.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local easing = require("easing")

IAENV.AddComponentPostInit("weather", function(inst)



local _world = TheWorld
local _ismastersim = _world.ismastersim
local _activatedplayer = nil

inst.cannotsnow = _world:HasTag("island") --for TileState

--------------------------------------------------------------------------
--[[ constants ]]
--------------------------------------------------------------------------

--We could fetch the actual upvalues, if any mod adds precip or lightning modes -M
local PRECIP_MODE_NAMES =
{
    "dynamic",
    "always",
    "never",
}
local PRECIP_MODES = table.invert(PRECIP_MODE_NAMES)
local PRECIP_TYPE_NAMES =
{
    "none",
    "rain",
    "snow",
}
local PRECIP_TYPES = table.invert(PRECIP_TYPE_NAMES)
local LIGHTNING_MODE_NAMES =
{
    "rain",
    "snow",
    "any",
    "always",
    "never",
}
local LIGHTNING_MODES = table.invert(LIGHTNING_MODE_NAMES)

local PRECIP_RATE_SCALE = 10
local MIN_PRECIP_RATE = .1
--how fast clouds form
local MOISTURE_RATES = {
    MIN = {
        autumn = 0,
        winter = 3,
        spring = 3,
        summer = 0,
    },
    MAX = {
        autumn = 0.1,
        winter = 3.75,
        spring = 3.75,
        summer = -0.2, --I figured making it dry this way is more fun -M
    }
}

--When the ceil is reached, it starts raining (unit is average days till rain)
local MOISTURE_CEIL_MULTIPLIERS =
{
    autumn = 5.5,
    winter = 6,
    spring = 5.5,
    summer = 4,
}

--When the floor is reached, it stops raining
local MOISTURE_FLOOR_MULTIPLIERS =
{
    autumn = 1,
    winter = 0.5,
    spring = 0.25,
    summer = 1,
}

--POP is not used in SW, so I guessed some reasonable values -M
local PEAK_PRECIPITATION_RANGES =
{
    autumn = { min = 1.0, max = 1.0 },
    winter = { min = 0.8, max = 1.0 },
    spring = { min = 0.3, max = 0.9 },
    summer = { min = 1.0, max = 1.0 },
}
local DRY_THRESHOLD = TUNING.MOISTURE_DRY_THRESHOLD
local WET_THRESHOLD = TUNING.MOISTURE_WET_THRESHOLD
local MIN_WETNESS = 0
local MAX_WETNESS = 100
local MIN_WETNESS_RATE = 0
local MAX_WETNESS_RATE = .75
local MIN_DRYING_RATE = 0
local MAX_DRYING_RATE = .3
local OPTIMAL_DRYING_TEMPERATURE = 70
local WETNESS_SYNC_PERIOD = 10
local SNOW_LEVEL_SYNC_PERIOD = .1

local SEASON_DYNRANGE_DAY = {
    autumn = .05,
    winter = .3,
    spring = .35,
    summer = .05,
}
local SEASON_DYNRANGE_NIGHT = {
    autumn = 0,
    winter = .5,
    spring = .25,
    summer = 0,
}

--[[ Hurricane constants ]]
local GUST_PHASE_NAMES = {
	"calm", --in SW called "wait"
	"active",
	"rampup",
	"rampdown",
}
local GUST_PHASES = table.invert(GUST_PHASE_NAMES)

--------------------------------------------------------------------------

local _hailsound = false
local _windsound = false

local _rainfx
local _snowfx
local _pollenfx
local _hasfx = false
-- local function TryGetFX(player)
	-- local pt = player and player:GetPosition() or {x=0,y=0,z=0}
	-- for i,v in pairs( TheSim:FindEntities(pt.x, pt.y, pt.z, 1, {"FX"}) ) do
		-- if v.prefab then
			-- if v.prefab == "rain" then
				-- _rainfx = v
			-- elseif v.prefab == "snow" then
				-- _snowfx = v
			-- elseif v.prefab == "pollen" then
				-- _pollenfx = v
			-- end
		-- end
	-- end
	-- local _hasfx = _rainfx ~= nil
-- end
-- TryGetFX(ThePlayer)
for i,v in pairs( Ents ) do
	if v.prefab then
		if v.prefab == "rain" then
			_rainfx = v
		elseif v.prefab == "snow" then
			_snowfx = v
		elseif v.prefab == "pollen" then
			_pollenfx = v
		end
	end
end
local _hasfx = _rainfx ~= nil
local _hailfx = _hasfx and SpawnPrefab("hail") or nil

local _season = "autumn"
local _isIAClimate = false

--This is just a crude bandaid fix because other mods override inst.OnUpdate, but we need its upvalues -M
local trueOnUpdate = inst.LongUpdate
--local upvname, upvalue = debug.getupvalue(trueOnUpdate, 1) --TODO ideally loop through all using UpvalueHacker
--while upvname == "_OnUpdate" or upvname == "OnUpdate_old" do
	--trueOnUpdate = upvalue
	--upvname, upvalue = debug.getupvalue(trueOnUpdate, 1)
--end

local StopAmbientRainSound_old = UpvalueHacker.GetUpvalue(trueOnUpdate, "StopAmbientRainSound")
local StopTreeRainSound_old = UpvalueHacker.GetUpvalue(trueOnUpdate, "StopTreeRainSound")
local StopUmbrellaRainSound_old = UpvalueHacker.GetUpvalue(trueOnUpdate, "StopUmbrellaRainSound")
--TODO this should probably be generalised to "is regular climate"
local StopAmbientRainSound = function(...) if not _isIAClimate then StopAmbientRainSound_old(...) end end
local StopTreeRainSound = function(...) if not _isIAClimate then StopTreeRainSound_old(...) end end
local StopUmbrellaRainSound = function(...) if not _isIAClimate then StopUmbrellaRainSound_old(...) end end
UpvalueHacker.SetUpvalue(trueOnUpdate, StopAmbientRainSound, "StopAmbientRainSound")
UpvalueHacker.SetUpvalue(trueOnUpdate, StopTreeRainSound, "StopTreeRainSound")
UpvalueHacker.SetUpvalue(trueOnUpdate, StopUmbrellaRainSound, "StopUmbrellaRainSound")

local StartAmbientRainSound = UpvalueHacker.GetUpvalue(trueOnUpdate, "StartAmbientRainSound")
local StartTreeRainSound = UpvalueHacker.GetUpvalue(trueOnUpdate, "StartTreeRainSound")
local StartUmbrellaRainSound = UpvalueHacker.GetUpvalue(trueOnUpdate, "StartUmbrellaRainSound")
local SetWithPeriodicSync = UpvalueHacker.GetUpvalue(trueOnUpdate, "SetWithPeriodicSync")

local function StartAmbientHailSound(intensity)
    if not _hailsound then
        _hailsound = true
        _world.SoundEmitter:PlaySound("ia/amb/rain/islandhailAMB", "hail")
    end
    _world.SoundEmitter:SetParameter("hail", "intensity", intensity)
end

local function StopAmbientHailSound()
    if _hailsound then
        _hailsound = false
        _world.SoundEmitter:KillSound("hail")
    end
end

local function StartAmbientWindSound(intensity)
    if not _windsound then
        _windsound = true
        _world.SoundEmitter:PlaySound("ia/amb/rain/islandwindAMB", "wind")
    end
    _world.SoundEmitter:SetParameter("wind", "intensity", intensity)
end

local function StopAmbientWindSound()
    if _windsound then
        _windsound = false
        _world.SoundEmitter:KillSound("wind")
    end
end

--Master simulation
local _moisturerateval = _ismastersim and 1 or nil
local _moisturerateoffset = _ismastersim and 0 or nil
local _moistureratemultiplier = _ismastersim and 1 or nil
local _moistureceilmultiplier = _ismastersim and 1 or nil
local _moisturefloormultiplier = _ismastersim and 1 or nil
local _lightningtargets_island = _ismastersim and {} or nil
local _lightningmode = UpvalueHacker.GetUpvalue(trueOnUpdate, "_lightningmode")
--let's hope nobody notices that we basically generate twice as much lightning if both climates are active (unlikely)
local _minlightningdelay_island = nil
local _maxlightningdelay_island = nil
local _nextlightningtime_island = _ismastersim and 5 or nil

local _hurricane_gust_timer = 0.0 --needed by client for simulation
local _hurricane_gust_period = 0.0 --needed by client for simulation
local _hurricane_gust_angletimer = _ismastersim and 0.0 or nil
local _hurricanetease_start = _ismastersim and 0 or nil
local _hurricanetease_started = _ismastersim and false or nil


--Network
local _noisetime = UpvalueHacker.GetUpvalue(trueOnUpdate, "_noisetime")
local _moisture_island = net_float(inst.inst.GUID, "weather._moisture_island")
local _moisturerate_island = net_float(inst.inst.GUID, "weather._moisturerate_island")
local _moistureceil_island = net_float(inst.inst.GUID, "weather._moistureceil_island", "moistureceil_islanddirty")
local _moisturefloor_island = net_float(inst.inst.GUID, "weather._moisturefloor_island")
local _peakprecipitationrate_island = net_float(inst.inst.GUID, "weather._peakprecipitationrate_island")
local _wetness_island = net_float(inst.inst.GUID, "weather._wetness_island")
local _wet_island = net_bool(inst.inst.GUID, "weather._wet_island", "wet_islanddirty")
--this is "preciptype" except there's only rain on islands, so it can be a bool just fine
local _precipisland = net_bool(inst.inst.GUID, "weather._precipisland", "precipislanddirty")
local _precipmode = UpvalueHacker.GetUpvalue(trueOnUpdate, "_precipmode")
local _snowlevel = UpvalueHacker.GetUpvalue(trueOnUpdate, "_snowlevel")
local _lightningtargets = UpvalueHacker.GetUpvalue(trueOnUpdate, "_lightningtargets")
local _hurricane = net_bool(inst.inst.GUID, "weather._hurricane", "hurricanedirty")
local _hurricane_timer = net_float(inst.inst.GUID, "weather._hurricane_timer")
local _hurricane_duration = net_float(inst.inst.GUID, "weather._hurricane_duration")
local _hurricane_gust_speed = net_float(inst.inst.GUID, "weather._hurricane_gust_speed", "hurricane_gust_speeddirty")
--note: _hurricane_gust_angle is a net_ushortint, so it is only whole, positive numbers 
local _hurricane_gust_angle = net_ushortint(inst.inst.GUID, "weather._hurricane_gust_angle", "hurricane_gust_angledirty")
local _hurricane_gust_peak = net_float(inst.inst.GUID, "weather._hurricane_gust_peak")
local _hurricane_gust_state = net_tinybyte(inst.inst.GUID, "weather._hurricane_gust_state")

--------------------------------------------------------------------------
--[[ HURRICANE ]]
--------------------------------------------------------------------------

--TODO this has to be re-written to support client prediction better
local function UpdateHurricaneWind(dt)
	-- TheSim:ProfilerPush("hurricanewind")
	local percent = _hurricane_timer:value() / _hurricane_duration:value()
	if TUNING.HURRICANE_PERCENT_WIND_START <= percent and percent <= TUNING.HURRICANE_PERCENT_WIND_END then
		_hurricane_gust_timer = _hurricane_gust_timer + dt
		if _ismastersim then
			--TODO This should almost certainly be a DoTaskInTime -M
			--or test when exactly it changes in SW, might be cooler to make it change at sunset
			_hurricane_gust_angletimer = _hurricane_gust_angletimer + dt
			if _hurricane_gust_angletimer > 16*TUNING.SEG_TIME then		
				_hurricane_gust_angle:set(math.random(0,360))
				_hurricane_gust_angletimer = 0
			end
		end
		
		if _hurricane_gust_state:value() == GUST_PHASES.calm then
			_hurricane_gust_speed:set(0)
			if _hurricane_gust_timer >= _hurricane_gust_period then
				-- print("GUST Ramp up")
				_hurricane_gust_peak:set(GetRandomMinMax(TUNING.WIND_GUSTSPEED_PEAK_MIN, TUNING.WIND_GUSTSPEED_PEAK_MAX))
				_hurricane_gust_timer = 0.0
				_hurricane_gust_period = TUNING.WIND_GUSTRAMPUP_TIME
				_hurricane_gust_state:set(GUST_PHASES.rampup)
				-- self.inst:PushEvent("wind_rampup")
				-- self.inst:PushEvent("windguststart")
			end

		elseif _hurricane_gust_state:value() == GUST_PHASES.rampup then
			local peak = 0.5 * _hurricane_gust_peak:value()
			local gustspeed = -peak * math.cos(PI * _hurricane_gust_timer / _hurricane_gust_period) + peak
			SetWithPeriodicSync(_hurricane_gust_speed, gustspeed, 20, _ismastersim)
			if _hurricane_gust_timer >= _hurricane_gust_period then
				-- print("GUST Peak")
				_hurricane_gust_timer = 0.0
				_hurricane_gust_period = _ismastersim and GetRandomMinMax(TUNING.WIND_GUSTLENGTH_MIN, TUNING.WIND_GUSTLENGTH_MAX) or TUNING.WIND_GUSTLENGTH_MAX + 10
				_hurricane_gust_state:set(GUST_PHASES.active)
			end

		elseif _hurricane_gust_state:value() == GUST_PHASES.active then
			_hurricane_gust_speed:set(_hurricane_gust_peak:value())
			if _hurricane_gust_timer >= _hurricane_gust_period then
				-- print("GUST Ramp down")
				_hurricane_gust_timer = 0.0
				_hurricane_gust_period = TUNING.WIND_GUSTRAMPDOWN_TIME
				_hurricane_gust_state:set(GUST_PHASES.rampdown)
			end

		elseif _hurricane_gust_state:value() == GUST_PHASES.rampdown then
			local peak = 0.5 * _hurricane_gust_peak:value()
			local gustspeed = peak * math.cos(PI * _hurricane_gust_timer / _hurricane_gust_period) + peak
			SetWithPeriodicSync(_hurricane_gust_speed, gustspeed, 20, _ismastersim)
			if _hurricane_gust_timer >= _hurricane_gust_period then
				-- print("GUST Calm")
				_hurricane_gust_timer = 0.0
				_hurricane_gust_period = _ismastersim and GetRandomMinMax(TUNING.WIND_GUSTDELAY_MIN, TUNING.WIND_GUSTDELAY_MAX) or TUNING.WIND_GUSTDELAY_MAX + 10
				_hurricane_gust_state:set(GUST_PHASES.calm)
				-- self.inst:PushEvent("windgustend")
			end
		end
	else
		_hurricane_gust_timer = 0.0
		_hurricane_gust_speed:set(0.0)
	end
	-- TheSim:ProfilerPop()
end


local function StartHurricaneStorm(duration_override)
	if not _hurricane:value() then
		print("Hurricane start")
		_hurricane_timer:set(0)
		_hurricane_duration:set(duration_override or math.random(TUNING.HURRICANE_LENGTH_MIN, TUNING.HURRICANE_LENGTH_MAX))

		_hurricane_gust_speed:set(0.0)
		_hurricane_gust_timer = 0.0
		_hurricane_gust_period = 0.0 --GetRandomWithVariance(10.0, 4.0)
		_hurricane_gust_peak:set(0.0) --GetRandomWithVariance(0.5, 0.25)
		_hurricane_gust_state:set(GUST_PHASES.calm)
		
		_hurricane:set(true)
	end
end

local function StopHurricaneStorm()
	if _hurricane:value() then
		print("Hurricane stop")
		_hurricane_gust_speed:set(0.0)
		_hurricane_gust_timer = 0.0
		_hurricane_gust_period = 0.0
		_hurricane_gust_peak:set(0.0)
		_hurricane_gust_state:set(GUST_PHASES.calm)
		_hurricane:set(false)
	end
end

--dunno if we really need tease, since hurricane no longer triggers precip either way -M
-- local function StartHurricaneTease(duration_override)
	-- StartHurricaneStorm(duration_override)
-- end

-- local function StopHurricaneTease()
	-- StopHurricaneStorm()
-- end

--------------------------------------------------------------------------

local CalculateMoistureRate_Island = _ismastersim and function()
    return _moisturerateval * _moistureratemultiplier + _moisturerateoffset
end or nil

local RandomizeMoistureCeil_Island = _ismastersim and function()
    return (1 + math.random()) * TUNING.TOTAL_DAY_TIME * _moistureceilmultiplier
end or nil

local RandomizeMoistureFloor_Island = _ismastersim and function()
    return (.25 + math.random() * .5) * _moisture_island:value() * _moisturefloormultiplier
end or nil

local RandomizePeakPrecipitationRate_Island = _ismastersim and function(season)
    local range = PEAK_PRECIPITATION_RANGES[season]
    return range.min + math.random() * (range.max-range.min)
end or nil

local function CalculatePrecipitationRate_Island()
    if _precipmode:value() == PRECIP_MODES.always then
        return .1 + perlin(0, _noisetime:value() * .1, 0) * .9
    elseif _precipisland:value() and _precipmode:value() ~= PRECIP_MODES.never then
        local p = (_moisture_island:value() - _moisturefloor_island:value()) / (_moistureceil_island:value() - _moisturefloor_island:value())
		p = math.max(0, math.min(1, p))
        local rate = MIN_PRECIP_RATE + (1 - MIN_PRECIP_RATE) * math.sin(p * PI)
		-- if _hurricane:value() then
			-- rate = rate * TUNING.HURRICANE_RAIN_SCALE
		-- end
        return math.min(rate, _peakprecipitationrate_island:value())
    end
    return 0
end

local StartPrecipitation_Island = _ismastersim and function()
    _nextlightningtime_island = GetRandomMinMax(_minlightningdelay_island or 5, _maxlightningdelay_island or 15)
	_moisture_island:set(_moistureceil_island:value())
	_moisturefloor_island:set(RandomizeMoistureFloor_Island(_season))
	_peakprecipitationrate_island:set(RandomizePeakPrecipitationRate_Island(_season))
	_precipisland:set(true)
	if _season == "winter" then --should already be handled in OnUpdate
		StartHurricaneStorm()
	end
end or nil

local StopPrecipitation_Island = _ismastersim and function()
	_moisture_island:set(_moisturefloor_island:value())
	_moistureceil_island:set(RandomizeMoistureCeil_Island())
	_precipisland:set(false)
	-- StopHurricaneStorm() --uses _hurricane_timer instead
end or nil

--this is ONLY used in PushWeather
local function CalculatePOP_Island()
    return (_precipisland:value() and 1)
        or ((_moistureceil_island:value() <= 0 or _moisture_island:value() <= _moisturefloor_island:value()) and 0)
        or (_moisture_island:value() < _moistureceil_island:value() and (_moisture_island:value() - _moisturefloor_island:value()) / (_moistureceil_island:value() - _moisturefloor_island:value()))
        or 1
end

--this is ONLY used in PushWeather
local function CalculateLight_Island()
    if _precipmode:value() == PRECIP_MODES.never then
        return 1
    end
	
    local dynrange = _world.state.isday and SEASON_DYNRANGE_DAY[_season] or SEASON_DYNRANGE_NIGHT[_season]

    if _precipmode:value() == PRECIP_MODES.always then
        return 1 - dynrange
    end
    local p = 1 - math.min(math.max((_moisture_island:value() - _moisturefloor_island:value()) / (_moistureceil_island:value() - _moisturefloor_island:value()), 0), 1)
    if _precipisland:value() then
        p = easing.inQuad(p, 0, 1, 1)
    end
    return p * dynrange + 1 - dynrange
end

--this is ONLY called in OnUpdate
local function CalculateWetnessRate_Island(temperature, preciprate)
	return --Positive wetness rate when it's raining
		(_precipisland:value() and easing.inSine(preciprate, MIN_WETNESS_RATE, MAX_WETNESS_RATE, 1))
		--Negative drying rate when it's not raining
		or -math.clamp(easing.linear(temperature, MIN_DRYING_RATE, MAX_DRYING_RATE, OPTIMAL_DRYING_TEMPERATURE)
					+ easing.inExpo(_wetness_island:value(), 0, 1, MAX_WETNESS),
					.01, 1)
end

local function PushWeather_Island()
    local data =
    {
        moisture = _moisture_island:value(),
        pop = CalculatePOP_Island(),
        precipitationrate = CalculatePrecipitationRate_Island(),
        snowlevel = 0,
        wetness = _wetness_island:value(),
        light = CalculateLight_Island(),
		-- gustspeed = _hurricane_gust_speed:value(),
    }
	_world:PushEvent("islandweathertick", data)
	if not _ismastersim then --update visuals directly, probably the cause of some weird subtle bugs
		_world:PushEvent("weathertick", data)
	end
end

--------------------------------------------------------------------------
--[[ Event Callbacks ]]
--------------------------------------------------------------------------

local function OnSeasonTick_Island(src, data)
    _season = data.season

    if _ismastersim then
		--It rains less in the middle of summer
		local p = 1 - math.sin(PI * data.progress)
		_moisturerateval = MOISTURE_RATES.MIN[_season] + p * (MOISTURE_RATES.MAX[_season] - MOISTURE_RATES.MIN[_season])
		_moisturerateoffset = 0

        _moisturerate_island:set(CalculateMoistureRate_Island())
        _moistureceilmultiplier = MOISTURE_CEIL_MULTIPLIERS[_season] or MOISTURE_CEIL_MULTIPLIERS.autumn
        _moisturefloormultiplier = MOISTURE_FLOOR_MULTIPLIERS[_season] or MOISTURE_FLOOR_MULTIPLIERS.autumn
    end
end

local function OnPlayerActivated(src, player)
    _activatedplayer = player
    if _hasfx then
        _hailfx.entity:SetParent(player.entity)
		-- inst:OnUpdate(0)
		--TODO How to clear snowflakes if _isIAClimate?
		-- _snowfx.particles_per_tick = 0
		-- _snowfx:PostInit()
		-- _pollenfx.particles_per_tick = 0
		-- _pollenfx:PostInit()
    end
	-- player:DoTaskInTime(0,function() TryGetFX(player) end)
end

local function OnPlayerDeactivated(src, player)
    if _activatedplayer == player then
        _activatedplayer = nil
		if _hasfx then
			_hailfx.entity:SetParent(nil)
		end
    end
end

--These three are for lightning control in particular
local ChangeTable = _ismastersim and function(t1, t2, item)
	for i, v in ipairs(t1) do
		if v == item then
			table.remove(t1, i)
			--note: this makes item the last element in the ranking, so climate-hopping reduces your odds of getting struck by lightning
			table.insert(t2, item)
			return true
		end
	end
end

local OnClimateDirty = _ismastersim and function(player)
	if IsInIAClimate(player) then
		ChangeTable(_lightningtargets, _lightningtargets_island, player)
	else
		ChangeTable(_lightningtargets_island, _lightningtargets, player)
	end
end

local OnPlayerJoined = _ismastersim and function(src, player)
	if player then
		-- inst:DoTaskInTime(0, function()
			if IsInIAClimate(player) then
				--remove and add to our stalky update table or sth idk
				ChangeTable(_lightningtargets, _lightningtargets_island, player)
			end
		-- end)
		src:ListenForEvent("climatechange", OnClimateDirty, player)
	end
end or nil

local OnPlayerLeft = _ismastersim and function(src, player)
	if player then
		src:RemoveEventCallback("climatechange", OnClimateDirty, player)
	end
    for i, v in ipairs(_lightningtargets_island) do
        if v == player then
            table.remove(_lightningtargets_island, i)
            return
        end
    end
end or nil


local OnForcePrecipitation = _ismastersim and function(src, enable)
    _moisture_island:set(enable ~= false and _moistureceil_island:value() or _moisturefloor_island:value())
end or nil

local OnSetMoistureScale = _ismastersim and function(src, data)
    _moistureratemultiplier = data or _moistureratemultiplier
    _moisturerate_island:set(CalculateMoistureRate_Island())
end or nil

local OnDeltaMoisture = _ismastersim and function(src, delta)
    _moisture_island:set(math.min(math.max(_moisture_island:value() + delta, _moisturefloor_island:value()), _moistureceil_island:value()))
end or nil

local OnDeltaMoistureCeil = _ismastersim and function(src, delta)
    _moistureceil_island:set(math.max(_moistureceil_island:value() + delta, _moisturefloor_island:value()))
end or nil

local OnDeltaWetness = _ismastersim and function(src, delta)
    _wetness_island:set(math.clamp(_wetness_island:value() + delta, MIN_WETNESS, MAX_WETNESS))
end or nil

local OnSetLightningDelay = _ismastersim and function(src, data)
    if _precipisland:value() and data.min and data.max then
        _nextlightningtime_island = GetRandomMinMax(data.min, data.max)
    end
    _minlightningdelay_island = data.min
    _maxlightningdelay_island = data.max
end or nil

local ForceResync = _ismastersim and function(netvar)
    netvar:set_local(netvar:value())
    netvar:set(netvar:value())
end or nil
local OnSimUnpaused = _ismastersim and function()
    --Force resync values that client may have simulated locally
    ForceResync(_moisture_island)
    ForceResync(_wetness_island)
end or nil

local OnForceHurricane = _ismastersim and function(src, enable)
    if enable ~= _hurricane:value() then
		if enable then
			StartHurricaneStorm(type(enable) == "number" and enable or nil)
		else
			StopHurricaneStorm()
		end
	end
end or nil

local OnSetGustAngle = _ismastersim and function(src, angle)
	angle = angle % 360
    if angle ~= _hurricane_gust_angle:value() then
		_hurricane_gust_angle:set(angle)
	end
end or nil

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------

--Initialize network variables
_moisture_island:set(0)
_moisturerate_island:set(0)
_moistureceil_island:set(0)
_moisturefloor_island:set(0)
_precipisland:set(false)
_peakprecipitationrate_island:set(1)
_wetness_island:set(0)
_wet_island:set(false)

--Dedicated server does not need to spawn the local fx
if _hasfx then
    _hailfx.particles_per_tick = 0
    _hailfx.splashes_per_tick = 0
end

--Register events
inst.inst:ListenForEvent("seasontick", OnSeasonTick_Island, _world)
inst.inst:ListenForEvent("playeractivated", OnPlayerActivated, _world)
inst.inst:ListenForEvent("playerdeactivated", OnPlayerDeactivated, _world)

--Register network variable sync events (worldstate)
inst.inst:ListenForEvent("moistureceil_islanddirty", function() _world:PushEvent("moistureceil_islandchanged", _moistureceil_island:value()) end)
inst.inst:ListenForEvent("precipislanddirty", function() _world:PushEvent("precipitation_islandchanged", _precipisland:value()) end)
inst.inst:ListenForEvent("wet_islanddirty", function() _world:PushEvent("wet_islandchanged", _wet_island:value()) end)
inst.inst:ListenForEvent("hurricanedirty", function() _world:PushEvent("hurricanechanged", _hurricane:value()) end)
inst.inst:ListenForEvent("hurricane_gust_speeddirty", function() _world:PushEvent("gustspeedchanged", _hurricane_gust_speed:value()) end)
inst.inst:ListenForEvent("hurricane_gust_angledirty", function() _world:PushEvent("gustanglechanged", _hurricane_gust_angle:value()) end)

if _ismastersim then
    --Initialize master simulation variables
    _moisturerate_island:set(CalculateMoistureRate_Island())
    _moistureceil_island:set(RandomizeMoistureCeil_Island())

    --Register master simulation events
    inst.inst:ListenForEvent("ms_playerjoined", OnPlayerJoined, _world)
    inst.inst:ListenForEvent("ms_playerleft", OnPlayerLeft, _world)
    inst.inst:ListenForEvent("ms_forceprecipitation", OnForcePrecipitation, _world)
    inst.inst:ListenForEvent("ms_forceprecipitation_island", OnForcePrecipitation, _world)
    inst.inst:ListenForEvent("ms_setmoisturescale", OnSetMoistureScale, _world)
    inst.inst:ListenForEvent("ms_deltamoisture", OnDeltaMoisture, _world)
    inst.inst:ListenForEvent("ms_deltamoisture_island", OnDeltaMoisture, _world)
    inst.inst:ListenForEvent("ms_deltamoistureceil", OnDeltaMoistureCeil, _world)
    inst.inst:ListenForEvent("ms_deltawetness", OnDeltaWetness, _world)
    inst.inst:ListenForEvent("ms_setlightningdelay", OnSetLightningDelay, _world)
    inst.inst:ListenForEvent("ms_simunpaused", OnSimUnpaused, _world)
    inst.inst:ListenForEvent("ms_forcehurricane", OnForceHurricane, _world)
    inst.inst:ListenForEvent("ms_setgustangle", OnSetGustAngle, _world)
end

local OnRemoveEntity_old = inst.OnRemoveEntity
if _hasfx then function inst:OnRemoveEntity(...)
    if _hailfx.entity:IsValid() then
        _hailfx:Remove()
    end
    OnRemoveEntity_old(inst, ...)
end end


--[[
    Client updates temperature, moisture, precipitation effects, and snow
    level on its own while server force syncs values periodically. Client
    cannot start, stop, or change precipitation on its own, and must wait
    for server syncs to trigger these events.
--]]
local OnUpdate_old = inst.OnUpdate
function inst:OnUpdate(dt)
	_isIAClimate = _activatedplayer and IsInIAClimate(_activatedplayer)
	
	if _ismastersim
	and (_world:HasTag("island") or _world:HasTag("volcano"))
	and not _world:HasTag("forest") and not _world:HasTag("caves") then
		SetWithPeriodicSync(_snowlevel, 0, SNOW_LEVEL_SYNC_PERIOD, _ismastersim)
	end
	if _ismastersim or not _isIAClimate then
		OnUpdate_old(self, dt)
	else
		SetWithPeriodicSync(_noisetime, _noisetime:value() + dt, 30, _ismastersim)
	end
	
	if _ismastersim or _isIAClimate then
		local preciprate = CalculatePrecipitationRate_Island()
		
		if _hurricane:value() then
			SetWithPeriodicSync(_hurricane_timer, _hurricane_timer:value() + dt, 100, _ismastersim)
			if _hurricane_duration:value() <= _hurricane_timer:value() then
				StopHurricaneStorm()
			else
				UpdateHurricaneWind(dt)
			end
		end
		
		--Update moisture and toggle precipitation
		if _precipmode:value() == PRECIP_MODES.always then
			if _ismastersim and not _precipisland:value() then
				StartPrecipitation_Island()
			end
		elseif _precipmode:value() == PRECIP_MODES.never then
			if _ismastersim and _precipisland:value() then
				StopPrecipitation_Island()
			end
		elseif _precipisland:value() then
			--Dissipate moisture
			local delta = preciprate * dt * PRECIP_RATE_SCALE
			-- if _hurricane:value() then
				-- delta = delta * TUNING.HURRICANE_DISSIPATION_SCALE
			-- end
			local moisture = math.max(_moisture_island:value() - delta, 0)
			if moisture <= _moisturefloor_island:value() then
				if _ismastersim then
					StopPrecipitation_Island()
				else
					_moisture_island:set_local(math.min(_moisturefloor_island:value() + .001, _moisture_island:value()))
				end
			else
				if _ismastersim and _hurricane:value()
				and moisture <= (_moisturefloor_island:value() + TUNING.HURRICANE_GUST_END_MOISTURE) then
					StopHurricaneStorm() --TODO parallel to _hurricane_timer, can be removed once we better sync precip and hurricane times
				end
				SetWithPeriodicSync(_moisture_island, moisture, 100, _ismastersim)
			end
		elseif _moistureceil_island:value() > 0 then
			--Accumulate moisture
			local moisture = _moisture_island:value() + _moisturerate_island:value() * dt
			if moisture >= _moistureceil_island:value() then
				if _ismastersim then
					StartPrecipitation_Island()
				else
					_moisture_island:set_local(math.max(_moistureceil_island:value() - .001, _moisture_island:value()))
				end
			else
				if _ismastersim and not _hurricane:value() and _season == "winter"
				and moisture >= (_moistureceil_island:value() - TUNING.HURRICANE_GUST_START_MOISTURE) then
					StartHurricaneStorm()
				end
				SetWithPeriodicSync(_moisture_island, moisture, 100, _ismastersim)
			end
		end

		--Update wetness
		local wetrate = CalculateWetnessRate_Island(_world.state.islandtemperature, preciprate)
		SetWithPeriodicSync(_wetness_island, math.clamp(_wetness_island:value() + wetrate * dt, MIN_WETNESS, MAX_WETNESS), WETNESS_SYNC_PERIOD, _ismastersim)
		if _ismastersim then
			if _wet_island:value() then
				if _wetness_island:value() < DRY_THRESHOLD then
					_wet_island:set(false)
				end
			elseif _wetness_island:value() > WET_THRESHOLD then
				_wet_island:set(true)
			end
		end
		
		if _ismastersim then
            if _lightningmode == LIGHTNING_MODES.always or
                LIGHTNING_MODE_NAMES[_lightningmode] == PRECIP_TYPE_NAMES[_precipisland:value() and 2 or 1] or
				-- (LIGHTNING_MODE_NAMES.hurricane == _lightningmode and _hurricane
					-- and MIN_LIGHTNING_HURRICANE < _hurricane_percent and MAX_LIGHTNING_HURRICANE > _hurricane_percent) or
                (_lightningmode == LIGHTNING_MODES.any and _precipisland:value()) then
                if _nextlightningtime_island > dt then
                    _nextlightningtime_island = _nextlightningtime_island - dt
                else
					-- local lightning_preciprate = _hurricane:value() and math.max(.2, preciprate / TUNING.HURRICANE_RAIN_SCALE) or preciprate
					local lightning_preciprate = preciprate
                    local min = _minlightningdelay_island or easing.linear(lightning_preciprate, _hurricane:value() and 4 or 30, _hurricane:value() and -2 or 10, 1)
                    local max = _maxlightningdelay_island or (min + easing.linear(lightning_preciprate, _hurricane:value() and 8 or 30, _hurricane:value() and -4 or 10, 1))
					_nextlightningtime_island = GetRandomMinMax(min, max)
                    if (lightning_preciprate > .75 or _lightningmode == LIGHTNING_MODES.always) and next(_lightningtargets_island) ~= nil
					and (not _hurricane:value() or math.random() < TUNING.HURRICANE_LIGHTNING_STRIKE_CHANCE) then
                        local targeti = math.min(math.floor(easing.inQuint(math.random(), 1, #_lightningtargets_island, 1)), #_lightningtargets_island)
                        local target = _lightningtargets_island[targeti]
                        table.remove(_lightningtargets_island, targeti)
                        table.insert(_lightningtargets_island, target)

                        local x, y, z = target.Transform:GetWorldPosition()
                        local radius = 2 + math.random() * 8
                        local theta = math.random() * 2 * PI
                        local pos = Vector3(x + radius * math.cos(theta), y, z + radius * math.sin(theta))
                        _world:PushEvent("ms_sendlightningstrike", pos)
                    else
                        SpawnPrefab(lightning_preciprate > .5 and "thunder_close" or "thunder_far")._islandthunder:set(true)
                    end
                end
            end
		end
		
		if _isIAClimate then
			
			--Update precipitation effects
			if _precipisland:value() then
				local preciprate_sound = preciprate
				if _activatedplayer == nil then
					StartTreeRainSound(0)
					StopUmbrellaRainSound_old()
				elseif _activatedplayer.replica.sheltered ~= nil and _activatedplayer.replica.sheltered:IsSheltered() then
					StartTreeRainSound(preciprate_sound)
					StopUmbrellaRainSound_old()
					preciprate_sound = preciprate_sound - .4
				else
					StartTreeRainSound(0)
					if _activatedplayer.replica.inventory:EquipHasTag("umbrella") then
						preciprate_sound = preciprate_sound - .4
						StartUmbrellaRainSound()
					else
						StopUmbrellaRainSound_old()
					end
				end
				StartAmbientRainSound(preciprate_sound)
				if _hurricane:value() then --TODO and not volcano
					StartAmbientHailSound(preciprate_sound)
				end
				if _hasfx then
					_rainfx.particles_per_tick = 5 * preciprate
					_rainfx.splashes_per_tick = 2 * preciprate
					if _hurricane:value() then --TODO and not volcano
						_hailfx.particles_per_tick = 5 * preciprate
						_hailfx.splashes_per_tick = 4 * preciprate
					else
						_hailfx.particles_per_tick = 0
						_hailfx.splashes_per_tick = 0
					end
				end
			else
				StopAmbientHailSound()
				StopAmbientRainSound_old()
				StopTreeRainSound_old()
				StopUmbrellaRainSound_old()
				if _hasfx then
					_rainfx.particles_per_tick = 0
					_rainfx.splashes_per_tick = 0
					_hailfx.particles_per_tick = 0
					_hailfx.splashes_per_tick = 0
				end
			end
			
			if _hurricane_gust_speed:value() > 0 then
				StartAmbientWindSound(_hurricane_gust_speed:value())
			else
				StopAmbientWindSound()
			end
			
			--Update pollen
			if _hasfx then
				_pollenfx.particles_per_tick = 0
				_snowfx.particles_per_tick = 0
			end
		end
		
		PushWeather_Island()
	end
	
	if not _isIAClimate and _hasfx then
		--no hail outside the islands climate
		_hailfx.particles_per_tick = 0
		_hailfx.splashes_per_tick = 0
		StopAmbientHailSound()
		StopAmbientWindSound()
	end
	
end

inst.LongUpdate = inst.OnUpdate

local OnSave_old = inst.OnSave
if OnSave_old then function inst:OnSave()
	local t = OnSave_old(self)
	t.moisturerateval_island = _moisturerateval
	t.moisturerateoffset_island = _moisturerateoffset
	t.moistureratemultiplier_island = _moistureratemultiplier
	t.moisturerate_island = _moisturerate_island:value()
	t.moisture_island = _moisture_island:value()
	t.moisturefloor_island = _moisturefloor_island:value()
	t.moistureceilmultiplier_island = _moistureceilmultiplier
	t.moisturefloormultiplier_island = _moisturefloormultiplier
	t.moistureceil_island = _moistureceil_island:value()
	t.precipisland = _precipisland:value() or nil
	t.peakprecipitationrate_island = _peakprecipitationrate_island:value()
	t.minlightningdelay_island = _minlightningdelay_island
	t.maxlightningdelay_island = _maxlightningdelay_island
	t.nextlightningtime_island = _nextlightningtime_island
	t.wetness_island = _wetness_island:value()
	t.wet_island = _wet_island:value() or nil
	t.hurricane_timer= _hurricane and _hurricane:value() and _hurricane_timer:value() or nil
	t.hurricane_duration = _hurricane and _hurricane:value() and _hurricane_duration:value() or nil
	t.hurricane_gust_angle = _hurricane_gust_angle:value() or nil
    return t
end end

local OnLoad_old = inst.OnLoad
if OnLoad_old then function inst:OnLoad(data)
	OnLoad_old(self, data)
    _season = data.season or "autumn"
    _moisturerateval = data.moisturerateval_island or 1
    _moisturerateoffset = data.moisturerateoffset_island or 0
    _moistureratemultiplier = data.moistureratemultiplier_island or 1
    _moisturerate_island:set(data.moisturerate_island or CalculateMoistureRate_Island())
    _moisture_island:set(data.moisture_island or 0)
    _moisturefloor_island:set(data.moisturefloor_island or 0)
    _moistureceilmultiplier = data.moistureceilmultiplier_island or 1
    _moisturefloormultiplier = data.moisturefloormultiplier_island or 1
    _moistureceil_island:set(data.moistureceil_island or RandomizeMoistureCeil_Island())
    _precipisland:set(data.precipisland == true)
    _peakprecipitationrate_island:set(data.peakprecipitationrate_island or 1)
    _minlightningdelay_island = data.minlightningdelay_island
    _maxlightningdelay_island = data.maxlightningdelay_island
    _nextlightningtime_island = data.nextlightningtime_island or 5
    _wetness_island:set(data.wetness_island or 0)
    _wet_island:set(data.wet_island == true)
	_hurricane_gust_angle:set(data.hurricane_gust_angle or math.random(0, 360))
	if data.hurricane_duration and data.hurricane_timer then
		StartHurricaneStorm(data.hurricane_duration)
		_hurricane_timer:set(data.hurricane_timer or 0)
	end
	
	PushWeather_Island()
end end


function inst:GetIADebugString()
    local preciprate = CalculatePrecipitationRate_Island()
    local wetrate = CalculateWetnessRate_Island(_world.state.islandtemperature, preciprate)
    local str =
    {
        string.format("moisture:%2.2f(%2.2f/%2.2f) + %2.2f", _moisture_island:value(), _moisturefloor_island:value(), _moistureceil_island:value(), _moisturerate_island:value()),
        string.format("preciprate:(%2.2f of %2.2f)", preciprate, _peakprecipitationrate_island:value()),
        string.format("wetness:%2.2f(%s%2.2f)%s", _wetness_island:value(), wetrate > 0 and "+" or "", wetrate, _wet_island:value() and " WET" or ""),
        string.format("lightning:%2.2f (%s)", _nextlightningtime_island, LIGHTNING_MODE_NAMES[_lightningmode]),
        string.format("hurricane:%2.2f/%2.2f(%s)", _hurricane_timer:value(), _hurricane_duration:value(), GUST_PHASE_NAMES[_hurricane_gust_state:value()] or "unknown gust phase"),
    }
	
    return table.concat(str, ", ")
end


end)
%%+%%postinit/components/wildfires.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("wildfires", function(cmp)


local ForceWildfireForPlayer
local LightFireForPlayer_old
for i, v in ipairs(cmp.inst.event_listening["ms_lightwildfireforplayer"][cmp.inst]) do
	LightFireForPlayer_old = UpvalueHacker.GetUpvalue(v, "LightFireForPlayer")
	if LightFireForPlayer_old then
		ForceWildfireForPlayer = v
		break
	end
end

local _scheduledtasks = UpvalueHacker.GetUpvalue(LightFireForPlayer_old, "_scheduledtasks")


local function LightFireForPlayer(player, rescheduleFn)
	if IsInIAClimate(player) then
		_scheduledtasks[player] = nil
		rescheduleFn(player)
	else
		LightFireForPlayer_old(player, rescheduleFn)
	end
end

UpvalueHacker.SetUpvalue(ForceWildfireForPlayer, LightFireForPlayer, "LightFireForPlayer")


end)
%%+%%postinit/components/wisecracker.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function bermudatriangleexit(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_WORMHOLE"))
end
local function crab_fail(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_CRAB_ESCAPE"))
end
local function trawl_full(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_TRAWL_FULL"))
end
local function boat_damaged(inst, data)
	inst.components.talker:Say(GetString(inst, data.message))
end
local function boostbywave(inst, data)
    if not inst.last_wave_boost_talk or GetTime() - inst.last_wave_boost_talk > TUNING.SEG_TIME * 3 then
        inst.last_wave_boost_talk = GetTime()
        inst.components.talker:Say(GetString(inst, "ANNOUNCE_WAVE_BOOST"))
    end
end
local function whalehuntlosttrail(inst, data)
	if data.washedaway then
		inst.components.talker:Say(GetString(inst, "ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING"))
	else
		inst.components.talker:Say(GetString(inst, "ANNOUNCE_WHALE_HUNT_LOST_TRAIL"))
	end
end
local function whalehuntbeastnearby(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_WHALE_HUNT_BEAST_NEARBY"))
end
local function treasureuncover(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_TREASURE_DISCOVER"))
end
local function magic_fail(inst, data)
	inst.components.talker:Say(GetString(inst, "ANNOUNCE_MAGIC_FAIL"))
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddComponentPostInit("wisecracker", function(cmp)


cmp.inst:ListenForEvent("bermudatriangleexit", bermudatriangleexit)
cmp.inst:ListenForEvent("crab_fail", crab_fail)
cmp.inst:ListenForEvent("trawl_full", trawl_full)
cmp.inst:ListenForEvent("boat_damaged", boat_damaged)
cmp.inst:ListenForEvent("boostbywave", boostbywave)
cmp.inst:ListenForEvent("whalehuntlosttrail", whalehuntlosttrail)
cmp.inst:ListenForEvent("whalehuntbeastnearby", whalehuntbeastnearby)
cmp.inst:ListenForEvent("treasureuncover", treasureuncover)
-- This is just for the volcano staff used underground
cmp.inst:ListenForEvent("magic_fail", magic_fail)


end)
%%+%%postinit/components/witherable.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local function onvolcanic(self, volcanic)
    if volcanic then
        self.inst:AddTag("witherable_volcanic")
    else
        self.inst:RemoveTag("witherable_volcanic")
    end
end

local function onoceanic(self, oceanic)
    if oceanic then
        self.inst:AddTag("witherable_oceanic")
    else
        self.inst:RemoveTag("witherable_oceanic")
    end
end

IAENV.AddComponentPostInit("witherable", function(cmp)

addsetter(cmp, "volcanic", onvolcanic)
addsetter(cmp, "oceanic", onoceanic)

cmp.volcanic = false
cmp.oceanic = false


local _WitherHandler = UpvalueHacker.GetUpvalue(cmp.ForceWither, "WitherHandler")

local DoCropWither = UpvalueHacker.GetUpvalue(_WitherHandler, "DoCropWither")
local DoPickableWither = UpvalueHacker.GetUpvalue(_WitherHandler, "DoPickableWither")

local function DoHackableWither(inst, self)
    local hackable = inst.components.hackable
    if hackable == nil then
        return false
    end

    self.restore_cycles = hackable.cycles_left
    if not hackable:IsBarren() then
        hackable:MakeBarren()
    end
    return true
end

local function WitherHandler(target, self, force)
    local _temperature = rawget(TheWorld.state, "temperature")
    if IsInIAClimate(self.inst) then
        TheWorld.state.temperature = TheWorld.state.islandtemperature
    end
	if self.volcanic then
		self.task = nil
		self.task_to_time = nil

		if not (force or (TheWorld.state.temperature <= self.wither_temp)) then
			--Reschedule
			self:Start()
		else
			self.withered = true
			if DoCropWither(self.inst, self) or DoPickableWither(self.inst, self) or DoHackableWither(self.inst, self) then
				self:DelayRejuvenate(TUNING.TOTAL_DAY_TIME)
			else
				print("Failed to wither "..tostring(self.inst))
			end
		end
	elseif target.components.hackable then
        self.task = nil
        self.task_to_time = nil

         --This is one of two lines we needed to change for temperature
        if force or (not TheWorld.state.israining and TheWorld.state.temperature > self.wither_temp) then
            self.withered = true
            if DoHackableWither(self.inst, self) then
                self:DelayRejuvenate(TUNING.TOTAL_DAY_TIME)
            else
                print("Failed to wither "..tostring(self.inst))
            end
        else
            --Reschedule
            self:Start()
        end
    else
        _WitherHandler(target, self, force)
    end
    TheWorld.state.temperature = _temperature
end


UpvalueHacker.SetUpvalue(cmp.ForceWither, WitherHandler, "WitherHandler")

local _RejuvenateHandler = UpvalueHacker.GetUpvalue(cmp.ForceRejuvenate, "RejuvenateHandler")

local DoPickableRejuvenate = UpvalueHacker.GetUpvalue(_RejuvenateHandler, "DoPickableRejuvenate")

local function DoHackableRejuvenate(inst, self)
    local hackable = inst.components.hackable
    if hackable == nil then
        return false
    end
    if self.restore_cycles ~= nil then
        hackable.cycles_left = math.max(hackable.cycles_left or 0, self.restore_cycles)
        self.restore_cycles = nil
    else
        hackable.cycles_left = nil
    end
    if not hackable:IsBarren() then
        hackable:MakeEmpty()
    end
    return true
end

local function RejuvenateHandler(target, self, force)
    local _temperature = rawget(TheWorld.state, "temperature")
    if IsInIAClimate(self.inst) then
        TheWorld.state.temperature = TheWorld.state.islandtemperature
    end
	if self.volcanic then
		self.task = nil
		self.task_to_time = nil

		if not (force or TheWorld.state.temperature >= self.wither_temp) then
			--Reschedule
			self:Start()
		elseif DoPickableRejuvenate(self.inst, self) or DoHackableRejuvenate(self.inst, self) then
			self.withered = false
			self:DelayWither(15)
		else
			self.withered = false
			print("Failed to rejuvenate "..tostring(self.inst))
		end
	elseif target.components.hackable then
        self.task = nil
        self.task_to_time = nil

        if not (force or TheWorld.state.temperature < self.rejuvenate_temp or TheWorld.state.israining) then
            --Reschedule
            self:Start()
        elseif DoHackableRejuvenate(self.inst, self) then
            self.withered = false
            self:DelayWither(15)
        else
            self.withered = false
            print("Failed to rejuvenate "..tostring(self.inst))
        end
    else
        _RejuvenateHandler(target, self, force)
    end
    TheWorld.state.temperature = _temperature
end

--TODO sure this needs to be set everytime? -M
UpvalueHacker.SetUpvalue(cmp.ForceRejuvenate, RejuvenateHandler, "RejuvenateHandler")


end)
%%+%%postinit/components/worldstate.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddComponentPostInit("worldstate", function(cmp)

--------------------------------------------------------------------------
--[[ Private member functions ]]
--------------------------------------------------------------------------

local SetVariable
for i, v in ipairs(cmp.inst.event_listening["temperaturetick"][TheWorld]) do
	SetVariable = UpvalueHacker.GetUpvalue(v, "SetVariable")
	if SetVariable then
		break
	end
end
if not SetVariable then return end

--------------------------------------------------------------------------
--[[ Private event handlers ]]
--------------------------------------------------------------------------

local function OnIslandTemperatureTick(src, temperature)
    SetVariable("islandtemperature", temperature)
end

local function OnIslandWeatherTick(src, data)
    SetVariable("islandmoisture", data.moisture)
    SetVariable("islandpop", data.pop)
    SetVariable("islandprecipitationrate", data.precipitationrate)
    SetVariable("islandwetness", data.wetness)
    -- SetVariable("gustspeed", data.gustspeed)
end

local function OnIslandMoistureCeilChanged(src, moistureceil)
    SetVariable("islandmoistureceil", moistureceil)
end

local function OnIslandPrecipitationChanged(src, rain)
    SetVariable("islandisraining", rain, "islandrain")
end

local function OnIslandWetChanged(src, wet)
    SetVariable("islandiswet", wet)
end

local function OnHurricaneChanged(src, b)
    SetVariable("hurricane", b)
end

local function OnGustSpeedChanged(src, speed)
    SetVariable("gustspeed", speed)
end

local function OnGustAngleChanged(src, angle)
    SetVariable("gustangle", angle)
end

--------------------------------------------------------------------------
--[[ Initialization ]]
--------------------------------------------------------------------------
--[[
    World state variables are initialized to default values that can be
    used by entities if there are no world components controlling those
    variables.  e.g. If there is no season component on the world, then
    everything will run in autumn state.
--]]

cmp.data.islandtemperature = TUNING.STARTING_TEMP
cmp.data.islandmoisture = 0
cmp.data.islandpop = 0
cmp.data.islandprecipitationrate = 0
cmp.data.islandwetness = 0
cmp.data.islandmoistureceil = 0
cmp.data.islandisraining = false
cmp.data.islandiswet = false
cmp.data.hurricane = false
cmp.data.gustspeed = 0
cmp.data.gustangle = 0

cmp.inst:ListenForEvent("islandtemperaturetick", OnIslandTemperatureTick)
cmp.inst:ListenForEvent("islandweathertick", OnIslandWeatherTick)
cmp.inst:ListenForEvent("moistureceil_islandchanged", OnIslandMoistureCeilChanged)
cmp.inst:ListenForEvent("precipitation_islandchanged", OnIslandPrecipitationChanged)
cmp.inst:ListenForEvent("wet_islandchanged", OnIslandWetChanged)
cmp.inst:ListenForEvent("hurricanechanged", OnHurricaneChanged)
cmp.inst:ListenForEvent("gustspeedchanged", OnGustSpeedChanged)
cmp.inst:ListenForEvent("gustanglechanged", OnGustAngleChanged)

cmp.inst:ListenForEvent("snowcoveredchanged", function(inst, show)
    TheSim:HideAnimOnEntitiesWithTag("Climate_island", "snow")
    TheSim:HideAnimOnEntitiesWithTag("Climate_volcano", "snow")
end)


end)
%%+%%postinit/prefabs/ash.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("ash", function(inst)


if TheWorld.ismastersim then

	inst:AddComponent("fertilizer")
	inst.components.fertilizer.fertilizervalue = TUNING.POOP_FERTILIZE
	inst.components.fertilizer.soil_cycles = TUNING.POOP_SOILCYCLES
	inst.components.fertilizer.withered_cycles = TUNING.POOP_WITHEREDCYCLES
	inst.components.fertilizer:MakeVolcanic()
	
end


end)%%+%%postinit/prefabs/book_birds.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local onread_old
local function onread(inst, reader, ...)
    if TheWorld.state.iswinter and IsInIAClimate(reader) then
        return false, "NOBIRDS"
    end
	return onread_old(inst, reader, ...)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("book_birds", function(inst)


if TheWorld.ismastersim then

	onread_old = inst.components.book.onread
	inst.components.book.onread = onread
	
end


end)
%%+%%postinit/prefabs/book_gardening.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function trygrowhackable(inst)
	if inst:IsInLimbo()
		or (inst.components.witherable ~= nil
			and inst.components.witherable:IsWithered()) then
		return
	end

	if inst.components.hackable ~= nil then
		if inst.components.hackable:CanBeHacked() and inst.components.hackable.caninteractwith then
			return
		end
		inst.components.hackable:FinishGrowing()
	end
end

local onread_old
local function onread(inst, reader, ...)
	local ret = onread_old(inst, reader, ...)
	if ret then -- should another mod make this book fail, then play along
		local x, y, z = reader.Transform:GetWorldPosition()
		local range = 30
		local ents = TheSim:FindEntities(x, y, z, range, nil, { "pickable", "stump", "withered", "INLIMBO" })
		if #ents > 0 then
			trygrowhackable(table.remove(ents, math.random(#ents)))
			if #ents > 0 then
				local timevar = 1 - 1 / (#ents + 1)
				for i, v in ipairs(ents) do
					v:DoTaskInTime(timevar * math.random(), trygrowhackable)
				end
			end
		end
	end
	return ret
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("book_gardening", function(inst)


if TheWorld.ismastersim then

	onread_old = inst.components.book.onread
	inst.components.book.onread = onread
	
end


end)
%%+%%postinit/prefabs/cactus.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _makeemptyfn
local function makeemptyfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _makeemptyfn then _makeemptyfn(inst, ...) end
end
local function makeemptyfn_hackable(inst)
	inst.components.pickable:MakeEmpty() -- This does everything for us
end

local _makebarrenfn
local function makebarrenfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _makebarrenfn then _makebarrenfn(inst, ...) end
end
local function makebarrenfn_hackable(inst)
	inst.components.pickable:MakeBarren() -- This does everything for us
end

local _onpickedfn
local function onpickedfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _onpickedfn then _onpickedfn(inst, ...) end
end

local function onfinishfn_hackable(inst, doer, loot)
	doer.SoundEmitter:PlaySound("dontstarve/wilson/harvest_sticks")
	if inst.has_flower and doer and doer.components.inventory then
		local flower = SpawnPrefab("cactus_flower")
		if flower then
			if flower.components.inventoryitem then
				flower.components.inventoryitem:InheritMoisture(TheWorld.state.wetness, TheWorld.state.iswet)
			end
			doer.components.inventory:GiveItem(flower, nil, inst:GetPosition())
		end
	end
	inst.components.pickable:Pick(inst) -- Purposefully no valid doer given to avoid damage & double loot
end

local _onregenfn
local function onregenfn(inst, ...)
	inst.components.hackable:Regen()
	if _onregenfn then _onregenfn(inst, ...) end
end

----------------------------------------------------------------------------------------

local function postinitfn(inst)


if TheWorld.ismastersim then

	inst:AddComponent("hackable")
	inst.components.hackable:SetUp("cactus_meat")
	inst.components.hackable.max_cycles = 127 -- dirty, but realistically speaking, never reached anyways
	inst.components.hackable.cycles_left = 127
	inst.components.hackable.hacksleft = 1
	inst.components.hackable.maxhacks = 1
	
	_makeemptyfn = inst.components.pickable.makeemptyfn
	inst.components.pickable.makeemptyfn = makeemptyfn
	inst.components.hackable.makeemptyfn = makeemptyfn_hackable
	
	_makebarrenfn = inst.components.pickable.makebarrenfn
	inst.components.pickable.makebarrenfn = makebarrenfn
	inst.components.hackable.makebarrenfn = makebarrenfn_hackable
	
	_onpickedfn = inst.components.pickable.onpickedfn
	inst.components.pickable.onpickedfn = onpickedfn
	
	inst.components.hackable.onfinishfn = onfinishfn_hackable
	
	_onregenfn = inst.components.pickable.onregenfn
	inst.components.pickable.onregenfn = onregenfn
	
end


end

IAENV.AddPrefabPostInit("cactus", postinitfn)
IAENV.AddPrefabPostInit("oasis_cactus", postinitfn)
%%+%%postinit/prefabs/campfire.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function makepostinitfn(rainrate, floodrate, windrate)
	
	local updatefn_old
	local function updatefn(inst)
		if IsInIAClimate(inst) then
			inst.components.fueled.rate = 1
				+ rainrate * TheWorld.state.islandprecipitationrate
				+ (inst:HasTag("flooded") and floodrate or 0)
				+ windrate * TheWorld.state.gustspeed
		else
			updatefn_old(inst)
		end
	end

	----------------------------------------------------------------------------------------

	return function(inst)


	inst:AddComponent("floodable")

	if TheWorld.ismastersim then

		inst.components.floodable:SetFX(nil, .5) --update faster

		if inst.components.fueled and inst.components.fueled.updatefn then
			updatefn_old = inst.components.fueled.updatefn
			inst.components.fueled.updatefn = updatefn
			--We should be editing sectionfn too, but that's just one update period (a second) per section.
		end
		
	end


	end
	
end


IAENV.AddPrefabPostInit("campfire", makepostinitfn(TUNING.CAMPFIRE_RAIN_RATE, TUNING.CAMPFIRE_FLOOD_RATE, TUNING.CAMPFIRE_WIND_RATE))
IAENV.AddPrefabPostInit("firepit", makepostinitfn(TUNING.FIREPIT_RAIN_RATE, TUNING.CAMPFIRE_FLOOD_RATE, TUNING.CAMPFIRE_WIND_RATE))
IAENV.AddPrefabPostInit("coldfire", makepostinitfn(TUNING.COLDFIRE_RAIN_RATE, TUNING.COLDFIRE_FLOOD_RATE, TUNING.COLDFIRE_WIND_RATE))
IAENV.AddPrefabPostInit("coldfirepit", makepostinitfn(TUNING.COLDFIREPIT_RAIN_RATE, TUNING.COLDFIRE_FLOOD_RATE, TUNING.COLDFIRE_WIND_RATE))
%%+%%postinit/prefabs/chester.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("chester", function(inst)
	
	
	inst.Physics:CollidesWith(COLLISION.WAVES)
	
	
end)
%%+%%postinit/prefabs/chester_eyebone.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onSinkRescue(self, oldpt, newowner)
	for chester, v in pairs(self.components.leader.followers) do
		local pt = self:GetPosition()
		if newowner then
			pt = newowner:GetPosition()
		end
		chester.Transform:SetPosition(pt.x, pt.y, pt.z)
		if newowner and newowner:HasTag("aquatic") then
			chester:RemoveFromScene()
		else
			chester:ReturnToScene()
		end
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("chester_eyebone", function(inst)


if TheWorld.ismastersim then

	inst.onSinkRescue = onSinkRescue
	
end


end)
%%+%%postinit/prefabs/cookpot.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onStartFlooded(inst)
	if inst.components.container then
		inst.components.container.canbeopened = false
		inst.components.container:Close()
	end
	if inst.components.stewer and inst.components.stewer:IsCooking() then
		inst.components.stewer.product = "wetgoop"
	end
end

local function onStopFlooded(inst)
	if inst.components.container then
		inst.components.container.canbeopened = true 
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("cookpot", function(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

end


end)
%%+%%postinit/prefabs/dirtpile.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local function dohack(inst)
	-- This section is actually a Hunter component postinit
	-- Need to wait a tick for Hunter to set the callback
	if inst._ondirtremove and not rawget(_G, "IA_DIRTPILE_UPVALUEHACKED") then
		-- This fails quiet if something is awry
		local old_GetSpawnPoint = UpvalueHacker.GetUpvalue(inst._ondirtremove, "ResetHunt", "StartCooldown", "OnCooldownEnd", "BeginHunt", "OnUpdateHunt", "StartDirt", "SpawnDirt", "GetSpawnPoint")
		if old_GetSpawnPoint then
			
			local function IsValidLand(pt)
				local tile = TheWorld.Map:GetTileAtPoint(pt.x, pt.y, pt.z)
				return not IsWater(tile)
			end

			local function GetSpawnPoint(pt, radius, hunt)
				local spawn_point = old_GetSpawnPoint(pt, radius, hunt)
				if spawn_point and IsValidLand(spawn_point) then
					return spawn_point
				end
			end
			UpvalueHacker.SetUpvalue(inst._ondirtremove, GetSpawnPoint, "ResetHunt", "StartCooldown", "OnCooldownEnd", "BeginHunt", "OnUpdateHunt", "StartDirt", "SpawnDirt", "GetSpawnPoint")

			local function GetRunAngle(pt, angle, radius)
				local offset, result_angle = FindWalkableOffset(pt, angle, radius, 14, true, false, IsValidLand)
				return result_angle
			end
			UpvalueHacker.SetUpvalue(inst._ondirtremove, GetRunAngle, "ResetHunt", "StartCooldown", "OnCooldownEnd", "BeginHunt", "OnUpdateHunt", "StartDirt", "GetNextSpawnAngle", "GetRunAngle")
			
			rawset(_G, "IA_DIRTPILE_UPVALUEHACKED", true)
			
		end
	end
	
	
	-- Failsafe (the first dirt can spawn on water, but that is usually a fresh hunt, so it doesn't matter)
	if inst:GetIsOnWater() or IsInIAClimate(inst) then
		inst:Remove()
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("dirtpile", function(inst)


if TheWorld.ismastersim then

	inst:DoTaskInTime(0, dohack)
	
end


end)
%%+%%postinit/prefabs/eel.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("eel", function(inst)


inst:AddTag("fishmeat")
-- inst:AddTag("packimfood")

if TheWorld.ismastersim then

    if inst.components.tradable then
		inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
	end
	
	inst:AddComponent("appeasement")
	inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_TINY
	
end


end)
%%+%%postinit/prefabs/fireflies.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------
-- TheWorld:PushEvent("ms_setphase","night")

local needtoupvaluehack = true

local updatelight_old
local fadeout

local function updatelight( inst, ... )
	if TheWorld.state.iswinter and IsInIAClimate(inst) then
		if fadeout then
			return fadeout( inst, ... )
		end
	else
		return updatelight_old( inst, ... )
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("fireflies", function(inst)


if TheWorld.ismastersim then

	if needtoupvaluehack then

		updatelight_old = UpvalueHacker.GetUpvalue(inst.components.inventoryitem.ondropfn, "updatelight")
		if updatelight_old then

			fadeout = UpvalueHacker.GetUpvalue(updatelight_old, "fadeout") or fadeout
			UpvalueHacker.SetUpvalue(inst.components.inventoryitem.ondropfn, updatelight, "updatelight")

			needtoupvaluehack = fadeout == nil

		end
	end

end


end)
%%+%%postinit/prefabs/firesuppressor.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

-- local CanInteract_old
-- local function CanInteract(inst)
	-- return CanInteract_old(inst) and not inst:HasTag("flooded")
-- end

local function onStartFlooded(inst)
	--trick the machine into thinking it's out of juice
	local lying = not inst:HasTag("fueldepleted")
	if lying then inst:AddTag("fueldepleted") end
	
	inst.components.machine:TurnOff()
	inst:AddTag("alwayson") --seems unused, so hopefully this won't clash with anything
	
	if lying then inst:RemoveTag("fueldepleted") end
end

local function onStopFlooded(inst)
	inst:RemoveTag("alwayson")
	if inst.components.firedetector then
		inst.components.firedetector:ActivateEmergencyMode()
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("firesuppressor", function(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded
	
	-- CanInteract_old = inst.components.machine.caninteractfn
	-- inst.components.machine.caninteractfn = CanInteract

end


end)
%%+%%postinit/prefabs/fish.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("fish", function(inst)


inst:AddTag("fishmeat")
inst:AddTag("packimfood")

if TheWorld.ismastersim then

    if inst.components.tradable then
		inst.components.tradable.dubloonvalue = TUNING.DUBLOON_VALUES.SEAFOOD
	end
	
	inst:AddComponent("appeasement")
	inst.components.appeasement.appeasementvalue = TUNING.APPEASEMENT_TINY
	
end


end)
%%+%%postinit/prefabs/float_fx.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

local function fn(inst)


local tile = TheWorld.Map:GetTileAtPoint(inst:GetPosition():Get())
if tile < GROUND.OCEAN_START or tile > GROUND.OCEAN_END then

    inst.AnimState:SetOceanBlendParams(0)
	
end


end

IAENV.AddPrefabPostInit("float_fx_front", fn)
IAENV.AddPrefabPostInit("float_fx_back", fn)%%+%%postinit/prefabs/gears.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("gears", function(inst)


if TheWorld.ismastersim then

    inst:AddComponent("fuel")
    inst.components.fuel.fueltype = FUELTYPE.MECHANICAL
    inst.components.fuel.fuelvalue = TUNING.TOTAL_DAY_TIME
	
end


end)%%+%%postinit/prefabs/gestalt.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("gestalt", function(inst)


inst:AddTag("amphibious")

if TheWorld.ismastersim then
end


end)%%+%%postinit/prefabs/grass.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local animdata = {
	bankgust = "grass_floating",
	bankidle = "grass",
}

IAENV.AddPrefabPostInit("grass", function(inst)


if TheWorld.ismastersim then

	MakePickableBlowInWindGust(inst, TUNING.GRASS_WINDBLOWN_SPEED, TUNING.GRASS_WINDBLOWN_FALL_CHANCE, animdata)
	
end


end)%%+%%postinit/prefabs/healthregenbuff.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local onextendedfn_old
local function onextendedfn(inst, ...)
	onextendedfn_old(inst, ...)
	inst.components.timer:SetTimeLeft("regenover", inst.components.timer:GetTimeLeft("regenover") + TUNING.JELLYBEAN_DURATION * TUNING.WARLY_IA_GOURMET_BONUS)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("healthregenbuff", function(inst)


if TheWorld.ismastersim then

	if GetTime() > 0 and inst.components.timer:GetTimeLeft("regenover") == TUNING.JELLYBEAN_DURATION then
		--just spawned, not loaded
		inst.components.timer:SetTimeLeft("regenover", TUNING.JELLYBEAN_DURATION * (1 + TUNING.WARLY_IA_GOURMET_BONUS))
	end
	
	onextendedfn_old = inst.components.debuff.onextendedfn
	inst.components.debuff.onextendedfn = onextendedfn
	
end


end)%%+%%postinit/prefabs/heatrock.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local GetRangeForTemperature
local AdjustLighting
local UpdateImages
local function temperaturedelta(inst, data)
	local ambient_temp = IsInIAClimate(inst) and TheWorld.state.islandtemperature or TheWorld.state.temperature
	local cur_temp = inst.components.temperature:GetCurrent()
	local range = GetRangeForTemperature(cur_temp, ambient_temp)
	AdjustLighting(inst, range, ambient_temp)

	if range <= 1 then
		if inst.lowTemp == nil or inst.lowTemp > cur_temp then
			inst.lowTemp = math.floor(cur_temp)
		end
		inst.highTemp = nil
	elseif range >= 5 then
		if inst.highTemp == nil or inst.highTemp < cur_temp then
			inst.highTemp = math.ceil(cur_temp)
		end
		inst.lowTemp = nil
	elseif inst.lowTemp ~= nil then
		if GetRangeForTemperature(inst.lowTemp, ambient_temp) >= 3 then
			inst.lowTemp = nil
		end
	elseif inst.highTemp ~= nil and GetRangeForTemperature(inst.highTemp, ambient_temp) <= 3 then
		inst.highTemp = nil
	end

	if range ~= inst.currentTempRange then
		UpdateImages(inst, range)

		if (inst.lowTemp ~= nil and range >= 3) or
			(inst.highTemp ~= nil and range <= 3) then
			inst.lowTemp = nil
			inst.highTemp = nil
			inst.components.fueled:SetPercent(inst.components.fueled:GetPercent() - 1 / TUNING.HEATROCK_NUMUSES)
		end
	end
end

-- Heatrock emits constant temperatures depending on the temperature range it's in
local emitted_temperatures = { -10, 10, 25, 40, 60 }

local function HeatFn(inst, observer)
    local range = GetRangeForTemperature(inst.components.temperature:GetCurrent(),
		IsInIAClimate(inst) and TheWorld.state.islandtemperature or TheWorld.state.temperature)
    if range <= 2 then
        inst.components.heater:SetThermics(false, true)
    elseif range >= 4 then
        inst.components.heater:SetThermics(true, false)
    else
        inst.components.heater:SetThermics(false, false)
    end
    return emitted_temperatures[range]
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("heatrock", function(inst)


if TheWorld.ismastersim then
	
	if not inst.components.climatetracker then
		inst:AddComponent("climatetracker")
	end
	inst.components.climatetracker.period = 10
	
	for i, v in ipairs(inst.event_listening["temperaturedelta"][inst]) do
		GetRangeForTemperature = UpvalueHacker.GetUpvalue(v, "GetRangeForTemperature")
		AdjustLighting = UpvalueHacker.GetUpvalue(v, "AdjustLighting")
		UpdateImages = UpvalueHacker.GetUpvalue(v, "UpdateImages")
		if GetRangeForTemperature and AdjustLighting and UpdateImages then
			--TemperatureChange
			inst:RemoveEventCallback("temperaturedelta", v)
			inst:ListenForEvent("temperaturedelta", temperaturedelta)
			break
		end
	end
	
	inst.components.heater.heatfn = HeatFn
	inst.components.heater.carriedheatfn = HeatFn
	
end


end)
%%+%%postinit/prefabs/icebox.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onStartFlooded(inst)
	inst:RemoveTag("fridge")
end

local function onStopFlooded(inst)
	inst:AddTag("fridge")
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("icebox", function(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

end


end)
%%+%%postinit/prefabs/inventoryitem_classified.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function SerializeObsidianCharge(inst, percent)
    inst.obsidian_charge:set((percent or 0) * 63)
end

local function DeserializeObsidianCharge(inst)
    if inst._parent ~= nil then
        inst._parent:PushEvent("obsidianchargechange", {percent = inst.obsidian_charge:value() / 63})
    end
end

local function SerializeInvSpace(inst, percent)
    inst.invspace:set((percent or 0) * 63)
end

local function DeserializeInvSpace(inst)
    if inst._parent ~= nil then
        inst._parent:PushEvent("invspacechange", {percent = inst.invspace:value() / 63})
    end
end

local function RegisterNetListeners(inst)
    inst:ListenForEvent("obsidianchargedirty", DeserializeObsidianCharge)
    inst:ListenForEvent("invspacedirty", DeserializeInvSpace)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("inventoryitem_classified", function(inst)



inst.deployatrange = net_bool(inst.GUID, "deployable.deployatrange")
inst.candeployonland = net_bool(inst.GUID, "deployable.candeployonland")
inst.candeployonshallowocean = net_bool(inst.GUID, "deployable.candeployonshallowocean")
inst.candeployonbuildableocean = net_bool(inst.GUID, "deployable.candeployonbuildableocean")
inst.candeployonunbuildableocean = net_bool(inst.GUID, "deployable.candeployonunbuildableocean")
inst.obsidian_charge = net_smallbyte(inst.GUID, "obsidiantool.obsidian_charge", "obsidianchargedirty")
inst.invspace = net_smallbyte(inst.GUID, "inventory.invspace", "invspacedirty")

inst.deployatrange:set(false)
inst.candeployonland:set(true)
inst.candeployonshallowocean:set(false)
inst.candeployonbuildableocean:set(false)
inst.candeployonunbuildableocean:set(false)
inst.obsidian_charge:set(0)
inst.invspace:set(0)

if not TheWorld.ismastersim then

    inst.DeserializeObsidianCharge = DeserializeObsidianCharge
    inst.DeserializeInvSpace = DeserializeInvSpace

    --Delay net listeners until after initial values are deserialized
    inst:DoTaskInTime(0, RegisterNetListeners)
    return
	
end

inst.SerializeObsidianCharge = SerializeObsidianCharge
inst.SerializeInvSpace = SerializeInvSpace


end)
%%+%%postinit/prefabs/lantern.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _onequipfn
local function onequipfn(self, owner)
	if owner.sg:HasStateTag("rowing") then return end
	return _onequipfn(self, owner)
end
local _ontakefuelfn
local function ontakefuelfn(self)
	local owner = self.components.inventoryitem.owner
	if owner and owner.sg and owner.sg:HasStateTag("rowing") then return end
	return _ontakefuelfn(self)
end
local _turnonfn
local function turnonfn(self)
	local owner = self.components.inventoryitem.owner
	if owner and owner.sg and owner.sg:HasStateTag("rowing") then
		self.components.machine.oncooldown = false
		self:DoTaskInTime(0,function() self.components.machine:TurnOff() end)
		return
	end
	return _turnonfn(self)
end
-- local _ondropfn
-- local function ondropfn(self)
	-- local owner = self.components.inventoryitem.owner
	-- if owner and owner.sg and owner.sg:HasStateTag("rowing") then return end
	-- return _ondropfn(self)
-- end
	
local function startrowing(self,data)
	self.components.equippable.onunequipfn(self, data and data.owner or nil)
	self.components.machine:TurnOff()
end
local function stoprowing(self,data)
	self.components.equippable.onequipfn(self, data and data.owner or nil)
	self.components.machine:TurnOn()
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("lantern", function(inst)


if TheWorld.ismastersim then

	_onequipfn = inst.components.equippable.onequipfn
	inst.components.equippable.onequipfn = onequipfn
	_ontakefuelfn = inst.components.fueled.ontakefuelfn
	inst.components.fueled.ontakefuelfn = ontakefuelfn
	_turnonfn = inst.components.machine.turnonfn
	inst.components.machine.turnonfn = turnonfn
	-- _ondropfn = inst.components.inventoryitem.ondropfn
	-- inst.components.inventoryitem.ondropfn = ondropfn
	
	inst:ListenForEvent("startrowing", startrowing)
	inst:ListenForEvent("stoprowing", stoprowing)
	
end


end)
%%+%%postinit/prefabs/lighter.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _onequipfn
local function onequipfn(self, owner)
	if owner.sg:HasStateTag("rowing") then return end
	return _onequipfn(self, owner)
end
	
local function startrowing(self,data)
	self.components.equippable.onunequipfn(self, data and data.owner or nil)
end
local function stoprowing(self,data)
	self.components.equippable.onequipfn(self, data and data.owner or nil)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("lighter", function(inst)


if TheWorld.ismastersim then

	_onequipfn = inst.components.equippable.onequipfn
	inst.components.equippable.onequipfn = onequipfn
	
	inst:ListenForEvent("startrowing", startrowing)
	inst:ListenForEvent("stoprowing", stoprowing)
	
end


end)
%%+%%postinit/prefabs/lightning.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local StartFX_old
local function StartFX(proxy, ...)
	if not TheLocalPlayer or IsInIAClimate(TheLocalPlayer) == IsInIAClimate(proxy) then
		StartFX_old(proxy, ...)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("lightning", function(inst)

for per, _ in pairs(inst.pendingtasks) do
	if per.fn ~= inst.Remove and per.period == 0 then --assume there's only the two vanilla tasks
		StartFX_old = per.fn
		per.fn = StartFX
		break
	end
end


end)%%+%%postinit/prefabs/lureplant.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("lureplant", function(inst)


if TheWorld.ismastersim then

	if inst.components.minionspawner.validtiletypes then
		inst.components.minionspawner.validtiletypes[GROUND.BEACH] = true
		inst.components.minionspawner.validtiletypes[GROUND.JUNGLE] = true
		inst.components.minionspawner.validtiletypes[GROUND.TIDALMARSH] = true
		inst.components.minionspawner.validtiletypes[GROUND.MEADOW] = true
	end	

end


end)
%%+%%postinit/prefabs/mandrake.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("mandrake", function(inst)
	
	
	inst.Physics:CollidesWith(COLLISION.WAVES)
	
	
end)
%%+%%postinit/prefabs/marsh_bush.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _makeemptyfn
local function makeemptyfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _makeemptyfn then _makeemptyfn(inst, ...) end
end
local function makeemptyfn_hackable(inst)
	inst.components.pickable:MakeEmpty() -- This does everything for us
end

local _makebarrenfn
local function makebarrenfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _makebarrenfn then _makebarrenfn(inst, ...) end
end
local function makebarrenfn_hackable(inst)
	inst.components.pickable:MakeBarren() -- This does everything for us
end

local _onpickedfn
local function onpickedfn(inst, ...)
	inst.components.hackable.canbehacked = false
	if _onpickedfn then _onpickedfn(inst, ...) end
end

local function onfinishfn_hackable(inst, doer, loot)
	doer.SoundEmitter:PlaySound("dontstarve/wilson/harvest_sticks")
	inst.components.pickable:Pick(inst) -- Purposefully no valid doer given to avoid damage & double loot
end

local _onregenfn
local function onregenfn(inst, ...)
	inst.components.hackable:Regen()
	if _onregenfn then _onregenfn(inst, ...) end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("marsh_bush", function(inst)


if TheWorld.ismastersim then

	inst:AddComponent("hackable")
	inst.components.hackable:SetUp("twigs")
	inst.components.hackable.max_cycles = 127 -- dirty, but realistically speaking, never reached anyways
	inst.components.hackable.cycles_left = 127
	inst.components.hackable.hacksleft = 1
	inst.components.hackable.maxhacks = 1
	
	_makeemptyfn = inst.components.pickable.makeemptyfn
	inst.components.pickable.makeemptyfn = makeemptyfn
	inst.components.hackable.makeemptyfn = makeemptyfn_hackable
	
	_makebarrenfn = inst.components.pickable.makebarrenfn
	inst.components.pickable.makebarrenfn = makebarrenfn
	inst.components.hackable.makebarrenfn = makebarrenfn_hackable
	
	_onpickedfn = inst.components.pickable.onpickedfn
	inst.components.pickable.onpickedfn = onpickedfn
	
	inst.components.hackable.onfinishfn = onfinishfn_hackable
	
	_onregenfn = inst.components.pickable.onregenfn
	inst.components.pickable.onregenfn = onregenfn
	
end


end)
%%+%%postinit/prefabs/meatrack.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local spec_meatrack_items = {
	seaweed = "seaweed",
	seaweed_dried = "seaweed_dried",
	fish_tropical = "tropical_fish",
	solofish_dead = "dogfish",
	swordfish_dead = "swordfish",
	fish_med = "fish_raw",
	fish_small = "fish_raw_small",
	jellyfish_dead = "jellyfish_dead",
	jellyjerky = "jellyjerky",
	rainbowjellyfish_dead = "jellyfish_dead",
}

local onstartdryingold
local function onstartdrying(inst, ingredient)
	onstartdryingold(inst, ingredient)

	if spec_meatrack_items[ingredient] then
		inst.AnimState:OverrideSymbol("swap_dried", "meat_rack_food_sw", spec_meatrack_items[ingredient])
	end
end

local ondonedryingold
local function ondonedrying(inst, product)
	ondonedryingold(inst, product)

	if spec_meatrack_items[product] then
		inst.AnimState:OverrideSymbol("swap_dried", "meat_rack_food_sw", spec_meatrack_items[product])
	end
end

local getstatus
local function getstatus_ia(inst)
	local ret = getstatus(inst)
	if IsInIAClimate(inst) then
		if ret:find("DRYINGINRAIN") then
			if not TheWorld.state.islandisraining then
				ret = ret:gsub("DRYINGINRAIN","DRYING")
			end
		elseif TheWorld.state.islandisraining then
			ret = ret:gsub("DRYING","DRYINGINRAIN")
		end
	end
	return ret
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("meatrack", function(inst)


if TheWorld.ismastersim then

	onstartdryingold = inst.components.dryer.onstartdrying
	inst.components.dryer:SetStartDryingFn(onstartdrying)
	ondonedryingold = inst.components.dryer.ondonedrying
	inst.components.dryer:SetDoneDryingFn(ondonedrying)
	getstatus = inst.components.inspectable.getstatus
	inst.components.inspectable.getstatus = getstatus_ia
	
end


end)%%+%%postinit/prefabs/player_classified.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function OnPoisonDamage(parent, data)
    parent.player_classified.poisonpulse:set_local(true)
    parent.player_classified.poisonpulse:set(true)
end

local function OnBoostByWave(parent, data)
    if parent.sg:HasStateTag("running") then 
        local boost = data.boost or TUNING.WAVEBOOST
        if parent.components.sailor then
            local boat = parent.components.sailor:GetBoat()
            if boat and boat.waveboost and not data.boost then
                boost = boat.waveboost
            end
        end
        parent.player_classified.waveboost:set_local(boost)
        parent.player_classified.waveboost:set(boost)
    end 
end

local function OnPoisonPulseDirty(inst)
    if inst._parent ~= nil then
        inst._parent:PushEvent("poisondamage")
    end
end

local function OnWaveBoostDirty(inst)
    if inst._parent and inst._parent.components.locomotor then
        inst._parent.components.locomotor.boost = inst.waveboost:value()
    end
end

local function OnClimateDirty(inst)
    if inst._parent ~= nil then
        inst._parent:PushEvent("climatechange", {climate = inst._climate:value()})
    end
end

local function OnPeerTelescope(inst)
    if inst._parent ~= nil then
		if inst._parent.HUD and inst._parent.HUD.controls then
			inst._parent.HUD.controls:ShowMap()
		end
		-- if TheFocalPoint.entity:GetParent() == inst._parent then
			-- TheFocalPoint.SoundEmitter:PlaySound("dontstarve/HUD/Together_HUD/learn_map")
		-- end
    end
end

local function RegisterNetListeners(inst)
    if TheWorld.ismastersim then
        inst._parent = inst.entity:GetParent()
        inst:ListenForEvent("poisondamage", OnPoisonDamage, inst._parent)
        inst:ListenForEvent("boostbywave", OnBoostByWave, inst._parent)
    else
        inst.poisonpulse:set_local(false)
        inst.waveboost:set_local(0)
        --inst.facingsynced:set_local(false)
        inst:ListenForEvent("poisonpulsedirty", OnPoisonPulseDirty)
        inst:ListenForEvent("waveboostdirty", OnWaveBoostDirty)
        inst:ListenForEvent("climatedirty", OnClimateDirty)
    end
	inst:ListenForEvent("telescope.peer", OnPeerTelescope)
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("player_classified", function(inst)


inst.isjellybrainhat = net_bool(inst.GUID, "builder.jellybrainhat", "recipesdirty")

inst.hasmomentum = net_bool(inst.GUID, "locomotor.hasmomentum")
inst.externalspeedadder = net_float(inst.GUID, "locomotor.externalspeedadder")
inst.externalaccelerationadder = net_float(inst.GUID, "locomotor.externalaccelerationadder")
inst.externalaccelerationmultiplier = net_float(inst.GUID, "locomotor.externalaccelerationmultiplier")
inst.externaldecelerationadder = net_float(inst.GUID, "locomotor.externaldecelerationadder")
inst.externaldecelerationmultiplier = net_float(inst.GUID, "locomotor.externaldecelerationmultiplier")
inst.windspeedmult = net_float(inst.GUID, "locomotor.windspeedmult")

inst.disable = net_bool(inst.GUID, "locomotor.disable")
--inst.facingsynced = net_bool(inst.GUID, "locomotor.facingsynced")
inst.waveboost = net_ushortint(inst.GUID, "locomotor.waveboost", "waveboostdirty")

inst.ispoisoned = net_bool(inst.GUID, "poisonable.ispoisoned")
inst.poisonpulse = net_bool(inst.GUID, "poisonable.poisonpulse")

inst._climate = net_tinybyte(inst.GUID, "climatetracker._climate", "climatedirty")

inst.peertelescope = net_event(inst.GUID, "telescope.peer")

inst.isjellybrainhat:set(false)

inst.hasmomentum:set(false)
inst.externalspeedadder:set(0)
inst.externalaccelerationadder:set(0)
inst.externalaccelerationmultiplier:set(1)
inst.externaldecelerationadder:set(0)
inst.externaldecelerationmultiplier:set(1)
inst.windspeedmult:set(1)

inst.disable:set(false)

inst.ispoisoned:set(false)

inst._climate:set(0)

--Delay net listeners until after initial values are deserialized
inst:DoTaskInTime(0, RegisterNetListeners)


end)
%%+%%postinit/prefabs/portablecookpot.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function onStartFlooded(inst)
	if inst.components.container then
		inst.components.container.canbeopened = false
		inst.components.container:Close()
	end
	if inst.components.stewer and inst.components.stewer:IsCooking() then
		inst.components.stewer.product = "wetgoop"
	end
end

local function onStopFlooded(inst)
	if inst.components.container then
		inst.components.container.canbeopened = true 
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("portablecookpot", function(inst)


if IA_CONFIG.oldwarly then
	inst:RemoveTag("mastercookware")
end

inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

end


end)


if not IA_CONFIG.oldwarly then return end


IAENV.AddPrefabPostInit("portablecookpot_item", function(inst)


--Klei pls
if not inst.components.floater then
	MakeInventoryFloatable(inst)
	-- inst.components.floater:UpdateAnimations("idle_water", "idle_drop")
end

if TheWorld.ismastersim then

    inst.components.deployable.restrictedtag = nil

end


end)%%+%%postinit/prefabs/prototyper.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

local function fn(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	--rest handled in postinit/components/builder.lua
	
end


end

IAENV.AddPrefabPostInit("researchlab", fn)
IAENV.AddPrefabPostInit("researchlab2", fn)
IAENV.AddPrefabPostInit("researchlab3", fn)
IAENV.AddPrefabPostInit("researchlab4", fn)
%%+%%postinit/prefabs/rainometer.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function DoCheckRain(inst)
	if not inst:HasTag("burnt") and inst:HasTag("flooded") then
		if inst.task ~= nil then
			inst.task:Cancel()
			inst.task = nil
		end
		inst.AnimState:SetPercent("meter", 1)
	end
end

local function onStartFlooded(inst)
	if not inst.floodtask then
		inst.floodtask = inst:DoPeriodicTask(4, DoCheckRain)
	end
end

local function onStopFlooded(inst)
	if inst.floodtask then
		inst.floodtask:Cancel()
		inst.floodtask = nil
	end
	inst:PushEvent("animover") --hopefully this doesn't need any event data
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("rainometer", function(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	inst.components.floodable.onStartFlooded = onStartFlooded
	inst.components.floodable.onStopFlooded = onStopFlooded

end


end)
%%+%%postinit/prefabs/sapling.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local animdata = {
	bankgust = "sapling_floating",
	bankidle = "sapling",
}

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("sapling", function(inst)


if TheWorld.ismastersim then

	MakePickableBlowInWindGust(inst, TUNING.SAPLING_WINDBLOWN_SPEED, TUNING.SAPLING_WINDBLOWN_FALL_CHANCE, animdata)
	
end


end)
%%+%%postinit/prefabs/sewing_tape.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddPrefabPostInit("sewing_tape", function(inst)


if TheWorld.ismastersim then

	inst:AddComponent("repairer")
	inst.components.repairer.healthrepairvalue = TUNING.TRUSTY_TAPE_BOAT_HEALING
	inst.components.repairer.repairmaterial = "boat"
	
end


end)
%%+%%postinit/prefabs/shadowmeteor.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local SMASHABLE_WORK_ACTIONS =
{
	CHOP = true,
	DIG = true,
	HAMMER = true,
	MINE = true,
}
local SMASHABLE_TAGS = { "_combat", "_inventoryitem", "campfire" }
for k, v in pairs(SMASHABLE_WORK_ACTIONS) do
	table.insert(SMASHABLE_TAGS, k.."_workable")
end
local NON_SMASHABLE_TAGS = { "INLIMBO", "playerghost" }

local function beforeexplode(inst)
	if inst.striketask ~= nil then return print("Warning: Island Adventures could not check crashing meteor for water") end
	if not inst:GetIsOnWater() then return end
	
	inst:CancelAllPendingTasks()
	
	if inst.warnshadow ~= nil then
		inst.warnshadow:Remove()
		inst.warnshadow = nil
	end
	-- inst:DoTaskInTime(.1, function(inst)
		-- if inst.striketask ~= nil then return end
		-- if not inst:GetIsOnWater() then return end
		
		inst.SoundEmitter:PlaySound("dontstarve/common/meteor_impact")

		local shakeduration = .7 * inst.size
		local shakespeed = .02 * inst.size
		local shakescale = .5 * inst.size
		local shakemaxdist = 40 * inst.size
		ShakeAllCameras(CAMERASHAKE.FULL, shakeduration, shakespeed, shakescale, inst, shakemaxdist)
		
		local x, y, z = inst.Transform:GetWorldPosition()
		local ents = TheSim:FindEntities(x, y, z, inst.size * TUNING.METEOR_RADIUS, nil, NON_SMASHABLE_TAGS, SMASHABLE_TAGS)
		for i, v in ipairs(ents) do
			--V2C: things "could" go invalid if something earlier in the list
			--     removes something later in the list.
			--     another problem is containers, occupiables, traps, etc.
			--     inconsistent behaviour with what happens to their contents
			--     also, make sure stuff in backpacks won't just get removed
			--     also, don't dig up spawners
			if v:IsValid() and not v:IsInLimbo() then
				if v.components.combat ~= nil then
					v.components.combat:GetAttacked(inst, inst.size * TUNING.METEOR_DAMAGE, nil)
				elseif v.components.boathealth ~= nil --only do boat damage if there is no sailor who re-routes his damage already
				and not (v.components.sailable and v.components.sailable.sailor) then
					v.components.boathealth:DoDelta(- inst.size * TUNING.METEOR_DAMAGE, "combat")
				elseif v.components.workable ~= nil then
					if v.components.workable:CanBeWorked() and not (v.sg ~= nil and v.sg:HasStateTag("busy")) then
						local work_action = v.components.workable:GetWorkAction()
						--V2C: nil action for campfires
						if (work_action == nil or SMASHABLE_WORK_ACTIONS[work_action.id]) and
							(work_action ~= ACTIONS.DIG
							or (v.components.spawner == nil and
								v.components.childspawner == nil)) then
							v.components.workable:WorkedBy(inst, inst.workdone or 20)
						end
					end
				elseif v.components.inventoryitem ~= nil then
					if v.components.container ~= nil then
						-- Spill backpack contents, but don't destroy backpack
						if math.random() <= TUNING.METEOR_SMASH_INVITEM_CHANCE then
							v.components.container:DropEverything()
						end
						Launch(v, inst, TUNING.LAUNCH_SPEED_SMALL)
					elseif v.components.mine ~= nil and not v.components.mine.inactive then
						-- Always smash things on the periphery so that we don't end up with a ring of flung loot
						v.components.mine:Deactivate()
						Launch(v, inst, TUNING.LAUNCH_SPEED_SMALL)
					-- elseif (inst.peripheral or math.random() <= TUNING.METEOR_SMASH_INVITEM_CHANCE)
						-- and not v:HasTag("irreplaceable") then
						-- -- Always smash things on the periphery so that we don't end up with a ring of flung loot
						-- local vx, vy, vz = v.Transform:GetWorldPosition()
						-- SpawnPrefab("ground_chunks_breaking").Transform:SetPosition(vx, 0, vz)
						-- v:Remove()
					else
						Launch(v, inst, TUNING.LAUNCH_SPEED_SMALL)
					end
				end
			end
		end

		--custom water stuff
		SpawnAt("splash_water_big",inst)
		inst:Remove()
	-- end)
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("shadowmeteor", function(inst)


if TheWorld.ismastersim then

	--this triggers a split second before the actual onexplode, roughly when the meteor visually lands
	inst:DoTaskInTime(1.25, beforeexplode)
	
end


end)

%%+%%postinit/prefabs/shadowwaxwell.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function embarkboat(inst, data)
	local pos
	if data.target then --the boat the leader is trying to embark
		local target_pt = data.target:GetPosition()
		local offset = FindWaterOffset(target_pt, data.target:GetAngleToPoint(inst:GetPosition()) + ((math.random() * .4)-.2)*PI, 5, 36)
		if offset then
			pos = target_pt + offset
		end
	end
	if not pos then
		local target_pt = inst.components.follower:GetLeader() and inst.components.follower:GetLeader():GetPosition() or inst:GetPosition()
		local offset = FindWaterOffset(target_pt, math.random() * 2*PI, 5, 36)
		if offset then
			pos = target_pt + offset
		end
	end
	if pos then
		inst.sg:GoToState("embark_shadow", pos)
	end
end

local function disembarkboat(inst, data)
	if data.boat_to_boat then return end
	local pos
	local inst_pt = inst:GetPosition()
	if data.pos then
		local offset = FindGroundOffset(inst_pt, inst:GetAngleToPoint(data.pos) + ((math.random() * .4)-.2)*PI, 5, 36)
		if offset then
			pos = inst_pt + offset
		end
	end
	if not pos then
		local target_pt = inst.components.follower:GetLeader() and inst.components.follower:GetLeader():GetPosition() or inst:GetPosition()
		local offset = FindGroundOffset(target_pt, math.random() * 2*PI, 5, 36)
		if offset then
			pos = target_pt + offset
		end
	end
	if pos then
		inst.sg:GoToState("disembark_shadow", pos)
	end
end

local function stopfollowing(inst, data)
    if data.leader then
        inst:RemoveEventCallback("embarkboat", inst.embarkboat, data.leader)
        inst:RemoveEventCallback("disembarkboat", inst.disembarkboat, data.leader)
    end
end
local function startfollowing(inst, data)
    if data.leader then
        inst:ListenForEvent("embarkboat", inst.embarkboat, data.leader)
        inst:ListenForEvent("disembarkboat", inst.disembarkboat, data.leader)
    end
end

local function onremove(inst)
	if inst.boat then
		-- SpawnAt("statue_transition", inst.boat)
		SpawnAt("statue_transition_2", inst.boat)
		inst.boat.sailor = nil
		inst.boat:DoTaskInTime(3 * FRAMES, inst.boat.Remove)
	end
end

local function onspawn(inst)
	if IsOnWater(inst) and not inst.boat then
		inst:AddTag("aquatic")
		inst:AddTag("sailing")
		-- inst.components.locomotor:SetExternalSpeedAdder(boat, "SAILOR", boat.components.sailable.movementbonus)
		inst.components.locomotor.hasmomentum = true

		inst.boat = SpawnPrefab("shadowwaxwell_boat")
		inst.boat.sailor = inst
		inst.boat.Physics:Teleport(0, -0.1, 0)
		inst:AddChild(inst.boat)
	end
end

local nodebrisdmg
local function nodebrisdmg_ia(inst, amount, overtime, cause, ignore_invincible, afflicter, ...)
	return nodebrisdmg and nodebrisdmg(inst, amount, overtime, cause, ignore_invincible, afflicter, ...)
		or cause == "coconut" --might need afflicter tags in the future -M
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

local function fn(inst)


inst.AnimState:OverrideSymbol("paddle", "swap_paddle", "paddle")
inst.AnimState:OverrideSymbol("wake_paddle", "swap_paddle", "wake_paddle")


if TheWorld.ismastersim then

	if inst.components.health then
		nodebrisdmg = inst.components.health.redirect
		inst.components.health.redirect = nodebrisdmg_ia
	end

	inst.embarkboat = function(leader, data) return embarkboat(inst, data) end
	inst.disembarkboat = function(leader, data) return disembarkboat(inst, data) end
	inst:ListenForEvent("startfollowing", startfollowing)
	inst:ListenForEvent("stopfollowing", stopfollowing)
	inst:ListenForEvent("onremove", onremove)

	inst:DoTaskInTime(0, onspawn)

end


end

IAENV.AddPrefabPostInit("shadowlumber", fn)
IAENV.AddPrefabPostInit("shadowminer", fn)
IAENV.AddPrefabPostInit("shadowdigger", fn)
IAENV.AddPrefabPostInit("shadowduelist", fn)
%%+%%postinit/prefabs/tentacle.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function quackify(inst)
	if IsOnWater(inst) then
		--The animations are off, gotta make a custom bank if we want them on water. -M
		-- inst.AnimState:SetBank("quacken_tentacle")
		-- inst.AnimState:SetBuild("quacken_tentacle")
		inst:Remove()
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("tentacle", function(inst)


	inst:DoTaskInTime(0, quackify)


end)
%%+%%postinit/prefabs/thunder_close.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local ScreenFlash_old
local function ScreenFlash(self, ...)
	--for some reason, this thing runs on dedicated too -M
	if not TheLocalPlayer or IsInIAClimate(TheLocalPlayer) == (self._islandthunder:value() or false) then
		ScreenFlash_old(self, ...)
	end
end

local OnRandDirty_old
local function OnRandDirty(self, ...)
	if TheLocalPlayer and IsInIAClimate(TheLocalPlayer) == (self._islandthunder:value() or false) then
		OnRandDirty_old(self, ...)
	end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("thunder_close", function(inst)


inst._islandthunder = net_bool(inst.GUID, "thunder_close._islandthunder")

for per, _ in pairs(inst.pendingtasks) do
	if per.fn ~= inst.Remove and per.period == 0 then --assume there's only the three vanilla tasks
		ScreenFlash_old = per.fn
		per.fn = ScreenFlash
		break
	end
end
		
if inst.event_listeners and inst.event_listeners.randdirty and inst.event_listeners.randdirty[inst] then
	OnRandDirty_old = inst.event_listeners.randdirty[inst][1]
	inst.event_listeners.randdirty[inst][1] = OnRandDirty
end


end)%%+%%postinit/prefabs/thunder_far.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local PlayThunderSound_old
local function PlayThunderSound(self, ...)
	if TheLocalPlayer and IsInIAClimate(TheLocalPlayer) == (self._islandthunder:value() or false) then
		PlayThunderSound_old(self, ...)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("thunder_far", function(inst)


inst._islandthunder = net_bool(inst.GUID, "thunder_close._islandthunder")

for per, _ in pairs(inst.pendingtasks) do
	if per.fn ~= inst.Remove and per.period == 0 then --assume there's only the two vanilla tasks
		PlayThunderSound_old = per.fn
		per.fn = PlayThunderSound
		break
	end
end


end)%%+%%postinit/prefabs/torch.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _onequipfn
local function onequipfn(self, owner)
	if owner.sg:HasStateTag("rowing") then return end
	return _onequipfn(self, owner)
end
	
local function startrowing(self,data)
	self.components.equippable.onunequipfn(self, data and data.owner or nil)
	if self.components.inventoryitem.onputininventoryfn then --this should be "turnoff"
		self.components.inventoryitem.onputininventoryfn(self, data and data.owner or nil)
	end
end
local function stoprowing(self,data)
	self.components.equippable.onequipfn(self, data and data.owner or nil)
end

local function postinitfn(inst)


if TheWorld.ismastersim then

	_onequipfn = inst.components.equippable.onequipfn
	inst.components.equippable.onequipfn = onequipfn
	
	inst:ListenForEvent("startrowing", startrowing)
	inst:ListenForEvent("stoprowing", stoprowing)
	
end


end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("torch", postinitfn)
IAENV.AddPrefabPostInit("redlantern", postinitfn)
%%+%%postinit/prefabs/trees.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local stagename = {
	"short",
	"normal",
	"tall",
	"old",
}

local function OnGustAnimDone(inst)
	if inst:HasTag("stump") or inst:HasTag("burnt") then
		inst:RemoveEventCallback("animover", OnGustAnimDone)
		return
	end
	if inst.components.blowinwindgust and inst.components.blowinwindgust:IsGusting() then
		local anim = math.random(1,2)
		inst.AnimState:PlayAnimation("blown_loop_".. stagename[inst.components.growable.stage] ..tostring(anim), false)
		inst.SoundEmitter:PlaySound("ia/common/wind_tree_creak") --I won't bother with the spot emitters -M
	else
		inst:DoTaskInTime(math.random()/2, function(inst)
			inst:RemoveEventCallback("animover", OnGustAnimDone)
			inst.AnimState:PlayAnimation("blown_pst_" .. stagename[inst.components.growable.stage], false)
			inst.AnimState:PushAnimation(math.random() > .5 and inst.anims.sway1 or inst.anims.sway2, true)
		end)
	end
end

local function OnGustStart(inst, windspeed)
	if inst:HasTag("stump") or inst:HasTag("burnt") then
		return
	end
	inst:DoTaskInTime(math.random()/2, function(inst)
		-- if inst.spotemitter == nil then
			-- AddToNearSpotEmitter(inst, "treeherd", "tree_creak_emitter", TUNING.TREE_CREAK_RANGE)
		-- end
		inst.AnimState:PlayAnimation("blown_pre_" .. stagename[inst.components.growable.stage], false)
		inst.SoundEmitter:PlaySound("ia/common/wind_tree_creak")
		inst:ListenForEvent("animover", OnGustAnimDone)
	end)
end

local function OnGustFall(inst)
	inst.components.workable:Destroy(inst)
end

local function postinitfn(inst)


if TheWorld.ismastersim then
	if not inst:HasTag("burnt") and not inst:HasTag("stump") then

        inst:AddComponent("blowinwindgust")
        inst.components.blowinwindgust:SetWindSpeedThreshold(TUNING.EVERGREEN_WINDBLOWN_SPEED)
        inst.components.blowinwindgust:SetDestroyChance(TUNING.EVERGREEN_WINDBLOWN_FALL_CHANCE)
        inst.components.blowinwindgust:SetGustStartFn(OnGustStart)
        inst.components.blowinwindgust:SetDestroyFn(OnGustFall)
        inst.components.blowinwindgust:Start()
		
	end
end


end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("evergreen", postinitfn)
IAENV.AddPrefabPostInit("evergreen_sparse", postinitfn)
IAENV.AddPrefabPostInit("deciduoustree", postinitfn)
%%+%%postinit/prefabs/trinkets.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function makepostinitfn(dubloonvalue)
	dubloonvalue = dubloonvalue or 3
	return function(inst)
		if inst.components.tradable then
			inst.components.tradable.dubloonvalue = dubloonvalue
		end
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

for i = 1, NUM_TRINKETS do
	IAENV.AddPrefabPostInit("trinket_".. i, makepostinitfn(TUNING.DUBLOON_VALUES.TRINKETS[i]))
end
%%+%%postinit/prefabs/variants_ia.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function IsOnIATurf(inst)
	local tile = TheWorld.Map:GetTileAtPoint(inst:GetPosition():Get())
	--Hardcode beach because it is "climate neutral" for compatibility with old worlds (beach surrounds mainland) -M
	return CLIMATE_TURFS and tile and CLIMATE_TURFS.ISLAND[tile] or tile == GROUND.BEACH
end

----------------------------------------------------------------------------------------

local POSSIBLE_VARIANTS = {
	grass = {
		default = {build="grass1"},
		tropical = {build="grassgreen_build",testfn=IsOnIATurf},
	},
	krampus = {
		default = {build="krampus_build"},
		tropical = {build="krampus_hawaiian_build",testfn=IsInIAClimate},
	},
	butterfly = {
		default = {build="butterfly_basic",invimage="default"},
		tropical = {build="butterfly_tropical_basic",invimage="butterfly_tropical",testfn=IsInIAClimate},
	},
	cutgrass = {
		default = {build="cutgrass",invimage="default"},
		tropical = {build="cutgrassgreen",invimage="cutgrass_tropical"},
	},
	butterflywings = {
		default = {build="butterfly_wings",bank="butterfly_wings",invimage="default"},
		tropical = {build="butterfly_tropical_wings",bank="butterfly_tropical_wings",invimage="butterflywings_tropical"},
	},
	log = {
		default = {build="log",invimage="default"},
		tropical = {build="log_tropical",invimage="log_tropical",sourceprefabs={
			"palmtree",
			"jungletree",
			"mangrovetree",
			"livingjungletree",
			"leif_palm",
		}},
	},
	cave_banana = {
		default = {name="default",build="cave_banana",invimage="default"},
		tropical = {name="BANANA",build="bananas",invimage="bananas",sourceprefabs={
			"primeape",
			"primeapebarrel",
			"jungletree",
		}},
	},
	cave_banana_cooked = {
		default = {name="default",build="cave_banana",invimage="default"},
		tropical = {name="BANANA_COOKED",build="bananas",invimage="bananas_cooked"},
	},
}

----------------------------------------------------------------------------------------

local function fn(inst)


if TheWorld.ismastersim then

	if not inst.components.visualvariant then
		inst:AddComponent("visualvariant")
	end
	for k,v in pairs(POSSIBLE_VARIANTS[inst.prefab]) do
		--allow others to override us
		if not next(inst.components.visualvariant.possible_variants) then
			inst.components.visualvariant.possible_variants = POSSIBLE_VARIANTS[inst.prefab]
		elseif not inst.components.visualvariant.possible_variants[k] then
			inst.components.visualvariant.possible_variants[k] = v
		end
	end
	
end


end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

for k,v in pairs(POSSIBLE_VARIANTS) do
	IAENV.AddPrefabPostInit(k, fn)
end
%%+%%postinit/prefabs/warly.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

if not IA_CONFIG.oldwarly then return end

local onnewspawn_old
local function onnewspawn(inst,...)
	inst.components.inventory:Equip(SpawnAt("chefpack",inst))

	if onnewspawn_old then return onnewspawn_old(inst,...) end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("warly", function(inst)


if TheWorld.ismastersim then

    if inst.components.hunger ~= nil then
		inst.components.hunger:SetRate(TUNING.WILSON_HUNGER_RATE * TUNING.WARLY_IA_HUNGER_RATE_MODIFIER)	
	end

    if inst.components.eater ~= nil then
		--Damnit Klei stop screwing with this stuff. -M
		if inst.components.eater.preferseatingtags ~= nil then
			for i = #inst.components.eater.preferseatingtags, 1, -1 do
				if inst.components.eater.preferseatingtags[i] == "preparedfood"
				or inst.components.eater.preferseatingtags[i] == "pre-preparedfood" then
					inst.components.eater.preferseatingtags[i] = nil
				end
			end
			if #inst.components.eater.preferseatingtags == 0 then
				inst.components.eater.preferseatingtags = nil
			end
		else
			inst.components.eater:SetPrefersEatingTag(nil)
		end
    end

    if inst.components.foodmemory ~= nil then
		inst.components.foodmemory:SetDuration(TUNING.WARLY_IA_SAME_OLD_COOLDOWN)
		inst.components.foodmemory:SetMultipliers(TUNING.WARLY_IA_SAME_OLD_MULTIPLIERS)
		inst.components.foodmemory.restricttag = "preparedfood"
		inst.components.foodmemory.rawmult = TUNING.WARLY_IA_MULT_RAW
		inst.components.foodmemory.cookedmult = TUNING.WARLY_IA_MULT_COOKED
		inst.components.foodmemory.driedmult = TUNING.WARLY_IA_MULT_DRIED
	end

	onnewspawn_old = inst.OnNewSpawn
	inst.OnNewSpawn = onnewspawn
	
end


end)%%+%%postinit/prefabs/warningshadow.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function shrink(inst, time, startsize, endsize)
	inst.AnimState:SetMultColour(1,1,1,0.33)
	inst.Transform:SetScale(startsize, startsize, startsize)
	inst.components.colourtweener:StartTween({1,1,1,0.75}, time)
	inst.components.sizetweener:StartTween(.5, time, inst.Remove)
	inst.SoundEmitter:PlaySound("ia/common/bomb_fall")
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("warningshadow", function(inst)

inst.entity:AddSoundEmitter()

if TheWorld.ismastersim then

	inst.shrink = shrink
	
	inst:AddComponent("sizetweener")
	inst:AddComponent("colourtweener")
	
end


end)
%%+%%postinit/prefabs/winterometer.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local tempcheckhacked = false
local function DoCheckTemp(self)
	if not self:HasTag("burnt") then
		if self:HasTag("flooded") then
			self.AnimState:SetPercent("meter", math.random())
			return
		end
		if self._iaclimate == nil then
			self._iaclimate = IsInIAClimate(self)
		end
		self.AnimState:SetPercent("meter", 1 - math.clamp(
			self._iaclimate and TheWorld.state.islandtemperature or TheWorld.state.temperature,
			0, TUNING.OVERHEAT_TEMP) / TUNING.OVERHEAT_TEMP)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("winterometer", function(inst)


inst:AddComponent("floodable")

if TheWorld.ismastersim then

	inst.components.floodable:SetFX("shock_machines_fx",5)
	
	if not tempcheckhacked then
		for i, v in ipairs(inst.event_listening["animover"][inst]) do
			if UpvalueHacker.GetUpvalue(v, "DoCheckTemp") then
				-- StartCheckTemp = v
				tempcheckhacked = true
				UpvalueHacker.SetUpvalue(v, DoCheckTemp, "DoCheckTemp")
				break
			end
		end
	end
	
end


end)

%%+%%postinit/prefabs/woodie.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local function startbeaver(inst, data)
	if inst.components.poisonable then
		inst.components.poisonable:SetBlockAll(true)
	end
	inst.components.health.cantdrown = true
end
local function stopbeaver(inst, data)
	if inst.components.poisonable and not inst:HasTag("playerghost") then
		inst.components.poisonable:SetBlockAll(false)
	end
	inst.components.health.cantdrown = false
end

local function deployitem(inst, data)
	if not inst:HasTag("playerghost")
	and data.prefab == "coconut" or data.prefab == "jungletreeseed" then
		--inst.components.beaverness:DoDelta(TUNING.WOODIE_PLANT_TREE_GAIN)
		inst.components.sanity:DoDelta(TUNING.SANITY_TINY)
	end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddPrefabPostInit("woodie", function(inst)


if TheWorld.ismastersim then

	inst:ListenForEvent("startbeaver", startbeaver)
	inst:ListenForEvent("stopbeaver", stopbeaver)
	inst:ListenForEvent("deployitem", deployitem)
	
end


end)
%%+%%postinit/prefabs/world.lua%%-%%local function installIAcomponents(inst)
	print("Loading world with IA:",inst:HasTag("forest") and "Has Forest" or "No Forest",inst:HasTag("island") and "Has Islands" or "No Islands")
	if inst.ismastersim then
		if inst:HasTag("island") then
			--inst:AddComponent('tiled')
			inst:AddComponent("worldislandtemperature")
			inst:AddComponent("tigersharker")
			inst:AddComponent("rainbowjellymigration")
			inst:AddComponent("wavemanager_ia") --this excludes visuals, those are clientside only
			inst:AddComponent("chessnavy")
			inst:AddComponent("whalehunter")
			inst:AddComponent("twisterspawner")
			inst:AddComponent("floodmosquitospawner")
			inst:AddComponent("hailrain")
			--inst:AddSpoofedComponent("worldshorecollisions", "shorecollisions")
		end
		inst:AddComponent("doydoyspawner")
	end
	if inst:HasTag("island") then
		inst:AddComponent("flooding")
		GLOBAL.TileState_GroundCreep = true
		if inst.net and inst.net.components.weather then
			inst.net.components.weather.cannotsnow = true
		end
	end
	inst.installIAcomponents = nil --self-destruct after use
end

--------------------------------------------------------------------------

AddPrefabPostInit("world", function(inst)

--------------------------------------------------------------------------

inst.installIAcomponents = installIAcomponents

local OnPreLoad_old = OnPreLoad
inst.OnPreLoad = function(...)
	local primaryworldtype = inst.topology and inst.topology.overrides and inst.topology.overrides.primaryworldtype 
	if not inst.topology or not inst.topology.ia_worldgen_version then primaryworldtype = "merged" end --pre-RoT fix

	if primaryworldtype then
		if primaryworldtype ~= "default" and inst:HasTag("forest") then --crude caves fix
			inst:AddTag("island")
		end
		if primaryworldtype ~= "default" and primaryworldtype ~= "merged" then
			inst:RemoveTag("forest")
		end
	end

	if inst.installIAcomponents then
		inst:installIAcomponents()
	end

	return OnPreLoad_old and OnPreLoad_old(...)
end

--------------------------------------------------------------------------

end)
%%+%%postinit/stategraphs/SGbird.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _hop_exit
local function hop_exit(inst, ...)
    if inst.updateWater then
        inst:updateWater()
    end
    if _hop_exit then _hop_exit(inst, ...) end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddStategraphPostInit("bird", function(sg)


_hop_exit = sg.states["hop"].onexit
sg.states["hop"].onexit = hop_exit


end)
%%+%%postinit/stategraphs/SGfrog.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _fall_exit
local function fall_exit(inst, ...)
    if IsOnWater(inst) then
        SpawnAt("splash_water_sink", inst)
        inst:Remove()
    end
    if _fall_exit then _fall_exit(inst, ...) end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddStategraphPostInit("frog", function(sg)


if TheWorld.ismastersim then
	_fall_exit = sg.states["fall"].onexit
	sg.states["fall"].onexit = fall_exit
end


end)
%%+%%postinit/stategraphs/SGmerm.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local states=
{
    State{
        name = "fishing_pre",
        tags = {"canrotate", "prefish", "fishing"},
        onenter = function(inst)
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("fish_pre")
        end,

        events =
        {
            EventHandler("animover", function(inst)
                inst:PerformBufferedAction()
                inst.sg:GoToState("fishing")
            end),
        },
    },

    State{
        name = "fishing",
        tags = {"canrotate", "fishing"},

        onenter = function(inst)
            inst.AnimState:PlayAnimation("fish_loop", true)
            inst.components.fishingrod:WaitForFish()
        end,

        events =
        {
            EventHandler("fishingnibble", function(inst) inst.sg:GoToState("fishing_nibble") end ),
            EventHandler("fishingloserod", function(inst) inst.sg:GoToState("loserod") end),
        },
    },

    State{
        name = "fishing_pst",
        tags = {"canrotate", "fishing"},
        onenter = function(inst)
            -- inst.AnimState:PushAnimation("fish_loop", true)
            inst.AnimState:PlayAnimation("fish_pst")
        end,

        events =
        {
            EventHandler("animover", function(inst) inst.sg:GoToState("idle") end),
        },
    },

    State{
        name = "fishing_nibble",
        tags = {"canrotate", "fishing", "nibble"},
        onenter = function(inst)
            inst.AnimState:PushAnimation("fish_loop", true)
            inst.components.fishingrod:Hook()
        end,

        events = 
        {
            EventHandler("fishingstrain", function(inst) inst.sg:GoToState("fishing_strain") end),
        },
    },

    State{
        name = "fishing_strain",
        tags = {"canrotate", "fishing"},
        onenter = function(inst)
            inst.components.fishingrod:Reel()
        end,

        events = 
        {
            EventHandler("fishingcatch", function(inst, data)
                inst.sg:GoToState("catchfish", data.build)
            end),

            EventHandler("fishingloserod", function(inst)
                -- inst.sg:GoToState("loserod")
                inst.sg:GoToState("fishing_pst")
            end),
        },
    },

    State{
        name = "catchfish",
        tags = {"canrotate", "fishing", "catchfish"},
        onenter = function(inst, build)
            inst.AnimState:PlayAnimation("fishcatch")
            inst.AnimState:OverrideSymbol("fish01", build, "fish01")
        end,
        
        timeline = 
        {
            TimeEvent(10*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/Merm/whoosh_throw")
            end), 
            TimeEvent(14*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/creatures/Merm/spear_water")
            end), 
            TimeEvent(34*FRAMES, function(inst) 
                inst.components.fishingrod:Collect()
            end),
        },

        events =
        {
            EventHandler("animover", function(inst) 
                inst.sg:RemoveStateTag("fishing")
                inst.sg:GoToState("idle")
            end),
        },

        onexit = function(inst)
            inst.AnimState:ClearOverrideSymbol("fish01")
        end,
    }, 
}

local actionhandler_fish =  ActionHandler(ACTIONS.FISH, "fishing_pre")

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddStategraphPostInit("merm", function(sg)


sg.actionhandlers[ACTIONS.FISH] = actionhandler_fish

for _,v in pairs(states) do
	sg.states[v.name] = v
end


end)
%%+%%postinit/stategraphs/SGshadowcreature.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------


-- local _hit_event_animover = inst.states["hit"].events["animover"].fn
local function hit_event_animover(inst, ...)
    local pos = inst:GetPosition()
    local offset = FindGroundOffset(pos, 2*math.pi*math.random(), 10, 12)

    if offset then
        pos = pos + offset
        inst.Transform:SetPosition(pos:Get())
    end

    inst.sg:GoToState("appear")
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddStategraphPostInit("shadowcreature", function(sg)


-- _hit_event_animover = sg.states["hit"].events["animover"].fn
sg.states["hit"].events["animover"].fn = hit_event_animover


end)
%%+%%postinit/stategraphs/SGshadowwaxwell.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------


IAENV.AddStategraphState("shadowmaxwell",State{

	name = "embark_shadow",
	tags = { "boating", "nointerrupt", "jumping", "moving", "busy", "canrotate", "nomorph", "amphibious"},

	onenter = function(inst, pos)
		inst.Physics:ClearCollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
		inst.components.locomotor:StopMoving()
		--inst.components.locomotor:EnableGroundSpeedMultiplier(false)
		inst.AnimState:PlayAnimation("jumpboat") --24 * FRAMES
		inst.AnimState:PushAnimation("landboat", false)
		-- inst.SoundEmitter:PlaySound("ia/common/boatjump_whoosh")

		inst.sg.statemem.startpos = inst:GetPosition()
		inst.sg.statemem.targetpos = pos

		if inst.components.health ~= nil then
			inst.components.health:SetInvincible(true)
		end
	end,

	onexit = function(inst)
		inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
		inst.components.locomotor:Stop()
		--inst.components.locomotor:EnableGroundSpeedMultiplier(true)
		if inst.components.health ~= nil then
			inst.components.health:SetInvincible(false)
		end
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				--end of landboat
				inst.components.locomotor:Stop()
				inst.sg:GoToState("idle")
			end
		end),
	},

	timeline =
	{
		TimeEvent(7 * FRAMES, function(inst)
			inst:ForceFacePoint(inst.sg.statemem.targetpos:Get())
			local dist = inst:GetPosition():Dist(inst.sg.statemem.targetpos)
			local speed = dist / (18/30)
			inst.Physics:SetMotorVelOverride(1 * speed, 0, 0)
			
			SpawnAt("sanity_raise", inst.sg.statemem.targetpos)
		end),
		TimeEvent(20 * FRAMES, function(inst)
			SpawnAt("statue_transition_2", inst.sg.statemem.targetpos)
		end),
		TimeEvent(22 * FRAMES, function(inst)
			if not inst.boat then
				inst.boat = SpawnAt("shadowwaxwell_boat", inst.sg.statemem.targetpos)
			end
		end),
		TimeEvent(24 * FRAMES, function(inst)
			--end of jumpboat
			-- inst:PerformBufferedAction()
			inst.Transform:SetPosition(inst.sg.statemem.targetpos:Get())
			inst.Physics:Stop()
			inst.components.locomotor:Stop()

			inst:AddTag("aquatic")
			inst:AddTag("sailing")
			inst.components.locomotor.hasmomentum = true

			if inst.boat then
				-- inst.SoundEmitter:PlaySound(inst.boat.landsound)
				--attach boat code
				-- inst.boat = inst.boat
				inst.boat.sailor = inst
				inst.boat.Physics:Teleport(0, -0.1, 0)
				inst:AddChild(inst.boat)
			end
		end),
	},
})

IAENV.AddStategraphState("shadowmaxwell",State{

	name = "disembark_shadow",
	tags = { "boating", "nointerrupt", "jumping", "moving", "busy", "canrotate", "nomorph", "amphibious"},

	onenter = function(inst, pos)
		inst.Physics:ClearCollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
		inst.components.locomotor:StopMoving()
		--inst.components.locomotor:EnableGroundSpeedMultiplier(false)
		inst.AnimState:PlayAnimation("jumpboat") --24 * FRAMES
		inst.AnimState:PushAnimation("landboat", false)
		-- inst.SoundEmitter:PlaySound("ia/common/boatjump_whoosh")

		inst.sg.statemem.startpos = inst:GetPosition()
		inst.sg.statemem.targetpos = pos

		if inst.components.health ~= nil then
			inst.components.health:SetInvincible(true)
		end

		if inst.boat then
			inst:RemoveChild(inst.boat)
			inst.boat.Physics:Teleport(inst.sg.statemem.startpos:Get())
		end
	end,

	onexit = function(inst)
		inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
		inst.components.locomotor:Stop()
		--inst.components.locomotor:EnableGroundSpeedMultiplier(true)
		if inst.components.health ~= nil then
			inst.components.health:SetInvincible(false)
		end
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				--end of landboat
				inst.components.locomotor:Stop()
				inst.sg:GoToState("idle")
			else
				--end of jumpboat
				inst.Transform:SetPosition(inst.sg.statemem.targetpos:Get())
				inst.Physics:Stop()
				inst.components.locomotor:Stop()
				
				-- inst:PerformBufferedAction()
				inst:RemoveTag("aquatic")
				inst:RemoveTag("sailing")
				-- inst.components.locomotor:RemoveExternalSpeedAdder(boat, "SAILOR")
				inst.components.locomotor.hasmomentum = false
			end
		end),
	},

	timeline =
	{
		TimeEvent(7 * FRAMES, function(inst)
			inst:ForceFacePoint(inst.sg.statemem.targetpos:Get())
			local dist = inst:GetPosition():Dist(inst.sg.statemem.targetpos)
			local speed = dist / (18/30)
			inst.Physics:SetMotorVelOverride(1 * speed, 0, 0)
		end),
		TimeEvent(9 * FRAMES, function(inst)
			-- SpawnAt("statue_transition", inst.sg.statemem.startpos)
			SpawnAt("statue_transition_2", inst.sg.statemem.startpos)
		end),
		TimeEvent(12 * FRAMES, function(inst)
			if inst.boat then
				inst.boat:Remove()
				inst.boat = nil
			end
		end),
	},
})


IAENV.AddStategraphState("shadowmaxwell",State{

	name = "row_start_ia",
	tags = {"moving", "running", "boating", "canrotate"},

	onenter = function(inst)
		inst.components.locomotor:RunForward()
		inst.AnimState:PlayAnimation("row_pre")
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				inst.sg:GoToState("row_ia")
			end
		end),
	},
})
IAENV.AddStategraphState("shadowmaxwell",State{

	name = "row_ia",
	tags = {"moving", "running", "boating", "canrotate"},

	onenter = function(inst)
		inst.components.locomotor:RunForward()
		if not inst.AnimState:IsCurrentAnimation("row_loop") then
			inst.AnimState:PlayAnimation("row_loop", true)
		end
		inst.sg:SetTimeout(inst.AnimState:GetCurrentAnimationLength())
	end,

	ontimeout = function(inst)
		inst.sg:GoToState("row_ia")
	end,
})
IAENV.AddStategraphState("shadowmaxwell",State{

	name = "row_stop_ia",
	tags = {"canrotate", "idle"},

	onenter = function(inst)
		inst.components.locomotor:Stop()
		inst.AnimState:PlayAnimation("row_pst")
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				inst.sg:GoToState("idle")
			end
		end),
	},
})

IAENV.AddStategraphState("shadowmaxwell",State{

	name = "sail_start_ia",
	tags = {"moving", "running", "boating", "canrotate"},

	onenter = function(inst)
		inst.components.locomotor:RunForward()
		inst.AnimState:PlayAnimation("sail_pre")
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				inst.sg:GoToState("sail_ia")
			end
		end),
	},
})
IAENV.AddStategraphState("shadowmaxwell",State{

	name = "sail_ia",
	tags = {"moving", "running", "boating", "sailing", "canrotate"},

	onenter = function(inst)
		inst.components.locomotor:RunForward()
		if not inst.AnimState:IsCurrentAnimation("sail_loop") then
			inst.AnimState:PlayAnimation("sail_loop", true)
		end
		inst.sg:SetTimeout(inst.AnimState:GetCurrentAnimationLength())
	end,

	ontimeout = function(inst)
		inst.sg:GoToState("sail_ia")
	end,
})
IAENV.AddStategraphState("shadowmaxwell",State{

	name = "sail_stop_ia",
	tags = {"canrotate", "idle"},

	onenter = function(inst)
		inst.components.locomotor:Stop()
		inst.AnimState:PlayAnimation("sail_pst")
	end,

	events =
	{
		EventHandler("animover", function(inst)
			if inst.AnimState:AnimDone() then
				inst.sg:GoToState("idle")
			end
		end),
	},
})



local event_locomote_old
local function locomote_handler(inst)

	if inst.sg:HasStateTag("nointerrupt") then return end

	local is_moving = inst.sg:HasStateTag("moving")
	local should_move = inst.components.locomotor:WantsToMoveForward()

	local leader = inst.components.follower and inst.components.follower:GetLeader()
	local leaderHasSail = leader and leader.sg and leader.sg:HasStateTag("sailing")
	local hasSail = inst.sg:HasStateTag("sailing")

	if not inst.sg:HasStateTag("busy") and not inst:HasTag("busy") and inst.boat then
		if not inst.sg:HasStateTag("attack") then
			if is_moving and not should_move then
				inst.sg:GoToState(hasSail and "sail_stop_ia" or "row_stop_ia")
			elseif not is_moving and should_move then
				inst.sg:GoToState(leaderHasSail and "sail_start_ia" or "row_start_ia")
			end
		end
		return
	end
	
	return event_locomote_old(inst)
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddStategraphPostInit("shadowmaxwell", function(sg)


event_locomote_old = sg.events["locomote"].fn
sg.events["locomote"].fn = locomote_handler


end)
%%+%%postinit/stategraphs/SGwilson.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

IAENV.AddStategraphPostInit("wilson", function(inst)


local ToggleOffPhysics
local ToggleOnPhysics
local DoFoleySounds
local ClearStatusAilments
local ForceStopHeavyLifting

do
    --FIX Collision Problems from ToggleOn/OffPhysics functions.
    local _jumpin_onenter = inst.states["jumpin"].onenter
    local _jumpin_onexit = inst.states["jumpin"].onexit
    ToggleOffPhysics = UpvalueHacker.GetUpvalue(_jumpin_onenter, "ToggleOffPhysics")
    ToggleOnPhysics = UpvalueHacker.GetUpvalue(_jumpin_onexit, "ToggleOnPhysics")
    UpvalueHacker.SetUpvalue(_jumpin_onenter, function(...) ToggleOffPhysics(...) end, "ToggleOffPhysics")
    UpvalueHacker.SetUpvalue(_jumpin_onexit, function(...) ToggleOnPhysics(...) end, "ToggleOnPhysics")

    local _run_start_timeevent_2 = inst.states["run_start"].timeline[2].fn
    DoFoleySounds = UpvalueHacker.GetUpvalue(_run_start_timeevent_2, "DoFoleySounds")
    UpvalueHacker.SetUpvalue(_run_start_timeevent_2, function(...) DoFoleySounds(...) end, "DoFoleySounds")

    local _electrocute_onenter = inst.states["electrocute"].onenter
    ClearStatusAilments = UpvalueHacker.GetUpvalue(_electrocute_onenter, "ClearStatusAilments")
    ForceStopHeavyLifting = UpvalueHacker.GetUpvalue(_electrocute_onenter, "ForceStopHeavyLifting")
    UpvalueHacker.SetUpvalue(_electrocute_onenter, function(...) ClearStatusAilments(...) end, "ClearStatusAilments")
    UpvalueHacker.SetUpvalue(_electrocute_onenter, function(...) ForceStopHeavyLifting(...) end, "ForceStopHeavyLifting")


    local _ToggleOnPhysics = ToggleOnPhysics
    ToggleOnPhysics = function(inst, ...)
        _ToggleOnPhysics(inst, ...)
        inst.Physics:CollidesWith(COLLISION.WAVES)
    end
end

local function OnExitRow(inst)
    local boat = inst.replica.sailor:GetBoat()
    if boat and boat.components.rowboatwakespawner then
        boat.components.rowboatwakespawner:StopSpawning()
    end
    if inst.sg.nextstate ~= "row_ia" and inst.sg.nextstate ~= "sail_ia" then
        inst.components.locomotor:Stop(nil, true)
        if inst.sg.nextstate ~= "row_stop_ia" and inst.sg.nextstate ~= "sail_stop_ia" then --Make sure equipped items are pulled back out (only really for items with flames right now)
            local equipped = inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if equipped then
                equipped:PushEvent("stoprowing", {owner = inst})
            end
            if boat then
                boat.replica.sailable:PlayIdleAnims()
            end
        end
    end
end

local function OnExitSail(inst)
    local boat = inst.replica.sailor:GetBoat()
    if boat and boat.components.rowboatwakespawner then 
        boat.components.rowboatwakespawner:StopSpawning()
    end 

    if inst.sg.nextstate ~= "sail_ia" then 
        inst.SoundEmitter:KillSound("sail_loop")
        if inst.sg.nextstate ~= "row_ia" then 
            inst.components.locomotor:Stop(nil, true)
        end
        if inst.sg.nextstate ~= "row_stop_ia" and inst.sg.nextstate ~= "sail_stop_ia" then
            if boat then
                boat.replica.sailable:PlayIdleAnims()
            end
        end
    end
end

local function installBermudaFX(inst)

    if inst.sg.statemem.startinfo then print("WARNING: installBermudaFX twice???") return end

    inst.AnimState:Pause()

    inst.sg.statemem.startinfo = {
        --TODO store original ADDcolour and erosion
        -- colour = inst.AnimState:GetMultColour(),
        scale = inst.Transform:GetScale(),
    }

    --[[
    local textures = {
        "images/bermudaTriangle01.tex",
        "images/bermudaTriangle02.tex",
        "images/bermudaTriangle03.tex",
        "images/bermudaTriangle04.tex",
        "images/bermudaTriangle05.tex",
    }
    --]]

    local colours = {
        {30/255, 57/255, 81/255, 1.0},
        {30/255, 57/255, 81/232, 1.0},
        {30/255, 57/255, 81/232, 1.0},
        {30/255, 57/255, 81/232, 1.0},

        {255/255, 255/255, 255/255, 1.0},
        {255/255, 255/255, 255/255, 1.0},

        {0, 0, 0, 1.0},
    }

    local colourfn = nil
    local posfn = nil
    local scalefn = nil
    local texturefn = nil

    colourfn = function()
        local colour = colours[math.random(#colours)]
        inst.AnimState:SetAddColour(colour[1], colour[2], colour[3], colour[4])
        inst.sg.statemem.colourtask = nil
        inst.sg.statemem.colourtask = inst:DoTaskInTime(math.random(10, 15) * FRAMES, colourfn)
    end

    posfn = function()
        local offset = Vector3(math.random(-1, 1) * .1, math.random(-1, 1) * .1, math.random(-1, 1) * .1)
        inst.Transform:SetPosition((inst:GetPosition() + offset):Get())
        inst.sg.statemem.postask = nil
        inst.sg.statemem.postask = inst:DoTaskInTime(math.random(6, 9) * FRAMES, posfn)
    end

    scalefn = function()
        inst.Transform:SetScale(math.random(95, 105) * 0.01, math.random(99, 101) * 0.01, 1)

        inst.sg.statemem.scaletask = nil
        inst.sg.statemem.scaletask = inst:DoTaskInTime(math.random(5, 8) * FRAMES, scalefn)
    end

    texturefn = function()
        inst.AnimState:SetErosionParams(math.random(1, 4) * 0.1, 0, 1)
        --AnimState does not have SetErosionTexture in DST, and TheSim is a touchy subject
        --inst.AnimState:SetErosionParams(math.random(4, 6) * 0.1, 0, 1)
        --TheSim:SetErosionTexture(textures[math.random(#textures)])

        inst.sg.statemem.texturetask = nil
        inst.sg.statemem.texturetask = inst:DoTaskInTime(math.random(4, 7) * FRAMES, texturefn)
    end

    colourfn()
    posfn()
    scalefn()
    texturefn()
end

local function removeBermudaFX(inst)

    if inst.sg.statemem.startinfo then
        inst.sg.statemem.colourtask:Cancel()
        inst.sg.statemem.colourtask = nil
        inst.sg.statemem.postask:Cancel()
        inst.sg.statemem.postask = nil
        inst.sg.statemem.scaletask:Cancel()
        inst.sg.statemem.scaletask = nil
        inst.sg.statemem.texturetask:Cancel()
        inst.sg.statemem.texturetask = nil

        --TODO can we restore the original values from statemem?
        inst.AnimState:SetAddColour(0,0,0,1)
        inst.Transform:SetScale(1,1,1)
        inst.AnimState:SetErosionParams(0, 0, 0)
        --TheSim:SetErosionTexture("images/erosion.tex")

        inst.AnimState:Resume()

        inst.sg.statemem.startinfo = nil
    end
end


--STATEGRAPH PATCHES, not poluting this files namespace though.
do
    local _fishing_strain_onenter = inst.states["fishing_strain"].onenter
    inst.states["fishing_strain"].onenter = function(inst, ...)
        _fishing_strain_onenter(inst, ...)

        if inst.components.sailor and inst.components.sailor:IsSailing() then
            if math.random() < TUNING.FISHING_CROCODOG_SPAWN_CHANCE then          
                TheWorld.components.hounded:SummonSpawn(Point(inst.Transform:GetWorldPosition()), "crocodog")
            end 
        end
    end

    local _transform_werebeaver_exit = inst.states["transform_werebeaver"].onexit
    inst.states["transform_werebeaver"].onexit = function(inst, ...)
        if inst.sg:HasStateTag("drowning") then return end -- simple hack to prevent looping
        if inst.components.sailor and inst.components.sailor:IsSailing() then
            inst.sg:AddStateTag("drowning")

            --this will cause the boat to "drown" the player and handle the rest of the code.
            if inst.components.sailor and inst.components.sailor:IsSailing() then
                inst.components.sailor.boat.components.boathealth:MakeEmpty()
            end 
            --inst.sg:GoToState("werebeaver_death_boat")
        else
            _transform_werebeaver_exit(inst, ...)
        end
    end


    local _play_flute_onenter = inst.states["play_flute"].onenter
    inst.states["play_flute"].onenter = function(inst, ...)
        _play_flute_onenter(inst, ...)
        local act = inst:GetBufferedAction()
        if act and act.invobject and act.invobject.flutebuild then
            inst.AnimState:OverrideSymbol("pan_flute01", act.invobject.flutebuild or "pan_flute", act.invobject.flutesymbol or "pan_flute01")
        end
    end
    local _use_fan_onenter = inst.states["use_fan"].onenter
    inst.states["use_fan"].onenter = function(inst, ...)
        _use_fan_onenter(inst, ...)
		local invobject = inst.bufferedaction.invobject
        if invobject and invobject.components.fan and invobject.components.fan.overridebuild then
            inst.AnimState:OverrideSymbol(
                "fan01",
                invobject.components.fan.overridebuild or "fan",
                invobject.components.fan.overridesymbol or "swap_fan"
            )
        end
    end

    local _mine_timeevent_1 = inst.states["mine"].timeline[1].fn --How to make sure this is our intended target?
    inst.states["mine"].timeline[1].fn = function(inst, ...)
        if inst.sg.statemem.action ~= nil then
            local target = inst.sg.statemem.action.target
            if target ~= nil and target:IsValid() then
                local coral = target:HasTag("coral")
                local charcoal = target:HasTag("charcoal")
                if coral or charcoal then
                    if target.Transform ~= nil then
                        SpawnAt("mining_fx", target)
                    end
                    inst.SoundEmitter:PlaySound(coral and "ia/common/coral_mine" or "ia/common/charcoal_mine")
                    inst:PerformBufferedAction()
                    return
                end
            end
        end
        _mine_timeevent_1(inst, ...) --default handler
    end

end

do
    -- HANDLER PATCHES

    local _locomote_eventhandler = inst.events.locomote.fn
    inst.events.locomote.fn = function(inst, data)
        local is_attacking = inst.sg:HasStateTag("attack")

        local is_moving = inst.sg:HasStateTag("moving")
        local is_running = inst.sg:HasStateTag("running")
        local should_move = inst.components.locomotor:WantsToMoveForward()
        if inst.components.sailor and inst.components.sailor.boat and not inst.components.sailor.boat.components.sailable then
            should_move = false
        end

        local should_run = inst.components.locomotor:WantsToRun()
        local hasSail = inst.replica.sailor and inst.replica.sailor:GetBoat() and inst.replica.sailor:GetBoat().replica.sailable:GetIsSailEquipped() or false
        if not should_move then
            if inst.components.sailor and inst.components.sailor.boat then
                inst.components.sailor.boat:PushEvent("boatstopmoving")
            end
        end 
        if should_move then 
            if inst.components.sailor and inst.components.sailor.boat then
                inst.components.sailor.boat:PushEvent("boatstartmoving")
            end
        end 

        if inst.sg:HasStateTag("busy") or inst:HasTag("busy") then
            return _locomote_eventhandler(inst, data)
        end
        if inst.components.sailor and inst.components.sailor:IsSailing() then
            if not is_attacking then
                if is_moving and not should_move then         
                    if hasSail then
                        inst.sg:GoToState("sail_stop_ia")
                    else
                        inst.sg:GoToState("row_stop_ia")
                    end
                elseif not is_moving and should_move or (is_moving and should_move and is_running ~= should_run) then         
                    if hasSail then
                        inst.sg:GoToState("sail_start_ia")
                    else
                        inst.sg:GoToState("rowl_start_ia")
                    end
                end
            end
            return
        end

        _locomote_eventhandler(inst, data)
    end

    local _death_eventhandler = inst.events.death.fn
    inst.events.death.fn = function(inst, data)
        if data.cause == "drowning" then
            inst.sg:GoToState("death_boat")
        else
            if inst.components.sailor and inst.components.sailor.boat and inst.components.sailor.boat.components.container then
                inst.components.sailor.boat.components.container:Close(true)
            end
            _death_eventhandler(inst, data)
        end
    end

    local _attacked_eventhandler = inst.events.attacked.fn
    inst.events.attacked.fn = function(inst, data)
        if inst.components.sailor and inst.components.sailor:IsSailing() then
            local boat = inst.components.sailor:GetBoat()
            if not inst.components.health:IsDead() and not (boat and boat.components.boathealth and boat.components.boathealth:IsDead()) then

                if not boat.components.sailable or not boat.components.sailable:CanDoHit() then 
                    return 
                end

                if data.attacker and (data.attacker:HasTag("insect") or data.attacker:HasTag("twister"))then
                    local is_idle = inst.sg:HasStateTag("idle")
                    if not is_idle then
                        return
                    end
                end

                boat.components.sailable:GetHit()
                
                _attacked_eventhandler(inst, data)
            end
        else
            _attacked_eventhandler(inst, data)
        end
    end

	local _attack_actionhandler = inst.actionhandlers[ACTIONS.ATTACK].deststate
	inst.actionhandlers[ACTIONS.ATTACK].deststate = function(inst, action, ...)
		if not (inst.sg:HasStateTag("attack") and action.target == inst.sg.statemem.attacktarget or inst.components.health:IsDead()) then
			local weapon = inst.components.combat ~= nil and inst.components.combat:GetWeapon() or nil
			if weapon and weapon:HasTag("speargun") then
				return "speargun"
			end
		end
		return _attack_actionhandler(inst, action, ...)
	end

    -- Disembark properly and drop no skeleton
    local _death_animover = inst.states.death.events.animover.fn
    inst.states.death.events.animover.fn = function(inst, ...)
        if inst.AnimState:AnimDone() and not inst.sg:HasStateTag("dismounting")
        and IsOnWater(inst) then
            if inst.components.sailor then
                inst.components.sailor:Disembark()
            end
            inst:PushEvent(inst.ghostenabled and "makeplayerghost" or "playerdied", {skeleton = false})
        else
            _death_animover(inst, ...)
        end
    end
end

do
	local _attack_onenter = inst.states.attack.onenter
	inst.states.attack.onenter = function(inst, data)

		local equip = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
		if equip and equip:HasTag("cutlass") then
			SetSoundAlias("dontstarve/wilson/attack_weapon", "ia/common/swordfish_sword")
		elseif equip and equip:HasTag("pegleg") then
			SetSoundAlias("dontstarve/wilson/attack_weapon", "ia/common/pegleg_weapon")
		end

		_attack_onenter(inst, data)

		SetSoundAlias("dontstarve/wilson/attack_weapon", nil)

	end
end

do
	local _fish_actionhandler = inst.actionhandlers[ACTIONS.FISH].deststate
	inst.actionhandlers[ACTIONS.FISH].deststate = function(inst, action, ...)
		if action.target and action.target.components.workable
		and action.target.components.workable:GetWorkAction() == ACTIONS.FISH
		and action.target.components.workable:CanBeWorked() then
			return "fishing_retrieve"
		end
		if type(_fish_actionhandler) == "function" then
			return _fish_actionhandler(inst, action, ...)
		end
		return _fish_actionhandler
	end
end


local actionhandlers = {
    ActionHandler(ACTIONS.EMBARK, "embark"),
    ActionHandler(ACTIONS.DISEMBARK, "disembark"),
    ActionHandler(ACTIONS.THROW, "throw"),
    ActionHandler(ACTIONS.LAUNCH_THROWABLE, "cannon"),
    ActionHandler(ACTIONS.RETRIEVE, "dolongaction"),
    ActionHandler(ACTIONS.STICK, "doshortaction"),
    ActionHandler(ACTIONS.DEPLOY_AT_RANGE, "doshortaction"),
    ActionHandler(ACTIONS.LAUNCH, "doshortaction"),
    ActionHandler(ACTIONS.HACK, function(inst)
        if inst:HasTag("beaver") then
            return not inst.sg:HasStateTag("gnawing") and "gnaw" or nil
        end
        return not inst.sg:HasStateTag("prehack") and (inst.sg:HasStateTag("hacking") and "hack" or "hack_start") or nil
    end),
    ActionHandler(ACTIONS.TOGGLEON, "give"),
    ActionHandler(ACTIONS.TOGGLEOFF, "give"),
    ActionHandler(ACTIONS.REPAIRBOAT, "dolongaction"),
    ActionHandler(ACTIONS.CUREPOISON, function(inst, action)
        local target = action.target

        if not target or target == inst then
            return "quickeat"
        else
            return "give"
        end
    end),
    ActionHandler(ACTIONS.PACKUP, "doshortaction"),
    ActionHandler(ACTIONS.PEER, "peertelescope"),
}

local events = {
    EventHandler("drown_fake", function(inst, data)
        if inst.components.health and not inst.components.health:IsDead() then
            if IsOnWater(inst) then
                if data and not data.rescueitem then
                    data.rescueitem = inst -- require a rescueitem for logic
                end
                inst.sg:GoToState("death_boat", data)
            elseif IsOnLand(inst) then
                if data and not data.rescueitem then
                    data.rescueitem = inst -- require a rescueitem for logic
                end
                --inst.sg:GoToState("death_boat", data)
            end
        end          
    end),

    EventHandler("vacuum_in", function(inst)
        if inst.components.health and not inst.components.health:IsDead() and
        not (IsOnWater(inst:GetPosition())) and
        not inst.sg:HasStateTag("vacuum_in") and
        not (inst.components.sailor and inst.components.sailor:IsSailing()) then
            inst.sg:GoToState("vacuumedin")
        end          
    end),

    EventHandler("vacuum_out", function(inst, data)
        if inst.components.health and not inst.components.health:IsDead() and
        not (IsOnWater(inst:GetPosition())) and
        not inst.sg:HasStateTag("vacuum_out") and
        not (inst.components.sailor and inst.components.sailor:IsSailing()) then 
            inst.sg:GoToState("vacuumedout", data)
        else
            inst:RemoveTag("NOVACUUM")
        end          
    end),

    EventHandler("vacuum_held", function(inst)
        if inst.components.health and not inst.components.health:IsDead() and
        not (IsOnWater(inst:GetPosition())) and
        not inst.sg:HasStateTag("vacuum_held") and
        not (inst.components.sailor and inst.components.sailor:IsSailing()) then 

            inst.sg:GoToState("vacuumedheld")
        end          
    end),

    EventHandler("sailequipped", function(inst)
        if inst.sg:HasStateTag("rowing") then 
            inst.sg:GoToState("sail_ia")
            local equipped = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if equipped then 
                equipped:PushEvent("stoprowing", {owner = inst})
            end
        end 
    end),

    EventHandler("sailunequipped", function(inst)
        if inst.sg:HasStateTag("sailing") then 
            inst.sg:GoToState("row_ia")

            if not inst:HasTag("mime") then
                inst.AnimState:OverrideSymbol("paddle", "swap_paddle", "paddle")
            end
            --TODO allow custom paddles?
            inst.AnimState:OverrideSymbol("wake_paddle", "swap_paddle", "wake_paddle")
            
            local equipped = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if equipped then 
                equipped:PushEvent("startrowing", {owner = inst})
            end
        end         
    end),

    EventHandler("boatattacked", inst.events.attacked.fn),

    EventHandler("boostbywave", function(inst, data)
        if inst.sg:HasStateTag("running") then 
            
            local boost = data.boost or TUNING.WAVEBOOST
            if inst.components.sailor then
                local boat = inst.components.sailor:GetBoat()
                if boat and boat.waveboost and not data.boost then
                    boost = boat.waveboost
                end
                -- sanity boost, walani's surfboard mainly
                if boat and boat.wavesanityboost and inst.components.sanity then
                    inst.components.sanity:DoDelta(boat.wavesanityboost)
                end
            end

            if inst.components.locomotor then
                inst.components.locomotor.boost = boost
            end
        end 
    end),
}

local states = {
    State{
        name = "rowl_start_ia",
        tags = { "moving", "running", "rowing", "boating", "canrotate", "autopredict" },

        onenter = function(inst)
            local boat = inst.replica.sailor:GetBoat()

            inst.components.locomotor:RunForward()

            if not inst:HasTag("mime") then
                inst.AnimState:OverrideSymbol("paddle", "swap_paddle", "paddle")
            end
            --TODO allow custom paddles?
            inst.AnimState:OverrideSymbol("wake_paddle", "swap_paddle", "wake_paddle")

			--RoT has row_pre, which is identical but uses the equipped item as paddle
            inst.AnimState:PlayAnimation("row_ia_pre")
            if boat then
                boat.replica.sailable:PlayPreRowAnims()
            end

            DoFoleySounds(inst)

            local equipped = inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if equipped then 
                equipped:PushEvent("startrowing", {owner = inst})
            end
            inst:PushEvent("startrowing")
        end,

        onupdate = function(inst)
            inst.components.locomotor:RunForward()
        end,

        onexit = OnExitRow,

        events = {   
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("row_ia")
				end
			end),
        },  
    },

    State{
        name = "row_ia",
        tags = { "moving", "running", "rowing", "boating", "canrotate", "autopredict" },

        onenter = function(inst) 
            local boat = inst.replica.sailor:GetBoat()

            if boat and boat.replica.sailable.creaksound then
                inst.SoundEmitter:PlaySound(boat.replica.sailable.creaksound, nil, nil, true)
            end
            inst.SoundEmitter:PlaySound("ia/common/boat/paddle", nil, nil, true)
            DoFoleySounds(inst)

            if not inst.AnimState:IsCurrentAnimation("row_loop") then
				--RoT has row_medium, which is identical but uses the equipped item as paddle
                inst.AnimState:PlayAnimation("row_loop", true)
            end
            if boat then
                boat.replica.sailable:PlayRowAnims()
            end

            if boat and boat.components.rowboatwakespawner then 
                boat.components.rowboatwakespawner:StartSpawning()
            end

            if inst.components.mapwrapper
            and inst.components.mapwrapper._state > 1
            and inst.components.mapwrapper._state < 5 then
                inst.sg:AddStateTag("nomorph")
                -- TODO pause predict?
            end

            inst.sg:SetTimeout(inst.AnimState:GetCurrentAnimationLength())
        end,

        onexit = OnExitRow,

        timeline = {
            TimeEvent(8*FRAMES, function(inst)
                local boat = inst.replica.sailor:GetBoat()
                if boat and boat.replica.container then
                    local trawlnet = boat.replica.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
                    if trawlnet and trawlnet.rowsound then
                        inst.SoundEmitter:PlaySound(trawlnet.rowsound, nil, nil, true)
                    end
                end
            end),
        },

        events = {
            EventHandler("trawlitem", function(inst) 
                local boat = inst.replica.sailor:GetBoat() 
                if boat then
                    boat.replica.sailable:PlayTrawlOverAnims()
                end
            end),
        },

        ontimeout = function(inst) inst.sg:GoToState("row_ia") end,
    },

    State{
        name = "row_stop_ia",
        tags = { "canrotate", "idle", "autopredict"},

        onenter = function(inst)
            inst.components.locomotor:Stop()
            local boat = inst.replica.sailor:GetBoat()
            inst.AnimState:PlayAnimation("row_pst")
            if boat then
                boat.replica.sailable:PlayPostRowAnims()
            end

            --If the player had something in their hand before starting to row, put it back.
            if inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS) then
                inst.AnimState:PushAnimation("item_out", false)
            end
        end,

        events = {
            EventHandler("animqueueover", function(inst)
				if inst.AnimState:AnimDone() then
					local equipped = inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
					if equipped then
						equipped:PushEvent("stoprowing", {owner = inst})
					end
					inst:PushEvent("stoprowing")
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "sail_start_ia",
        tags = {"moving", "running", "canrotate", "boating", "sailing", "autopredict"},

        onenter = function(inst)
            local boat = inst.replica.sailor:GetBoat()

            inst.components.locomotor:RunForward()

            inst.AnimState:PlayAnimation("sail_pre")
            if boat then
                boat.replica.sailable:PlayPreSailAnims()
            end

            local equipped = inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if equipped then 
                equipped:PushEvent("startsailing", {owner = inst})
            end
        end,

        onupdate = function(inst)
            inst.components.locomotor:RunForward()
        end,

        onexit = OnExitSail,

        events = {   
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("sail_ia")
				end
			end),
        },
    },

    State{
        name = "sail_ia",
        tags = {"canrotate", "moving", "running", "boating", "sailing", "autopredict"},

        onenter = function(inst)
            local boat = inst.replica.sailor:GetBoat()

            local loopsound = nil 
            local flapsound = nil 

            if boat and boat.replica.container and boat.replica.container.hasboatequipslots then 
                local sail = boat.replica.container:GetItemInBoatSlot(BOATEQUIPSLOTS.BOAT_SAIL)
                if sail then 
                    loopsound = sail.loopsound
                    flapsound = sail.flapsound
                end 
            elseif boat and boat.replica.sailable.sailsound then
                loopsound = boat.replica.sailable.sailsound
            end
           
            if not inst.SoundEmitter:PlayingSound("sail_loop") and loopsound then 
                inst.SoundEmitter:PlaySound(loopsound, "sail_loop", nil, true)
            end 

            if flapsound then 
                inst.SoundEmitter:PlaySound(flapsound, nil, nil, true) 
            end

            if boat and boat.replica.sailable.creaksound then
                inst.SoundEmitter:PlaySound(boat.replica.sailable.creaksound, nil, nil, true)
            end
            
            if not inst.AnimState:IsCurrentAnimation("sail_loop") then
                inst.AnimState:PlayAnimation("sail_loop", true)
            end
            if boat then
                boat.replica.sailable:PlaySailAnims()
            end

            if boat and boat.components.rowboatwakespawner then 
                boat.components.rowboatwakespawner:StartSpawning()
            end 

            if inst.components.mapwrapper
            and inst.components.mapwrapper._state > 1
            and inst.components.mapwrapper._state < 5 then
                inst.sg:AddStateTag("nomorph")
                --TODO pause predict?
            end
            inst.sg:SetTimeout(inst.AnimState:GetCurrentAnimationLength())
        end,

        onexit = OnExitSail,

        events = {   
            --EventHandler("animover", function(inst) inst.sg:GoToState("sail_ia") end ),
            EventHandler("trawlitem", function(inst) 
                local boat = inst.replica.sailor:GetBoat() 
                if boat then
                    boat.replica.sailable:PlayTrawlOverAnims()
                end
            end),
        },

        ontimeout = function(inst) inst.sg:GoToState("sail_ia") end,
    },

    State{
        name = "sail_stop_ia",
        tags = {"canrotate", "idle", "autopredict"},

        onenter = function(inst) 
            local boat = inst.replica.sailor:GetBoat()

            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("sail_pst")
            if boat then
                boat.replica.sailable:PlayPostSailAnims()
            end
        end,
            
        events = {   
            EventHandler("animover", function(inst) 
				if inst.AnimState:AnimDone() then
					local equipped = inst.replica.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
					if equipped then 
						equipped:PushEvent("stopsailing", {owner = inst})
					end
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "embark",
        tags = {"canrotate", "boating", "busy", "nomorph", "nopredict"},
        onenter = function(inst)
            local BA = inst:GetBufferedAction()
            if BA.target and BA.target.components.sailable and not BA.target.components.sailable:IsOccupied() then
                BA.target.components.sailable.isembarking = true
                if inst.components.sailor and inst.components.sailor:IsSailing() then
                    inst.components.sailor:Disembark(nil, true)
                else
                    inst.sg:GoToState("jumponboatstart")
                end
			else
				--go to idle first so wilson can go to the talk state if desired -M
				--and in my defence, Klei does that too, in opengift state
				inst.sg:GoToState("idle")
				inst:PushEvent("actionfailed", { action = inst.bufferedaction, reason = "INUSE" })
				inst:ClearBufferedAction()
            end
        end,

        onexit = function(inst)
        end,
    },

    State{
        name = "disembark",
        tags = {"canrotate", "boating", "busy", "nomorph", "nopredict"},
        onenter = function(inst)
            inst:PerformBufferedAction()
        end,

        onexit = function(inst)
        end,
    },

    State{
        name = "jumponboatstart",
        tags = { "doing", "nointerupt", "busy", "canrotate", "nomorph", "nopredict", "amphibious"},

        onenter = function(inst)
			if inst.Physics.ClearCollidesWith then
			inst.Physics:ClearCollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            inst.components.locomotor:StopMoving()
            --inst.components.locomotor:EnableGroundSpeedMultiplier(false)
            inst.AnimState:PlayAnimation("jumpboat")
            inst.SoundEmitter:PlaySound("ia/common/boatjump_whoosh")

            local BA = inst:GetBufferedAction()
            inst.sg.statemem.startpos = inst:GetPosition()
            inst.sg.statemem.targetpos = BA.target and BA.target:GetPosition()
            
            inst:PushEvent("ms_closepopups")

            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(true)
            end

            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
            end
        end,

        onexit = function(inst)
        --This shouldn"t actually be reached
			if inst.Physics.ClearCollidesWith then
			inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            inst.components.locomotor:Stop()
            --inst.components.locomotor:EnableGroundSpeedMultiplier(true)
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(false)
            end

            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
        end,

        timeline = {
            -- Make the action cancel-able until this?
            TimeEvent(7 * FRAMES, function(inst)
                inst:ForceFacePoint(inst.sg.statemem.targetpos:Get())
                local dist = inst:GetPosition():Dist(inst.sg.statemem.targetpos)
                local speed = dist / (18/30)
                inst.Physics:SetMotorVelOverride(1 * speed, 0, 0)
            end),
        },

        events = {
            EventHandler("animover", function(inst)
                if inst.components.playercontroller ~= nil then
                    inst.components.playercontroller:Enable(true)
                end

                if inst.components.health ~= nil then
                    inst.components.health:SetInvincible(false)
                end
                inst.Transform:SetPosition(inst.sg.statemem.targetpos:Get())
                inst.Physics:Stop()

                inst.components.locomotor:Stop()
                --inst.components.locomotor:EnableGroundSpeedMultiplier(true)
                inst:PerformBufferedAction()
            end),
        },
    },

    State{
        name = "jumpboatland",
        tags = { "doing", "nointerupt", "busy", "canrotate", "invisible", "nomorph", "nopredict", "amphibious"},

        onenter = function(inst, pos)
			if inst.Physics.ClearCollidesWith then
			inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(true)
            end
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("landboat")
            local boat = inst.components.sailor.boat 
            if boat and boat.landsound then
                inst.SoundEmitter:PlaySound(boat.landsound)
            end
        end,

        onexit = function(inst)
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(false)
            end
        end,

        events = {
            EventHandler("animqueueover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "jumpoffboatstart",
        tags = { "doing", "nointerupt", "busy", "canrotate", "nomorph", "nopredict", "amphibious"},

        onenter = function(inst, pos)
			if inst.Physics.ClearCollidesWith then
			inst.Physics:ClearCollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            inst.components.locomotor:StopMoving()
            --inst.components.locomotor:EnableGroundSpeedMultiplier(false)
            inst.AnimState:PlayAnimation("jumpboat")
            inst.SoundEmitter:PlaySound("ia/common/boatjump_whoosh")

            inst.sg.statemem.startpos = inst:GetPosition()
            inst.sg.statemem.targetpos = pos
            
            inst:PushEvent("ms_closepopups")

            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(true)
            end

            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
            end
        end,

        onexit = function(inst)
        --This shouldn"t actually be reached
			if inst.Physics.ClearCollidesWith then
			inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            inst.components.locomotor:Stop()
            --inst.components.locomotor:EnableGroundSpeedMultiplier(true)
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(false)
            end

            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
        end,

        timeline = {
            --Make the action cancel-able until this?
            TimeEvent(7 * FRAMES, function(inst)
                inst:ForceFacePoint(inst.sg.statemem.targetpos:Get())
                local dist = inst:GetPosition():Dist(inst.sg.statemem.targetpos)
                local speed = dist / (18/30)
                inst.Physics:SetMotorVelOverride(1 * speed, 0, 0)
            end),
        },

        events = {
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.Transform:SetPosition(inst.sg.statemem.targetpos:Get())
					if inst.components.health ~= nil then
						inst.components.health:SetInvincible(false)
					end
					inst.sg:GoToState("jumpoffboatland")
				end
            end),
        },
    },

    State{
        name = "jumpoffboatland",
        tags = { "doing", "nointerupt", "busy", "canrotate", "nomorph", "nopredict", "amphibious"},

        onenter = function(inst, pos)
			if inst.Physics.ClearCollidesWith then
			inst.Physics:CollidesWith(COLLISION.LIMITS) --R08_ROT_TURNOFTIDES
			end
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(true)
            end
            inst.Physics:Stop()
            inst.AnimState:PlayAnimation("land", false)
            inst.SoundEmitter:PlaySound("ia/common/boatjump_to_land")
            PlayFootstep(inst)
        end,

        onexit = function(inst)
            if inst.components.health ~= nil then
                inst.components.health:SetInvincible(false)
            end
        end,

        events = {
            EventHandler("animqueueover", function(inst)
                inst:PerformBufferedAction()
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "hack_start",
        tags = {"prehack", "working"},

        onenter = function(inst)
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("chop_pre")
        end,

        events = {
            EventHandler("unequip", function(inst) inst.sg:GoToState("idle") end),
            EventHandler("animover", function(inst)
                if inst.AnimState:AnimDone() then
                    inst.sg:GoToState("hack")
                end
            end),
        },
    },

    State{
        name = "hack",
        tags = {"prehack", "hacking", "working"},

        onenter = function(inst)
            inst.sg.statemem.action = inst:GetBufferedAction()
            inst.AnimState:PlayAnimation("chop_loop")            
        end,

        timeline = {
            TimeEvent(2*FRAMES, function(inst) 
                inst:PerformBufferedAction() 
            end),


            TimeEvent(9*FRAMES, function(inst)
                inst.sg:RemoveStateTag("prehack")
            end),

            TimeEvent(14*FRAMES, function(inst)
                if inst.components.playercontroller ~= nil and
                inst.components.playercontroller:IsAnyOfControlsPressed(
                CONTROL_PRIMARY, CONTROL_ACTION, CONTROL_CONTROLLER_ACTION) and
                inst.sg.statemem.action ~= nil and
                inst.sg.statemem.action:IsValid() and
                inst.sg.statemem.action.target ~= nil and
                inst.sg.statemem.action.target.components.hackable ~= nil and
                inst.sg.statemem.action.target.components.hackable:CanBeHacked() and
                inst.sg.statemem.action.target:IsActionValid(inst.sg.statemem.action.action) and
                CanEntitySeeTarget(inst, inst.sg.statemem.action.target) then
                    inst:ClearBufferedAction()
                    inst:PushBufferedAction(inst.sg.statemem.action)
                end
            end),

            TimeEvent(16*FRAMES, function(inst) 
                inst.sg:RemoveStateTag("hacking")
            end),
        },

        events = {
            EventHandler("unequip", function(inst) inst.sg:GoToState("idle") end),
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
			end),
        },
    },

    State{
        name = "death_boat",
        tags = {"busy", "pausepredict", "nomorph" },

        onenter = function(inst, params)
            ClearStatusAilments(inst)
            ForceStopHeavyLifting(inst)

            inst.components.locomotor:Stop()
            inst.components.locomotor:Clear()
            inst:ClearBufferedAction()
            if params and params.rescueitem and inst.components.health then
                --This guy isn"t actually dying.
                inst.sg.statemem.rescueitem = params.rescueitem
                inst.components.health:SetInvincible(true)
            end

            inst.components.burnable:Extinguish()

            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:RemotePausePrediction()
                inst.components.playercontroller:Enable(false)
            end

            -- inst.last_death_position = inst:GetPosition()

            inst.AnimState:Hide("swap_arm_carry")
            inst.AnimState:PlayAnimation("boat_death")

            inst.components.inventory:DropEverything(true)

            SpawnAt("boat_death", inst)

            if inst:HasTag("beaver") then
                inst.AnimState:SetBuild("werebeaver_boat_death")
                inst.AnimState:SetBank("werebeaver_boat_death")
                inst.AnimState:PlayAnimation("boat_death")
                inst.SoundEmitter:PlaySound("ia/characters/woodie/sinking_death_werebeaver")
            else
                if not inst:HasTag("mime") then
                    local soundname = inst.soundsname or inst.prefab
                    --local path = inst.talker_path_override or "ia/characters/vanilla/"
                    --inst.SoundEmitter:PlaySound(path..soundname.."_drown_voice")
                    local path = inst.talker_path_override or "ia/characters/"
                    inst.SoundEmitter:PlaySound(path..soundname.."/sinking_death")
                end
            end

            inst.sg:SetTimeout(8) -- just in case

            --Don"t process other queued events if we died this frame
            inst.sg:ClearBufferedEvents()
        end,

        onexit= function(inst) 
            if not inst.sg.statemem.rescueitem then
                --You should never leave this state once you enter it!
                assert(false, "Left drown state.")
            end
        end,

        ontimeout= function(inst)  --failsafe
            if inst.sg.statemem.rescueitem then
                --copy from animover
                if inst:HasTag("beaver") then
                    inst.AnimState:SetBank("werebeaver")
                    if inst.components.skinner then
                        inst.components.skinner:SetSkinMode("werebeaver_skin")
                    else
                        inst.AnimState:SetBuild("werebeaver")
                    end
                end
                inst:PushEvent("beachresurrect", {rescueitem = inst.sg.statemem.rescueitem})
                inst.sg.statemem.rescueitem:PushEvent("preventdrowning", {target = inst})
                if inst.components.playercontroller ~= nil then
                    inst.components.playercontroller:Enable(true)
                end
            else
                inst:PushEvent(inst.ghostenabled and "makeplayerghost" or "playerdied", {skeleton = false})
            end
        end,

        timeline = {
            TimeEvent(50*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("ia/common/boat/sinking/shadow")
            end),
            TimeEvent(70*FRAMES, function(inst)
                inst.DynamicShadow:Enable(false)
            end),
        },

        events = {
            EventHandler("animover", function(inst)
                if inst.sg.statemem.rescueitem then
                    if inst:HasTag("beaver") then
                        inst.AnimState:SetBank("werebeaver")
                        if inst.components.skinner then
                            inst.components.skinner:SetSkinMode("werebeaver_skin")
                        else
                            inst.AnimState:SetBuild("werebeaver")
                        end
                    end
                    inst:PushEvent("beachresurrect", {rescueitem = inst.sg.statemem.rescueitem})
                    inst.sg.statemem.rescueitem:PushEvent("preventdrowning", {target = inst})
                    if inst.components.playercontroller ~= nil then
                        inst.components.playercontroller:Enable(true)
                    end
                else
                    inst:PushEvent(inst.ghostenabled and "makeplayerghost" or "playerdied", {skeleton = false})
                end
            end),
        },
    },

    State{
        name = "jumpinbermuda",
        tags = {"doing", "busy", "canrotate", "nopredict", "nomorph"},

        onenter = function(inst, data)
            inst.components.locomotor:Stop()

            inst.sg.statemem.teleportarrivestate = "jumpoutbermuda" -- for teleporter cmp
            inst.sg.statemem.target = data.teleporter
            if data.teleporter ~= nil and data.teleporter.components.teleporter ~= nil then
                data.teleporter.components.teleporter:RegisterTeleportee(inst)
            end

            installBermudaFX(inst)
        end,

        onexit = function(inst)
            removeBermudaFX(inst)

            if inst.sg.statemem.isteleporting then
                inst.components.health:SetInvincible(false)

                if TUNING.DO_SEA_DAMAGE_TO_BOAT and inst.components.sailor.boat and
                inst.components.sailor.boat.components.boathealth then
                    inst.components.sailor.boat.components.boathealth:SetInvincible(false)
                end
                if inst.components.playercontroller ~= nil then
                    inst.components.playercontroller:Enable(true)
                end
                inst:Show()
                inst.DynamicShadow:Enable(true)
            elseif inst.sg.statemem.target ~= nil
            and inst.sg.statemem.target:IsValid()
            and inst.sg.statemem.target.components.teleporter ~= nil then
                inst.sg.statemem.target.components.teleporter:UnregisterTeleportee(inst)
            end
        end,

        timeline = {
            -- this is just hacked in here to make the sound play BEFORE the player hits the wormhole
            TimeEvent(30*FRAMES, function(inst)
                inst:Hide()
                removeBermudaFX(inst)
                inst.components.health:SetInvincible(true)
                SpawnPrefab("pixel_out").Transform:SetPosition(inst:GetPosition():Get())
            end),

            TimeEvent(40*FRAMES, function(inst)
                if inst.sg.statemem.target ~= nil
                and inst.sg.statemem.target:IsValid()
                and inst.sg.statemem.target.components.teleporter ~= nil then
                    --Unregister first before actually teleporting
                    inst.sg.statemem.target.components.teleporter:UnregisterTeleportee(inst)
                    if inst.sg.statemem.target.components.teleporter:Activate(inst) then
                        inst.sg.statemem.isteleporting = true
                        inst.components.health:SetInvincible(true)

                        if TUNING.DO_SEA_DAMAGE_TO_BOAT and inst.components.sailor.boat and 
                        inst.components.sailor.boat.components.boathealth then
                            inst.components.sailor.boat.components.boathealth:SetInvincible(true)
                        end

                        if inst.components.playercontroller ~= nil then
                            inst.components.playercontroller:Enable(false)
                        end
                        inst:Hide()
                        inst.DynamicShadow:Enable(false)
                        return
                    end
                    inst.sg:GoToState("jumpoutbermuda")
                end
            end),
        },
    },

    State{
        name = "jumpoutbermuda",
        tags = {"doing", "busy", "canrotate", "nopredict", "nomorph"},

        onenter = function(inst, data)
            inst.components.locomotor:Stop()

            SpawnPrefab("pixel_in").Transform:SetPosition(inst:GetPosition():Get())
        end,

        onexit = function(inst)
            removeBermudaFX(inst)
            inst:Show()
        end,

        timeline =
        {

            TimeEvent(10*FRAMES, function(inst)
                inst:Show()
                installBermudaFX(inst)
                --inst.components.health:SetInvincible(false)
            end),

            TimeEvent(35*FRAMES, function(inst)
                inst.sg:GoToState("idle") 
            end),
        },
    },

    State{
        name = "vacuumedin",
        tags = {"busy", "vacuum_in", "canrotate", "pausepredict"},

        onenter = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
                end
                inst.AnimState:PlayAnimation("flying_pre")
                inst.AnimState:PlayAnimation("flying_loop", true)
        end,

        onexit = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
        end,
    },

    State{
        name = "vacuumedheld",
        tags = {"busy", "vacuum_held", "pausepredict"},

        onenter = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
            end
            inst.DynamicShadow:Enable(false)
            inst:Hide()
        end,

        onexit = function(inst)
            inst:Show()
            inst.DynamicShadow:Enable(true)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
        end,
    },

    State{
        name = "vacuumedout",
        tags = {"busy", "vacuum_out", "canrotate", "pausepredict"},

        onenter = function(inst, data)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
            end
            inst.AnimState:PlayAnimation("flying_loop", true)

            inst.sg.mem.angle = math.random(360)
            inst.sg.mem.speed = data.speed

            local rx, rz = math.rotate(math.rcos(inst.sg.mem.angle) * inst.sg.mem.speed, math.rsin(inst.sg.mem.angle) * inst.sg.mem.speed, math.rad(inst.Transform:GetRotation()))

            DoShoreMovement(inst, {x = rx, z = rz}, function() inst.Physics:SetMotorVelOverride(rx, 0, rz) end)

            inst.sg:SetTimeout(FRAMES*10)
        end,


        onupdate = function(inst)
            local rx, rz = math.rotate(math.rcos(inst.sg.mem.angle) * inst.sg.mem.speed, math.rsin(inst.sg.mem.angle) * inst.sg.mem.speed, math.rad(inst.Transform:GetRotation()))

            DoShoreMovement(inst, {x = rx, z = rz}, function() inst.Physics:SetMotorVelOverride(rx, 0, rz) end)
        end,

        ontimeout = function(inst)
            inst.Physics:ClearMotorVelOverride()

            local item = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
            if item then
                inst.components.inventory:DropItem(item)
            end

            for i = 1, 4 do
                item = nil 
                local slot = math.random(1,inst.components.inventory:GetNumSlots())
                item = inst.components.inventory:GetItemInSlot(slot)
                if item then 
                    inst.components.inventory:DropItem(item, true, true)
                end 
            end

            inst.Physics:SetMotorVel(0,0,0)
            inst.sg:GoToState("vacuumedland")
            inst:DoTaskInTime(5, function(inst) inst:RemoveTag("NOVACUUM") end)
        end,

        onexit = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
        end,
    },

    State{
        name = "vacuumedland",
        tags = {"busy", "pausepredict"},

        onenter = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(false)
                inst.components.playercontroller:RemotePausePrediction()
            end
            inst.AnimState:PlayAnimation("flying_land")
            inst.components.health:SetInvincible(true)
        end,

        onexit = function(inst)
            if inst.components.playercontroller ~= nil then
                inst.components.playercontroller:Enable(true)
            end
            inst.components.health:SetInvincible(false)
        end,

        events = {
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
			end),
        },
    },

    State{
        name = "throw",
        tags = {"attack", "notalking", "abouttoattack"},
        
        onenter = function(inst)
            if inst:HasTag("_sailor") and inst:HasTag("sailing") then
                inst.sg:AddStateTag("boating")
            end
            inst.sg.statemem.target = inst.components.combat.target
            inst.components.combat:StartAttack()
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("throw")
            
            if inst.components.combat.target then
                if inst.components.combat.target and inst.components.combat.target:IsValid() then
                    inst:FacePoint(inst.components.combat.target.Transform:GetWorldPosition())
                end
            end
            
        end,
        
        timeline=
        {
            TimeEvent(7*FRAMES, function(inst)
                inst:PerformBufferedAction()
                inst.components.combat:DoAttack(inst.sg.statemem.target)
                inst.sg:RemoveStateTag("abouttoattack")
            end),
            TimeEvent(11*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
        },
        
        events=
        {
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "speargun",
        tags = {"attack", "notalking", "abouttoattack"},

        onenter = function(inst)
            if inst:HasTag("_sailor") and inst:HasTag("sailing") then
                inst.sg:AddStateTag("boating")
            end
            inst.sg.statemem.target = inst.components.combat.target
            inst.components.combat:StartAttack()
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("speargun")
            
            if inst.components.combat.target then
                if inst.components.combat.target and inst.components.combat.target:IsValid() then
                    inst:FacePoint(inst.components.combat.target.Transform:GetWorldPosition())
                end
            end
        end,
        
        timeline=
        {
           
            TimeEvent(12*FRAMES, function(inst)
                inst:PerformBufferedAction()
                inst.components.combat:DoAttack(inst.sg.statemem.target)
                inst.sg:RemoveStateTag("abouttoattack")
                inst.SoundEmitter:PlaySound("ia/common/use_speargun")
            end),
            TimeEvent(20*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
        },
        
        events=
        {
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end),
        },
    },

    State{
        name = "cannon",
        tags = {"busy"},

        onenter = function(inst)
            if inst:HasTag("_sailor") and inst:HasTag("sailing") then
                inst.sg:AddStateTag("boating")
            end
            inst.AnimState:PlayAnimation("give")
        end,

        timeline = {
            TimeEvent(13*FRAMES, function(inst) 
                --Light Cannon
                inst.sg:RemoveStateTag("abouttoattack")
                inst:PerformBufferedAction()
            end),
            TimeEvent(15*FRAMES, function(inst) inst.sg:RemoveStateTag("attack") end),
        },

        events = {
            EventHandler("animover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
			end),
        },
    },
	
    State{
        name = "peertelescope",
        tags = {"doing", "busy", "canrotate", "nopredict"},

        onenter = function(inst)
            inst.sg.statemem.action = inst:GetBufferedAction()
            local act = inst:GetBufferedAction()

			if act then
			local pt = act.GetActionPoint and act:GetActionPoint() or act.pos
				if pt then
					inst:ForceFacePoint(pt.x, pt.y, pt.z)
				end
			end
            inst.AnimState:PlayAnimation("telescope", false)
            inst.AnimState:PushAnimation("telescope_pst", false)

            inst.components.locomotor:Stop()
        end,

        timeline = 
        {
            TimeEvent(20*FRAMES, function(inst) inst.SoundEmitter:PlaySound("ia/common/use_spyglass") end),
        },

        events = {
            EventHandler("animover", function(inst)
                if not inst.AnimState:AnimDone() then --skip the second callback
					inst:PerformBufferedAction()
					-- if ThePlayer and inst == ThePlayer and ThePlayer.HUD and ThePlayer.HUD.controls then
						-- ThePlayer.HUD.controls:ShowMap()
					-- end
				end
            end ),
            EventHandler("animqueueover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end ),
        },
    },
	
    State{
        name = "fishing_retrieve",
        --tags = {"prefish", "fishing", "boating"},
        onenter = function(inst)
            inst.components.locomotor:Stop()
            inst.AnimState:PlayAnimation("fishing_pre") --14
            inst.AnimState:PushAnimation("fishing_cast") --8-11, new in DST, contains part of old fishing_pre
            inst.AnimState:PushAnimation("bite_heavy_pre") --5
            inst.AnimState:PushAnimation("bite_heavy_loop") --14
            inst.AnimState:PushAnimation("fish_catch", false)
            inst.AnimState:OverrideSymbol("fish01", "graves_water_crate", "fish01")
        end,

        onexit = function(inst)
            inst.AnimState:ClearOverrideSymbol("fish01")
        end,

        timeline =
        {
            TimeEvent(13*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve/common/fishingpole_cast") end),
            TimeEvent(15*FRAMES, function(inst)
                inst.SoundEmitter:PlaySound("dontstarve/common/fishingpole_baitsplash")
                inst:PerformBufferedAction()
            end),
            TimeEvent((22+5+14+8)*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve/common/fishingpole_fishcaught") end),
            TimeEvent((22+5+14+14)*FRAMES, function(inst)
                local equippedTool = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
                if equippedTool and equippedTool.components.fishingrod and equippedTool.components.fishingrod.target then
                    equippedTool.components.fishingrod.target:PushEvent("retrieve")
                end
            end),
            TimeEvent((22+5+14+23)*FRAMES, function(inst) inst.SoundEmitter:PlaySound("dontstarve/common/fishingpole_fishland") end),
            TimeEvent((22+5+14+14+10)*FRAMES, function(inst)
				local equippedTool = inst.components.inventory:GetEquippedItem(EQUIPSLOTS.HANDS)
				if equippedTool and equippedTool.components.fishingrod then
					equippedTool.components.fishingrod:Retrieve()
				end
			end),
            --TimeEvent((26+5+14+24)*FRAMES, function(inst)end),
        },

        events=
        {
            EventHandler("animqueueover", function(inst)
				if inst.AnimState:AnimDone() then
					inst.sg:GoToState("idle")
				end
            end ),
        },
    },
}

for k, v in pairs(actionhandlers) do
    assert(v:is_a(ActionHandler), "Non-action handler added in mod actionhandler table!")
    inst.actionhandlers[v.action] = v
end

for k, v in pairs(events) do
    assert(v:is_a(EventHandler), "Non-event added in mod events table!")
    inst.events[v.name] = v
end

for k, v in pairs(states) do
    assert(v:is_a(State), "Non-state added in mod state table!")
    inst.states[v.name] = v
end


end)
%%+%%postinit/widgets/containerwidget.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local BoatEquipSlot = require "widgets/boatequipslot"
local BoatBadge = require "widgets/boatbadge"
local ItemTile = require "widgets/itemtile"
local InvSlot = require "widgets/invslot"
local Widget = require "widgets/widget"
local Text = require "widgets/text"
local UIAnim = require "widgets/uianim"
local ImageButton = require "widgets/imagebutton"

----------------------------------------------------------------------------------------

local DOUBLECLICKTIME = .33
local HUD_ATLAS = "images/ia_hud.xml"

local _Open
local function Open(self, container, doer, boatwidget)
    local _GetWidget = container.replica.container.GetWidget
    function container.replica.container:GetWidget()
        return _GetWidget(self, boatwidget)
    end
    _Open(self, container, doer)
    local widget = container.replica.container:GetWidget()
    container.replica.container.GetWidget = _GetWidget

    self.onitemequipfn = function(inst, data) self:OnItemEquip(data.item, data.eslot) end
    self.inst:ListenForEvent("equip", self.onitemequipfn, container)
  
    self.onitemunequipfn = function(inst, data) self:OnItemUnequip(data.item, data.eslot) end
    self.inst:ListenForEvent("unequip", self.onitemunequipfn, container)

    if container.replica.container.type == "boat" then
        self.boatbadge:SetPosition(widget.badgepos.x, widget.badgepos.y)
        self.boatbadge:Show()
        if container and container.replica.boathealth then
            self.inst:ListenForEvent("boathealthchange", function(boat, data) self:BoatDelta(boat, data) end, container)
            self.boatbadge:SetPercent(container.replica.boathealth:GetPercent(), container.replica.boathealth:GetMaxHealth())
        end

        if container.replica.container.hasboatequipslots then
            self:AddBoatEquipSlot(BOATEQUIPSLOTS.BOAT_SAIL, HUD_ATLAS, "equip_slot_boat_utility.tex")
            self:AddBoatEquipSlot(BOATEQUIPSLOTS.BOAT_LAMP, HUD_ATLAS, "equip_slot_boat_light.tex")
            local lastX = widget.equipslotroot.x
            local lastY = widget.equipslotroot.y
            local spacing = 80
            local eslot_order = {}
            for k, v in ipairs(self.boatEquipInfo) do
                local slot = BoatEquipSlot(v.slot, v.atlas, v.image, self.owner)
                self.boatEquip[v.slot] = self:AddChild(slot)
                slot:SetPosition(lastX, lastY, 0)
                lastX = lastX - spacing
                local obj = container.replica.container:GetItemInBoatSlot(v.slot)
                if obj then
                    local tile = ItemTile(obj)
                    slot:SetTile(tile)
                end
                if not container.replica.container._enableboatequipslots:value() then
                    slot:Hide()
                end
            end    
        end
        self.boatbadge:MoveToFront()

        self:Refresh()
    end 
end

local function AddBoatEquipSlot(self, slot, atlas, image, sortkey)
    sortkey = sortkey or #self.boatEquipInfo
    table.insert(self.boatEquipInfo, {slot = slot, atlas = atlas, image = image, sortkey = sortkey})
    table.sort(self.boatEquipInfo, function(a,b) return a.sortkey < b.sortkey end)
end

local function BoatDelta(self, boat, data)
    if data.damage then
        self:Shake(0.25, 0.05, 5)
    end
    
    self.boatbadge:SetPercent(data.percent, data.maxhealth)

    if data.percent <= .25 then
        self.boatbadge:StartWarning()
    else
        self.boatbadge:StopWarning()
    end

    if self.prev_boat_pct and data.percent > self.prev_boat_pct then
        self.boatbadge:PulseGreen()
        --TheFrontEnd:GetSound():PlaySound("dontstarve/HUD/health_up")
    elseif self.prev_boat_pct and data.damage and data.percent < self.prev_boat_pct then
        self.boatbadge:PulseRed()
        --TheFrontEnd:GetSound():PlaySound("dontstarve/HUD/health_down")
    end
    self.prev_boat_pct = data.percent
end

local function OnItemEquip(self, item, slot)
    if slot ~= nil and self.boatEquip[slot] ~= nil then
        self.boatEquip[slot]:SetTile(ItemTile(item))
    end
end 

local function OnItemUnequip(self, item, slot)
    if slot ~= nil and self.boatEquip[slot] ~= nil then
        self.boatEquip[slot]:SetTile(nil)
    end
end 


local _Refresh
local function Refresh(self)
    _Refresh(self)
    local boatequips = self.container.replica.container.GetBoatEquips and self.container.replica.container:GetBoatEquips() or {}
    for k, v in pairs(self.boatEquip) do
        local item = boatequips[k]
        if item == nil then
            if v.tile ~= nil then
                v:SetTile(nil)
            end
        elseif v.tile == nil or v.tile.item ~= item then
            v:SetTile(ItemTile(item))
        else
            v.tile:Refresh()
        end
    end
end

local _Close
local function Close(self)
    if self.isopen then
        if self.container ~= nil then
            if self.onitemequipfn then
                self.inst:RemoveEventCallback("equip", self.onitemequipfn, self.container)
                self.onitemequipfn = nil
            end
            if self.onitemunequipfn then
                self.inst:RemoveEventCallback("unequip", self.onitemunequipfn, self.container)
                self.onitemunequipfn = nil
            end
        end
        _Close(self)
        self.boatbadge:Hide()
        for i,v in pairs(self.boatEquip) do
            v:Kill()
        end
    end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("widgets/containerwidget", function(widget)


widget.boatEquipInfo = {}
widget.boatEquip = {}

widget.boatbadge = widget:AddChild(BoatBadge(widget.owner))
widget.boatbadge:Hide()

widget.AddBoatEquipSlot = AddBoatEquipSlot
widget.BoatDelta = BoatDelta
widget.OnItemEquip = OnItemEquip
widget.OnItemUnequip = OnItemUnequip

_Open = widget.Open
widget.Open = Open
_Close = widget.Close
widget.Close = Close
_Refresh = widget.Refresh
widget.Refresh = Refresh


end)

%%+%%postinit/widgets/healthbadge.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local UIAnim = require("widgets/uianim")

----------------------------------------------------------------------------------------

local OnUpdateOld
local function OnUpdate(self, dt)
  OnUpdateOld(self, dt)

  local poison = self.owner.ispoisoned or (self.owner.player_classified and self.owner.player_classified.ispoisoned:value())

  if self.poison ~= poison then
    self.poison = poison
    if poison then
      self.poisonanim:GetAnimState():PlayAnimation("activate")
      self.poisonanim:GetAnimState():PushAnimation("idle", true)
      self.poisonanim:Show()
    else
      self.owner.SoundEmitter:PlaySound("ia/common/antivenom_use")
      self.poisonanim:GetAnimState():PlayAnimation("deactivate")
    end
  end
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("widgets/healthbadge", function(widget)


widget.poisonanim = widget.underNumber:AddChild(UIAnim())
widget.poisonanim:GetAnimState():SetBank("poison")
widget.poisonanim:GetAnimState():SetBuild("poison_meter_overlay")
widget.poisonanim:GetAnimState():PlayAnimation("deactivate")
widget.poisonanim:Hide()
widget.poisonanim:SetClickable(false)
widget.poison = false -- So it doesn't trigger on load

OnUpdateOld = widget.OnUpdate
widget.OnUpdate = OnUpdate


end)
%%+%%postinit/widgets/inventorybar.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

----------------------------------------------------------------------------------------

local _GetInventoryLists
local function GetInventoryLists(self, same_container_only)
    same_container_only = false
    local lists = _GetInventoryLists(self, same_container_only)
    if not same_container_only then
        local firstcontainer = self.owner.HUD:GetFirstOpenContainerWidget()
        if firstcontainer then
            if firstcontainer.boatEquip then
                table.insert(lists, firstcontainer.boatEquip)
            end
        end
        local containers = self.owner.HUD:GetOpenContainerWidgets() 
        if containers then 
            for k,v in pairs(containers) do
                if v and v ~= firstcontainer then
                    table.insert(lists, v.inv)
                    if v.boatEquip then 
                        table.insert(lists, v.boatEquip)
                    end 
                end 
            end     
        end 
    end
    return lists
end

----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("widgets/inventorybar", function(widget)


_GetInventoryLists = widget.GetInventoryLists
widget.GetInventoryLists = GetInventoryLists


end)
%%+%%postinit/widgets/itemtile.lua%%-%%local IAENV = env
GLOBAL.setfenv(1, GLOBAL)

local UIAnim = require("widgets/uianim")
local Image = require("widgets/image")
local Text = require("widgets/text")

----------------------------------------------------------------------------------------


--separate so we can refresh our stuff once on init
local function Refresh_IA(self, ...)
    if self.ismastersim then
        if self.item.components.obsidiantool ~= nil then
            local charge, maxcharge = self.item.components.obsidiantool:GetCharge()
            self.obsidian_charge:GetAnimState():SetPercent("anim", charge / maxcharge)
        end

        if self.item.components.inventory and self.invspace then
            self.invspace:GetAnimState():SetPercent("anim", self.item.components.inventory:NumItems() / self.item.components.inventory.maxslots)
        end
    elseif self.item.replica.inventoryitem ~= nil then
        self.item.replica.inventoryitem:DeserializeUsage()
    end

	if self.item and self.item.fusevalue then
		-- self.fusebg:Show()
		self.fuse:SetString(tostring(math.ceil(self.item.fusevalue)))
	end
end

local _Refresh
local function Refresh(self, ...)
    _Refresh(self, ...)
	Refresh_IA(self, ...)
end


local _StartDrag
local function StartDrag(self, ...)
    _StartDrag(self, ...)
    if self.item.replica.inventoryitem ~= nil then -- HACK HACK: items without an inventory component won't have any of these
        if self.obsidian_charge ~= nil then
            self.obsidian_charge:Hide()
        end
        if self.invspace ~= nil then
            self.invspace:Hide()
        end
        if self.fusebg ~= nil then
            self.fusebg:Hide()
        end
    end
end


----------------------------------------------------------------------------------------
--Try to initialise all functions locally outside of the post-init so they exist in RAM only once
----------------------------------------------------------------------------------------

IAENV.AddClassPostConstruct("widgets/itemtile", function(widget)


if widget.item:HasTag("show_invspace") then
    widget.invspace = widget:AddChild(UIAnim())
    widget.invspace:GetAnimState():SetBank("trawlnet_meter")
    widget.invspace:GetAnimState():SetBuild("trawlnet_meter")
    widget.invspace:SetClickable(false)
end

if widget.item:HasTag("obsidiantool") then
    widget.obsidian_charge = widget:AddChild(UIAnim())
    widget.obsidian_charge:GetAnimState():SetBank("obsidian_tool_meter")
    widget.obsidian_charge:GetAnimState():SetBuild("obsidian_tool_meter")
    widget.obsidian_charge:SetClickable(false)
end

if widget.item:HasTag("fuse") then
	--Doesn't work for some reason. -M
    -- widget.fusebg = widget:AddChild(Image(HUD_ATLAS, "resource_needed.tex"))
    -- widget.fusebg:SetClickable(false)
    -- widget.fusebg:Hide()

	widget.fuse = widget:AddChild(Text(NUMBERFONT, 50))
	if JapaneseOnPS4 and JapaneseOnPS4() then
		widget.fuse:SetHorizontalSqueeze(0.7)
	end
	widget.fuse:SetPosition(5,0,0)
end

if widget.item:HasTag("gourmetfood") then
    widget.gourmetstar = widget:AddChild(Image("images/ia_hud.xml", "gourmetstar.tex"))
    widget.gourmetstar:SetPosition(20,-20,0) --right bottom corner
    widget.gourmetstar:SetClickable(false)
end

--I HATE THIS, but idk how else to ensure proper ordering of these, without nasty hacks. -Z
if widget.fusebg then widget.fusebg:MoveToBack() end
if widget.obsidian_charge then widget.obsidian_charge:MoveToBack() end
if widget.invspace then widget.invspace:MoveToBack() end
if widget.spoilage then widget.spoilage:MoveToBack() end
if widget.bg then widget.bg:MoveToBack() end

if widget.invspace then
    widget.inst:ListenForEvent("invspacechange", function(invitem, data)
		widget.invspace:GetAnimState():SetPercent("anim", data.percent)
	end, widget.item)
end
if widget.obsidian_charge then
    widget.inst:ListenForEvent("obsidianchargechange", function(invitem, data)
		widget.obsidian_charge:GetAnimState():SetPercent("anim", data.percent)
	end, widget.item)
end
if widget.fuse then
    widget.inst:ListenForEvent("fusechanged", function(invitem, data)
		-- widget.fusebg:Show()
		if invitem and invitem.fusevalue then
			widget.fuse:SetString(tostring(math.ceil(invitem.fusevalue)))
		end
	end, widget.item)
end

Refresh_IA(widget)

_Refresh = widget.Refresh
widget.Refresh = Refresh
_StartDrag = widget.StartDrag
widget.StartDrag = StartDrag


end)
%%+%%strings/common.lua%%-%%return {
  
  ACTIONS = {
	JUMPIN = {
		BERMUDA = "Enter",
	},
	ACTIVATE = {
		SAND = "Destroy",
	},
    RUMMAGE = {
        INSPECT = "Inspect",
    },
	UNWRAP = {
		--if somebody already made this a table, don't overwrite any of their changes -M
		GENERIC = type(GLOBAL.STRINGS.ACTIONS.UNWRAP) == "string" and GLOBAL.STRINGS.ACTIONS.UNWRAP or nil,
		OPENCAN = "Open", --tunacan
	},
	PACKUP = GLOBAL.STRINGS.ACTIONS.PICKUP,
  },

  SKIN_NAMES =
  {
    walani_none = "Walani",
    -- warly_none = "Warly",
    wilbur_none = "Wilbur",
    woodlegs_none = "Woodlegs",
  },
  
  CHARACTER_NAMES =
  {
    walani = "Walani",
    -- warly = "Warly",
    wilbur = "Wilbur",
    woodlegs = "Woodlegs",
  },

  CHARACTER_QUOTES =
  {
    walani = "\"Forgive me if I don't get up. I don't want to.\"",
    -- warly = "\"Nothing worthwhile is ever done on an empty stomach!\"",
    wilbur = "\"Ooo ooa oah ah!\"",
    woodlegs = "\"Don't ye mind th'scurvy. Yarr-harr-harr!\"",
  },

  CHARACTER_TITLES =
  {
    walani = "The Unperturbable",
    -- warly = "The Culinarian",
    wilbur = "The Monkey King",
    woodlegs = "The Pirate Captain",
  },

  CHARACTER_DESCRIPTIONS =
  {
    walani = "*Loves surfing\n*Dries off quickly\n*Is a pretty chill gal",
    -- warly = "*Has a refined palate\n*Cooks in custom kitchenware\n*Brings a stylish chef pouch",
    wilbur = "*Can't talk\n*Slow as biped, but fast as quadruped\n*Is a monkey",
    woodlegs = "*Can sniff out treasure\n*Captain of the \"Sea Legs\"\n*Pirate",
  },

  FLOODEDITEM = "Flooded",
  GOURMETPREFIX = "Gourmet ", --Please note that the space is intentional, so translations may use hyphons or whatever -M
  GOURMETGENERIC = "Dish", --failsafe, in case the original name is invalid
  
  NAMES =
  {
    WALANI = "Walani",
    -- WARLY = "Warly",
    WILBUR = "Wilbur",
    WOODLEGS = "Woodlegs",
    
    DROWNING = "Drowning",
    POISON = "Poison",

    CRAB = "Crabbit",
    CRABHOLE = "Crabbit Den",
    CRAB_HIDDEN = "Shifting Sands",
    SAND = "Sand",
    SANDDUNE = "Sandy Pile", --Changed from "Sandy Dune"

    ROCK_CORAL = "Coral Reef",
    CORAL = "Coral",

    BARREL_GUNPOWDER = "Gunpowder Barrel", --Changed from "Barrel o' Gunpowder"

    SEAWEED = "Seaweed",
    SEAWEED_COOKED = "Roasted Seaweed", --Changed from "Cooked Seaweed"
    SEAWEED_DRIED = "Dried Seaweed",
    SEAWEED_PLANTED = "Seaweed",

    LIMESTONE = "Limestone",
    LIMESTONENUGGET = "Limestone",

    SWORDFISH = "Swordfish",
    SWORDFISH_DEAD = "Dead Swordfish", --Changed from "Swordfish"
    SOLOFISH = "Dogfish",
    SOLOFISH_DEAD = "Dead Dogfish", --Changed from "Dogfish"

    FISHINHOLE = "Shoal", --Changed from "School of Fish"
    FISH_TROPICAL = "Tropical Fish",
    FISH_MED = "Raw Fish", -- Used to be "Steak"
    FISH_MED_COOKED = "Fish Steak",
    FISH_SMALL = "Fish Morsel", --Changed from "Raw Fish"
    FISH_SMALL_COOKED = "Cooked Fish Morsel", --Changed from "Cooked Fish"
    SPOILED_FISH = "Spoiled Fish",

    BOAT_RAFT = "Raft",
    BOAT_LOGRAFT = "Log Raft",
    BOAT_ROW = "Row Boat",
    BOAT_CARGO = "Cargo Boat",
    BOAT_ARMOURED = "Armoured Boat",
    BOAT_ENCRUSTED = "Encrusted Boat",
    BOAT_SURFBOARD = "Surfboard",
    BOAT_SURFBOARD_ITEM = "Surfboard",
    BOAT_WOODLEGS = "The \"Sea Legs\"",

    SAIL_PALMLEAF = "Thatch Sail",
    SAIL_CLOTH = "Cloth Sail",
    SAIL_SNAKESKIN = "Snakeskin Sail",
    SAIL_FEATHER = "Feather Lite Sail",
    IRONWIND = "Iron Wind",
    BOAT_LANTERN = "Boat Lantern",
    TRAWLNET = "Trawl Net",
    TRAWLNETDROPPED = "Trawl Net",
    BOATCANNON = "Boat Cannon",

    BUSH_VINE = "Viney Bush",
    SNAKEDEN = "Viney Bush",
    VINE = "Vine",
    DUG_BUSH_VINE = "Viney Bush Root",

    BAMBOOTREE = "Bamboo Patch",
    BAMBOO = "Bamboo",

    MUSSEL = "Mussel",
    MUSSEL_COOKED = "Cooked Mussel",
    MUSSEL_STICK = "Mussel Stick",
    MUSSEL_FARM = "Mussels",

    MESSAGEBOTTLE = "Message in a Bottle",
    MESSAGEBOTTLEEMPTY = "Empty Bottle",
    BURIEDTREASURE = "X Marks the Spot",


-- These are copied over from SW directly and haven't really been looked at yet

    TURF_BEACH = "Beach Turf",
    TURF_JUNGLE = "Jungle Turf",
    TURF_SWAMP = "Swamp Turf",

    TURF_VOLCANO = "Volcano Turf",
    TURF_ASH = "Ashy Turf",
    TURF_MAGMAFIELD = "Magma Turf",
    TURF_TIDALMARSH = "Tidal Marsh Turf",
    TURF_MEADOW = "Meadow Turf",

    PORTAL_SHIPWRECKED = "Malfunctioning Novelty Ride",

    BOOK_METEOR = "Joy of Volcanology",

    TRINKET_IA_13 = "Orange Soda",
    TRINKET_IA_14 = "Voodoo Doll",
    TRINKET_IA_15 = "Ukulele",
    TRINKET_IA_16 = "License Plate",
    TRINKET_IA_17 = "Old Boot",
    TRINKET_IA_18 = "Ancient Vase",
    TRINKET_IA_19 = "Brain Cloud Pill",
    TRINKET_IA_20 = "Sextant",
    TRINKET_IA_21 = "Toy Boat",
    TRINKET_IA_22 = "Wine Bottle Candle",
    TRINKET_IA_23 = "Broken AAC Device", -- AAC = Augmentative and Alternative Communication

    SUNKEN_BOAT_TRINKET_1 = "Sextant",
    SUNKEN_BOAT_TRINKET_2 = "Toy Boat", -- "Prototype 0021",
    SUNKEN_BOAT_TRINKET_3 = "Soaked Candle",
    SUNKEN_BOAT_TRINKET_4 = "Sea Worther",
    SUNKEN_BOAT_TRINKET_5 = "Old Boot",

    PRIMEAPE = "Prime Ape",
    PRIMEAPEBARREL = "Prime Ape Hut",
    WILDBOREHOUSE = "Wildbore House",
    WILDBORE = "Wildbore",
    WILDBOREGUARD = "Wildbore Guard",
    WOODLEGS_CAGE = "Woodlegs' Cage",
    WOODLEGS_KEY1 = "Bone Key",
    WOODLEGS_KEY2 = "Golden Key",
    WOODLEGS_KEY3 = "Iron Key",
    BERRYBUSH_SNAKE = "Berry Bush",
    BERRYBUSH2_SNAKE = "Berry Bush",
    DOYDOY = "Doydoy",
    DOYDOYBABY = "Baby Doydoy",
    DOYDOYTEEN = "Teen Doydoy",
    DOYDOYEGG = "Doydoy Egg",
    DOYDOYEGG_CRACKED = "Cracked Doydoy Egg",
    DOYDOYEGG_COOKED = "Fried Doydoy Egg",
    DOYDOYNEST = "Doydoy Nest",
    DOYDOYFEATHER = "Doydoy Feather",
    DUG_BAMBOOTREE = "Bamboo Root",
    PALMLEAF_HUT = "Palm Leaf Hut",
	PALMLEAF_UMBRELLA = "Palm Leaf Umbrella",
    THATCHPACK = "Thatch Pack",
    GRASS_WATER = "Grass",

    PIRATEPACK = "Booty Bag",
    PEG_LEG = "Peg Leg",

    SEASHELL = "Seashell",
    SEASHELL_BEACHED = "Seashell",
    PALMTREE = "Palm Tree",
    LEIF_PALM = "Treeguard",
    COCONUT = "Coconut",
    COCONUT_SAPLING = "Palm Tree Sapling",
    COCONUT_HALVED = "Halved Coconut",
    COCONUT_COOKED = "Roasted Coconut",

    MACHETE = "Machete",
    GOLDENMACHETE = "Luxury Machete",
    TELESCOPE = "Spyglass",
    SUPERTELESCOPE = "Super Spyglass",
    BERMUDATRIANGLE = "Electric Isosceles",
    SANDBAG = "Sandbag",
    SANDBAG_ITEM = "Sandbag",
    SANDBAGSMALL = "Sandbag",
    SANDBAGSMALL_ITEM = "Sandbag",
    DUBLOON = "Dubloons",

    OBSIDIAN_BENCH = "Obsidian Workbench",
    OBSIDIAN_BENCH_BROKEN = "Broken Obsidian Workbench",

    JUNGLETREE = "Jungle Tree",
    JUNGLETREESEED = "Jungle Tree Seed",
    JUNGLETREESEED_SAPLING = "Jungle Tree Sapling",

    BANANA_TREE = "Banana Tree",
    BANANA = "Banana",
    BANANA_COOKED = "Cooked Banana",

    BOAT_INDICATOR = "Don't Click On Me!",
    ARMOR_LIFEJACKET = "Life Jacket",
    ROCK_LIMPET = "Limpet Rock",
    LIMPETS = "Limpets",
    LIMPETS_COOKED = "Cooked Limpets",
    SWEET_POTATO = "Sweet Potato",
    SWEET_POTATO_COOKED = "Cooked Sweet Potato",
    SWEET_POTATO_SEEDS = "Sweet Potato Seeds",
    SWEET_POTATO_PLANTED = "Sweet Potato",

    LUGGAGECHEST = "Steamer Trunk",
    OCTOPUSCHEST = "Octo Chest",

    PEACOCK = "Peacock", --what.
    COCONADE = "Coconade",
    OBSIDIANCOCONADE = "Obsidian Coconade",
    MONKEYBALL = "Silly Monkey Ball",
    OX = "Water Beefalo",
    BABYOX = "Baby Water Beefalo",

    TOUCAN = "Toucan",
    SEAGULL = "Seagull",
    SEAGULL_WATER = "Seagull",
    PARROT = "Parrot",
    CORMORANT = "Cormorant",

    TUNACAN = '"Ballphin Free" Tuna', --this isnt the right formatting, right...?

    SEATRAP = "Sea Trap",

    DRAGOON = "Dragoon",
    DRAGOONEGG = "Dragoon Egg",
    DRAGOONSPIT = "Dragoon Saliva",
    DRAGOONDEN = "Dragoon Den",
    DRAGOONHEART = "Dragoon Heart",
    SNAKE = "Snake",
    SNAKE_POISON = "Poison Snake",
    VENOMGLAND = "Venom Gland",
    LOBSTER = "Wobster",
    LOBSTER_DEAD = "Dead Wobster",
    LOBSTER_DEAD_COOKED = "Delicious Wobster",
    LOBSTERHOLE = "Wobster Den",
    BALLPHIN = "Bottlenose Ballphin",
    BALLPHINHOUSE = "Ballphin Palace",
    DORSALFIN = "Dorsal Fin",
    FLOATER = "Floater",
    NUBBIN = "Coral Nubbin",
    CORALLARVE = "Coral Larva",
    WHALE_BLUE = "Blue Whale",
    WHALE_WHITE = "White Whale",
    WHALE_CARCASS_BLUE = "Blue Whale Carcass",
    WHALE_CARCASS_WHITE = "White Whale Carcass",

    WHALE_BUBBLES = "Suspicious Bubbles",

    BLUBBER = "Blubber",
    BLUBBERSUIT = "Blubber Suit",

    ANTIVENOM = "Anti Venom",
    BLOWDART_POISON = "Poison Dart",
    POISONHOLE = "Poisonous Hole",
    SPEAR_POISON = "Poison Spear",

    FABRIC = "Cloth",

    OBSIDIANAXE = "Obsidian Axe",
    OBSIDIANMACHETE = "Obsidian Machete",
    OBSIDIANSPEARGUN = "Obsidian Speargun",
    SPEAR_OBSIDIAN = "Obsidian Spear",
    ARMOROBSIDIAN = "Obsidian Armor",

    CAPTAINHAT = "Captain Hat",
    PIRATEHAT = "Pirate Hat",
    WORNPIRATEHAT = "Worn Pirate Hat",
    GASHAT = "Particulate Purifier",
    AERODYNAMICHAT = "Sleek Hat",

    JELLYFISH = "Jellyfish",
    JELLYFISH_PLANTED = "Jellyfish",
    JELLYFISH_DEAD = "Dead Jellyfish",
    JELLYFISH_COOKED = "Cooked Jellyfish",
    JELLYJERKY = "Dried Jellyfish",
	
	RAINBOWJELLYFISH = "Rainbow Jellyfish",
	RAINBOWJELLYFISH_PLANTED = "Rainbow Jellyfish",
	RAINBOWJELLYFISH_DEAD = "Dead Rainbow Jellyfish",
	RAINBOWJELLYFISH_COOKED = "Cooked Rainbow Jellyfish",
	RAINBOWJELLYJERKY = "Dried Rainbow Jellyfish",
	
    SPEARGUN = "Speargun",
    SPEARGUN_POISON = "Poison Speargun",

    HARPOON = "Harpoon",

    TRIDENT = "Trident",

    ARMOR_SNAKESKIN = "Snakeskin Jacket",
    SNAKESKINHAT = "Snakeskin Hat",
    SNAKESKIN = "Snakeskin",

    BIGFISHINGROD = "Sport Fishing Rod",

    CHIMINEA = "Chiminea",
    OBSIDIANFIREPIT = "Obsidian Fire Pit",
    OBSIDIAN = "Obsidian",
    LAVAPOOL = "Lava Pool",
    EARRING = "One True Earring",
    CUTLASS = "Cutlass Supreme",
    ARMORSEASHELL = "Seashell Suit",
    SEASACK = "Sea Sack",
    PIRATIHATITATOR = "Piratihatitator",
    SLOTMACHINE = "Slot Machine",
    VOLCANO = "Volcano",
    VOLCANO_EXIT = "Volcano",
    VOLCANO_ALTAR = "Volcano Altar of Snackrifice",
    VOLCANOSTAFF = "Volcano Staff",
    ICEMAKER = "Ice Maker 3000",
    COFFEEBEANS = "Coffee Beans",
    COFFEE = "Coffee",
    COFFEEBEANS_COOKED = "Roasted Coffee Beans",
    COFFEEBUSH = "Coffee Plant",
    DUG_COFFEEBUSH = "Coffee Plant",
    CHEFPACK = "Chef Pouch",
    MAILPACK = "Letter Carrier Bag",
    -- PORTABLECOOKPOT = "Portable Crock Pot",
    -- PORTABLECOOKPOT_ITEM = "Portable Crock Pot",
    ELEPHANTCACTUS = "Elephant Cactus",
    ELEPHANTCACTUS_ACTIVE = "Prickly Elephant Cactus",
    ELEPHANTCACTUS_STUMP = "Elephant Cactus Stump",
    DUG_ELEPHANTCACTUS = "Elephant Cactus",
    ARMORCACTUS = "Cactus Armor",
    NEEDLESPEAR = "Cactus Spike",
    PALMLEAF = "Palm Leaf",
    ARMORLIMESTONE = "Limestone Suit",
    WALL_LIMESTONE = "Limestone Wall",
    WALL_LIMESTONE_ITEM = "Limestone Wall",
	WALL_ENFORCEDLIMESTONE = "Sea Wall",
	WALL_ENFORCEDLIMESTONE_ITEM = "Sea Wall",
    ARMOR_WINDBREAKER = "Windbreaker",
    BOTTLELANTERN = "Bottle Lantern",
    SANDCASTLE = "Sand Castle",
    DOUBLE_UMBRELLAHAT = "Dumbrella",
    HAIL_ICE = "Hail",

    CALIFORNIAROLL = "California Roll",
    SEAFOODGUMBO = "Seafood Gumbo",
    BISQUE = "Bisque",
    -- CEVICHE = "Ceviche",
    JELLYOPOP = "Jelly-O Pop",
    -- BANANAPOP = "Banana Pop",
    LOBSTERBISQUE = "Wobster Bisque",
    LOBSTERDINNER = "Wobster Dinner",
    SHARKFINSOUP = "Shark Fin Soup",
    SURFNTURF = "Surf 'n' Turf",

    SWEETPOTATOSOUFFLE = "Sweet Potato Souffle",
    -- MONSTERTARTARE = "Monster Tartare",
    -- FRESHFRUITCREPES = "Fresh Fruit Crepes",
    MUSSELBOUILLABAISE = "Mussel Bouillabaise",


    BIOLUMINESCENCE = "Bioluminescence",
    SHARK_FIN = "Shark Fin",
    SHARK_GILLS = "Shark Gills",
    STUNGRAY = "Stink Ray",
    TURBINE_BLADES = "Turbine Blades",
    TIGERSHARK = "Tiger Shark",
    TIGEREYE = "Eye of the Tiger Shark",
    SHARKITTEN = "Sharkitten",
    BOATREPAIRKIT = "Boat Repair Kit",
    OBSIDIAN_WORKBENCH = "Obsidian Workbench",
    RAWLING = "Rawling",
    PACKIM_FISHBONE = "Fishbone",
    PACKIM = "Packim Baggims",
    SHARX = "Sea Hound",
    SNAKEOIL = "Snake Oil",

	CROCODOG = "Crocodog",
	POISONCROCODOG = "Yellow Crocodog",
	WATERCROCODOG = "Blue Crocodog",
	
    FROG_POISON = "Poison Frog",

    MYSTERYMEAT = "Bile-Covered Slop",

    OCTOPUSKING = "Yaarctopus",

    MAGMAROCK = "Magma Pile",
    MAGMAROCK_GOLD = "Magma Pile",
    ROCK_OBSIDIAN = "Obsidian Boulder",
    ROCK_CHARCOAL = "Charcoal Boulder",
    VOLCANO_SHRUB = "Burnt Ash Tree",

    FLUP = "Flup",

    CORAL_BRAIN_ROCK = "Brainy Sprout",
    CORAL_BRAIN = "Brainy Matter",
    BRAINJELLYHAT = "Brain of Thought",
    EUREKAHAT = "Eureka! Hat",--wha...

    MANGROVETREE = "Mangrove",
    FLAMEGEYSER = "Krissure",
    TIDALPOOL = "Tidal Pool",
    TIDAL_PLANT = "Plant",

    TELEPORTATO_SW_RING = "Ring Thing",
    TELEPORTATO_SW_BOX = "Screw Thing",
    TELEPORTATO_SW_CRANK = "Grassy Thing",
    TELEPORTATO_SW_POTATO = "Wooden Potato Thing",
    TELEPORTATO_SW_BASE = "Wooden Platform Thing",
    TELEPORTATO_SW_CHECKMATE = "Wooden Platform Thing",

    KNIGHTBOAT = "Floaty Boaty Knight",

    LIVINGJUNGLETREE = "Regular Jungle Tree",

    WALLYINTRO_DEBRIS = "Debris",
    WALLYINTRO = "Rude Bird",

    BLOWDART_FLUP = "Eyeshot",

    MOSQUITO_POISON = "Poison Mosquito",

    MERMFISHER = "Fishermerm",
    MERMHOUSE_FISHER = "Fishermerm's Hut",
    MOSQUITOSACK_YELLOW = "Yellow Mosquito Sack",
    SHARK_TEETHHAT = "Shark Tooth Crown",
    BOAT_TORCH ="Boat Torch",

    MARSH_PLANT_TROPICAL = "Plant",
    WILDBOREHEAD = "Wildbore Head",

    SWIMMINGHORROR = "Swimming Horror",

    CRATE = "Crate",
    BUOY = "Buoy",

    SHARKITTENSPAWNER_ACTIVE = "Sharkitten Den",
    SHARKITTENSPAWNER_INACTIVE = "Sandy Pile",

    TWISTER = "Sealnado",
    TWISTER_SEAL = "Seal",

    SHIPWRECK = "Wreck",
    WRECKOF = "Wreck of the %s",
    TURF_SNAKESKIN = "Snakeskin Rug",

    WILBUR_UNLOCK = "Soggy Monkey",
    WILBUR_CROWN = "Tarnished Crown",

    MAGIC_SEAL = "Magic Seal",
    WIND_CONCH = "Howling Conch",
    SAIL_STICK = "Sail Stick",

    SHIPWRECKED_ENTRANCE = "Seaworthy",
    SHIPWRECKED_EXIT = "Seaworthy",

    INVENTORYWATERYGRAVE = "Watery Grave",
    WATERYGRAVE = "Watery Grave",
    PIRATEGHOST = "Pirate Ghost",

    KRAKEN = "Quacken",
    KRAKEN_TENTACLE = "Quacken Tentacle",
    WOODLEGSHAT = "Lucky Hat",
    SPEAR_LAUNCHER = "Speargun",

    KRAKENCHEST = "Chest of the Depths",

    OX_FLUTE = "Dripple Pipes",
    OXHAT = "Horned Helmet",
    OX_HORN = "Horn",

    QUACKENBEAK = "Quacken Beak",
    QUACKERINGRAM = "Quackering Ram",
    QUACKENDRILL = "Quacken Drill",

    TAR = "Tar",
    TAR_EXTRACTOR = "Tar Extractor",
    TAR_POOL = "Tar Slick",
    TAR_TRAP = "Tar Trap",
    TARLAMP = "Tar Lamp",
    TARSUIT = "Tar Suit",

    SEA_YARD = "Sea Yard",
    SEA_CHIMINEA = "Buoyant Chiminea",       

    ROE = "Roe",
    ROE_COOKED = "Cooked Roe",
    FISH_FARM = "Fish Farm", 

    PURPLE_GROUPER = "Purple Grouper",
    PIERROT_FISH = "Pierrot Fish",
    NEON_QUATTRO = "Neon Quattro",

    PURPLE_GROUPER_COOKED = "Cooked Purple Grouper",
    PIERROT_FISH_COOKED = "Cooked Pierrot Fish",
    NEON_QUATTRO_COOKED = "Cooked Neon Quattro",   

    TROPICALBOUILLABAISSE = "Tropical Bouillabaisse",
    CAVIAR = "Caviar",

    SEA_LAB = "Sea Lab",
    WATERCHEST = "Sea Chest",

    SEAWEED_STALK = "Seaweed Stalk",
    MUSSEL_BED = "Mussel Bed",
	
    TROPICALFAN = "Tropical Fan",
	
	TERRAFORMSTAFF = "Atlantis Staff",

    POISONBALM = "Poison Balm",
  },

  RECIPE_DESC =
  {
    POISONBALM = "The excruciating pain means it's working.",
    ANTIVENOM = "Cures that not-fresh \"poison\" feeling.",
    BLOWDART_POISON = "Spit poison at your enemies.",
    BOAT_ROW = "Row, row, row your boat!",
    BALLPHINHOUSE = "EeEe! EeEe!",
    MACHETE = "Hack stuff!",
    GOLDENMACHETE = "Hack stuff with elegance (and metal)!",
    ARMOR_LIFEJACKET = "Safety first!",
    TELESCOPE = "See across the sea.",
    SUPERTELESCOPE = "See across more sea.",
    PALMLEAF_HUT = "Escape the rain. Mostly.",
    SANDBAG_ITEM = "Sand. Water's greatest enemy.",
    CHIMINEA = "Fire and wind don't mix.",
    PIRATEHAT = "It's a pirate's life for ye!",
    WORNPIRATEHAT = "It's a pirate's life for ye!",
    PIRATIHATITATOR = "Make your pirate hat... magic!",
    SLOTMACHINE = "Leave nothing to chance! Except this.",
    SANDCASTLE = "Therapeutic and relaxing.",
    ICEMAKER = "Ice, ice, baby!",
    VOLCANOSTAFF = "The sky is falling!",
    MUSSEL_STICK = "Mussels stick to it!",
    SEATRAP = "It's a trap for sea creatures.",
    LIMESTONENUGGET = "Stone, with a hint of lime.",
    ARMORLIMESTONE = "Sartorial reef.",
    WALL_LIMESTONE_ITEM = "Coral reef walling.",
	WALL_RUINEDLIMESTONE_ITEM = "Tough wall segments, sorta.",
	WALL_ENFORCEDLIMESTONE_ITEM = "Strong wall segments to build at sea.",
    ARMOR_WINDBREAKER = "Break some wind!",
    BOTTLELANTERN = "Glowing ocean goo in a bottle.",
    OBSIDIANAXE = "Like a regular axe, only hotter.",
    OBSIDIANMACHETE = "Hack'n'burn!",
    OBSIDIANFIREPIT = "The fieriest of all fires!",
    BOAT_RAFT = "Totally sort of seaworthy.",
    SURFBOARD_ITEM = "Cowabunga dudes!",
    BOAT_CARGO = "Hoarding at sea!",
    BOAT_ENCRUSTED = "A tank on high seas!",
    SAIL_PALMLEAF = "Catch the wind!",
    SAIL_CLOTH = "Catch even more wind!",
    SAIL_SNAKESKIN = "Heavy duty wind catcher.",
    SAIL_FEATHER = "Like a bird's wing, for your boat!",
    BOAT_LANTERN = "Shed some light on the situation.",
    BOATCANNON = "It's got your boat's back.",
    TRAWLNET = "The patient fisher is always rewarded.",
    CAPTAINHAT = "Wear one. Your boat will respect you more.",
	NUBBIN = "There's nubbin better!",
    SEASACK = "Keeps your food fresher, longer!",
    ARMORSEASHELL = "Pretty poison prevention.",
    SPEAR_OBSIDIAN = "How about a lil fire with your spear?",
    ARMOROBSIDIAN = "Hot to the touch.",
    COCONADE = "KA-BLAM!",
    OBSIDIANCOCONADE = "KA-BLAMMIER!",
    SPEAR_LAUNCHER = "Laterally eject your spears.",
    SPEARGUN = "Never sail without one!",
    SPEARGUN_POISON = "Sick shot!",
    OBSIDIANSPEARGUN = "Hot shot!",
    CUTLASS = "Fish were harmed in the making of this.",
    SANDCASTLE = "Therapeutic and relaxing.",
    WALL_LIMESTONE_ITEM = "Strong wall segments.",
    FABRIC = "Bamboo is so versatile!",
    MESSAGEBOTTLEEMPTY = "Don't forget to recycle!",
    ICE = "Water of the solid kind.",
    AERODYNAMICHAT = "Aerodynamic design for efficient travel.",
    GASHAT = "Keep nasty airborne particulates away!",
    SNAKESKINHAT = "Keep the rain out, and look cool doing it.",
    ARMOR_SNAKESKIN = "Stay dry and leathery.",
    ARMORCACTUS = "Prickly to the touch.",
    SPEAR_POISON = "Jab'em with a sick stick.",
    IRONWIND = "Motorin'!",
    BOATREPAIRKIT = "Stay afloat in that boat!",
    MONKEYBARREL = "Monkey around by putting monkeys around.",
    BRAINJELLYHAT = "Well aren't you clever?",
    EUREKAHAT = "For when inspiration strikes.",
    BOAT_ARMOURED = "Shell out for this hearty vessel.",
    THATCHPACK = "Carry a light load.",
    BOAT_LOGRAFT = "Boat at your own risk.",
    SANDBAGSMALL_ITEM = "Floodproof.",
    WALL_LIMESTONE = "Tough wall segments.",
    GOLDNUGGET = "Gold! Gold! Gold!",
    BOOK_METEOR = "And the sky shall rain fire!",
    BLUBBERSUIT = "A disgusting way to stay dry.",
    BOAT_TORCH = "See, at sea.",
    PRIMEAPEBARREL = "More monkeys!",
    MONKEYBALL = "Get down to monkey business.",
    WILDBOREHOUSE = "Pig out!",
    DRAGOONDEN = "Enter the Dragoon's Den.",
    BOAT_SURFBOARD = "Hang ten!",
    DOUBLE_UMBRELLAHAT = "Definitely function over fashion.",
    SHARK_TEETHHAT = "Look formidable on the seas.",
    CHEFPACK = "Freshen up your foodstuffs.",
    -- PORTABLECOOKPOT_ITEM = "Better than any takeaway food.",
    BUOY = "Mark your place in the water.",
    WIND_CONCH = "The gales come early.",
    SAILSTICK = "May the wind be always at your back.",
    TURF_SNAKESKIN = "Really ties the room together.",
    DOYDOYNEST = "Just doy it.",
    SHIPWRECKED_ENTRANCE = "Take a vacation. Go somewhere less awful.",
    WOODLEGSHAT = "Sniff out treasures.",
    BOAT_WOODLEGS = "Go do some pirate stuff.",
    OX_FLUTE = "Make the world weep.",
    OXHAT = "Shell out for some poison protection.",
    BOOK_METEOR = "On comets, meteors and eternal stardust.",
    PALMLEAF_UMBRELLA = "Posh & portable tropical protection.",
    QUACKERINGRAM = "Everybody better get out of your way!",
    TAR_EXTRACTOR = "This offshore rig knows the drill.",        
    SEA_YARD = "Keep your boats ship-shape!",
    SEA_CHIMINEA = "Fire that floats!",   
    FISH_FARM = "Grow your own fishfood with roe!",     
    TARLAMP = "A light for your hand, or for your boat!",
    TARSUIT = "The slickest way to stay dry.",
    SEA_LAB = "Unlock crafting recipes... at sea!",
    WATERCHEST = "Davy Jones' storage locker.",
    MUSSEL_BED = "Relocate your favorite mollusc.",
    QUACKENDRILL = "For Deep Sea Quacking.",
    TROPICALFAN = "Luxuriously soft, luxuriously tropical.",
  },

  TABS =
  {
    NAUTICAL = "Nautical",
    OBSIDIAN = "Obsidian",
  },

  PARROTNAMES =
  {
    "Danjaya",
    "Jean Claud Van Dan",
    "Donny Jepp",
    "Crackers",
    "Sully",
    "Reginald VelJohnson",
    "Dan Van 3000",
    "Van Dader",
    "Dirty Dan",
    "Harry",
    "Sammy",
    "Zoe",
    "Kris",
    "Trent",
    "Harrison",
    "Alethea",
    "Jonny Dregs",
    "Frankie",
    "Pollygon",
    "Vixel",
    "Hank",
    "Cutiepie",
    "Vegetable",
    "Scurvy",
    "Black Beak",
    "Octoparrot",
    "Migsy",
    "Amy",
    "Victoire",
    "Cornelius",
    "Long John",
    "Dr Hook",
    "Horatio",
    "Iago",
    "Wilde",
    "Murdoch",
    "Lightoller",
    "Boxhall",
    "Moody",
    "Phillips",
    "Fleet",
    "Barrett",
	"Wisecracker",
  },

  MERMNAMES =
  {
    "Glorpy",
    "Gloppy",
    "Blupper",
    "Glurtski",
    "Glummer",
    "Gluts",
    "Slerm",
    "Sloosher",
    "Slurnnious",
    "Brutter",
    "Glunt",
    "Mropt",
    "Shlorpen",
    "Blunser",
    "Fthhhhh",
    "Blort",
    "Slpslpslp",
    "Glorpen",
    "Rut Rut",
    "Mrwop",
    "Glipn",
    "Glert",
    "Sherpl",
    "Shlubber",

    "Christian",
    "Dan",
    "Drew",
    "Dave",
    "Jon",
    "Matt",
    "Nathan",
    "Vic",
  },

  BALLPHINNAMES=
  {
    "Miah",
    "Marius",
    "Brian",
    "Sushi",
    "Bait",
    "Chips",
    "Poseidon",
    "Flotsam",
    "Jetsam",
    "Seadog",
    "Gilly",
    "Fin",
	"Flipper",
    "Chum",
    "Seabreeze",
    "Tuna",
    "Sharky",
    "Wanda",
    "Neptune",
    "Seasalt",
    "Phlipper",
    "Miso",
    "Wasabi",
    "Jaws",
    "Babel",
    "Earl",
    "Fishi"
  },

  SHIPNAMES =
  {
    "Nautilus",
    "Mackay-Bennett",
    "Mary Celeste",
    "Beagle",
    "Monitor",
    "Santa Maria",
    "Bluenose",
    "Adriatic",
    "Nomadic",
    "Mauretania",
    "Endeavour",
    "Batavia",
    "Edmund Fitzgerald",
    "Pequod",
    "Mississinewa",
    "African Queen",
    "Mont-Blanc",
    "Anita Marie",
    "Caine",
    "Orca",
    "Pharaoh",
    "Nellie",
    "Piper Maru",
    "Minnow",
    "Syracusia",
    "Baron of Renfrew",
    "Ariel",
    "Blackadder",
    "Hispaniola",
    "Pelican",
    "Golden Hind",
    "Resolution",
	"Nina Clara",
	"Pinafore",
  },

  BORE_TALK_FOLLOWWILSON = {"YOU OK BY ME", "I LOVE FRIEND", "YOU IS GOOD", "I FOLLOW!"},
  BORE_TALK_FIND_LIGHT = {"SCARY", "NO LIKE DARK", "WHERE IS SUN?", "STAY NEAR FIRE", "FIRE IS GOOD"},
  BORE_TALK_LOOKATWILSON = {"WHO ARE YOU?", "YOU NOT BORE.", "UGLY MONKEY MAN", "YOU HAS MEAT?"},
  BORE_TALK_RUNAWAY_WILSON = {"TOO CLOSE!", "STAY 'WAY!", "YOU BACK OFF!", "THAT MY SPACE."},
  BORE_TALK_FIGHT = {"I KILL NOW!", "YOU GO SMASH!", "RAAAWR!", "NOW YOU DUN IT!", "GO 'WAY!", "I MAKE YOU LEAVE!",},
  BORE_TALK_RUN_FROM_SPIDER = {"SPIDER BAD!", "NO LIKE SPIDER!", "SCARY SPIDER!"},
  BORE_TALK_HELP_CHOP_WOOD = {"KILL TREE!", "SMASH MEAN TREE!", "I PUNCH TREE!"},
  BORE_TALK_HELP_HACK = {"I HELP GET BUSH!", "I PUNCH BUSH!", "WE PUNCHIN' PLANTS NOW?"},
  BORE_TALK_ATTEMPT_TRADE = {"WHAT YOU GOT?", "BETTER BE GOOD.", "NO WASTE MY TIME."},
  BORE_TALK_PANIC = {"NOOOOO!", "TOO DARK! TOO DARK!", "AAAAAAAAAH!!"},
  BORE_TALK_PANICFIRE = {"HOT HOT HOT!", "OWWWWW!", "IT BURNS!"},
  BORE_TALK_FIND_MEAT = {"ME HUNGRY!", "YUM!", "I EAT FOOD!", "TIME FOR FOOD!"},
  BORE_TALK_EAT_MEAT = {"NOM NOM NOM", "YUM!"},
  BORE_TALK_GO_HOME = {"HOME TIME!", "HOME! HOME!"},

  MERM_TALK_FIND_FOOD = {"Flut!", "Glort grolt flut.", "Florty glut."},
  MERM_TALK_PANIC = {"GLOP GLOP GLOP!", "GLORRRRRP!", "FLOPT! FTHRON!"},
  MERM_TALK_FIGHT = {"GLIE, FLORPY FLOPPER!", "NO! G'WUT OFF, GLORTER!", "WULT FLROT, FLORPER!"},
  MERM_TALK_RUNAWAY = {"Florpy glrop glop!", "GLORP! GLOPRPY GLUP!", "Glut glut flrop!"},
  MERM_TALK_GO_HOME = {"Wort wort flrot.", "Wrut glor gloppy flort."},
  MERM_TALK_FISH = {"Blut flort.", "Glurtsu gleen.", "Blet blurn."},

  BALLPHIN_TALK_FOLLOWWILSON = {"EE!! EE!!", "EEEE!", "EEE, EE?", "EE EEE EE"},
  BALLPHIN_TALK_HOME = {"NEEEEE!!", "Nee! NEe!", "NEE! NEE!"},
  BALLPHIN_TALK_FIND_LIGHT = {"EEEK! EEEK!", "EEK EEK EEK!"},
  BALLPHIN_TALK_PANIC = {"EEEEEEEEH!!", "EEEEEEEEE!!"},
  BALLPHIN_TALK_FIND_MEAT = {"Eee?", "Eee eee ee?", "Ee, ee?"},
  BALLPHIN_TALK_HELP_MINE_CORAL = {"KEEEEEE!", "KEE! KEE!", "KEEE!"},

  SUNKEN_BOAT_SQUAWKS = {"Squaak!", "Raaawk!"},
  SUNKEN_BOAT_REFUSE_TRADE = {"Sqwaak! Useless junk!", "Go away! Sqwaak!", "Wolly does NOT want THAT.", "Land lubber!"},
  SUNKEN_BOAT_ACCEPT_TRADE = {"Thanks, matey!", "A fair trade!", "Yaarr. Thanks buddy."},
  SUNKEN_BOAT_IDLE = 
  {
    "Sqwaaaak!",
    "Where's me treasures?",
    "Wolly wants a cracker.",
    "Abandon ship! Abandon ship!",
    "Thar she blows!",
    "Treasures from the sea?",
    "Lost! Lost! Waaark? Lost!",
    "The treasure's going down!",
  },

  RAWLING =
  {
    in_inventory =
    {
      "Let's cut the bottom out of the basket.",
    },

    equipped =
    {
      "You can carry me. For a couple of steps.",
      "Is this some kind of Canadian joke?",
      "Feel \"free\" to throw me.",
    },

    on_thrown =
    {
      "To the peach basket!",
      "Shoot!",
      "You miss 100% of the shots you don't take!",
      "I believe I can fly!",
    },

    on_ground =
    {
      "I could use a little pick me up.",
    },

    in_container =
    {
      "This isn't a peach basket...",
    },

    on_pickedup=
    {
      "Is that you, James?",
      "You're MY MVP!",
    },

    on_dropped=
    {
      "Dribble me!",
    },

    on_ignite =
    {
      "I'm on fire!",
      "Ow ow ow ow ow!",
    },

    on_extinguish =
    {
      "Saved!",
    },

    on_bounced =
    {
      "Ouch!",
      "Nothin' but peaches!",
      "Splish!",
      "Rejected!",
    },

    on_hit_water =
    {
      "Swish!",
    },
  },

  TALKINGBIRD =
  {
    in_inventory =
    {
      "Adventure!",
      "You stink!",
      "SQUAAAWK!",
      "Hey you!",
      "Chump!",
      "Nerd!",
      "Treasure!",
      "Walk the plank!",
      "Cracker!",
    },

    in_container =
    {
      "Don't bury me!",
      "Out, out!",
      "Sunk!",
      "Me eyes! Me eyes!",
      "Too dark!",
    },

    on_ground =
    {
      "Nice one!",
      "Chump!",
      "Big head!",
      "You stink!",
    },

    on_pickedup =
    {
      "Chump!",
      "Hello!",
      "Feed me!",
      "I'm hungry!",
      "Ouch!",
    },

    on_dropped =
    {
      "Chump!",
      "Bye now!",
      "See ya chump!",
      "Goodbye!",
    },

    on_mounted =
    {
      "Onward!",
      "Uh-oh!",
      "Are you sure about this?",
    },

    on_dismounted =
    {
      "Land!",
      "Solid ground!",
      "We made it!",
    },

    other_owner =
    {
      "Help!",
      "Ack!",
      "Scurvy!",
      "Save me!",
      "I'm okay!",
    },
  },
  
  
  UI = {
	WORLDGEN_IA = {
	  VERBS = {
		-- "Keelhauling",
		"Inundating with",
		"Setting course for",
		"Hoisting",
	  },
	  NOUNS = {
		"jungle...",
		"deep, dark waters...",
		"palms...",
		"snakes...",
		"sea monsters...",
		"a bottle of rum...",
		"fish heads...",
		"chests and chests of dubloons...",
		"chatty parrots...",
		"seafood...",
		"vast ocean...",
		"thalassophobia...",
		"jetsam...",
	  },
	},
    CRAFTING = {
      NEEDSEALAB = "Use a sea lab to build a prototype!",
	},
    CUSTOMIZATIONSCREEN = {
        PRIMARYWORLDTYPE = "World Type",
        ISLANDQUANTITY = "Island Quantity",
        ISLANDSIZE = "Island Size",
        VOLCANO = "Volcano",
        DRAGOONEGG = "Dragoon Eggs",
        TIDES = "Tides",
        FLOODS = "Floods",
        OCEANWAVES = "Waves",
        POISON = "Poison",
        BERMUDATRIANGLE = "Electric Isosceles",
		
		FISHINHOLE = "Shoals",
		SEASHELL = "Seashells",
		BUSH_VINE = "Viney Bushes",
		SEAWEED = "Seaweeds",
		SANDHILL = "Sandy Piles",
		CRATE = "Crates",
		BIOLUMINESCENCE = "Bioluminescence",
		CORAL = "Corals",
		CORAL_BRAIN_ROCK = "Brainy Sprouts",
        BAMBOO = "Bamboo",
		TIDALPOOL = "Tidal Pools",
		POISONHOLE = "Poisonous Holes",
		
		SWEET_POTATO = "Sweet Potatoes",
		LIMPETS = "Limpets",
        MUSSEL_FARM = "Mussels",
		
		WILDBORES = "Wildbores",
		WHALEHUNT = "Whaling",
		CRABHOLE = "Crabbits",
		OX = "Water Beefalos",
		SOLOFISH = "Dogfish",
		DOYDOY = "Doydoys",
        JELLYFISH = "Jellyfish",
		LOBSTER = "Wobsters",
		SEAGULL = "Seagulls",
		BALLPHIN = "Ballphins",
		PRIMEAPE = "Prime Apes",
		
        SHARX = "Sea Hounds",
		CROCODOG = "Crocodogs",
		TWISTER = "Sealnado",
		TIGERSHARK = "Tiger Sharks",
		KRAKEN = "Quacken",
		FLUP = "Flup",
		MOSQUITO = "Poison Mosquitos",
		SWORDFISH = "Swordfish",
		STUNGRAY = "Stink Rays",
		PRESETLEVELS = {
			SURVIVAL_SHIPWRECKED_CLASSIC = "Shipwrecked",
		},
		PRESETLEVELDESC = {
			SURVIVAL_SHIPWRECKED_CLASSIC = "A world of (almost) exclusively Shipwrecked content.",
		},
		TASKSETNAMES = {
			ISLANDADVENTURES = "Islands",
		},
    },
    SANDBOXMENU = {
		IA_NOCAVES_TITLE = "No Cave Entrances!",
		IA_NOCAVES_BODY = "Island-only worlds don't have cave entrances (unless you got an add-on mod for that).\nDo you want to remove the caves from this server?",
		ADDLEVEL_WARNING_IA = "Island-only worlds don't have cave entrances (unless you got an add-on mod for that).\nYou might not be able to access the caves!",
        CUSTOMIZATIONPREFIX_IA = "Island ", --Please note that the space is intentional, so translations may use hyphons or whatever -M
        SLIDEVERYRARE = "Much Less",
        WORLDTYPE_DEFAULT = "Forest",
        WORLDTYPE_MERGED = "Merged",
        WORLDTYPE_ISLANDS = "Islands",
        WORLDTYPE_ISLANDSONLY = "Islands Only",
        IA_START = "Island Adventures",
    },
  },
}
%%+%%strings/generic.lua%%-%%-- This speech is for Wilson, also mod characters if they don't have quotes already (hence "generic")
return {

ACTIONFAIL =
{
	REPAIRBOAT = 
	{
		GENERIC = "She's floating just fine right now.",
	},
	EMBARK = 
	{
		INUSE = "The ship has left port without me!",
	},
	INSPECTBOAT = 
	{
		INUSE = GLOBAL.STRINGS.CHARACTERS.GENERIC.ACTIONFAIL.STORE.INUSE
	},
},

ANNOUNCE_MAGIC_FAIL = "It won't work here.",

ANNOUNCE_SHARX = "I'm going to need a bigger boat...",

ANNOUNCE_TREASURE = "It's a map! And it marks a location!",
ANNOUNCE_MORETREASURE = "Seriously? Another one!?",
ANNOUNCE_OTHER_WORLD_TREASURE = "This map doesn't correlate to my current surroundings.",
ANNOUNCE_OTHER_WORLD_PLANT = "I don't think this soil has the proper nutrients.",

ANNOUNCE_MESSAGEBOTTLE =
{
	"The message is faded. I can't read it.",
},
ANNOUNCE_VOLCANO_ERUPT = "That can't be good.",
ANNOUNCE_MAPWRAP_WARN = "Here be monsters.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "It would seem my future is foggy.",
ANNOUNCE_MAPWRAP_RETURN = "I think I felt something brush against my leg...",
ANNOUNCE_CRAB_ESCAPE = "I could've sworn it was right there...",
ANNOUNCE_TRAWL_FULL = "My net filled up!",
ANNOUNCE_BOAT_DAMAGED = "I think I sprung a leak.",
ANNOUNCE_BOAT_SINKING = "I seem to be sinking.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "I need to get to land!",
ANNOUNCE_WAVE_BOOST = "Weeeee!",

ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Follow those bubbles!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "I wonder where it went...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "The water is too rough!",


DESCRIBE = {
	
	--Coming in from Shipwrecked Characters (SWC) -Cheese
	-- PORTABLECOOKPOT_ITEM = "Now we're cookin'!",
	CHEFPACK = "His bag of chef's tricks!",
	-- PORTABLECOOKPOT = 
	-- {
        -- COOKING_LONG = "I'm no chef, but I think that's going to take awhile.",
        -- COOKING_SHORT = "It's almost done!",
        -- DONE = "Mmmmm! It's ready to eat!",
        -- EMPTY = "He never leaves home without it.",
    -- },

	-- WARLY = 
    -- {
        -- GENERIC = "Good day, %s!",
        -- ATTACKER = "%s looks like they're planning to cook me!",
        -- MURDERER = "%s has been overcooked!",
        -- REVIVER = "%s is cooking up friendships.",
        -- GHOST = "Looks like you've been cooked, %s.",
		-- FIRESTARTER = "I think you're cooking the wrong stuff, %s.",
    -- },
    --

	SEAWEED_STALK = "Should plant this somewhere.", --copied from the Wikia because I couldn't find it in the game files. -M

	WILDBOREGUARD = "What's it guarding?",
	SOLOFISH_DEAD = "Good dog.",
	FISH_MED_COOKED = "Grilled to perfection.",
	PURPLE_GROUPER = "A fish with widespread appeal.",
	PURPLE_GROUPER_COOKED = "Avoid the green ones, they're not ripe yet.",

	GHOST_SAILOR = "I wonder what he wants?",
	FLOTSAM = "If only I had some way of hooking on to it from here.",
	SUNKEN_BOAT = 
	{
		GENERIC = "That fellow looks like he wants to talk.",
		ABANDONED = "This is why I hate the water.",
	},
	SUNKEN_BOAT_BURNT = "It's even less seaworthy than before.",
	SUNKEN_BOAT_TRINKET_1 = "An instrument of some sort.", --sextant
	SUNKEN_BOAT_TRINKET_2 = "Now all I need is a miniaturization machine!", --toy boat
	SUNKEN_BOAT_TRINKET_3 = "Looks kinda soggy.", --candle
	SUNKEN_BOAT_TRINKET_4 = "Scientific!", --sea worther
	SUNKEN_BOAT_TRINKET_5 = "If only I had another!", --boot
	SUNKBOAT = "It's no use to me out there!",
	-- BANANAPOP = "No, not brain freeze! I need that for science!",
	BISQUE = "Cooking that sure kept me bisque-y!",
	-- CEVICHE = "Can I get a bigger bowl? This one looks a little shrimpy.",
	SEAFOODGUMBO = "It's a jumbo seafood gumbo.",
	SURFNTURF = "It's perf!",
	SHARKFINSOUP = "It's shark fin-ished!",
	LOBSTERDINNER = "If I eat it in the morning is it still dinner?",
	LOBSTERBISQUE = "Could use more salt, but that's none of my bisque-ness.",
	JELLYOPOP = "Jelly-O pop it right in my mouth!",

	BOAT_ENCRUSTED = "A mere shell of a ship.",
	BABYOX = "Smaller, but just as smelly.",
	BALLPHINHOUSE = "The place where the ballphins roost.",
	DORSALFIN = "Guess that house is FINished.",
	NUBBIN = "I want nubbin to do with that.",
	CORALLARVE = "That's a baby coral reef.",
	RAINBOWJELLYFISH = "That's a lot of tendrils.",
	RAINBOWJELLYFISH_PLANTED = "A colorful blob of science.",
	RAINBOWJELLYFISH_DEAD = "An electric shock will not revive it. I tried.",
	RAINBOWJELLYFISH_COOKED = "A colorful snack!",
	RAINBOWJELLYJERKY = "All the water's dried right out of it.",
	WALL_ENFORCEDLIMESTONE = "I shelled out for the good stuff.",
	WALL_ENFORCEDLIMESTONE_ITEM = "I have to build it in the water.",
	CROCODOG = "I'd rather stay away from the business end of that jerk.",
	POISONCROCODOG = "That looks like an experiment gone wrong.",
	WATERCROCODOG = "It's a dog-eat-me world out here.",
	QUACKENBEAK = "I'd say I made the pecking order around here quite clear.",
	QUACKERINGRAM = "Does my ingenuity know no bounds?!",

	CAVIAR = "I never had it before I came here.",
	CORMORANT = "I bet it eats a lot of fish.",

	PURPLE_GROUPER = "Surf and turf, hold the turf.",
	PIERROT_FISH = "This one's extra water repellent.",
	NEON_QUATTRO = "It looks like a fish, but it feels clammy.",

	PURPLE_GROUPER_COOKED = "That fish is fin-ished.",
	PIERROT_FISH_COOKED = "Gilled to perfection.",
	NEON_QUATTRO_COOKED = "Fried fry.",

	FISH_FARM = 
	{
		EMPTY = "I need to find some fish eggs for this.",
		STOCKED = "The fish babies haven't hatched yet.",
		ONEFISH = "There's a fish!",
		TWOFISH = "The fish are still multiplying.",
		REDFISH = "This has been a successful fish experiment!",
		BLUEFISH  = "I'd better start harvesting these!",
	},

	ROE = "Fish babies.",
	ROE_COOKED = "Roe, sunny side up.",
	
	SEA_YARD =
	{
		ON = "For keeping my ships in tiptop shape!",
		OFF = "It's not in shipshape right now.",
		LOWFUEL = "I'll need to refill it soon.",
	},

	SEA_CHIMINEA = 
	{
		EMBERS = "Better put something on it before it goes out.",
		GENERIC = "Science protect my fires out here.",
		HIGH = "I'm glad we're surrounded by water.",
		LOW = "It's getting low.",
		NORMAL = "As cozy as it gets.",
		OUT = "It finally went out.",
	}, 

	TAR = "Do I have to hold it with my bare hands?",
	TAR_EXTRACTOR =
	{
		ON = "It's running smoothly.",
		OFF = "I have to turn it on.",
		LOWFUEL = "I need to refuel that.",
	},
	TAR_POOL = "There must be a way to get that tar out.",

	TARLAMP = "That's a real slick lamp.",
	TARSUIT = "I'll pitch a fit if I have to wear that.",
	TAR_TRAP = "Who's cleaning that up, I wonder?",

	TROPICALBOUILLABAISSE = "I seasoned it with a dash of science.",

	SEA_LAB = "For sea science!",
	WATERCHEST = "Watertight, just like all my theories.",
	QUACKENDRILL = "I can get more tar if I used this at sea.",
	HARPOON = "I don't intend to harp on the issue.",
	MUSSEL_BED = "I should find a good spot for these.",
	ANTIVENOM = "Tastes horrible!",
	VENOMGLAND = "Only poison can cure poison.",
	BLOWDART_POISON = "The pointy end goes that way.",
	OBSIDIANMACHETE = "It's hot to the touch.",
	SPEARGUN_POISON = "Poison tipped.",
	OBSIDIANSPEARGUN = "Fire tipped.",
	LUGGAGECHEST = "It looks like a premier steamer trunk.",
	PIRATIHATITATOR =
	{
		GENERIC = "It's twisting my tongue.",
		BURNT = "Fire doesn't really solve naming issues...",
	},
	COFFEEBEANS = "They could use some roasting.",
	COFFEE = "Smells delicious and energizing!",
	COFFEEBEANS_COOKED = "Heat definitely improved them.",
	COFFEEBUSH =
	{
		BARREN = "I think it needs to be fertilized.",
		WITHERED = "Looks malnourished.",
		GENERIC = "This is a plant I could learn to love.",
		PICKED = "Maybe they'll grow back?",
	},
	COFFEEBOT = "It's a coffee maker.",
	MUSSEL = "Could use some flexing.",
	MUSSEL_FARM =
	{
		 GENERIC = "I wonder if they are from Brussels.",
		 STICKPLANTED = "I really stuck it to them."
	},

	MUSSEL_STICK = "I'm really going to stick it to those mussels.",
	LOBSTER = "What a Wascally Wobster.",
	LOBSTERHOLE = "That Wascal is sleeping.",
	SEATRAP = "For the deadliest catch.",
	SANDCASTLE =
	{
		SAND = "It's a sandcastle, in the sand!",
		GENERIC = "Look what I made!"
	},
	BOATREPAIRKIT = "This will add some float to my boat.",

	BALLPHIN = "Such a round, rubbery fellow.",
	BOATCANNON = "The only thing better than a boat is a boat with a cannon.",
	BOTTLELANTERN = "A bottle full of sunshine.",
	BURIEDTREASURE = "Please be a good treasure!",
	BUSH_VINE =
	{
		BURNING = "Whoops.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "It's all viney!",
	},
	CAPTAINHAT = "The proper boating attire!",
	COCONADE =
	{
		BURNING = "This seems dangerous.",
		GENERIC = "I'll need to light it first.",
	},
	CORAL = "Living building material!",
	ROCK_CORAL = "The coral's formed a reef!",
	CRABHOLE = "They call a hole in the sand their home.",
	CUTLASS = "I hope this sword doesn't start to smell...",
	DUBLOON = "I'm rich!",
	FABRIC = "Soft cloth made from hard roots!",
	FISHINHOLE = "This area seems pretty fishy.",
	GOLDENMACHETE = "Hack in style!",
	JELLYFISH = "This creature is pure science!",
	JELLYFISH_DEAD = "It lived a good life. Maybe.",
	JELLYFISH_COOKED = "It's all wriggly.",
	JELLYFISH_PLANTED = "Science works in mysterious, blobby ways.",
	JELLYJERKY = "I'd be a jerk not to eat this.",

	ROCK_LIMPET =
	{
		GENERIC = "I could fill a pail with all those snails.",
		PICKED = "I can't fill a pail without snails.",
	},
	BOAT_LOGRAFT = "This looks... sort of boat-like...",
	MACHETE = "I like the cut of this blade.",
	MESSAGEBOTTLEEMPTY = "Just an empty bottle.",
	MOSQUITO_POISON = "These blasted mosquitoes carry a terrible sickness.",
	OBSIDIANCOCONADE = "It's even bombier!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "I should put something on the fire before it goes out.",
		GENERIC = "This fire pit is a conductor for even more... fire.",
		HIGH = "Good thing it's contained!",
		LOW = "The fire's getting a bit low.",
		NORMAL = "This is my best invention yet.",
		OUT = "At least I can start it up again.",
	},
	OX = "These creatures seem reasonable.",
	PIRATEHAT = "Fit for a cutthroat scallywag. Or me.",
	BOAT_RAFT = "This looks adequate.",
	BOAT_ROW = "It runs on elbow grease.",
	SAIL_PALMLEAF = "This should really transform my boating experience.",
	SANDBAG_ITEM = "Sand technology, on the go.",
	SANDBAG = "Keeps the water at bay.",
	SEASACK = "I hate when food has that not-so-fresh taste.",
	SEASHELL_BEACHED = "Sea refuse.",
	SEAWEED = "A weed. Of the sea.",

	SEAWEED_PLANTED = "Is that what passes for food around here?",
	SLOTMACHINE = "I suppose I could linger for a moment or two.",
	SNAKE_POISON = "Even worse than a regular snake!",
	SNAKESKIN = "I'm intrigued AND repelled.",
	SNAKESKINHAT = "It should repel the rain from my hair.",
	SOLOFISH = "It has that wet-dog smell.",
	SPEARGUN = "Oh, the science I could get up to with this!",
	SPOILED_FISH = "I'm not terribly curious about the smell.",
	SWORDFISH = "I think this fish evolved to run me through.",
	TRIDENT = "I wonder how old this artifact is?",
	TRINKET_IA_13 = "What is this substance?",
	TRINKET_IA_14 = "This thing gives me the creeps...",
	TRINKET_IA_15 = "Incredible! This guitar has undergone shrinkification!",
	TRINKET_IA_16 = "How did this get all the way out here?",
	TRINKET_IA_17 = "Where's the other one?",
	TRINKET_IA_18 = "A relic of a bygone era!",
	TRINKET_IA_19 = "Clouding of the brain. Never heard of it...",
	TURBINE_BLADES = "Perhaps this powered that beastly storm?",
	TURF_BEACH = "Sandy ground.",
	TURF_JUNGLE = "Very gnarled ground.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It appears to be closed.",
		OPEN = "The altar is open and ready to accept offerings!",
	},
	VOLCANO_ALTAR_BROKEN = "Er, that won't be a problem, will it?",
	WHALE_BLUE = "That whale has emotional issues.",
	WHALE_CARCASS_BLUE = "Gross. I think the bloating has begun.",
	WHALE_CARCASS_WHITE = "Gross. I think the bloating has begun.",

	ARMOR_SNAKESKIN = "How fashionable!",
	SAIL_CLOTH = "That wind isn't getting away now!",
	DUG_COFFEEBUSH = "This belongs in the ground!",
	LAVAPOOL = "A bit hot for my tastes.",
	BAMBOO = "Maybe I can bamboozle my enemies with this?",
	AERODYNAMICHAT = "It really cuts through the air!",
	POISONHOLE = "I think I'll stay away from that.",
	BOAT_LANTERN = "This will do wonders for my night vision!",
	SWORDFISH_DEAD = "I better not run with this.",
	LIMPETS = "Maybe starving wouldn't be so bad.",
	OBSIDIANAXE = "A winning combination!",
	COCONUT = "It requires a large nut hacker.",
	COCONUT_SAPLING = "It doesn't need my help to grow anymore.",
	COCONUT_COOKED = "Now I just need a cake.",
	BERMUDATRIANGLE = "Gives me an uneasy feeling.",
	SNAKE = "I wonder if it'll sell me some oil?",
	SNAKEOIL = "The label says \"Jay's Wondrous Snake Oil!\"",
	ARMORSEASHELL = "Arts and crafts!",
	SNAKE_FIRE = "Is that snake smoldering?",
	MUSSEL_COOKED = "I cook a mean mussel.",

	PACKIM_FISHBONE = "This seems like something I should carry around.",
	PACKIM = "I bet I could pack'im full of stuff.",

	ARMORLIMESTONE = "I'm sure this will hold up great!",
	TIGERSHARK = "Well that's terrifying.",
	WOODLEGS_KEY1 = "Something, somewhere must be locked.",
	WOODLEGS_KEY2 = "This key probably unlocks something.",
	WOODLEGS_KEY3 = "That's a key.",
	WOODLEGS_CAGE = "That seems like an excessive amount of locks.",
	OBSIDIAN_WORKBENCH = "I feel inspired.",

	NEEDLESPEAR = "I'm glad I didn't step on this.",
	LIMESTONENUGGET = "Could be a useful building material.",
	DRAGOON = "You're a quick one, aren't you?",

	ICEMAKER = 
	{
		OUT = "It needs more fuel.",
		VERYLOW = "I can hear it sputtering.",
		LOW = "It seems to be slowing down.",
		NORMAL = "It's putting along.",
		HIGH = "It's running great!",
	},

	DUG_BAMBOOTREE = "I need to plant this.",
	BAMBOOTREE =
	{
		BURNING = "Bye bye, bamboo.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "Golly, it's even floatier than wood!", --"Looks pretty sturdy.", -Mob
	},
	
	JUNGLETREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "That tree needs a hair cut.",
	},
	SHARK_GILLS = "I wish I had gills.",
	LEIF_PALM = "Someone gimme a hand with this palm!",
	OBSIDIAN = "It's a fire rock.",
	BABYOX = "It's a tiny meat beast.",
	STUNGRAY = "I think I'll keep my distance.",
	SHARK_FIN = "A sleek fin.",
	FROG_POISON = "It looks meaner than usual.",
	BOAT_ARMOURED = "That is one durable boat.",
	ARMOROBSIDIAN = "I'm a genius.",
	BIOLUMINESCENCE = "These make a soothing glow.",
	SPEAR_POISON = "Now it's extra deadly.",
	SPEAR_OBSIDIAN = "This will leave a mark.",
	SNAKEDEN =
	{
		BURNING = "Whoops.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "It's all viney!",
	},
	TOUCAN = "I tou-can't catch him.",
	MESSAGEBOTTLE = "Someone wrote me a note!",
	SAND = "A handy pile of pocket sand.",
	SANDDUNE = "You better stay out of my shoes.",
	PEACOCK = "Nothing more than a dressed up thief.",
	VINE = "Maybe I can tie stuff up with this.",
	SUPERTELESCOPE = "I can see forever!",
	SEAGULL = "Shoo! Find some other land!",
	SEAGULL_WATER = "Shoo! Find some other water!",
	PARROT = "I find myself fresh out of crackers.",
	ARMOR_LIFEJACKET = "Keeps me afloat, without my boat!",
	WHALE_BUBBLES = "Something's underwater here.",
	EARRING = "The fewer holes in my body, the better.",
	ARMOR_WINDBREAKER = "The wind doesn't stand a chance!",
	SEAWEED_COOKED = "Crispy.",
	BOAT_CARGO = "It has room for all my stuff!",
	GASHAT = "Sucks all the stink out.",
	ELEPHANTCACTUS = "Yikes! I could poke an eye out!",
	DUG_ELEPHANTCACTUS = "A portable poker plant.",
	ELEPHANTCACTUS_ACTIVE = "That cactus seems abnormally pokey.",
	ELEPHANTCACTUS_STUMP = "It'll sprout pokers again eventually.",
	SAIL_FEATHER = "It's feather-light!",
	WALL_LIMESTONE_ITEM = "These would do more good if I placed them.",
	JUNGLETREESEED = "I can hear the hissing of tiny snakes.",
	JUNGLETREESEED_SAPLING = "It will grow into a nice jungle tree.",
	VOLCANO = "My scientific know-how tells me that's a perfectly safe mountain!",
	IRONWIND = "This is how a scientist should travel.",
	SEAWEED_DRIED = "Salty!",
	TELESCOPE = "I spy with my little eye...",
	
	DOYDOY = "I feel oddly protective of this dumb bird.",
	DOYDOYBABY = "What a cute little, uh, thing.",
	DOYDOYEGG = "Maybe I should have let it hatch.",
	DOYDOYEGG_CRACKED = "Oh well. I'm sure there are lots more!",
	DOYDOYFEATHER = "Soft AND endangered!",

	PALMTREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "How tropical.",
	},
	PALMLEAF = "I'm fond of these fronds.",
	CHIMINEA = "Take that, wind!",
	DOUBLE_UMBRELLAHAT = "The second umbrella keeps the first umbrella dry.",
	CRAB = 
	{
		GENERIC = "Don't get snappy with me, mister.",
		HIDDEN = "I wonder where that crabbit went?",
	},
	TRAWLNET = "Nothing but net.",
	TRAWLNETDROPPED = 
	{
		SOON = "It is definitely sinking.",
		SOONISH = "I think it's sinking.",
		GENERIC = "It's bulging with potential!",
	},
	VOLCANO_EXIT = "There's a cool breeze blowing in from outside.",
	SHARX = "These things sure are persistent.",
	SEASHELL = "Maybe I could sell these.",
	WHALE_BUBBLES = "Something down there has bad breath.",
	MAGMAROCK = "I can dig it.",
	MAGMAROCK_GOLD = "I see a golden opportunity.",
	CORAL_BRAIN_ROCK = "I wonder what it's plotting...",
	CORAL_BRAIN = "Food for thought.",
	SHARKITTEN = "You've got to be kitten me!",
	SHARKITTENSPAWNER = 
	{
		GENERIC = "Is that sand pile purring?",
		INACTIVE = "That is a rather large pile of sand.",
	},
	LIVINGJUNGLETREE = "Just like any other tree.",
	WALLYINTRO_DEBRIS = "Part of a wrecked ship.",
	MERMFISHER = "You better not try anything fishy.",
	PRIMEAPE = "Those things are going to be the end of me.",
	PRIMEAPEBARREL = "Here be evil.",
	BARREL_GUNPOWDER = "How original.",
	PORTAL_SHIPWRECKED = "It's broken.",
	MARSH_PLANT_TROPICAL = "Planty.",
	TELEPORTATO_SW_POTATO = "Seems like it was made with a purpose in mind.",
	PIKE_SKULL = "Ouch.",
	PALMLEAF_HUT = "Shade, sweet shade.",
	FISH_SMALL_COOKED = "A small bit of cooked fish.",
	LOBSTER_DEAD = "You should cook up nicely.",
	MERMHOUSE_FISHER = "Doesn't smell very good.",
	WILDBORE = "Looks aggressive.",
	PIRATEPACK = "I can keep my booty in here.",
	TUNACAN = "Where did this can come from?",
	MOSQUITOSACK_YELLOW = "Part of a yellow mosquito.",
	SANDBAGSMALL = "This should keep the water out.",
	FLUP = "Leave me alone!",
	OCTOPUSKING = "I'm a sucker for this guy.",
	OCTOPUSCHEST = "I hope that thing is waterproof.",
	GRASS_WATER = "I hope you're thirsty, grass.",
	WILDBOREHOUSE = "What a bore-ing house.",
	FISH_SMALL = "A small bit of fish.",
	TURF_SWAMP = "Swampy turf.",
	FLAMEGEYSER = "Maybe I should stand back.",
	KNIGHTBOAT = "Get off the waterway, you maniac!",
	MANGROVETREE_BURNT = "I wonder how that happened.",
	TIDAL_PLANT = "Look. A plant.",
	WALL_LIMESTONE = "Sturdy.",
	FISH_MED = "A chunk of fish meat.",
	LOBSTER_DEAD_COOKED = "I can't wait to eat you.",
	BLUBBERSUIT = "Well, it's something.",
	BLOWDART_FLUP = "Eye see.",
	TURF_MEADOW = "Meadow-y turf.",
	TURF_VOLCANO = "Volcano-y turf.",
	SWEET_POTATO = "Looks yammy!",
	SWEET_POTATO_COOKED = "Looks even yammier!",
	SWEET_POTATO_PLANTED = "That's an odd looking carrot.",
	SWEET_POTATO_SEEDS = "My very own plant eggs.",
	BLUBBER = "Squishy.",
	TELEPORTATO_SW_RING = "Looks like I could use this.",
	TELEPORTATO_SW_BOX = "It looks like a part for something.",
	TELEPORTATO_SW_CRANK = "I wonder what this is used for.",
	TELEPORTATO_SW_BASE = "I think it's missing some parts.",
	VOLCANOSTAFF = "The label says \"Keep out of reach of children.\"",
	THATCHPACK = "I call it a thatchel.",
	SHARK_TEETHHAT = "What a dangerous looking hat.",
	TURF_ASH = "Ashy turf.",
	BOAT_TORCH = "This'll keep my hands free.",
	MANGROVETREE = "I wonder if it's getting enough water?",
	HAIL_ICE = "Chilling.",
	FISH_TROPICAL = "What a tropical looking fish.",
	TIDALPOOL = "A pool, left by the tides.",
	WHALE_WHITE = "Looks like a fighter.",
	VOLCANO_SHRUB = "You look ashen.",
	ROCK_OBSIDIAN = "Blast it! It won't be mined!",
	ROCK_CHARCOAL = "Would need an awfully big stocking for that.",
	DRAGOONDEN = "Even goons gotta sleep.",
	WILBUR_UNLOCK = "He looks kind of regal.",
	WILBUR_CROWN = "It's oddly monkey-sized.",
	TWISTER = "I thought it was strangely windy around here.",
	TWISTER_SEAL = "D'awww.",
	MAGIC_SEAL = "This is a powerful artifact.",
	SAIL_STICK = "There must be a scientific explanation for this.",
	WIND_CONCH = "I can hear the wind trapped within.",
	DRAGOONEGG = "Do I hear cracking?",
	BUOY = "Awww yaaaaa buoy!", 
	TURF_SNAKESKIN = "Sssstylish ssssstatement.",
	DOYDOYNEST = "It's for doydoy eggs, dummy.",
	ARMORCACTUS = "The best defense is a good offense.",
	BIGFISHINGROD = "To catch a big fish, you need a big rod.",
	BRAINJELLYHAT = "Two brains means double the ideas!",
	COCONUT_HALVED = "When I click them together, they make horsey sounds.",
	CRATE = "There must be a way to open it.",
	DEPLETED_BAMBOOTREE = "Will it grow again?",
	DEPLETED_BUSH_VINE = "One day it may return.",
	DEPLETED_GRASS_WATER = "Farewell, sweet plant.",
	DOYDOYEGG_COOKED = "A controlled chemical reaction has made this egg matter more nutritious.",
	DRAGOONHEART = "Where the dragoon once stored its feelings.",
	DRAGOONSPIT = "It's SPITacularly disgusting!",
	DUG_BUSH_VINE = "I suppose I should pick it up.",
	-- FRESHFRUITCREPES = "Sugary fruit! Part of a balanced breakfast.",
	KRAKEN = "Now's not the time for me to be Quacken wise!",
	KRAKENCHEST = "To the victor, the spoils.",
	KRAKEN_TENTACLE = "A beast that never sleeps.",
	MAGMAROCK_FULL = "I can dig it.",
	MAGMAROCK_GOLD_FULL = "I see a golden opportunity.",
	MONKEYBALL = "I have a strange desire to name it after myself.",
	-- MONSTERTARTARE = "There's got to be something else to eat around here.",
	MUSSELBOUILLABAISE = "Imagine the experiments I could run on it!",
	MYSTERYMEAT = "I'm not dissecting that.",
	OXHAT = "Nice and dry. This helmet will protect me from the elements.",
	OX_FLUTE = "Is it dripping...?",
	OX_HORN = "I grabbed the ox by the horn.",
	PARROT_PIRATE = "I try not to eat anything with a name.",
	PEG_LEG = "I can perform amputations if anyone'd like to wear it for real.",
	PIRATEGHOST = "He met a terrible end. I will too if I don't get out of here.",
	SANDBAGSMALL_ITEM = "A bag full of sand. Does science know no bounds?",
	SHADOWSKITTISH_WATER = "Yikes!",
	SHIPWRECKED_ENTRANCE = "Ahoy!",
	SHIPWRECKED_EXIT = "And so, I sail away into the horizon!",
	SAIL_SNAKESKIN = "Scale it and sail it!",
	SPEAR_LAUNCHER = "Science takes care of me.",
	SWEETPOTATOSOUFFLE = "Sweet potato souffles are a rising trend.",
	SWIMMINGHORROR = "Yikes! Get me back to land!",
	TIGEREYE = "More eyes means better sight... right?",
	TRINKET_IA_20 = "I'm not sure what it is, but it makes me feel smarter!",
	TRINKET_IA_21 = "I ought to measure it to ensure it's to scale.",
	TRINKET_IA_22 = "I'm sure someone would like this.",
	TURF_MAGMAFIELD = "Lava-y floor.",
	TURF_TIDALMARSH = "Marsh-y floor.",
	VOLCANO_ALTAR_TOWER = "How scary!",
	WATERYGRAVE = "Sure, I could fish it out of there. But should I?",
	WHALE_TRACK = "Whale, ho!",
	WILDBOREHEAD = "It smells as bad as it looks.",
	BOAT_WOODLEGS = "A vessel fit for a scallywag.",
	WOODLEGSHAT = "Does it make me look scurvy... I mean scary!?",
	SAIL_WOODLEGS = "The quintessential pirate sail.",
	SHIPWRECK = "Poor little boat.",
	INVENTORYGRAVE = "There was someone here before me!",
	INVENTORYMOUND = "There was someone here before me!",
	LIMPETS_COOKED = "Escargotcha!",
	RAWLING = "It's my buddy!",
	CALIFORNIAROLL = "But I don't have chopsticks.",
},
}
%%+%%strings/walani.lua%%-%%-- Notice that DST-specific quotes are missing as of now -Mobb
return {
ACTIONFAIL =
{
	REPAIRBOAT =
	{
		GENERIC = "It doesn't need any work.",
	},
	SHAVE =
	{
		AWAKEBEEFALO = "Woah, slow down. She's awake.",
		GENERIC = "Nah.",
		NOBITS = "My work here is done.",
	},
	STORE =
	{
		GENERIC = "It's holding all it can.",
		NOTALLOWED = "I could jam it in there I guess. Might get smushed.",
	},
	RUMMAGE =
	{	
		GENERIC = "Haha, nah.",	
	},
	COOK =
	{
		GENERIC = "Ughh, no.",
		TOOFAR = "I just need to walk over there to use it... Ughhh, I'm going to starve!",
	},
	GIVE =
	{
		DEAD = "Poor guy's dead.",
		SLEEPING = "Aw. Let it sleep.",
		BUSY = "It's doing something else right now.",
	},
	WRITE =
	{
		GENERIC = "Nah. Don't wanna.",
	},
	CHANGEIN =
	{
		GENERIC = "What's wrong with what I'm wearing?",
		BURNING = "Yeah, I think I'll pass.",
	},
	TEACH =
	{
		KNOWN = "I already know that, y'know?",
		CANTLEARN = "Looks boring.",
	},
},
ACTIONFAIL_GENERIC = "Well that didn't work.",
ANNOUNCE_MAGIC_FAIL = "It won't work. Me either! Haha.",
ANNOUNCE_ACCOMPLISHMENT = "Busywork.",
ANNOUNCE_ACCOMPLISHMENT_DONE = "Well, that's finished.",
ANNOUNCE_ADVENTUREFAIL = "All that work for nothing.",
ANNOUNCE_BEES = "Relax your thorax!",
ANNOUNCE_BOAT_DAMAGED = "My floater's been dinged!",
ANNOUNCE_BOAT_SINKING = "This thing is letting on water.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "I won't be floating much longer...",
ANNOUNCE_BOOMERANG = "Ow! Stop hitting yourself, Walani!",
ANNOUNCE_BURNT = "OUCH! That's burnin' my digits!",
ANNOUNCE_CANFIX = "\nI should probably repair that. Maybe later.", 
ANNOUNCE_CHARLIE = "Who's there?! Leave me alone!",
ANNOUNCE_CHARLIE_ATTACK = "ACHK! I SAID GO AWAY!",
ANNOUNCE_COLD = "Way too cold!",
ANNOUNCE_CRAB_ESCAPE = "I thought it was right here...",
ANNOUNCE_CRAFTING_FAIL = "Haha. I really messed that up.",
ANNOUNCE_DEERCLOPS = "Something big is headed this way!",
ANNOUNCE_DUSK = "Darkness will be here soon!",
ANNOUNCE_EAT =
{
	GENERIC = "Not too bad. Heh heh.",
	INVALID = "I'll take a pass on that one.",
	PAINFUL = "Ish my tongue shupposed t'shwell up like that?",
	SPOILED = "Gnarly! I think I'm gonna hurl...",
	STALE = "I mean, I guess that was food.",
	YUCKY = "Haha, wow, no.",
},
ANNOUNCE_ENTER_DARK = "H-holy geez, it's dark! HELP! Help me!",
ANNOUNCE_ENTER_LIGHT = "Sweet crispy light! I missed you!",
ANNOUNCE_FREEDOM = "Hooray, I'm free! Time for a nap?",
ANNOUNCE_HIGHRESEARCH = "Woah, I think that, like, expanded my mind!",
ANNOUNCE_HOT = "This heat is unbearable.",
ANNOUNCE_HOUNDS = "Junkyard dogs incomin'.",
ANNOUNCE_HUNGRY = "I'm crashing like a sick wave! Gimme food!",
ANNOUNCE_HUNT_BEAST_NEARBY = "I hear rustling nearby.",
ANNOUNCE_HUNT_LOST_TRAIL = "Ugh, it got away.",
ANNOUNCE_HUNT_LOST_TRAIL_SPRING = "The water washed the tracks away. Oh well.",
ANNOUNCE_INSUFFICIENTFERTILIZER = "I think it wants something. Hey! What do you want?",
ANNOUNCE_INV_FULL = "What am I, a pack animal?",
ANNOUNCE_KNOCKEDOUT = "Woah. What happened?",
ANNOUNCE_LIGHTNING_DAMAGE_AVOIDED = "Not today, nature!",
ANNOUNCE_LOWRESEARCH = "Radical! Knowledge!",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Uhhhm. Where am I?",
ANNOUNCE_MAPWRAP_RETURN = "The fog is clearing!",
ANNOUNCE_MAPWRAP_WARN = "Looks pretty foggy over there.",
ANNOUNCE_MESSAGEBOTTLE =
{
	"Reading's boring anyway.",
},
ANNOUNCE_MORETREASURE = "My luck continues!",
ANNOUNCE_MOSQUITOS = "Rude! Make your own blood!",
ANNOUNCE_NODANGERSIESTA = "Sleeping right now seems kinda dangerous.",
ANNOUNCE_NODANGERSLEEP = "Sleeping right now seems kinda dangerous.",
ANNOUNCE_NODAYSLEEP = "You know I'm always down for a nap but... not right now.",
ANNOUNCE_NODAYSLEEP_CAVE = "Are you nuts? I'm not sleepin' in a cave!",
ANNOUNCE_NOHUNGERSIESTA = "Foooooooooooooood...",
ANNOUNCE_NOHUNGERSLEEP = "Fooooooooooooooood...",
ANNOUNCE_NONIGHTSIESTA = "That would be improper napping form.",
ANNOUNCE_NONIGHTSIESTA_CAVE = "It's a bit too cavey around here for a siesta.",
ANNOUNCE_NOSLEEPONFIRE = "Uhh... That's on fire right now.",
ANNOUNCE_NO_TRAP = "Worst trap ever.",
ANNOUNCE_OTHER_WORLD_TREASURE = "I don't think this is anywhere around here.",
ANNOUNCE_OTHER_WORLD_PLANT = "Can't do that, the poor thing wouldn't grow here.",
ANNOUNCE_PECKED = "Hey! Stop that!",
ANNOUNCE_QUAKE = "The ground is shaking.",
ANNOUNCE_RESEARCH = "I feel smarter.",
ANNOUNCE_SHARX = "Something smells sharky.",
ANNOUNCE_SHELTER = "Ah. I'm in my element when I'm out of the elements.",
ANNOUNCE_THORNS = "Ow! It bit me!",
ANNOUNCE_TOOL_SLIP = "You're not making this any more fun!",
ANNOUNCE_TORCH_OUT = "WHERE DID MY LIGHT GO?!",
ANNOUNCE_TRAP_WENT_OFF = "My bad.",
ANNOUNCE_TRAWL_FULL = "My work has paid off!",
ANNOUNCE_TREASURE = "Woohoo! Treasure!",
ANNOUNCE_UNIMPLEMENTED = "Looks kinda half-baked.",
ANNOUNCE_VOLCANO_ERUPT = "The volcano speaks!",
ANNOUNCE_WAVE_BOOST = "Surf's up!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Whale, whale, whale!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "It must've dove deeper.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "The waters are way too rough.",
ANNOUNCE_WORMHOLE = "...Where am I?",
ANNOUNCE_DAMP = "A little water never hurt no one.",
ANNOUNCE_WET = "I'll need to towel off soon.",
ANNOUNCE_WETTER = "My clothes are all soggy... Haha.",
ANNOUNCE_SOAKED = "I am thoroughly soaked.",
BATTLECRY =
{
	GENERIC = "I'M A FORCE TO BE RECKONED WITH!",
	PIG = "DESTRUCTION!",
	PREY = "YOU WILL NOT WIN!",
	SPIDER = "YOU WILL REGRET THIS DAY!",
	SPIDER_WARRIOR = "I WILL END YOU!",
},
COMBAT_QUIT =
{
	GENERIC = "Oh man, you shoulda seen the look on your face.",
	PIG = "Haha, gotcha.",
	PREY = "Nah, I was just messin' with you.",
	SPIDER = "Pssh, nah, we're good.",
	SPIDER_WARRIOR = "Haha, nah. We're cool.",
},
DESCRIBE =
{

	SEAWEED_STALK = "Now I can plant it where I want.", --copied from the Wikia because I couldn't find it in the game files. -M

	BERRYBUSH =
	{
		GENERIC = "How lush!",
		PICKED = "Thanks for the snack, dude.",
		WITHERED = "I can nurse it back to health.",
	},
	INVENTORYGRAVE = "Surf that big wave in the sky, dude.",
	INVENTORYMOUND = "Surf that big wave in the sky, dude.",
	ACCOMPLISHMENT_SHRINE = "Well, that looks like a lot of busywork.",
	ACORN = "Come on out, nature!",
	ACORN_SAPLING = "Grow strong little dude.",
	ACORN_COOKED = "Sorry, tree baby.",
	ADVENTURE_PORTAL = "Why would I want to go in there?",
	AERODYNAMICHAT = "Aerodynamic. Choka.",
	AMULET = "Looks great, feels great.", --Red
	ANCIENT_ALTAR = "This is giving me major jeepers.",
	ANCIENT_ALTAR_BROKEN = "Maybe it still works?",
	ANCIENT_STATUE = "How depressing.",
	ANIMAL_TRACK = "Friends are near!",
	ANTIVENOM = "This'll make the sickness go away.",
	ARMORDRAGONFLY = "This armor is so hot right now.",
	ARMORGRASS = "Doesn't seem all that sturdy.",
	ARMORLIMESTONE = "Seems maybe, like, *too* sturdy.",
	ARMORMARBLE = "That's just overkill.",
	ARMOROBSIDIAN = "It kinda pokes my butt.",
	ARMORRUINS = "It's so fancy!",
	ARMORSEASHELL = "The ocean will protect me!",
	ARMORSLURPER = "So efficient!",
	ARMORSNURTLESHELL = "Protection from nature, by nature.",
	ARMORWOOD = "I hope the attacker doesn't have an axe.",
	ARMOR_LIFEJACKET = "In case the waves get all gnar'.",
	ARMOR_SANITY = "Eyuk! It makes my skin crawl.",
	ARMOR_SNAKESKIN = "I guess snakes aren't so bad.",
	ARMOR_WINDBREAKER = "The wind slips right around me!",
	BOAT_ARMOURED = "What a clunky looking board.",
	ASH =
	{
		GENERIC = "I must've missed the party.",
		REMAINS_EYE_BONE = "Huh. I guess it didn't like traveling?",
		REMAINS_GLOMMERFLOWER = "Huh. I guess it didn't like traveling?",
		REMAINS_THINGIE = "Huh. I guess it didn't like traveling?",
	},
	AXE = "I could cut trees with this... But I'd rather not.",
	BABYBEEFALO = "Growing up is a trap... don't do it!",
	BABYOX = "Stay young forever!",
	BACKPACK = "To haul my stuff around.",
	BACONEGGS = "Turn that frown upside down!",
	BALLPHIN = "My surfing buddies!",
	BAMBOO = "This looks pretty float-atious.",
	BAMBOOTREE =
	{
		BURNT = "I think it's dead.",
		CHOPPED = "Hurry up and grow already!",
		GENERIC = "I guess I could cut that down.",
	},
	BANDAGE = "I can patch myself up with this!",
	BAT = "Go flap somewhere else!",
	BATBAT = "Maybe I could bat some bats with this.",
	BATWING = "A couple more of these and I'll be flyin'!",
	BATWING_COOKED = "Looks a bit leathery.",
	BEARDHAIR = "Someone is probably missing these.",
	BEARGER = "Things don't have to get hairy, dude.",
	BEARGERVEST = "Made of real bearger chest!",
	BEARGER_FUR = "Now I can hibernate in comfort.",
	BANANAPOP = "The best way to keep cool. And very little preparation!",
	BISQUE = "This actually might've been worth the effort!",
	CEVICHE = "All I need is sunshine and some good food.",
	SEAFOODGUMBO = "My favorite!",
	SURFNTURF = "Can I eat it on my surfboard?",
	SHARKFINSOUP = "I could shove my face right in this.",
	LOBSTERDINNER = "Hey wobster, what's eatin' you? Oh, me!",
	LOBSTERBISQUE = "Looks fancy. And delicious.",
	JELLYOPOP = "Is this junk food or health food? I can't tell.",
	BEDROLL_FURRY = "For a more comfortable nap time!",
	BEDROLL_STRAW = "For nap time!",
	BEE =
	{
		GENERIC = "Well \"bzz bzz\" to you, too!",
		HELD = "You're probably safer here than out there, honestly.",
	},
	BEEBOX =
	{
		BURNT = "Maybe the bees did some redecorating?",
		FULLHONEY = "It's overflowing with sweet, sweet honey!",
		GENERIC = "That box has bees in and around it.",
		NOHONEY = "Would it be hypocritical to tell the bees to get to work?",
		SOMEHONEY = "Looks like the bees made me some honey! Thanks!",
	},
	BEEFALO =
	{
		FOLLOWER = "Aww, he loves me!",
		GENERIC = "I love these things!",
		NAKED = "Beautiful beach bod, bud.",
		SLEEPING = "Blissfully unaware of the terrors of night.",
	},
	BEEFALOHAT = "It smells like beefalo.",
	BEEFALOWOOL = "It looks more like hair to me.",
	BEEHAT = "Stops the bee kisses.",
	BEEHIVE = "The bees must sleep in there.",
	BEEMINE = "It's like a confetti bomb. But bees.",
	BELL = "Summons the big stomper.",
	BELL_BLUEPRINT = "A recipe for disaster.",
	BERMUDATRIANGLE = "Take me to a new surf spot!",
	BERRIES = "These are the edible kind, right?",
	BERRIES_COOKED = "They're all sticky now. Heh heh, gross.",
	BERRYBUSH =
	{
		BARREN = "It needs a little love.",
		GENERIC = "Awesome! That bush has berries!",
		PICKED = "It's kinda just a regular bush now.",
		WITHERED = "That bush isn't looking very good.",
	},
	BIOLUMINESCENCE = "Pretty glowy goop!",
	BIRDCAGE =
	{
		GENERIC = "I need to get a birdy buddy.",
		OCCUPIED = "I hope my birdy buddy is happy.",
		SLEEPING = "My birdy buddy's super sleepy.",
		HUNGRY = "My birdy buddy's belly's empty!",
		STARVING = "My birdy buddy's all bones!",
		DEAD = "My birdy buddy breathed his last...",
		SKELETON = "I have a lot of regrets in life.",
	},
	BIRDTRAP = "I can catch myself a birdy buddy with this.",
	BIRD_EGG = "There is a tiny birdy buddy in here!",
	BIRD_EGG_COOKED = "...I'm sorry, birdy buddy.",
	BISHOP = "Don't get any bright ideas.",
	BLUBBER = "If I had enough of this I could surf in any weather!",
	BLUBBERSUIT = "Gross, but effective.",
	BOARDS = "Not much surf in these boards.",
	BOATCANNON = "Can't we find a peaceful solution?",
	BOATREPAIRKIT = "Surfboard maintenance is essential!",
	BOAT_LANTERN = "Night-surfing. I love it!",
	BOAT_TORCH = "Night-surfing. I love it!",
	BOOMERANG = "They say if you love something, you should let it go.",
	BOTTLELANTERN = "This will keep the dark away.",
	BURIEDTREASURE = "Hope this is worth the work.",
	BUSHHAT = "This makes me feel at one with nature.",
	BUSH_VINE =
	{
		BURNT = "Not much use to anyone now.",
		CHOPPED = "Those vines are mine.",
		GENERIC = "Looks a little tangled.",
	},
	BUTTER = "Haha. Slippery!",
	BUTTERFLY =
	{
		GENERIC = "What a pretty pattern!",
		HELD = "You're my pretty pocket pal.",
	},
	BUTTERFLYMUFFIN = "What a pretty muffin!",
	BUTTERFLYWINGS = "I feel pretty bad about that.",
	CAMPFIRE =
	{
		EMBERS = "I need fuel for my fire!",
		GENERIC = "My cozy campfire!",
		HIGH = "Uhh... I hope this doesn't spread.",
		LOW = "I think it needs some energy!",
		NORMAL = "My cozy campfire!",
		OUT = "Well, that's that.",
	},
	CANE = "I cane, I saw.",
	CAPTAINHAT = "If only the boss could see me now.",
	BOAT_CARGO = "This surfboard sure has a lot of pockets.",
	CARROT = "They must've named these after oranges.",
	CARROT_COOKED = "Smells good!",
	CARROT_PLANTED = "Ooo, that's a good find!",
	CARROT_SEEDS = "I could grow a carrot with these.",
	CAVE_BANANA = "Potassium!",
	CAVE_BANANA_COOKED = "Cooked potassium!",
	CHARCOAL = "The remains of something burnt.",
	CHESSJUNK1 = "Lots of potential here!",
	CHESSJUNK2 = "I hope someone makes something out of that.",
	CHESSJUNK3 = "Look at all those parts.",
	CHESTER = "The best kind of friend... one who works for free.",
	CHESTER_EYEBONE =
	{
		GENERIC = "I get the feeling I'm being watched.",
		WAITING = "Nap time!",
	},
	CHIMINEA = "Stay safe from the howling winds, precious light!",
	SAIL_CLOTH = "I'll flow with the wind.",
	COCONADE =
	{
		BURNING = "This will make a big splash!",
		GENERIC = "Just holding it makes me feel powerful.",
	},
	COCONUT = "Imagine getting conked on the head by one of these!",
	COCONUT_SAPLING = "Hey little tree dude.",
	COCONUT_COOKED = "Hmmm. Yep. It's cooked now.",
	COFFEE = "Smells amazing!",
	COFFEEBEANS = "Come to mama!",
	COFFEEBEANS_COOKED = "Peppy!",
	COFFEEBUSH =
	 {
		BARREN = "Nooo, I need my java!",
		GENERIC = "Java!",
		PICKED = "Hurry up and grow back!",
		WITHERED = "If it grew on the volcano...",
	 },
	COLDFIRE =
	{
		EMBERS = "Don't leave me, light!",
		GENERIC = "I'm not really sure how this thing works.",
		HIGH = "Chillin'.",
		LOW = "That fire is slacking off.",
		NORMAL = "The fire is doing it's job.",
		OUT = "The fire is taking a break.",
	},
	COLDFIREPIT =
	{
		EMBERS = "Don't leave me, light!",
		GENERIC = "I'm not really sure how this thing works.",
		HIGH = "Chillin'.",
		LOW = "That fire is slacking off.",
		NORMAL = "The fire is doing it's job.",
		OUT = "The fire is taking a break.",
	},
	COMPASS =
	{
		GENERIC = "How do I use this thing again?",
		N = "North-ish?",
		S = "South-ish?",
		E = "East-ish?",
		W = "West-ish?",
		NE = "Northeast-ish?",
		SE = "Southeast-ish?",
		NW = "Northwest-ish?",
		SW = "Southwest-ish?",
	},
	COOKEDMEAT = "Surfing fuel!",
	COOKEDMONSTERMEAT = "This still looks awful.",
	COOKEDSMALLMEAT = "A tasty morsel.",
	COOKPOT =
	{
		BURNT = "The food might taste a bit burnt.",
		COOKING_LONG = "If I watch it it'll never boil.",
		COOKING_SHORT = "Food incoming!",
		DONE = "I cooked something. Yum!",
		EMPTY = "My kind of cooking... Just dump everything in and wait!",
	},
	CORAL = "I need a fish tank to put this in!",
	ROCK_CORAL = "What a pretty coral reef.",
	CORAL_BRAIN = "I get an uneasy feeling of despair near this.",
	CORAL_BRAIN_ROCK = "That is an impressive piece of coral.",
	CORN = "Aw, shucks.",
	CORN_COOKED = "I'll need a toothpick soon.",
	CORN_SEEDS = "I could grow some corn of my own with these.",
	CRAB =
	{
		GENERIC = "If I was on my surfboard I could catch you.",
		HIDDEN = "He's taking a break from running.",
	},
	CRABHOLE = "A beachfront home. Nice.",
	CUTGRASS = "It makes a swishing sound when I walk.",
	SWORDFISH_DEAD = "Woah, that fish is HUGE!",
	DEPLETED_GRASS =
	{
		GENERIC = "That grass looks pretty dead.",
	},
	DEVTOOL = "Useful!",
	DIRTPILE = "Well, would you look at that. A pile of dirt.",
	DIVININGROD =
	{
		COLD = "This rod isn't doing all that much.",
		GENERIC = "What a silly looking device.",
		HOT = "This rod is going crazy!",
		WARM = "I think the rod is trying to tell me something!",
		WARMER = "Woah, the rod is really going now.",
	},
	DOUBLE_UMBRELLAHAT = "This should keep me at least twice as dry.",
	DRAGONFRUIT_SEEDS = "I could grow a dragonfruit with these.",
	DRAGONPIE = "Delicious pie!",
	DUBLOON = "It's my lucky day!",
	DUG_BAMBOOTREE = "Planting this sounds like hard work.",
	DUG_BERRYBUSH = "Planting this sounds like hard work.",
	DUG_COFFEEBUSH = "Planting this sounds like hard work.",
	DUG_ELEPHANTCACTUS = "Planting this sounds like hard work.",
	DUG_GRASS = "Planting this sounds like hard work.",
	DUG_MARSH_BUSH = "Planting this sounds like hard work.",
	DUG_SAPLING = "Planting this sounds like hard work.",
	DURIAN = "Looks pretty difficult to eat.",
	DURIAN_COOKED = "Woah! That smells awful!",
	DURIAN_SEEDS = "I could grow a stink-fruit with these.",
	EARMUFFSHAT = "Keeps my ears fluffy and warm.",
	EARRING = "I hope someone didn't lose this...",
	EGGPLANT_SEEDS = "I could grow an eggplant with these.",
	ELEPHANTCACTUS = "Looking sharp!",
	ELEPHANTCACTUS_ACTIVE = "Ouch!",
	ELEPHANTCACTUS_STUMP = "It's taking a nap.",

	-----------------------------------------------------

	EVERGREEN =
	{
		BURNING = "That's not cool.",
		BURNT = "I know the feeling.",
		CHOPPED = "Sliced and diced.",
		GENERIC = "Reminds me of winter. Yuck.",
	},
	EVERGREEN_SPARSE =
	{
		BURNING = "That's not cool.",
		BURNT = "He's a burnout.",
		CHOPPED = "Cut down in its prime.",
		GENERIC = "Looks like the diet version.",
	},
	EYEBRELLAHAT = "My third eye will protect me.",
	EYEPLANT = "Made you look!",
	EYETURRET = "It's looking out for me.",
	EYETURRET_ITEM = "It's got my back.",
	FABRIC = "Where did my sticks go? I've been bamboozled!",
	FARMPLOT =
	{
		BURNT = "It's toast!",
		GENERIC = "Looks like manual labor to me.",
		GROWING = "I hope it's organic.", --Earth is having a ground-child
		NEEDSFERTILIZER = "That shrub could use some grub.",
	},
	FEATHERFAN = "An artificial ocean breeze.",
	FEATHERHAT = "I'm at one with my feathered friends.",
	SAIL_FEATHER = "For smooth and swift sailing!",
	FEATHER_CROW = "A real softy.",
	FEATHER_ROBIN = "I'm tickled by the color of this.",
	FEATHER_ROBIN_WINTER = "A portable reminder of the beauty of nature.",
	FEM_PUPPET = "Bummer.",
	FERTILIZER = "Ground food.",
	FIREFLIES =
	{
		GENERIC = "My kind of insects.",
		HELD = "My glowy little pocket pals.",
	},
	FIREHOUND = "This one seems angrier somehow.",
	FIREPIT =
	{
		EMBERS = "This fire is tired.",
		GENERIC = "Oh, sweet enemy of darkness.",
		HIGH = "Heh, woah! Hot stuff!",
		LOW = "It's barely doing its job.",
		NORMAL = "Could be better... could be worse.",
		OUT = "It's taking a break.",
	},
	FIRESTAFF = "It's a hot commodity.",
	FIRESUPPRESSOR =
	{
		LOWFUEL = "It needs some juice.",
		OFF = "It's out cold.",
		ON = "Fling it on!",
	},
	FISHINGROD = "Have rod, will travel.",
	FISHINHOLE = "Looks like a good place to get lunch.",
	FISHSTICKS = "Looks like these fish are gonna be stickin' around.",
	FISHTACOS = "All times are taco times.",
	FISH_COOKED = "From my own personal recipe.",
	SOLOFISH_DEAD = "Sorry, lil dude.",
	FISH_MED_COOKED = "Is it snacktime?",
	FISH_MED = "Needs more fire.",
	FISH_SMALL = "Small fish from a big pond.",
	FISH_SMALL_COOKED = "Is it snacktime?",
	FLAMEGEYSER = "It's got a hot temper.",
	FLINT = "This rock doesn't roll.",
	FLOTSAM = "Maybe I can fish it out.",
	FLOWER = "I'm very picky when it comes to these. Heh heh heh.",
	FLOWERHAT = "That's a happy looking headpiece!",
	FLOWERSALAD = "Now that's what I call health food.",
	FLOWER_EVIL = "Flowers shouldn't be that scary.",
	FLUP = "It's rude to stare, dude!",
	FOLIAGE = "It's all natural.",
	FOOTBALLHAT = "I feel like I could tackle anything.",
	FRUITMEDLEY = "A sweet treat!",
	GASHAT = "Protection from stink.",
	GEARS = "Looks like robot guts.",
	GOLDENAXE = "That's one treasury tool.",
	GOLDENMACHETE = "I can hack in style.",
	GOLDENPICKAXE = "I picked a good one.",
	GOLDENPITCHFORK = "It makes work feel shiny!",
	GOLDENSHOVEL = "I'm digging this fancy shovel.",
	GOLDNUGGET = "It's shiny and useful!",
	GRASS =
	{
		BARREN = "It needs help to grow.",
		BURNING = "That won't last.",
		GENERIC = "For all your grassy needs.",
		PICKED = "It will be back.",
		WITHERED = "It looks tired.",
	},
	GRASS_UMBRELLA = "This should keep me almost dry.",
	GREEN_CAP = "Looks sort of tasty.",
	GREEN_CAP_COOKED = "Fried fungus.",
	GREEN_MUSHROOM =
	{
		GENERIC = "Funky fungi.",
		INGROUND = "It's taking a nap.",
		PICKED = "Maybe it's thirsty.",
	},
	GUACAMOLE = "A total snack attack.",
	GUNPOWDER = "It goes boom.",
	HAIL_ICE = "From the freezer in the sky.",
	HAMBAT = "I can fight food with food.",
	HAMMER = "Smashing stuff *sounds* like work, but it's pretty fun.",
	HAWAIIANSHIRT = "This shirt is so me.",
	HEALINGSALVE = "It helps me live a little.",
	HEATROCK =
	{
		COLD = "It's icy!",
		FROZEN = "Refreshing.",
		GENERIC = "It's rock temperature.",
		HOT = "It's warm and glowing.",
		WARM = "It's a little toasty.",
	},
	HOMESIGN =
	{
		BURNT = "I know the feeling.",
		GENERIC = "Hang ten!",
	},
	HONEY = "Sticky, sweet and good to eat!",
	HOUND = "This dog is a real drag!",
	ICEMAKER =
	{
		HIGH = "Super chillin'.",
		LOW = "Not so chillin'.",
		NORMAL = "Just chillin'.",
		OUT = "Illin'.",
		VERYLOW = "Little bit of illin'.",
	},
	ICEPACK = "Keeps my snacks as cool as I am.",
	ICESTAFF = "Too cold to hold.",
	INSANITYROCK =
	{
		ACTIVE = "Ouch. My thoughts are hurting.",
		INACTIVE = "That's one dark tower.",
	},
	JAMMYPRESERVES = "Preserve those jams.",
	JELLYFISH = "Don't step on one in bare feet!!",
	JELLYFISH_COOKED = "I hope it doesn't sting on the way down.",
	JELLYFISH_DEAD = "It might still sting me.",
	JELLYFISH_PLANTED = "I hate these things.",
	JELLYJERKY = "Looks extra chewy.",
	JUNGLETREE =
	{
		BURNING = "That's not cool.",
		BURNT = "I know the feeling.",
		CHOPPED = "Sliced and diced.",
		GENERIC = "It's like nature's canopy.",
	},
	JUNGLETREESEED = "A tree yee shall be.",
	JUNGLETREESEED_SAPLING = "Ugh, planting that got me all sweaty. Gross.",
	KABOBS = "It's like a meatsicle!",
	KILLERBEE =
	{
		GENERIC = "It's badly BEEhaved.",
		HELD = "This bee needs to relax.",
	},
	KNIGHTBOAT = "What a horrible knight to have a curse.",
	KRAMPUS = "Stealing isn't cool!",
	KRAMPUS_SACK = "A bag of stolen goods.",
	LANTERN = "It really lightens the mood.",
	LAVAPOOL = "It's like a gooey campfire!",
	LAVASPIT =
	{
		COOL = "All dried up.",
		HOT = "Looks a little spicy.",
	},
	LIGHTNING_ROD =
	{
		CHARGED = "It's fully energized!",
		GENERIC = "It's powered by electricity.",
	},
	LIMESTONENUGGET = "That's some tough stuff.",
	ROCK_LIMPET =
	{
		GENERIC = "Just look at all these Barneys.",
		PICKED = "Nothing to eat here.",
	},
	LIMPETS = "They're free from the hustle and bustle of daily life.",
	LIMPETS_COOKED = "Still a bit slimy.",
	LIVINGJUNGLETREE = "That tree would make a great board.",
	LEIF_PALM = "Wanna be a board?!",
	LIVINGLOG = "It looks bummed.",
	LOBSTER = "Yummy sea bug.",
	LOBSTERHOLE = "I can wait as long as it takes.",
	LOBSTER_DEAD = "Soon to be good eats.",
	LOBSTER_DEAD_COOKED = "Now that's good eats!",
	LOG =
	{
		BURNING = "Waste of a good board.",
		GENERIC = "There's a board in there.",
	},
	BOAT_LOGRAFT = "Seriously?",
	LUGGAGECHEST = "This trunk is a little steamy.",
	LUREPLANT = "It's so attractive.",
	LUREPLANTBULB = "Get meat, the easy way.",
	MACHETE = "What a hack job.",
	MAGMAROCK = "It's warm to the touch.",
	MAGMAROCK_GOLD = "It's warm to the touch.",
	MALE_PUPPET = "Sorry dude.",
	MANDRAKE =
	{
		DEAD = "I was rooting for it.",
		GENERIC = "A mystical plant.",
		PICKED = "You're messing up my chill vibes, dude.",
	},
	MANDRAKESOUP = "Mystical soup.",
	MANDRAKE_COOKED = "Not as mystical as I thought.",
	MANGROVETREE = "This tree really likes water.",
	MANGROVETREE_BURNT = "How?",
	MARSH_BUSH =
	{
		BURNING = "The spikes are burning. Good.",
		GENERIC = "I don't need spikes.",
		PICKED = "Yeoch!",
	},
	MARSH_PLANT = "Planty.",
	MARSH_PLANT_TROPICAL = "Tropical planty.",
	MARSH_TREE =
	{
		BURNING = "I've never seen such a spiky fire.",
		BURNT = "Still spiky.",
		CHOPPED = "Not so spiky now.",
		GENERIC = "Me and spikes don't get along.",
	},
	MEAT = "Five second rule!",
	MEATBALLS = "Saucy.",
	MEATRACK =
	{
		BURNT = "Your days of jerkying are over.",
		DONE = "That's some good looking jerky.",
		DRYING = "See you later, water.",
		DRYINGINRAIN = "Water doesn't make things dry.",
		GENERIC = "This rack could use some meat.",
	},
	MEAT_DRIED = "Boy, this meat is jerky.",
	MERM = "Go dunk your head, guy.",
	MERMFISHER = "You don't mind working for a living.",
	MERMHEAD =
	{
		BURNT = "I like it better burnt.",
		GENERIC = "As if the pigs didn't smell bad enough.",
	},
	MERMHOUSE =
	{
		BURNT = "This house has char-acter.",
		GENERIC = "I could have sworn this was an outhouse.",
	},
	MERMHOUSE_FISHER = "Where the workers take five.",
	MESSAGEBOTTLE = "There must be a better way to send a message...",
	MESSAGEBOTTLEEMPTY = "I could whistle a tune with you.",
	MINERHAT = "Another job I hope to never do.",
	MONSTERLASAGNA = "Still smells monstery...",
	MONSTERMEAT = "Am I really hungry enough?",
	MONSTERMEAT_DRIED = "Tough to chew AND crazy-making!",
	MOSQUITOSACK_YELLOW = "Ewwww.",
	MOSQUITO_POISON = "Get lost!",
	MULTITOOL_AXE_PICKAXE = "I'm picky when it comes to tools.",
	MUSHTREE_MEDIUM = "Medium mushness.",
	MUSHTREE_SMALL = "Grow tree! Mush! Mush!",
	MUSHTREE_TALL = "That's a whole lot of mushtree!",
	MUSSEL = "I could eat a hundred of these.",
	MUSSEL_COOKED = "Needs shallots.",
	MUSSEL_FARM =
	{
		GENERIC = "There's food hanging out down there.",
		STICKPLANTED = "That's it mussels, do some pull ups.",
	},
	MUSSEL_STICK = "The mussels glop to it.",
	NIGHTLIGHT = "Lights the night with 'mares.",
	NIGHTMAREFUEL = "The stuff of nightmares.",
	NIGHTSWORD = "Wield the dark.",
	NITRE = "Not just any old dumb rock.",
	OBSIDIAN = "Ouch, you're hot!",
	OBSIDIANAXE = "I gotta work to make you work...",
	OBSIDIANCOCONADE = "Beware of the boom!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "This fire is tired.",
		GENERIC = "Oh, sweet enemy of darkness.",
		HIGH = "So much bright!",
		LOW = "It's barely doing its job.",
		NORMAL = "This fire keeps on lickin' and tickin'.",
		OUT = "It's taking a break.",
	},
	OBSIDIANMACHETE = "This blade's as hot as it is cool.",
	OBSIDIANSPEARGUN = "Oh, I like you.",
	OBSIDIAN_WORKBENCH = "For playing with fire.",
	OCTOPUSCHEST = "Booty-ya!",
	OCTOPUSKING = "You seem chill.",
	ONEMANBAND = "Let's get this jam sesh rollin'!",
	OX = "You smell like wet hair.",
	PACKIM = "You got a big mouth, fella.",
	PACKIM_FISHBONE = "I'll hold onto this.",
	PALMLEAF = "Would make a radical skirt.",
	PALMLEAF_HUT = "It's like indoors, but outdoors.",
	PALMLEAF_UMBRELLA = "My own pint-sized palm tree.",
	PALMTREE =
	{
		BURNING = "That's not cool.",
		BURNT = "I know the feeling.",
		CHOPPED = "Sliced and diced.",
		GENERIC = "Cool hair, tree.",
	},
	PANFLUTE = "Plays hypnotic tunes.",
	PAPYRUS = "Bet this burns good.",
	PARROT = "Will you ever stop squawking?",
	PEACOCK = "A tropical turkey!",
	PEROGIES = "Comfort food!",
	PETALS = "Flowers totally get me.",
	PETALS_EVIL = "These smell like bad karma.",
	PICKAXE = "My back hurts just looking at it.",
	PIGSKIN = "Not by the hair of his rumpy rump rump.",
	PIRATEHAT = "High fashion for the high seas.",
	PIRATEPACK = "Booty in the back.",
	PIRATIHATITATOR =
	{
		BURNT = "Fire always wins.",
		GENERIC = "It holds many sea-crets.",
	},
	PITCHFORK = "Looks like some kind of trident.",
	PLANTMEAT = "It's got all two food groups.",
	PLANTMEAT_COOKED = "Hey, you're not a REAL steak!",
	PLANT_NORMAL =
	{
		GENERIC = "Farming is so hard!",
		GROWING = "It's still just a child.",
		READY = "Can I get to the eating part now?",
		WITHERED = "Something made it all... gross.",
	},
	POISONHOLE = "Gag!",
	POMEGRANATE = "Seedy.",
	POMEGRANATE_COOKED = "Hot'n'juicy.",
	POMEGRANATE_SEEDS = "Ugh, these should go in the ground I guess...",
	POOP = "Surf sewage!",
	PORTAL_SHIPWRECKED = "I wonder what this does...",
	POWCAKE = "I'll eat whatever.",
	PRIMEAPE = "This guy's a major beach leech.",
	PRIMEAPEBARREL = "Gnarly domicile, man...",
	PURPLEAMULET = "This thing drives me nuts!",
	PURPLEGEM = "Shiny!",
	---------------------------------------------------------

	BOAT_RAFT = "Worst. Surfboard. Ever.",
	RAINOMETER =
	{
		BURNT = "Guess you didn't see that coming.",
		GENERIC = "Tells me when to paddle in.",
	},
	RATATOUILLE = "I'd rather get curvy than scurvy.",
	RAZOR = "You're not coming near my legs!",
	BARREL_GUNPOWDER = "Hmm, was I in charge of keeping these stowed?",
	REDGEM = "Booty-ful!",
	RED_CAP_COOKED = "I'm not THAT hungry.",
	REEDS =
	{
		BURNING = "Whoa. Heavy.",
		GENERIC = "More grass. Righteous.",
		PICKED = "Catch you on the flip flop.",
	},
	REFLECTIVEVEST = "Even sun worshipers need a break.",
	RESEARCHLAB =
	{
		BURNT = "Ugh, do I have to build you all over again now?",
		GENERIC = "I wish you were a do-all-the-work-for-me machine.",
	},
	RESEARCHLAB2 =
	{
		BURNT = "Ugh, do I have to build you all over again now?",
		GENERIC = "I still feel like I'm doing most of the work here.",
	},
	RESEARCHLAB3 =
	{
		BURNT = "Couldn't you have manipulated yourself into not getting burnt?",
		GENERIC = "Manipulating shadows sounds tough, glad I don't have to.",
	},
	RESURRECTIONSTATUE =
	{
		BURNT = "Up in smoke...",
		GENERIC = "You better work.",
	},
	RESURRECTIONSTONE = "Hope I never need you, weird wood dude...",
	ROCK = "I like you much better on land.",
	ROCKS = "Not flat. Won't skip.",
	ROCK_LIGHT =
	{
		GENERIC = "Gnarly!",
		LOW = "The lava is cooling.",
		NORMAL = "Gnarly!",
		OUT = "This fire is cooked.",
	},
	ROPE = "Good for a lot of boring stuff.",
	ROTTENEGG = "Smells like a ship cabin.",
	BOAT_ROW = "Awww, rowing? Ugh.",
	RUINSHAT = "Fit for the queen boss!",
	RUINS_BAT = "Know a few scallywags I'd like to introduce this to.",
	SAIL_PALMLEAF = "A blow boater's best friend.",
	SAND = "I like it between my toes and nowhere else.",
	SANDBAG = "Heavy lifting...",
	SANDBAGSMALL = "Heavy lifting...",
	SANDBAG_ITEM = "Heavy lifting...",
	SANDDUNE = "If this was bigger I could sand board.",
	SANDCASTLE =
	{
		GENERIC = "I feel like a kid again!",
		SAND = "I like it between my toes and nowhere else.",
	},
	SAPLING =
	{
		BURNING = "Not much to burn.",
		GENERIC = "Board material?",
		PICKED = "Looks noodled.",
		WITHERED = "Looks like I feel.",
	},
	SEAGULL = "Poop hawk!",
	SEAGULL_WATER = "Ewww, its nethers are touching my waves...",
	SEASACK = "Squishy.",
	SEASHELL = "No two are alike. Well, except those two. And, uh... that one.",
	SEASHELL_BEACHED = "A gift from the sea.",
	SEATRAP = "Wobster goes in. Dinner comes out.",
	SEAWEED = "Name says it all.",
	SEAWEED_COOKED = "A little better I guess...",
	SEAWEED_DRIED = "It's better with some crunch.",
	SEAWEED_PLANTED = "Gets caught on my board.",
	SEEDS = "Ugh, do I have to like, plant these?",
	SEEDS_COOKED = "They get stuck in my teeth.",
	SEWING_KIT = "I'm not really the \"sewing\" kind.",
	SHARKITTEN = "You're pretty cute for my worst nightmare.",
	SHARK_FIN = "The only kind of fin I wanna see.",
	SHARK_GILLS = "It won't be needing these.",
	SHARK_TEETHHAT = "Feels wrong having these on my head...",
	SHARX = "Shoo! Shoo! Shoo!",
	SHOVEL = "Ugh, digging...",
	SIESTAHUT =
	{
		BURNT = "Rest in peace.",
		GENERIC = "I could use a snooze.",
	},
	SILK = "Spider gunk...",
	SKELETON = "Surfing the beyond...",
	SKELETON_PLAYER = "Surfing the beyond...",
	SKULLCHEST = "This won't Kramp my style.",
	SLOTMACHINE = "Should I push my luck?",
	SMALLBIRD =
	{
		GENERIC = "Eye see you.",
		HUNGRY = "Hope your stomach is as big as your eye.",
		STARVING = "Blink twice if you're hungry.",
	},
	SMALLMEAT = "Mmmmmeat!",
	SMALLMEAT_DRIED = "A treat that travels well.",
	SNAKE = "I hope you can't swim.",
	SNAKEOIL = "I wasn't born yesterday.",
	SNAKESKIN = "I could make a scaly bikini out of this!",
	SNAKESKINHAT = "Raindrops keep falling on my hat.",
	SNAKE_POISON = "My buddy has a bodacious bite!",
	SOLOFISH = "Bring me my slippers.",
	SPEAR = "For stabbing problems.",
	SPEARGUN = "Point. Shoot.",
	SPEARGUN_POISON = "Highly contagious.",
	SPEAR_OBSIDIAN = "Ready. Aim. Fire-y.",
	SPEAR_POISON = "Want to take a sick day?",
	SPIDER =
	{
		DEAD = "I wonder if it will rain now?",
		GENERIC = "Crawly creep.",
		SLEEPING = "Aww, it's so peaceful and disgusting.",
	},
	SPIDERDEN = "They don't like trespassers.",
	SPIDEREGGSACK = "Starts a spider farm.",
	SPIDERGLAND = "Why does health food taste so bad?",
	SPIDERHAT = "Ha! I'm your boss now, spiders!",
	SPIDERQUEEN = "I don't bow to royalty.",
	SPIDER_WARRIOR =
	{
		DEAD = "Now I can rest in peace.",
		GENERIC = "Back off, you're germy!",
		SLEEPING = "Hope you're having a nightmare.",
	},
	SPOILED_FISH = "Gag material!",
	SPOILED_FOOD = "What a waste.",
	STINGER = "Glad I don't have to pick this out of my skin.",
	STRAWHAT = "Keeps my face from getting freckly.",
	STUFFEDEGGPLANT = "Health grub.",
	STUNGRAY = "I thought shark farts were bad...",
	SUNKBOAT = "Surfboards don't sink!",
	SUNKEN_BOAT =
	{
		ABANDONED = "Surfboards don't sink!",
		GENERIC = "Surfboards don't sink!",
	},
	SUPERTELESCOPE = "I can super sea!!",
	SURFBOARD = "My love for you is deeper than the ocean.",
	SURFBOARD_ITEM = "My pride and joy!",
	SWEET_POTATO = "Dessert!",
	SWEET_POTATO_COOKED = "Hmm, it's not that sweet actually...",
	SWEET_POTATO_PLANTED = "Dessert grows in the ground!",
	SWEET_POTATO_SEEDS = "Ugh, I guess I should plant these?",
	SWORDFISH = "I've resolved to be more of a lover than a fighter.",
	TAFFY = "Maybe I could wax my board with this stuff.",
	TALLBIRD = "I'm glad it can't fly.",
	TALLBIRDEGG = "There's a little dude relaxin' inside.",
	TALLBIRDEGG_COOKED = "Now if I could only get giant toast.",
	TALLBIRDEGG_CRACKED =
	{
		COLD = "Gelatinous...",
		GENERIC = "Raw...",
		HOT = "Hope it doesn't hard boil.",
		LONG = "It's growing...",
		SHORT = "C'mon squirt.",
	},
	TALLBIRDNEST =
	{
		GENERIC = "Bunch of future pecky jerks.",
		PICKED = "The eggs have flown the coop.",
	},
	TEENBIRD =
	{
		GENERIC = "It's got a ton of acne under those feathers. Haha, gross.",
		HUNGRY = "They're always hungry!",
		STARVING = "You've eaten me out of base and camp!",
	},
	TELEPORTATO_SW_BASE = "I sense its power...",
	TELEPORTATO_SW_BOX = "This thing attaches to the other thing?",
	TELEPORTATO_SW_CRANK = "I hope this isn't a broom 'cause I hate sweeping.",
	TELEPORTATO_SW_POTATO = "Tubular...",
	TELEPORTATO_SW_RING = "Doesn't look suited for hula-hooping...",
	TELESCOPE = "You can't hide from me, islands!",
	TENT =
	{
		BURNT = "Great! Just great...",
		GENERIC = "A cool, dry place to catch some Zzz's.",
	},
	THATCHPACK = "For when my pockets are full.",
	TIDALPOOL = "Wonder how deep it goes...",
	TIDAL_PLANT = "Stuff can grow anywhere I guess...",
	TIGERSHARK = "I'll never complain about regular sharks again!",
	TOPHAT = "Not quite my style...",
	TORCH = "Take that, night!",
	TOUCAN = "You could catch waves with a nose like that!",
	TRAILMIX = "Protein!",
	TRANSISTOR = "Thing-y what does the science stuff!",
	TRAP = "Catch me a beach breakfast!",
	TRAP_TEETH = "Ooh, that looks nasty!",
	TRAP_TEETH_MAXWELL = "Must avoid...",
	TRAWLNET = "Insert pun about surfing the Internet here.", -- not sorry -Mobb
	TRAWLNETDROPPED =
	{
		GENERIC = "A sack of sea goodies!",
		SOON = "Just a little more trawlin'...",
		SOONISH = "I wonder what it grabbed up...",
	},
	TREASURECHEST =
	{
		BURNT = "Nooooo! Goodbye shiny, shiny treasure...",
		GENERIC = "Treasure!",
	},
	TREASURECHEST_TRAP = "Tricky treasure!",
	TRIDENT = "I feel like the god of...something!",
	TRINKET_IA_1 = "Gross.",
	TRINKET_IA_10 = "I might need these if I ever take a gnarly wipeout.",
	TRINKET_IA_11 = "Hey there lil dude. Wanna come with me?",
	TRINKET_IA_12 = "Desse-what?",
	TRINKET_IA_13 = "Slammable soda!",
	TRINKET_IA_14 = "If I only had a pin...",
	TRINKET_IA_15 = "Choka! A Ukulele!",
	TRINKET_IA_16 = "An odd shaped plate...",
	TRINKET_IA_17 = "Too big...",
	TRINKET_IA_18 = "Old timey craftsmanship.",
	TRINKET_IA_19 = "I only take herbals...",
	TRINKET_IA_2 = "Aww, but I like real kazooing...",
	TRINKET_IA_23 = "Too much work to figure out what this does...",
	TRINKET_IA_3 = "Gord only knows what this is good for.",
	TRINKET_IA_4 = "Gnome thanks, that thing's creepy.",
	TRINKET_IA_5 = "Zzzzzzzoooooom!",
	TRINKET_IA_6 = "Don't wanna touch this with wet hands...",
	TRINKET_IA_7 = "Ooh, I'm good at this!",
	TRINKET_IA_8 = "Hardened what?",
	TRINKET_IA_9 = "I don't care if things are matchy.",
	TROPICALFAN = "Sweet relief.",
	FISH_TROPICAL = "Such tasty colors!",
	TRUNKVEST_SUMMER = "Lets my skin breath.",
	TUNACAN = "Whoa! Righteous non-spoilage!",
	TURBINE_BLADES = "Twirly!",
	TURF_ASH = "Ashy...",
	TURF_BEACH = "Take the beach to go.",
	TURF_CARPETFLOOR = "Make fists with your toes.",
	TURF_JUNGLE = "Gnarled-ly.",
	TURF_MARSH = "Goopy...",
	TURF_MEADOW = "Nice underfoot.",
	TURF_MUD = "Squelchy.",
	TURF_SINKHOLE = "I have a sinking feeling about this.",
	TURF_UNDERROCK = "Crunchy.",
	TURKEYDINNER = "I am thankful for this.",
	TWIGS = "Very useful.",
	UMBRELLA = "Keep off, elements!",
	UNAGI = "Ten more, please!",
	VENOMGLAND = "What a terrible gland.",
	VINE = "Good for lashing stuff down.",
	VOLCANO = "Mount gnarly!",
	VOLCANOSTAFF = "I'm the volcano's boss now!",
	VOLCANO_ALTAR =
	{
		GENERIC = "The volcano asks its price...",
		OPEN = "Ready to receive...",
	},
	VOLCANO_ALTAR_BROKEN = "Won't be taking any items now.",
	VOLCANO_EXIT = "Time to split this scene.",
	WAFFLES = "Brunch!",
	WALLYINTRO_DEBRIS = "Boat chunks...",
	WALL_HAY =
	{
		BURNT = "Not surprising... it was made out of hay...",
		GENERIC = "Better than no wall...",
	},
	WALL_HAY_ITEM = "Better than no wall...",
	WALL_LIMESTONE = "Now THIS is a wall!",
	WALL_LIMESTONE_ITEM = "Now THIS is a wall!",
	WALL_RUINS = "Why wall yourself off from the world?",
	WALL_RUINS_ITEM = "I could build a wall with this. But why bother?",
	WALL_STONE = "Seems strong...",
	WALL_STONE_ITEM = "Seems strong...",
	WALL_WOOD =
	{
		BURNT = "It was wood, after all...",
		GENERIC = "Knock on wood this keeps stuff out.",
	},
	WALL_WOOD_ITEM = "Knock on wood this keeps stuff out.",
	WASPHIVE = "The worst kind of hive!",
	WATERMELON = "Nothing better on a hot day!",
	WATERMELONHAT = "Next best thing to a watermelon bikini.",
	WATERMELONICLE = "Eat it before it melts!",
	WATERMELON_COOKED = "Hot watermelon...",
	WATERMELON_SEEDS = "I love watermelon... but I hate farm work...",
	WEBBERSKULL = "Not your run of the mill skull.",
	WETGOOP = "Is there dry goop?",
	WHALE_BLUE = "What's got ya down, fella?",
	WHALE_BUBBLES = "Something's down there...",
	WHALE_CARCASS_BLUE = "You don't have to be sad anymore...",
	WHALE_CARCASS_WHITE = "Vengeance is mine.",
	WHALE_WHITE = "Do ye spout black blood and roll fin out?",
	WILDBORE = "I'm not wild about it.",
	WILDBOREHOUSE = "Bores live in houses? Wild!",
	VOLCANO_SHRUB = "Rubs off on my hands.",
	ROCK_OBSIDIAN = "It'd be too much work to get you open...",
	ROCK_CHARCOAL = "Burnt, but good!",
	DRAGOONDEN = "Work out? Why bother.",

	ABIGAIL = "Hang ten, ectobuddy.",
	ARMORCACTUS = "How will I hug trees in this?",
	BASALT = "The strong, silent type.",
	BEEMINE_MAXWELL = "Sometimes I dance to the buzzing beat.",
	BIGFISHINGROD = "I'm ready to find a nice spot to relax with this.",
	BIGFOOT = "Just look at that goofy footed weirdo!",
	BIRCHNUTDRAKE = "Chillax, little dude.",
	BISHOP_NIGHTMARE = "This is why I don't play board games!",
	BLOWDART_FIRE = "A real quick way of lighting a firepit when no one's looking.",
	BLOWDART_FLUP = "It makes a wet squelch when it hits stuff.",
	BLOWDART_PIPE = "Do I have to shoot someone with it?",
	BLOWDART_POISON = "Not good for party tricks. I learned the hard way.",
	BLOWDART_SLEEP = "(Sometimes I use it for naps.)",
	BLUEAMULET = "I like to put it on when I'm feeling a little too steamed.",
	BLUEGEM = "The color of the ocean!",
	BLUEPRINT = "It's making my brain hurt just looking at it.",
	BLUE_CAP = "I didn't know mushrooms came in blue.",
	BLUE_CAP_COOKED = "Did I make it better or worse?",
	BLUE_MUSHROOM =
	{
		GENERIC = "Cooked or raw, I could eat a ton of these.",
		INGROUND = "It likes to sleep during the day. Just like me!",
		PICKED = "It needs time to unwind.",
	},
	BOAT = "The second best way to travel.",
	BOATCANNON = "Shooting it into the water can make some pretty sweet waves.",
	BONESHARD = "I don't think a cast will help now.",
	BONESTEW = "It looks like a pretty hearty meal.",
	BRAINJELLYHAT = "It's, like, blowing my mind!",
	BUGNET = "Maybe I could pass an afternoon catching butterflies.",
	BUNNYMAN = "Do you give good hugs?",
	BUOY = "It's just hanging out.",
	BUZZARD = "Not dead yet, friend!",
	CACTUS =
	{
		GENERIC = "It's fine if you just leave it alone.",
		PICKED = "Ouch! I got prickled.",
	},
	CACTUS_FLOWER = "You ever seen anything as pretty?",
	CACTUS_MEAT = "Cactus flesh... d'you think that's vegetarian?",
	CACTUS_MEAT_COOKED = "Looks pretty tasty now.",
	CATCOON = "It's very independent and loves garbage. Me too!",
	CATCOONDEN =
	{
		EMPTY = "Anyone there?",
		GENERIC = "Looks like a nice place to crash.",
	},
	CATCOONHAT = "I can feel the spirits of catcoons that made it.",
	CAVE_BANANA_TREE = "That's not a real banana!",
	CAVE_ENTRANCE =
	{
		GENERIC = "How much effort will it take to get in there?",
		OPEN = "I've always wanted to try spelunking.",
	},
	CAVE_EXIT = "Time to bail!",
	CAVE_FERN = "Nature finds a way, even here.",
	COCONUT_HALVED = "You get two for the price of one. Pfft.",
	COFFEEBOT = "I could go for a cup of joe.",
	COOKEDMANDRAKE = "Might as well eat it now.",
	COONTAIL = "This would make a stylish hat.",
	CRATE = "Wonder what's inside.",
	CROW =
	{
		GENERIC = "Akaw!",
		HELD = "Are we best friends now?",
	},
	CUTLASS = "It's been awhile since I held one of these.",
	CUTLICHEN = "Can I get something to eat now?",
	CUTREEDS = "It was hard work cutting those. Nap time!",
	CUTSTONE = "I don't have to build something now, do I?",
	DEADLYFEAST = "My gut can't handle that!",
	DECIDUOUSTREE =
	{
		BURNING = "Senseless.",
		BURNT = "Saying sorry won't bring it back.",
		CHOPPED = "Thanks for the logs. Sorry about, like, your body.",
		GENERIC = "It comes in so many colors!",
		POISON = "I said I was sorry!",
	},
	DEERCLOPS = "Yikes! We're in the impact zone now!",
	DEERCLOPS_EYEBALL = "Aw. Kind of reminds me of the boss.",
	DEPLETED_BAMBOOTREE = "It's gone for now.",
	DEPLETED_BUSH_VINE = "No more here.",
	DEPLETED_GRASS_WATER = "That was all it had to offer.",
	DEVTOOL_NODEV = "I couldn't possibly use that.",
	DIVININGRODBASE =
	{
		GENERIC = "What is that?",
		READY = "Maybe it wants a key?",
		UNLOCKED = "Let's get going!",
	},
	DIVININGRODSTART = "I can't wait to find a cool Thing!",
	DOYDOY = "Well hey there little guy.",
	DOYDOYBABY = "Aw! You look like you want a cuddle!",
	DOYDOYEGG = "Could be a doydoy. Or could be dinner.",
	DOYDOYEGG_COOKED = "You can taste the endangerment.",
	DOYDOYEGG_CRACKED = "I didn't touch it, I swear.",
	DOYDOYFEATHER = "It's soft to the touch.",
	DOYDOYNEST = "Looks like a great place to nap. For a doydoy.",
	DRAGONFLY = "I'd never have to put up with this on the open ocean!",
	DRAGONFLYCHEST = "What did I get?!",
	DRAGONFRUIT = "Decadent, and decorative!",
	DRAGONFRUIT_COOKED = "It tastes pretty.",
	DRAGON_SCALES = "I need a suit of these, immediately.",
	DRAGOON = "Woah, tone it down, my guy.",
	DRAGOONEGG = "I licked one once. It burned my tongue.",
	DRAGOONHEART = "It must have been in love. It's still crazy hot.",
	DRAGOONSPIT = "My brother used to do the same thing.",
	DRUMSTICK = "Does someone want to cook it for me?",
	DRUMSTICK_COOKED = "I feel like a warrior.",
	DUG_BUSH_VINE = "Do I really have to replant it?",
	EEL = "If you squint it's actually kind of cute.",
	EEL_COOKED = "I'm not gonna eat just an eel old thing!",
	EGGPLANT = "I've never seen an egg that shade of purple.",
	EGGPLANT_COOKED = "Is this, like, an omelette?",
	FEATHER_ROBIN_WINTER = "I would love a necklace made of these.",
	FISH = "Blub blub, little chum.",
	FLOWER_CAVE = "I want a whole wreath of them!",
	FLOWER_CAVE_DOUBLE = "I want a whole wreath of them!",
	FLOWER_CAVE_TRIPLE = "I want a whole wreath of them!",
	FRESHFRUITCREPES = "Score!",
	FROG =
	{
		DEAD = "It was too good for this world.",
		GENERIC = "Keep your tongue to yourself, bucko.",
		SLEEPING = "Sweet dreams.",
	},
	FROGGLEBUNWICH = "Not a bad afternoon snack.",
	FROGLEGS = "I don't really like touching them.",
	FROGLEGS_COOKED = "Tastes like doydoy.",
	FROG_POISON = "Best to just leave it alone.",
	GEMSOCKET =
	{
		GEMS = "I think it wants me to jam rocks in it.",
		VALID = "Lookin' good!",
	},
	GHOST = "You deserve a rest.",
	GLOMMER = "Looks like a friend.",
	GLOMMERFLOWER =
	{
		DEAD = "Poor lil thing.",
		GENERIC = "Wouldn't it look great in my hair?",
	},
	GLOMMERFUEL = "I'll make sure it goes to good use.",
	GLOMMERWINGS = "Sigh. Fly no more, friend.",
	GOATMILK = "It feels tingly going down.",
	GOOSE_FEATHER = "It's soft but... a bit grimy.",
	GRASS_WATER = "This grass is well hydrated!",
	GREENAMULET = "This necklace is a creative force. I'm feelin' it.",
	GREENGEM = "The color of nature!",
	GREENSTAFF = "This staff only destroys.",
	GUANO = "It's batilisk poop.",
	HOME = "Is it time for a nap?",
	HONEYCOMB = "It's sweet and full of bee babies.",
	HONEYHAM = "Is it a special occasion?",
	HONEYNUGGETS = "I'll just be lying here, shoving these into my mouth.",
	HORN = "It's a big animal horn.",
	HOTCHILI = "Yow! Burns my tongue SO GOOD.",
	HOUNDBONE = "It's a bunch of bones. How comforting.",
	HOUNDFIRE = "Hot! Too hot!",
	HOUNDMOUND = "I think there are some angry pups lurking nearby.",
	HOUNDSTOOTH = "Highlights the importance of regular dental checkups.",
	ICE = "It knows how to chill.",
	ICEBOX = "A constant reminder to keep it cool.",
	ICECREAM = "Perfect treat to pair with a hammock in the sun.",
	ICEHAT = "Keeps my head cold. And wet.",
	ICEHOUND = "What a chilly pup.",
	IRONWIND = "Uh... I'll stick to my board, thanks.",
	KNIGHT = "He looks like he could use a nap.",
	KNIGHT_NIGHTMARE = "He should go to sleep... and not wake up.",
	KOALEFANT_SUMMER = "Hang ten, big guy.",
	KOALEFANT_WINTER = "Hang ten, big snowy guy.",
	KRAKEN = "Surf's up!",
	KRAKENCHEST = "Treasure awaits me!",
	KRAKEN_TENTACLE = "It's much too floppy!",
	LEIF = "Step off, grey belly!",
	LEIF_SPARSE = "Step off, grey belly!",
	LICHEN = "This moss makes me sad.",
	LIGHTBULB = "Naturally bright. Just like me!",
	LIGHTNINGGOAT =
	{
		CHARGED = "Majestic!",
		GENERIC = "Do you think it would let me snuggle it?",
	},
	LIGHTNINGGOATHORN = "I feel a little bad about the dead goat.",
	LITTLE_WALRUS = "How ya doin', tiny?",
	LIVINGTREE = "There's a board in there just begging to get out.",
	LOCKEDWES = "You probably want me to like, free you or something, huh.",
	MAGIC_SEAL = "Why would anyone need this much power?",
	MAGMAROCK_FULL = "It's a big rock.",
	MAGMAROCK_GOLD_FULL = "Is that one sparkling?",
	MANRABBIT_TAIL = "Fluffy!",
	MARBLE = "Pretty fancy material.",
	MARBLEPILLAR = "What was it meant to hold up?",
	MARBLETREE = "Super weird.",
	MAXWELL = "He seems like kind of a jerk.",
	MAXWELLHEAD = "Woah, did I eat some bad berries?",
	MAXWELLLIGHT = "Weird.",
	MAXWELLLOCK = "Gives me the heebie jeebies.",
	MAXWELLPHONOGRAPH = "Jaunty, but grating.",
	MAXWELLTHRONE = "Woah. That's rough.",
	MINOTAUR = "Holy horns.",
	MINOTAURCHEST = "Whatcha got for me, magic chest?",
	MINOTAURHORN = "It was an ordeal to get this.",
	MOLE =
	{
		ABOVEGROUND = "Welcome to the surface!",
		HELD = "Are you comfy in there, buddy?",
		UNDERGROUND = "Who's down there?",
	},
	MOLEHAT = "I CAN SEE ALL!",
	MOLEHILL = "Nice hole, mole.",
	MONKEY = "You think he can surf?",
	MONKEYBALL = "What's that little dude? You want me to throw you?",
	MONKEYBARREL = "Neat abode, guys.",
	MONSTERTARTARE = "I'm not too keen on putting that in my mouth.",
	MOOSE = "You're a big one, huh!",
	MOOSEEGG = "It will one day hatch into a moo... a goo... a thing.",
	MOSQUITO =
	{
		GENERIC = "Filthy bloodsucker!",
		HELD = "Don't think this means we're friends.",
	},
	MOSQUITOSACK = "Makes an okay pillow if you plug your nose.",
	MOSSLING = "Don't you just want to pick it up and squeeze it?",
	MOUND =
	{
		DUG = "Thanks for the loot, dude.",
		GENERIC = "Seems rude to mess with it.",
	},
	MUSSELBOUILLABAISE = "Seafood, my favorite.",
	MYSTERYMEAT = "Total mushburger.",
	NEEDLESPEAR = "Eh. I don't get the point.",
	NIGHTMARELIGHT = "I don't care how weird it is, as long as it keeps darkness away.",
	NIGHTMARE_TIMEPIECE =
	{
		CALM = "I can breathe easy.",
		DAWN = "It's almost over...!",
		NOMAGIC = "I'm not getting anything.",
		STEADY = "I think it's keeping consistent.",
		WANING = "It's leaving...",
		WARN = "Woah! Things are really heating up!",
		WAXING = "It's gaining strength!",
	},
	NIGHTSTICK = "That's one gnarly-lookin' whacker.",
	ORANGEAMULET = "Finally, jewelry that gets me.",
	ORANGEGEM = "The world looks fractured when I peer through it!",
	ORANGESTAFF = "Ah, this staff was made for me!",
	OXHAT = "I hope it doesn't mess up my ponytails.",
	OX_FLUTE = "I'm gonna play some sweet jams on this baby.",
	OX_HORN = "I'm glad it's not attached to anything.",
	PANDORASCHEST = "Maybe I'll get something nice?",
	PARROT_PIRATE = "He's a squawkbuckler.",
	PEG_LEG = "Is it weird to just have one?",
	PENGUIN = "Hey little dude.",
	PERD = "He's a doofy little guy.",
	PIGGUARD = "Take it easy, big guy.",
	PIGGYBACK = "Was it worth it?",
	PIGHEAD =
	{
		BURNT = "Wasn't it bad enough already?",
		GENERIC = "Tough break, dude.",
	},
	PIGHOUSE =
	{
		BURNT = "Hope they had insurance.",
		FULL = "How do they all fit in there?",
		GENERIC = "Where the pigs kick back and relax.",
		LIGHTSOUT = "Turn it back on! PLEASE!",
	},
	PIGKING = "Haha. Am I supposed to curtsy or something?",
	PIGMAN =
	{
		DEAD = "Bad luck, dude.",
		FOLLOWER = "Let's hit the waves!",
		GENERIC = "Lookin' fine, swine.",
		GUARD = "Wow, you're really loyal. That's admirable.",
		WEREPIG = "Haha! What even is that?",
	},
	PIGTORCH = "It's kind of cute.",
	PIKE_SKULL = "Well that's not very nice.",
	PINECONE = "It's a tree baby.",
	PINECONE_SAPLING = "Grow on, little bud.",
	PIRATEGHOST = "Aw. He could've had an eternal nap, but he came back.",
	POND = "It's kind of hard to look at myself these days.",
	POND_ALGAE = "It makes me miss the open sea.",
	POTTEDFERN = "It can no longer grow free.",
	PUMPKIN = "You look nice today, pumpkin.",
	PUMPKINCOOKIE = "Score!",
	PUMPKIN_COOKED = "Smells autumn-y.",
	PUMPKIN_LANTERN = "Spooky!",
	PUMPKIN_SEEDS = "They're fine like this. No need to do any farming.",
	RABBIT =
	{
		GENERIC = "Look at its little ears!",
		HELD = "No need to be scared.",
	},
	RABBITHOLE =
	{
		GENERIC = "It's rabbit-shaped.",
		SPRING = "I guess they needed Me Time.",
	},
	RABBITHOUSE =
	{
		BURNT = "Aw. The bunnies lost their home.",
		GENERIC = "A decent enough place to live.",
	},
	RAINCOAT = "The surf can't touch me now!",
	RAINHAT = "High and dry.",
	RAWLING = "This dude cracks me up!",
	RED_CAP = "It might be a bad idea to just eat stuff I find on the ground.",
	RED_MUSHROOM =
	{
		GENERIC = "Now that's a mushroom!",
		INGROUND = "Hiding, little dude?",
		PICKED = "It might grow back on its own.",
	},
	RELIC =
	{
		BROKEN = "I'm not cleaning that up.",
		GENERIC = "Where's the ancient bed?",
	},
	RESEARCHLAB4 =
	{
		BURNT = "Guess I don't get to pull the lever anymore.",
		GENERIC = "That lever's calling to me.",
	},
	ROBIN =
	{
		GENERIC = "A song given wing.",
		HELD = "How are you doing, little guy?",
	},
	ROBIN_WINTER =
	{
		GENERIC = "You have a lovely voice!",
		HELD = "You're not too squished, are you?",
	},
	ROBOT_PUPPET = "Sorry about your existence.",
	ROCKY = "No need to fight!",
	ROCK_ICE =
	{
		GENERIC = "At least someone around here knows how to chill!",
		MELTED = "I didn't bring my puddle stompin' boots!",
	},
	ROCK_ICE_MELTED = "I didn't bring my puddle stompin' boots!",
	ROOK = "Check, mate!",
	ROOK_NIGHTMARE = "Is that thing real?!",
	RUBBLE = "A big ol' pile of rocks.",
	RUINS_RUBBLE = "A big ol' pile of old, old rocks.",
	SAIL_STICK = "Probably more useful than a regular stick.",
	SANDBAGSMALL_ITEM = "Remind me not to swim while carrying these!",
	SANITYROCK =
	{
		ACTIVE = "Go off!",
		INACTIVE = "See ya.",
	},
	SHADOWSKITTISH_WATER = "Hey!",
	SHARKITTENSPAWNER =
	{
		GENERIC = "There are kitties jammin' inside.",
		INACTIVE = "Just sand?",
	},
	SHIPWRECKED_ENTRANCE = "Aloha, world!",
	SHIPWRECKED_EXIT = "Aloha, world!",
	SLURPER = "It's a little gross, but who am I to judge?",
	SLURPERPELT = "Maybe it doubles as a blanket.",
	SLURPER_PELT = "Maybe it doubles as a blanket.",
	SLURTLE = "It tastes with its feet. Gross.",
	SLURTLEHAT = "I'm a little embarrassed to wear it in public.",
	SLURTLEHOLE = "The snail things come out of there.",
	SLURTLESLIME = "It's hard to hold on to.",
	SLURTLE_SHELLPIECES = "Holding on to these doesn't even seem worth it.",
	SNAKEDEN =
	{
		BURNT = "Not much use to anyone now.",
		CHOPPED = "Those vines are mine.",
		GENERIC = "Looks a little tangled.",
	},
	SAIL_SNAKESKIN = "Why bother when I have my board?",
	SNAKE_FIRE = "Too hot to handle!",
	SNURTLE = "It tastes with its feet. Gross.",
	SPEAR_LAUNCHER = "Seems a little aggressive.",
	SPIDERHOLE = "It's a hole. Full of SPIDERS.",
	SPIDER_DROPPER = "How rude of you to drop in!",
	SPIDER_HIDER = "I see you over there!",
	SPIDER_SPITTER = "No thank you!",
	STAFFLIGHT = "Isn't starlight bad for the skin?",
	STAFF_TORNADO = "I'm glad I'm not on the receiving end.",
	STALAGMITE = "A pretty cool rock.",
	STALAGMITE_FULL = "A pretty cool rock.",
	STALAGMITE_LOW = "A pretty cool rock.",
	STALAGMITE_MED = "A pretty cool rock.",
	STALAGMITE_TALL = "A pretty cool rock.",
	STALAGMITE_TALL_FULL = "A pretty cool rock.",
	STALAGMITE_TALL_LOW = "This rock seems uncool.",
	STALAGMITE_TALL_MED = "A pretty cool rock.",
	STATUEGLOMMER =
	{
		EMPTY = "Woah, far out.",
		GENERIC = "All messed up now.",
	},
	STATUEHARP = "No shoes, no... head... no service!",
	STATUEMAXWELL = "Guy's got an ego problem.",
	SUNKEN_BOAT_BURNT = "An admirer of the sea, burned to ash. What injustice!",
	SUNKEN_BOAT_TRINKET_1 = "I have no idea how to use that.",
	SUNKEN_BOAT_TRINKET_2 = "Where's the toy surf board?",
	SUNKEN_BOAT_TRINKET_3 = "A wet candle in a bottle. Mega-genius!",
	SUNKEN_BOAT_TRINKET_4 = "So how much is the sea worth?",
	SUNKEN_BOAT_TRINKET_5 = "I've already got a pair of boots.",
	SWEATERVEST = "I hope none of my surfer buds see me in this.",
	SWEETPOTATOSOUFFLE = "Good enough to eat!",
	SWIMMINGHORROR = "AH! I'm losin' it!",
	TELEBASE =
	{
		GEMS = "I think it likes purple gems.",
		VALID = "Good to go!",
	},
	TELEPORTATO_BASE =
	{
		ACTIVE = "Do I really want to go through that?",
		GENERIC = "Get your weird face out of here, dude!",
		LOCKED = "It still won't let me through.",
		PARTIAL = "It'd take a lot of effort to put this back together.",
	},
	TELEPORTATO_BOX = "This looks important.",
	TELEPORTATO_CRANK = "You wanna come with me, huh?",
	TELEPORTATO_POTATO = "Heh heh.",
	TELEPORTATO_RING = "I think I should hold on to it.",
	TELESTAFF = "It shows me things I never knew I could see.",
	TENTACLE = "Hands off, bucko!",
	TENTACLESPIKE = "It's pretty flimsy. I can't see it doing much damage.",
	TENTACLESPOTS = "These might help me out of a tight spot.",
	TENTACLE_GARDEN = "This has no right to exist.",
	TENTACLE_PILLAR = "It's all slimed up.",
	TENTACLE_PILLAR_ARM = "Much too slimy!",
	THULECITE = "It's otherworldly.",
	THULECITE_PIECES = "Weird.",
	TIGEREYE = "Nasty.",
	TREECLUMP = "I didn't want to get through anyway.",
	TRINKET_IA_20 = "I have no idea how to use that.",
	TRINKET_IA_21 = "Is there a toy surf board?",
	TRINKET_IA_22 = "A candle in a bottle. Genius.",
	TRUNKVEST_WINTER = "I could fall asleep in this.",
	TRUNK_COOKED = "Seems edible, as far as noses go.",
	TRUNK_SUMMER = "It's a meaty-looking trunk.",
	TRUNK_WINTER = "It's a cold, meaty-looking trunk.",
	TUMBLEWEED = "It's on a journey called \"life\".",
	TURF_SANDY = "It's getting in my shoes!",
	TURF_BADLANDS = "Keeps me grounded.",
	TURF_CAVE = "It's ground.",
	TURF_CHECKERFLOOR = "It's ground.",
	TURF_DECIDUOUS = "Keeps me grounded.",
	TURF_DESERTDIRT = "Keeps me grounded.",
	TURF_DIRT = "Dirt.",
	TURF_FOREST = "Keeps me grounded.",
	TURF_FUNGUS = "Keeps me grounded.",
	TURF_FUNGUS_GREEN = "Keeps me grounded.",
	TURF_FUNGUS_RED = "Keeps me grounded.",
	TURF_GRASS = "Grassy.",
	TURF_MAGMAFIELD = "Keeps me grounded.",
	TURF_ROAD = "Keeps me grounded.",
	TURF_ROCKY = "Rocky.",
	TURF_SAVANNA = "Keeps me grounded.",
	TURF_SNAKESKIN = "Keeps me grounded.",
	TURF_SWAMP = "Swampy.",
	TURF_TIDALMARSH = "Marshy.",
	TURF_VOLCANO = "Keeps me grounded.",
	TURF_WOODFLOOR = "Hardwood. Fancy.",
	TWISTER = "This thing needs to relax!",
	TWISTER_SEAL = "I just wanna squish its face into my face.",
	UNIMPLEMENTED = "If it was my job, it'd never get finished.",
	VOLCANO_ALTAR_TOWER = "A blatantly unnatural structure.",
	WALRUS = "Hey grey belly! How's life treatin' ya?",
	WALRUSHAT = "This plaid ain't bad.",
	WALRUS_CAMP =
	{
		EMPTY = "No one home.",
		GENERIC = "Sweet digs.",
	},
	WALRUS_TUSK = "That's a pretty impressive tooth.",
	WARG = "What's your deal, man?",
	WATERYGRAVE = "That wound's a little too fresh.",
	WHALE_TRACK = "Seems like a lot of effort to follow it.",
	WILBUR_CROWN = "I dig the style.",
	WILBUR_UNLOCK = "Welcome aboard, bud!",
	WILDBOREHEAD = "That's what happens when you lose your head.",
	WIND_CONCH = "Get those waves cranking!",
	WINTERHAT = "It's like a hug for my head.",
	WINTEROMETER =
	{
		BURNT = "Not much use to me now.",
		GENERIC = "Why put numbers on what you can feel?",
	},
	BOAT_WOODLEGS = "I'd still rather board.",
	WOODLEGSHAT = "Nautical.",
	SAIL_WOODLEGS = "An acceptable alternative to surfing... I guess.",
	WOODLEGS_CAGE = "Whoever invented cages had a cruel heart.",
	WOODLEGS_KEY1 = "It's a boney key.",
	WOODLEGS_KEY2 = "Fancy.",
	WOODLEGS_KEY3 = "An iron key. What's it open?",
	WORM =
	{
		DIRT = "Something's taking a dirt nap.",
		PLANT = "Nothing to see here.",
		WORM = "That dude can pull off some sweet aerials.",
	},
	WORMHOLE =
	{
		GENERIC = "Is that its front end, or back?",
		OPEN = "Well, I see no reason not to jump in.",
	},
	WORMHOLE_LIMITED = "I don't think it's feeling well.",
	WORMLIGHT = "I find myself strangely attracted to it.",
	SHIPWRECK = "Probably won't be sailing on that anytime soon.",
	YELLOWAMULET = "I absolutely glow when I wear it!",
	YELLOWGEM = "It's got a nice energy.",
	YELLOWSTAFF = "Isn't starlight bad for the skin?",
	CALIFORNIAROLL = "I could eat a boat load of that stuff.",

	OXWOOL = "Thanks, ox-dude.",
	BOAT_ENCRUSTED = "Whatever floats my boat.",
	JUNGLETREEGUARD = "No way this is worth the effort!",
	BABYOX = "Awww, you smell like garbage!",
	BALLPHINHOUSE = "Man, even their houses are cute.",
	DORSALFIN = "I thought I was the only one around here who'd fallen to pieces.",
	NUBBIN = "Heh. \"Nubbin.\"",
	CORALLARVE = "Look at this lil slime dude! How are you, slime dude?",
	RAINBOWJELLYFISH = "Hey there, little buddy.",
	RAINBOWJELLYFISH_PLANTED = "Lookin' good, lil dude!",
	RAINBOWJELLYFISH_DEAD = "Aw.",
	RAINBOWJELLYFISH_COOKED = "Aw jeez. It's even cute when it's cooked.",
	RAINBOWJELLYJERKY = "I feel bad. And also hungry.",
	WALL_ENFORCEDLIMESTONE = "A coral corral. Heh.",
	WALL_ENFORCEDLIMESTONE_ITEM = "I still have to like... build it.",
	POI = "Boy, could I ever go for some poi.",
	LOTUSCHIPS = "I just want to eat these until I die!",
	CROCODOG = "It's cute, from a safe distance.",
	POISONCROCODOG = "I respect its right to exist, but... not so nearby!",
	WATERCROCODOG = "What's the crocodeal, dude?!",
	QUACKENBEAK = "He was probably a bit peckish when he died.",
	QUACKERINGRAM = "I prefer to be a pacifist on the pacific.",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "I made them fancy, but they're still fish eggs.",
	CORMORANT = "Hang ten, stinky sea dude!",

	PURPLE_GROUPER = "His doofiness is kinda endearing.",
	PIERROT_FISH = "I can't kill that! Look how cute it is!",
	NEON_QUATTRO = "What a cute lil dude!",

	PURPLE_GROUPER_COOKED = "Sorry, man. It was you or me.",
	PIERROT_FISH_COOKED = "Delicious, delicious guilt.",
	NEON_QUATTRO_COOKED = "Sorry. I still gotta eat.",

	FISH_FARM = 
	{
		EMPTY = "I guess I gotta find fish eggs now. Oof.",
		STOCKED = "C'mon fish! I'm an \"instant gratification\" kind of gal.",
		ONEFISH = "Hey lil dude! Welcome to the farm!",
		TWOFISH = "Aw, my fish has buddies!",
		REDFISH = "It's looking like a real party in there!",
		BLUEFISH  = "Do I really have to eat them?",
	},

	ROE = "Roe, roe, roe my board... I'm going nuts out here.",
	ROE_COOKED = "At least they didn't have faces.",
	
	SEA_YARD = 
	{
		ON = "Does it work on surfboards?",
		OFF = "Ughhh, I should refill it.",
		LOWFUEL = "It's running on fumes. Same!",
	},
	
	SEA_CHIMINEA =
	{
		EMBERS = "It looks totally pooped.",
		GENERIC = "I taught the fire how to surf.",
		HIGH = "That thing's working waaaay too hard.",
		LOW = "It's okay, fire. You can take a rest if you want.",
		NORMAL = "Don't strain yourself, fire.",
		OUT = "I guess it needed a rest.",
	}, 

	TAR = "Why did I want this again?",
	TAR_EXTRACTOR =
	{
		ON = "It's doing everything for me. Great!",
		OFF = "I'm giving Mother Nature a rest.",
		LOWFUEL = "It's gonna run out of fuel.",
	},
	TAR_POOL = "Aww, the tar's seeping right into the ocean water.",

	TARLAMP = "Will this fit on a surfboard?",
	TARSUIT = "This may have been my worst idea. Ever.",
	TAR_TRAP = "Sticky and environmentally unfriendly!",

	TROPICALBOUILLABAISSE = "Eating a lot cures the desert island blues.",

	SEA_LAB = "In the middle of the ocean and I still have to do stuff!",
	WATERCHEST = "Now I don't need to swim back to shore for my stuff.",
	QUACKENDRILL = "This is not a drill! Wait, it totally is.",
	HARPOON = "I don't wanna hurt any poor animals.",
	MUSSEL_BED = "I should plant it before the poor things dry out.",
},
DESCRIBE_GENERIC = "Yup, that's definitely a thing.",
DESCRIBE_SMOLDERING = "It's getting too hot to handle.",
DESCRIBE_TOODARK = "HELP! I'm freakin' out here!",
EAT_FOOD =
{
	TALLBIRDEGG_CRACKED = "Sorry, lil guy.",
},
}
%%+%%strings/warly.lua%%-%%return{
    --By CheeseNuggets/Goat-Slice c: via 'Shipwrecked Characters'
	ACTIONFAIL = 
	{
--[[
	    REPAIR =
        {
            WRONGPIECE = "That was the incorrect ingredient.",
        },
	    BUILD =
        {
            MOUNTED = "The ground is simply too far below me.",
			HASPET = "I'm already busy with one, two is simply too much.",
        },
		SHAVE =
		{
			AWAKEBEEFALO = "It would be unwise to attempt this while the animal is awake.",
			GENERIC = "Not a shaveable beast.",
			NOBITS = "Nothing to shave.",
		},
		STORE =
		{
			GENERIC = "It is too full.",
			NOTALLOWED = "This is not the place for it.",
		    INUSE = "Right, pardon me. You first.",
		},
		CONSTRUCT =
        {
            INUSE = "Pardon me! It's already being worked on!",
            NOTALLOWED = "That isn't the correct ingredient.",
            EMPTY = "I require the ingredients first.",
            MISMATCH = "That is the incorrect recipe.",
        },
		RUMMAGE =
		{	
			GENERIC = "I cannot right now.",	
			INUSE = "After you!",	
		},
		USEKLAUSSACKKEY =
        {
        	WRONGKEY = "That was the incorrect ingredient.",
        	KLAUS = "We have quite the mess on our hands at the moment, I must try later.",
        },
        COOK =
        {
            GENERIC = "I'm not quite ready yet.",
            INUSE = "Excuse me, may I have a turn? I'm quite the chef myself, you know.",
            TOOFAR = "I'll need to get a little closer to cook with that.",
        },
        GIVE =
        {
		    GENERIC = "I simply cannot do that.",
            DEAD = "Oh dear...",
            SLEEPING = "It's sleeping.",
            BUSY = "Goodness, it seems busy.",
            ABIGAILHEART = "It pains me knowing it will never work.",
            GHOSTHEART = "I don't believe this apparition is real.",
			NOTGEM = "A proper chef knows not to throw just anything into a dish!",
            WRONGGEM = "I need to check the recipe list once more.",
            NOTSTAFF = "That is incorrect. I must try again.",
			MUSHROOMFARM_NEEDSSHROOM = "Could use a fresh mushroom or two.",
            MUSHROOMFARM_NEEDSLOG = "Definitely needs a log of the living variety.",
            SLOTFULL = "The seat is taken.",
            DUPLICATE = "I'm already quite aware of this.",
            NOTSCULPTABLE = "Not so fast, don't want to ruin anything do we?",
			NOTATRIUMKEY = "This is the incorrect ingredient.",
            CANTSHADOWREVIVE = "I simply cannot make it work.",
			WRONGSHADOWFORM = "Not quite right.",
			NOMOON = "I believe it requires a lunar influence.",
			PIGKINGGAME_MESSY = "Cleaning up the kitchen before cooking is a must.",
			PIGKINGGAME_DANGER = "We have much bigger pigs to fry.",
			PIGKINGGAME_TOOLATE = "I'd rather have a clear morning head.",
        },
        GIVETOPLAYER = 
        {
        	FULL = "I have a gift to give you! If you would mind emptying your pockets!",
            DEAD = "Well, I thought it was a fine gift. Nothing to die over.",
            SLEEPING = "Rise and shine, mon ami! I have something for you!",
            BUSY = "I'll have to try again later. They seem quite busy.",
    	},
    	GIVEALLTOPLAYER = 
        {
        	FULL = "Empty your rags, I have something more special, mon ami!",
            DEAD = "I, oh, I see... You're uh... a tad busy.",
            SLEEPING = "Rise and shine! A gift for you awaits!",
            BUSY = "I'll have to try again at a later date.",
    	},
        WRITE =
        {
            GENERIC = "Maybe later. My hands are covered in cooking oil.",
            INUSE = "Write away...",
        },
		DRAW =
        {
            NOIMAGE = "To create art I must first see it!",
        },
        CHANGEIN =
        {
            GENERIC = "I guess it never occurred to me I'd need to change.",
            BURNING = "It, oh, it appears to be on fire.",
			INUSE = "Well, I am excited to see your next outfit.",
        },
        ATTUNE =
        {
            NOHEALTH = "I'm not feeling of the best mind to do so...",
        },
        MOUNT =
        {
            TARGETINCOMBAT = "It would be unwise to attempt this while the animal is angry.",
            INUSE = "Oh. It must belong to someone else.",
        },
        SADDLE =
        {
            TARGETINCOMBAT = "It's too angry to do that.",
        },
		TEACH =
        {
            KNOWN = "Ah. I already knew that.",
            CANTLEARN = "That might be a bit beyond me.",
			WRONGWORLD = "This seems to point to points unknown.",
        },
		WRAPBUNDLE =
        {
            EMPTY = "I'd like to wrap up some fresh ingredients instead.",
        },
]]
		--IA
		REPAIRBOAT = 
	    {
		    GENERIC = "It will not work.",
	    },
	    EMBARK = 
	    {
		   INUSE = "Oh. It must belong to someone else.",
	    },
	    INSPECTBOAT = 
	    {
		   INUSE = GLOBAL.STRINGS.CHARACTERS.GENERIC.ACTIONFAIL.STORE.INUSE
	    },
		--
	},
	-- ACTIONFAIL_GENERIC = "I cannot do that.",
	ANNOUNCE_MAGIC_FAIL = "Sadly, I can not make it work.",
	-- ANNOUNCE_MOUNT_LOWHEALTH = "It's best not to mount a steed that has an empty stomach!",
	-- ANNOUNCE_DIG_DISEASE_WARNING = "Saved it before it expired!",
    -- ANNOUNCE_PICK_DISEASE_WARNING = "That plant must be near its expiration date.",
	-- ANNOUNCE_ACCOMPLISHMENT = "I am triumphant!",
	-- ANNOUNCE_ACCOMPLISHMENT_DONE = "I hope this feeling lasts forever...",
	-- ANNOUNCE_ADVENTUREFAIL = "I shall have to attempt that again.",
	-- ANNOUNCE_BEES = "The honeymakers are upon me!",
	-- ANNOUNCE_BOOMERANG = "Ouch! Damnable thing!",
	-- ANNOUNCE_BURNT = "Charred...",
	-- ANNOUNCE_CANFIX = "\nI believe I could repair that.",
	-- ANNOUNCE_CHARLIE = "What the devil!",
	-- ANNOUNCE_CHARLIE_ATTACK = "Gah! I do believe something bit me!",
	-- ANNOUNCE_COLD = "I'm... getting freezerburn...",
	-- ANNOUNCE_CRAFTING_FAIL = "I am lacking the required ingredients.",
	-- ANNOUNCE_DAMP = "I've been lightly spritzed.",
	-- ANNOUNCE_WET = "I am getting positively drenched.",
	-- ANNOUNCE_WETTER = "I fear I may be water soluble!",
	-- ANNOUNCE_DEERCLOPS = "I do not like that sound one bit!",
	-- ANNOUNCE_CAVEIN = "I do believe the earth above is collapsing.",
--[[
	ANNOUNCE_ANTLION_SINKHOLE = 
	{
		"Oh dear... The ground around us is collapsing.",
		"Incoming!",
		"The ground rumbles.",
	},
	ANNOUNCE_ANTLION_TRIBUTE =
	{
        "I hope this shall calm your nerves.",
        "A lovely gift, for you!",
        "I shall hope this satisfies your needs, great beast.",
		"Bon Appetit!",
	},
]]
	-- ANNOUNCE_SACREDCHEST_YES = "I am triumphant!",
	-- ANNOUNCE_SACREDCHEST_NO = "I suppose not.",
	-- ANNOUNCE_DUSK = "The dinner hour approaches.",
--[[
	ANNOUNCE_EAT =
	{
		GENERIC = "Magnifique!",
		INVALID = "Clearly inedible.",
		PAINFUL = "Aarg! My stomach...",
		SPOILED = "Blech! Why did I allow that to cross my lips?",
		STALE = "That was past its best-by date...",
		PREPARED = "Delectable!",
		SAME_OLD_1 = "I'd prefer some variety.",
		-- SAME_OLD_2 = "So bland.",
		-- SAME_OLD_3 = "I want to eat something different.",
		-- SAME_OLD_4 = "I can't stand this food.",
		-- SAME_OLD_5 = "Enough already!",
		SAME_OLD_2 = "I want to eat something different.",
		SAME_OLD_3 = "I can't stand this food anymore.",
		TASTY = "Tres magnifique!",
		COOKED = "Not very palatable.",
		DRIED = "A bit dry.",
		RAW = "Blech. Completely lacking in every way.",
		YUCKY = "I'm frankly offended by the mere suggestion.",
	},
]]
--[[
	ANNOUNCE_ENCUMBERED =
    {
        "Must...keep marching forward...!",
        "I'll get there... And there'll be a feast...!",
        "I'm carrying the weight of the world...",
        "Crock pots are never this heavy...",
        "Make way! Huhff...Make way.",
        "The ending shall... taste rewarding! ...It always is.",
        "Hmmpfh...",
        "The finish line... I can already taste it...",
        "Lovely... day today... isn't it? Hmmph.",
        "A single step... a single success.",
    },
	ANNOUNCE_ATRIUM_DESTABILIZING = 
    {
		"It's about to blow this kitchen whole!",
		"I will not let the door hit me on the way out!",
		"That is our call to leave!",
	},
]]
	-- ANNOUNCE_RUINS_RESET = "Ah, the worm has turned.",
	-- ANNOUNCE_THURIBLE_OUT = "Darn!",
	-- ANNOUNCE_SNARED = "Trapped!",
	-- ANNOUNCE_REPELLED = "I cannot puncture it while shielded!",
	-- ANNOUNCE_ENTER_DARK = "Darkness, darkness.",
	-- ANNOUNCE_ENTER_LIGHT = "A new day comes with the dawning light.",
	-- ANNOUNCE_FREEDOM = "Freeeeeeee!",
	-- ANNOUNCE_HIGHRESEARCH = "My brain is tingling!",
	-- ANNOUNCE_HOT = "I'm baking like a souffle here...",
	-- ANNOUNCE_HOUNDS = "I recognize that sound. Hunger.",
	-- ANNOUNCE_WORMS = "That was not a comforting sound.",
	-- ANNOUNCE_HUNGRY = "I need food...",
	-- ANNOUNCE_HUNT_BEAST_NEARBY = "Game is close at hand...",
	-- ANNOUNCE_HUNT_LOST_TRAIL = "I have lost the trail.",
	-- ANNOUNCE_HUNT_LOST_TRAIL_SPRING = "The trail has been washed out.",
	-- ANNOUNCE_INSUFFICIENTFERTILIZER = "It requires more manure.",
	-- ANNOUNCE_INV_FULL = "I cannot carry another stitch.",
	-- ANNOUNCE_KNOCKEDOUT = "My head... spinning...",
	-- ANNOUNCE_LIGHTNING_DAMAGE_AVOIDED = "That was much too close!",
	-- ANNOUNCE_LOWRESEARCH = "I did not learn any new tricks from that.",
	-- ANNOUNCE_MOSQUITOS = "Disease with wings!",
	-- ANNOUNCE_NODANGERSIESTA = "This is no time to close my eyes!",
	-- ANNOUNCE_NOWARDROBEONFIRE = "The clothes are long gone by now...",
    -- ANNOUNCE_NODANGERGIFT = "This is not a time for gifts!",
	-- ANNOUNCE_NOMOUNTEDGIFT = "I should like to open this on the ground, not while riding a beefalo.",
	-- ANNOUNCE_NODANGERSLEEP = "In this particular instance I'd prefer not to die in my sleep!",
	-- ANNOUNCE_NODAYSLEEP = "It is too bright to sleep.",
	-- ANNOUNCE_NODAYSLEEP_CAVE = "I'm not tired.",
	-- ANNOUNCE_NOHUNGERSIESTA = "I could use a nice meal first.",
	-- ANNOUNCE_NOHUNGERSLEEP = "My hunger trumps my exhaustion.",
	-- ANNOUNCE_NONIGHTSIESTA = "Siesta in the dark? I think not.",
	-- ANNOUNCE_NONIGHTSIESTA_CAVE = "This does not strike me as a relaxing place for siesta.",
	-- ANNOUNCE_NOSLEEPONFIRE = "I think not! That's a hotbed for danger!",
	-- ANNOUNCE_NODANGERAFK = "I cannot make a quick escape just yet!",
	-- ANNOUNCE_NO_TRAP = "Went off without a hitch.",
	-- ANNOUNCE_PECKED = "Gah! Enough!",
	-- ANNOUNCE_QUAKE = "That is not a comforting sound...",
	-- ANNOUNCE_RESEARCH = "Education is a lifelong process.",
	-- ANNOUNCE_SHELTER = "I am thankful for this tree's protective buffer.",
	-- ANNOUNCE_SOAKED = "I'm wetter than a dish rag!",
	-- ANNOUNCE_THORNS = "Gah!",
	-- ANNOUNCE_TOOL_SLIP = "Everything is slick...",
	-- ANNOUNCE_TORCH_OUT = "Come back, light!",
	-- ANNOUNCE_FAN_OUT = "It fell apart in my hands!",
    -- ANNOUNCE_COMPASS_OUT = "Oh. I believe it broke.",
	-- ANNOUNCE_TRAP_WENT_OFF = "Darn!",
	-- ANNOUNCE_UNIMPLEMENTED = "It is not operational yet.",
	-- ANNOUNCE_WORMHOLE = "I must be unhinged to travel so...",
	-- ANNOUNCE_TOWNPORTALTELEPORT = "Blech... I got sand in my mouth.",
	-- ANNOUNCE_TOADESCAPING = "Don't go just yet, toad! I still have more garlic for you!",
	-- ANNOUNCE_TOADESCAPED = "Darn, we'll have a grandiose meal another time then.",
	
	-- ANNOUNCE_DESPAWN = "Oh dear me. Might this be the final course?",
	-- ANNOUNCE_GHOSTDRAIN = "My humanity is becoming unhinged...",
	-- ANNOUNCE_PETRIFED_TREES = "Hm. Was that the sound of stone being built?",
	-- ANNOUNCE_KLAUS_ENRAGE = "Now's a better time than ever to flee!",
	-- ANNOUNCE_KLAUS_UNCHAINED = "What the deuce? I will be hiding in my crock pot if you need me!",
	-- ANNOUNCE_KLAUS_CALLFORHELP = "It has called upon minions for protection!",
	--hallowed nights
    -- ANNOUNCE_SPOOKED = "Oh dear. I must have ate something past its best-by date.",
	-- ANNOUNCE_BRAVERY_POTION = "Does it come in more flavors than tree?",

	--Island Adventures
    ANNOUNCE_SHARX = "I do believe they wish me harm.",
    ANNOUNCE_TREASURE = "I sense possible riches!",
    ANNOUNCE_MORETREASURE = "And yet more treasure!",
    ANNOUNCE_OTHER_WORLD_TREASURE = "This seems to point to points unknown.",
    ANNOUNCE_OTHER_WORLD_PLANT = "What are you doing so far from home?",

    ANNOUNCE_MESSAGEBOTTLE =
    {
	"The ink is smudged...",
    },
    ANNOUNCE_VOLCANO_ERUPT = "Incoming!",
    ANNOUNCE_MAPWRAP_WARN = "The implications of this are murky.",
    ANNOUNCE_MAPWRAP_LOSECONTROL = "Oh dear me, I have reached the point of no return.",
    ANNOUNCE_MAPWRAP_RETURN = "I have emerged from the edge of the world.",
    ANNOUNCE_CRAB_ESCAPE = "I was going to make you into a beautiful dinner!",
    ANNOUNCE_TRAWL_FULL = "The net is full!",
	ANNOUNCE_BOAT_DAMAGED = "The vessel is damaged...",
	ANNOUNCE_BOAT_SINKING = "Oh no... I can't die on an empty stomach!",
	ANNOUNCE_BOAT_SINKING_IMMINENT = "Into the soup!",
    ANNOUNCE_WAVE_BOOST = "Whoaaaa!",

	ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "The beast is close.",
	ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "The beast has slipped by me!",
	ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "How can I track anything in this deluge!",
	--
--[[
	BATTLECRY =
	{
		GENERIC = "I'm also an accomplished butcher!",
		PIG = "No part of you will go to waste, cochon!",
		PREY = "You look delicious!",
		SPIDER = "I hope it does not rain after I kill you!",
		SPIDER_WARRIOR = "You will die, pest!",
		DEER = "You've forced my hand!",
	},
	COMBAT_QUIT =
	{
		GENERIC = "There's no shame in running!",
		PIG = "Noooo, those hocks, those chops...",
		PREY = "Whew. I'm out of breath.",
		SPIDER = "I hope it didn't take any bites out of me.",
		SPIDER_WARRIOR = "That could have been worse.",
	},
]]
	DESCRIBE =
	{

		SEAWEED_STALK = "I could plant it for a sustainable source of seaweed.", --copied from the Wikia because I couldn't find it in the game files. -M

--[[
	    MULTIPLAYER_PORTAL = "What fresh devilment is this?",
		MULTIPLAYER_PORTAL_MOONROCK = "It does have quite the elegant glow to it.",
        CONSTRUCTION_PLANS = "A recipe of mad construction.",
        MOONROCKIDOL = "It appears to be some kind of offering.",
        MOONROCKSEED = "I would much rather have this be a distance away from me.",
		ANTLION = 
		{
			GENERIC = "It hungers for something.",
			VERYHAPPY = "Satisfied with our goods.",
			UNHAPPY = "The look in its eyes, the look of being angry and hungry.",
		},
		ANTLIONTRINKET = "A beach toy but without a beach.",
		SANDSPIKE = "Nearly kebab-ed!",
        SANDBLOCK = "I can appreciate good design.",
        GLASSSPIKE = "Glad to still be around to see it.",
        GLASSBLOCK = "Very tasteful.",
]]
		--SWC
		SURFBOARD = "It's as if it constantly drips wetness. I simply do not trust it.",
		CHEFPACK = "My bag of chef's tricks!",

--[[
		ABIGAIL_FLOWER = 
		{ 
			GENERIC = "It's a quite nice vein of flower.",
			LONG = "It's giving off an unsettling aura...",
			MEDIUM = "I don't like it.",
			SOON = "That flower is an apparition!",
			HAUNTED_POCKET = "I best put this away from me!",
			HAUNTED_GROUND = "There's something not quite right with that flower.",
		},

		BALLOONS_EMPTY = "These will need to be inflated to be useful.",
		BALLOON = "It's a fine decoration piece. For a party.",

		BERNIE_INACTIVE =
		{
			BROKEN = "It's been all broken to bits.",
			GENERIC = "It's a bit burnt up but still cuddly to some.",
		},
		BERNIE_ACTIVE = "The teddy bear has started... Moving. Is this a good sign?",
		BERNIE_BIG = "Oh dear me. I nearly thought it was a real grizzly.",
		BOOK_BIRDS = "A book about birds? Without recipes? Not something I'd spend my time on.",
		BOOK_TENTACLES = "A book of cephalopod related recipes perhaps?",
		BOOK_GARDENING = "I prefer my good old book of culinary recipes.",
		BOOK_SLEEP = "It doesn't have any good cooking recipes in it, does it?",
		BOOK_BRIMSTONE = "There's not a single recipe to be found within.",
		
		WAXWELLJOURNAL = "Who in their right mind would ever link their soul within this?",	
		LIGHTER = "Reminds me of sweet gas stoves...",
		LUCY = "A trusty companion of someone's.",
		SPEAR_WATHGRITHR = "For dramatic kebab-ing.",
	    WATHGRITHRHAT = "Dramatic headgear for protecting one's melon.",

        PLAYER =
        {
            GENERIC = "Salutations, %s!",
            ATTACKER = "%s is acting disarrayed.",
            MURDERER = "Murderer! I will not yield, prepare to be filleted!",
            REVIVER = "%s is good to have beside me!",
            GHOST = "We don't want a friend to go to waste do we? I'll cook you up a heart.",
			FIRESTARTER = "%s is having a bit too much fun with flames.",
        },
		WILSON = 
		{
			GENERIC = "Good afternoon, %s!",
			ATTACKER = "%s is not within the right mind.",
			MURDERER = "I will not yield, %s! I'll filet you!",
			REVIVER = "%s is good to have by my side! Cooking is a form of science, no?",
			GHOST = "We don't want a friend to go to waste do we? I'll cook you up a heart.",
			FIRESTARTER = "%s has been playing with fire a bit too loosely.",
		},
		WOLFGANG = 
		{
			GENERIC = "Bonjour, %s!",
			ATTACKER = "I'd best hide from %s. Don't want to be around for that empty stomach!",
			MURDERER = "You must be diced and then sliced, %s!",
			REVIVER = "%s has a heart as big as his appetite!",
			GHOST = "I should like to cook up a strong hearty heart for %s.",
			FIRESTARTER = "%s, be careful with your tools!",
		},
		WAXWELL = 
		{
			GENERIC = "Salutations, %s.",
			ATTACKER = "Back to your old tricks, %s?",
			MURDERER = "No holding back on this one, %s! It's been coming for much too long!",
			REVIVER = "%s has shown they can care for us. It's the little steps!",
			GHOST = "%s is in need of a heart, then again...",
			FIRESTARTER = "You enjoy making yourself out to be the villain, don't you %s?",
		},
		WX78 = 
		{
			GENERIC = "Salutations, %s!",
			ATTACKER = "Stop acting like such a rude contraption, %s.",
			MURDERER = "You're grinding your own gears, %s!",
			REVIVER = "%s can be a good companion... At times.",
			GHOST = "Only now does %s want a heart.",
			FIRESTARTER = "%s, such an effroyable robot.",
		},
		WILLOW = 
		{
			GENERIC = "Good afternoon, %s!",
			ATTACKER = "%s is on the verge of murder. With a hint of flame.",
			MURDERER = "%s, you cannot cook our friends! Away with you!",
			REVIVER = "I'm happy to have %s on my side but a lighter is simply not a stove!",
			GHOST = "I'll have to cook you up a heart, would you like it burnt?",
			FIRESTARTER = "%s burns with an alarming passion.",
		},
		WENDY = 
		{
			GENERIC = "'Allo, %s!",
			ATTACKER = "%s is quite the little troublemaker.",
			MURDERER = "%s is bloodlust! Stand back, I don't want to have to put my foot down!",
			REVIVER = "A good meal always cheers one up, even if for a moment! Right, %s?",
			GHOST = "Before I get you a heart, %s, could you ask if your sister enjoys ghost peppers?",
			FIRESTARTER = "Oh dear. The best fire is a cooking fire, %s!",
		},
		WOODIE = 
		{
			GENERIC = "Bonjour %s!",
			ATTACKER = "%s is stirring up trouble, knock on wood!",
			MURDERER = "%s is now on the chopping block!",
			REVIVER = "Glad to see %s by my side! I'll keep looking for a recipe with logs.",
			GHOST = "I should like to get %s a heart. Are there wooden hearts around?",
			BEAVER = "%s! Are you okay?",
			BEAVERGHOST = "%s is definitely not okay.",
			FIRESTARTER = "What has happened to your love of logs, %s?",
		},
		WICKERBOTTOM = 
		{
			GENERIC = "Salutations, %s!",
			ATTACKER = "%s's morals are becoming disarrayed.",
			MURDERER = "%s must have their books burnt and seared!",
			REVIVER = "%s is good to have by my side! Have you written any cook books yet?",
			GHOST = "I'll fix you up a heart and a nice cup of tea, %s.",
			FIRESTARTER = "I trust you to know what you're doing, %s!",
		},
		WES = 
		{
			GENERIC = "Bonjour, %s!",
			ATTACKER = "%s, would you mind we talk about this?",
			MURDERER = "I shall never cook a gourmet french meal for you once more, %s!",
			REVIVER = "%s always appreciates a good meal.",
			GHOST = "I'll cook you up a fine heart, %s!",
			FIRESTARTER = "I hope you know of the consequences, mon ami!",
		},
		WEBBER = 
		{
			GENERIC = "'Allo, %s!",
			ATTACKER = "%s is stirring up quite the trouble!",
			MURDERER = "I want to believe in accidents, %s, it must be that childish hunger!",
			REVIVER = "%s is always ready to give warm hugs!",
			GHOST = "%s could use a heart and some extra snacks tonight.",
			FIRESTARTER = "Remember, %s, the best fire is a cooking fire!",
		},
		WATHGRITHR = 
		{
			GENERIC = "Salutations, %s!",
			ATTACKER = "I must avoid %s's spear at all costs.",
			MURDERER = "%s shows no sign of stopping... I shall not cook them supper.",
			REVIVER = "%s is great to have by my side! I'd fear otherwise.",
			GHOST = "A valiant warrior should not go to waste, no? I'll cook you up a heart.",
			FIRESTARTER = "%s starts fires quite dramatically.",
		},
		WINONA =
        {
            GENERIC = "Salutations, %s!",
            ATTACKER = "%s's hunger must know of no bounds.",
            MURDERER = "Given the path you've chosen, I will not yield!",
            REVIVER = "%s is great to have beside me, more hands in the kitchen the better!",
            GHOST = "I'm sure %s would care for a finely crafted heart, no?",
			FIRESTARTER = "%s, must you cast sparks near my cooking so?",
        },
		WORTOX =
        {
            GENERIC = "Salutations, %s.",
            ATTACKER = "Stay away, you! I've had enough of your tricks!",
            MURDERER = "You nasty devil! Perhaps I know of a good imp recipe!",
            REVIVER = "I appreciate the help, %s. But must you turn up your nose at my cooking?",
            GHOST = "If I help you, might you try one of my meals at last?",
            FIRESTARTER = "I will surely come up with a recipe for souls if you cease the fire, %s!",
        },
]]
		WALANI = 
		{
		    GENERIC = "Good day, %s!",
	        ATTACKER = "%s, think of the many meals I have made you!",
	        MURDERER = "Murder! I will not yield, %s!",
	        REVIVER = "Always glad to see %s by my side!",
	        GHOST = "I'm sure %s would like many meals and a heart too, no?",
	        FIRESTARTER = "If you cannot stand the heat stay out of the kitchen, %s!",
		},
--[[
	    WARLY = 
		{
	        GENERIC = "How do you do, fellow %s?",
	        ATTACKER = "Is a cooking competition what you want, %s?",
	        MURDERER = "Murder! Now it must be you on the menu!",
	        REVIVER = "%s's work is under-appreciated!",
	        GHOST = "I'm sure %s would enjoy a well prepared ghost pepper.",
	        FIRESTARTER = "I'd never burn anything in the kitchen.",
		},
]]
	    WILBUR = 
		{
	        GENERIC = "Salutations, %s!",
	        ATTACKER = "%s is acting more wild than usual. I think no treats tonight.",
	        MURDERER = "I will not yield, %s! You shall be put on the menu!",
	        REVIVER = "%s is good to have beside me and not my crock pot!",
	        GHOST = "I'll have to cook up a heart and maybe some banana bread for %s.",
	        FIRESTARTER = "%s appears to enjoy burning our things.",
		},
	    WOODLEGS = 
		{
			GENERIC = "Salutations, %s!",
	        ATTACKER = "%s is on the verge of murder. More so than the usual.",
	        MURDERER = "Murder! Time to pirate! Away!",
	        REVIVER = "Always glad to see %s by my side! I wouldn't want an enemy of a pirate.",
	        GHOST = "I should like to fix %s up a heart. I'll need one that loves the sea.",
	        FIRESTARTER = "%s must be on a dangerous plundering with too much fire.",
		},
--[[
        MIGRATION_PORTAL = 
        {
            GENERIC = "This could take me to... strange places.",
            OPEN = "I'm getting dizzy near it...",
            FULL = "There happens to be no room for me.",
        },
		ABIGAIL = "Apparition!",
		ACCOMPLISHMENT_SHRINE = "I always wished to make a name for myself.",
		ACORN = "It rattles.",
        ACORN_SAPLING = "A new beginning...",
		ACORN_COOKED = "This could use something... Anything.",
		ADVENTURE_PORTAL = "What fresh devilment is this?",
		AMULET = "I wear safety.",
		ANCIENT_ALTAR = "A structure from antiquity.",
		ANCIENT_ALTAR_BROKEN = "It is broken.",
		ANCIENT_STATUE = "It gives off strange vibrations.",
		ANIMAL_TRACK = "These tracks point to fresh game.",
		ARMORDRAGONFLY = "Heavy and hot.",
		ARMORGRASS = "How much protection can grass really provide?",
		ARMORMARBLE = "Weighs a ton.",
		ARMORRUINS = "Ancient armor.",
		ARMORSKELETON = "A hearty suit out of hearty stock.",
		SKELETONHAT = "No good could possibly come from wearing this on your head.",
		ARMORSLURPER = "Ah. My appetite wanes under its protection.",
		ARMORSNURTLESHELL = "It allows me to turtle.",
		ARMORWOOD = "Sturdy, but quite flammable.",
		ARMOR_SANITY = "Am I crazy to wear this?",
		ASH =
		{
			GENERIC = "I miss ash covered cheeses. I miss cheeses, period.",
			REMAINS_EYE_BONE = "The eyebone was sacrificed in my travels.",
			REMAINS_GLOMMERFLOWER = "The unusual flower is but ash now.",
			REMAINS_THINGIE = "It is no more.",
		},
		AXE = "A trusty companion in these environs.",
		BABYBEEFALO = 
		{
			GENERIC = "You will fatten up nicely.",
		    SLEEPING = "Wouldn't want to wake it, stress makes meat chewy.",
        },
        BUNDLE = "Valuable ingredients are contained in here.",
        BUNDLEWRAP = "A good food wrap.",
		BACKPACK = "It has my back.",
		BACONEGGS = "Runny eggs... crisp bacon... I could die happy now...",
		BANDAGE = "First aid.",
		BASALT = "Made of strong stuff!",
		BAT = "If I only had a bat...",
		BATBAT = "A gruesome implement.",
		BATWING = "Hmmm, maybe a soup stock of batwings?",
		BATWING_COOKED = "Needs garlic...",
		BATCAVE = "That seems like something I should steer clear of.",
		BEARDHAIR = "Disgusting.",
		BEARGER = "Oh, I don't like you one bit!",
		BEARGERVEST = "Furry refuge from the elements.",
		BEARGER_FUR = "Feels warm.",
		BEDROLL_FURRY = "Cozy.",
		BEDROLL_STRAW = "A little better than bare ground. Scratchy.",
		BEEQUEEN = "I think I'll prefer to partake in honey harvesting elsewhere...",
		BEEQUEENHIVE = 
		{
			GENERIC = "I'd prefer it all in a jar, not the ground.",
			GROWING = "The bees have been cooking up a new home.",
		},
        BEEQUEENHIVEGROWN = "My word, it's huge!",
        BEEGUARD = "Your army cannot protect your sweet honey forever!",
		MINISIGN =
        {
            GENERIC = "Too small for a restaurant sign.",
            UNDRAWN = "I could draw the specials on there.",
        },
        MINISIGN_ITEM = "This would be better off in the ground.",
		HIVEHAT = "I don't consider myself a ruler, but it feels great to be appreciated!",
		BEE =
		{
			GENERIC = "Where there are bees, there is honey!",
			HELD = "Hi, honey.",
		},
		BEEBOX =
		{
			BURNT = "Disastrously caramelized.",
			FULLHONEY = "Honey jackpot!",
			GENERIC = "Home of the honeymakers!",
			NOHONEY = "No more honey...",
			SOMEHONEY = "There is a little honey.",
			READY = "Honey jackpot!",
		},
		MUSHROOM_FARM =
		{
			STUFFED = "A bit overstocked, but more the merrier!",
			LOTS = "I can already taste the soups!",
			SOME = "It's picking up quite well! I'm excited, aren't you?",
			EMPTY = "Let's get it started with a mushroom or spore!",
			ROTTEN = "Looks like it's gone sour, I better clean it up.",
			BURNT = "Charred.",
			SNOWCOVERED = "No mushroom could possibly thrive in this cold.",
		},
		BEEFALO =
		{
			FOLLOWER = "That's it, my friend. I lead, you follow.",
			GENERIC = "Here's the beef.",
			NAKED = "Chin up, it'll grow back.",
			SLEEPING = "The sirloin slumbers...",
			--Domesticated states:
            DOMESTICATED = "This one's quite calm.",
            ORNERY = "It's boiling up!",
            RIDER = "I think I could actually handle this one.",
            PUDGY = "I've spoiled this one with my delicious meals.",
		},
		BEEFALOHAT = "Fits perfectly.",
		BEEFALOWOOL = "The beast's loss is my gain.",
		BEEHAT = "Essential honey harvesting attire.",
		BEESWAX = "A classic protective shield for cheeses and preserved foods!",
		BEEHIVE = "I can hear the activity within.",
		BEEMINE = "Weaponized bees.",
		BEEMINE_MAXWELL = "I pity whoever trips this.",
		BELL = "Should I ring it?",
		BELL_BLUEPRINT = "Fascinating.",
		BERRIES = "Fresh fruit!",
		BERRIES_COOKED = "Could use a pinch of sugar...",
		BERRIES_JUICY = "They spoil at an alarming rate.",
        BERRIES_JUICY_COOKED = "Could use a pinch of sugar.",
		BERRYBUSH =
		{
			BARREN = "They require care and fertilizer.",
			GENERIC = "Berries!",
			PICKED = "More will return.",
			WITHERED = "The heat has stifled these berries.",
			DISEASED = "Why must the plants get sick!",
		    DISEASING = "This plant appears to be curdling.",
			BURNING = "Bushes burn all the same.",
		},
	    BERRYBUSH_JUICY =
		{
			BARREN = "They require care and fertilizer.",
			WITHERED = "The heat spoiled the berries before they did so themselves.",
			GENERIC = "Ripe berries!",
			PICKED = "Maybe I could have preserved them.",
			DISEASED = "Another deathly bush?",
		    DISEASING = "This plant appears to be curdling.",
			BURNING = "Bushes burn all the same.",
		},
		BIGFOOT = "Please do not squish me!",
		BIRCHNUTDRAKE = "What madness is this?",
		BIRDCAGE =
		{
			GENERIC = "Suitable lodgings for a feathered beast.",
			OCCUPIED = "I now have an egg farm!",
			SLEEPING = "Sleep now, lay later.",
			HUNGRY = "Let me cook something nice up for you.",
			STARVING = "Oh, what do birds eat? A nice brisket?",
			DEAD = "Maybe it will wake up.",
			SKELETON = "It is not waking up. Oh dear.",
		},
		BIRDTRAP = "Oh, roast bird! Hm, don't get ahead of yourself, Warly...",
		BIRD_EGG = "Nature's perfect food.",
		BIRD_EGG_COOKED = "Could use a few different herbs...",
		BISHOP = "You don't strike me as particularly spiritual.",
		BISHOP_NIGHTMARE = "You are grinding my gears, dear fellow.",
		BLOWDART_FIRE = "Breathing fire!",
		BLOWDART_FLUP = "How considerate of that dead thing!",
		BLOWDART_PIPE = "They won't know what hit them.",
		BLOWDART_SLEEP = "A sleep aid!",
		BLOWDART_YELLOW = "It's as electrifying as it is a quick cooker.",
		BLUEAMULET = "Brrrrrr!",
		BLUEGEM = "Such a cool blue.",
		BLUEPRINT = 
		{ 
            COMMON = "A recipe for technology!",
            RARE = "You don't see recipes like this just anywhere!",
        },
		SKETCH = "Share your recipes with another mind.",
		BLUE_CAP = "What deliciousness shall you yield?",
		BLUE_CAP_COOKED = "Could use a dash of smoked salt and balsamic vinegar...",
		BLUE_MUSHROOM =
		{
			GENERIC = "Ah, a blue truffle!",
			INGROUND = "It retreats from the light.",
			PICKED = "I hope the truffles are restocked soon.",
		},
		BOARDS = "Sigh. It would be so perfect for grilling salmon.",
		BONESHARD = "I could make a hearty stock with these.",
		BONESTEW = "Warms my soul!",
		BOOMERANG = "Oh good. I have separation anxiety.",
		BUGNET = "For catching alternative protein.",
		BUNNYMAN = "I have so many good rabbit recipes...",
		BUSHHAT = "Snacks to go?",
		BUTTER = "I thought I would never see you again, old friend!",
		BUTTERFLY =
		{
			GENERIC = "Your aerial dance is so soothing to behold...",
			HELD = "Don't slip from my butterfingers.",
		},
		BUTTERFLYMUFFIN = "Delectable!",
		BUTTERFLYWINGS = "I wonder what dishes I could create with these?",
		BUZZARD = "If only you were more turkey than vulture...",
		SHADOWDIGGER = "I don't like you... Not one bit.",
		
		CACTUS =
		{
			GENERIC = "I bet it has a sharp flavor.",
			PICKED = "It will live to prick again.",
		},
		CACTUS_FLOWER = "Such a pretty flower from such a prickly customer!",
		CACTUS_MEAT = "I hope it does not prickle going down.",
		CACTUS_MEAT_COOKED = "Could use some tortillas and melted queso...",
		CAMPFIRE =
		{
			EMBERS = "I should stoke the fire.",
			GENERIC = "To keep the dark at bay.",
			HIGH = "Rivals a grease fire!",
			LOW = "It is getting low.",
			NORMAL = "I should like to sit by you for a moment.",
			OUT = "I will have to light you again.",
		},
		CANE = "Now we are cooking with gas!",
		CARROT = "Fresh picked produce!",
		CARROT_COOKED = "Could use a dash of olive oil and cilantro...",
		CARROT_PLANTED = "Ah, a fresh carrot!",
		CARROT_SEEDS = "Future carrots!",
		CARTOGRAPHYDESK = 
		{	
			GENERIC = "A beautiful map on a beautiful finished desk! Humanity!",
			BURNING = "Why must this place be so cruel?",
			BURNT = "Ah, such a shame. Au revoir.",
		},
		CATCOON = "What perky little ears.",
		CATCOONDEN =
		{
			EMPTY = "Vacant of critters.",
			GENERIC = "How many critters can fit in there?",
		},
		CATCOONHAT = "Not quite my style.",
		CAVE_BANANA = "Just the flavor I needed!",
		CAVE_BANANA_COOKED = "Could use some oats and a few chocolate chips...",
		CAVE_BANANA_TREE = "There must be monkeys close by.",	
        CAVE_ENTRANCE = "I wonder what's underneath that?",
        CAVE_ENTRANCE_RUINS = "I don't care to find out what lies beneath.",
       
       	CAVE_ENTRANCE_OPEN = 
        {
            GENERIC = "Darn.",
            OPEN = "Dare I?",
            FULL = "I wasn't too excited to hop down there any how.",
        },
        CAVE_EXIT = 
        {
            GENERIC = "I should like to see the surface again.",
            OPEN = "Thank goodness.",
            FULL = "What the devil? Let me up!",
        },
		
		CAVE_FERN = "How does anything grow down here?",
		CHARCOAL = "This, a grill and some meat and I'd have dinner.",
		CHESSPIECE_PAWN = 
        {
		GENERIC = "Pawns can do a lot if given the chance.",
		},
        CHESSPIECE_ROOK = 
        {
			GENERIC = "Simply decorative.",
			STRUGGLE = "Something's cooking up!",
		},
        CHESSPIECE_KNIGHT = 
        {
			GENERIC = "A trusty stone steed.",
			STRUGGLE = "Something's cooking up!",
		},
        CHESSPIECE_BISHOP = 
        {
			GENERIC = "Simply decorative.",
			STRUGGLE = "Something's cooking up!",
		},
		CHESSPIECE_MUSE = "It's a very intimidating piece.",
        CHESSPIECE_FORMAL = "Not much of a king without a heavy head.",
        CHESSPIECE_HORNUCOPIA = "A masterpiece! Despite its in-edibleness I enjoy its presence.",
        CHESSPIECE_PIPE = "Never thought I'd see such a peculiar piece out here.",
        CHESSPIECE_DEERCLOPS = "I'm not too comfortable cooking around that.",
        CHESSPIECE_BEARGER = "Not my favorite memoir piece.",
        CHESSPIECE_MOOSEGOOSE = "The beast's stone-meats are a mockery.",
        CHESSPIECE_DRAGONFLY = "Could we get a sculpture of a less bad memory?",
		CHESSJUNK1 = "Broken chess pieces?",
		CHESSJUNK2 = "More broken chess pieces?",
		CHESSJUNK3 = "And yet more broken chess pieces?",
		CHESTER = "You look cute and inedible.",
		CHESTER_EYEBONE =
		{
			GENERIC = "The eye follows me wherever I go...",
			WAITING = "It sleeps.",
		},
		COLDFIRE =
		{
			EMBERS = "I should stoke the fire.",
			GENERIC = "Fire that cools?",
			HIGH = "The flames climb higher!",
			LOW = "It's getting low.",
			NORMAL = "I should like to sit by you for a moment.",
			OUT = "I will have to light you again.",
		},
		COLDFIREPIT =
		{
			EMBERS = "I should stoke the fire.",
			GENERIC = "Fire that cools?",
			HIGH = "The flames climb higher!",
			LOW = "It's getting low.",
			NORMAL = "I should like to sit by you for a moment.",
			OUT = "I will have to light you again.",
		},
		COMPASS =
		{
			E = "East.",
			GENERIC = "Hmm, no reading.",
			N = "North.",
			NE = "Northeast.",
			NW = "Northwest.",
			S = "South.",
			SE = "Southeast.",
			SW = "Southwest.",
			W = "West.",
		},
		COOKEDMANDRAKE = "Could use horseradish...",
		COOKEDMEAT = "Could use a chimichurri sauce...",
		COOKEDMONSTERMEAT = "Could use... uh... I don't even...",
		COOKEDSMALLMEAT = "Could use sea salt...",
		COOKPOT = 
		{
			BURNT = "Tragique.",
			COOKING_LONG = "A masterpiece takes time.",
			COOKING_SHORT = "Nearly there...",
			DONE = "Ahh, fini!",
			EMPTY = "Empty pot, empty heart.",
		},
		COONTAIL = "Chat noodle.",
		CORN = "Corn! Sweet, sweet corn!",
		CORN_COOKED = "Could use miso and lardons...",
		CORN_SEEDS = "The promise of so many more corn dishes!",
		CANARY =
		{
			GENERIC = "I won't be cooking you up any time soon.",
			HELD = "You're a very lovely bird.",
		},
		CANARY_POISONED = "I'll keep a distance.",
		CRITTERLAB = "There's creatures in that den, scurrying about.",
        CRITTER_GLOMLING = "Unbelievably adorable, and such grace!",
        CRITTER_DRAGONLING = "I could use your help cooking, my friend!",
		CRITTER_LAMB = "You're so adorable I could gobble you right up! I won't, of course.",
        CRITTER_PUPPY = "I don't suppose you'll be wanting my scraps?",
        CRITTER_KITTEN = "A very cute companion, brings a smile to one's face!",
		CRITTER_PERDLING = "I won't be gobbling you up, but you surely will be gobbling it up.",
		
		CROW =
		{
			GENERIC = "Raven stew perhaps?",
			HELD = "Hush, my pet.",
		},
		CUTGRASS = "What shall I craft?",
		CUTLICHEN = "Hmm, odd.",
		CUTREEDS = "Smells like greenery.",
		CUTSTONE = "Compressed stones, nice presentation.",
		DEADLYFEAST = "I would not recommend this.",
		DECIDUOUSTREE =
		{
			BURNING = "Au revoir, tree.",
			BURNT = "Crisp, no?",
			CHOPPED = "Sliced!",
			GENERIC = "A bouquet of leaves.",
			POISON = "No thank you!",
		},
		DEER = 
		{
			GENERIC = "It's been a long while since I last had deer...",
			ANTLER = "What a stunning specimen.",
		},
		DEER_ANTLER = "Well, I hope it doesn't miss it.",
        DEER_GEMMED = "Goodness, it's being controlled like some sort of puppet!",
		DEERCLOPS = "I once had a saucier who looked like that.",
		DEERCLOPS_EYEBALL = "Giant eyeball... soup?",
		DEPLETED_GRASS =
		{
			GENERIC = "Well past its expiry date.",
		},
		GOGGLESHAT = "Tres cool.",
        DESERTHAT = "Anything to keep sand out of my dinner!",
		DEVTOOL = "Efficient, oui?",
		DEVTOOL_NODEV = "No, I am a traditionalist.",
		DIRTPILE = "It's making a bit of a mess, isn't it?",
		DIVININGROD =
		{
			COLD = "Hmm, keep looking.",
			GENERIC = "A finely tuned radar stick.",
			HOT = "I can almost smell it!",
			WARM = "I've caught onto something!",
			WARMER = "Warmer, warmer...!",
		},
		DIVININGRODBASE =
		{
			GENERIC = "Is it a chopping block?",
			READY = "How do I turn it on?",
			UNLOCKED = "Preparation complete!",
		},
		DIVININGRODSTART = "That looks important.",
		DRAGONFLY = "I'm not cut out for this.",
		DRAGONFLYCHEST = "Ooh la la, burnproof storage.",
		DRAGONFLYFURNACE = 
		{
			HAMMERED = "Uh, something has been put out of order here...",
			GENERIC = "A spicy furnace, I'll gladly enjoy its presence!", --no gems
			NORMAL = "It's just getting started!", --one gem
			HIGH = "Scalding hot!", --two gems
		},
		DRAGONFRUIT = "So exotic!",
		DRAGONFRUIT_COOKED = "Could use a spread of pudding and chia seeds...",
		DRAGONFRUIT_SEEDS = "They hatch dragonfruits.",
		DRAGONPIE = "Flaky crust, tart filling... heavenly!",
		DRAGON_SCALES = "Hot to the touch!",
		DRUMSTICK = "Dark meat!",
		DRUMSTICK_COOKED = "Could use a light honey garlic glaze...",
		DUG_BERRYBUSH = "Shall I bring it back to life?",
		DUG_BERRYBUSH_JUICY = "Shall I bring it back to life?",
		DUG_GRASS = "Shall I bring it back to life?",
		DUG_MARSH_BUSH = "Shall I bring it back to life?",
		DUG_SAPLING = "Shall I bring it back to life?",
		DURIAN = "That odor...",
		DURIAN_COOKED = "Could use onions and chili...",
		DURIAN_SEEDS = "Even these smell...",
		EARMUFFSHAT = "Ahh, fuzzy!",
		EEL = "Anguille.",
		EEL_COOKED = "Could use some cajun spices...",
		EGGPLANT = "Aubergine!",
		EGGPLANT_COOKED = "Could use tomato sauce and Parmesan...",
		EGGPLANT_SEEDS = "Hatches more eggplants!",
		
		ENDTABLE = 
		{
			BURNT = "I assume someone got a little too paranoid of that thing.",
			GENERIC = "It looks much nicer now that it no longer has suspicious intentions.",
			EMPTY = "It awaits embellishments.",
			WILTED = "It has seen better days.",
			FRESHLIGHT = "Perfect dinner light.",
			OLDLIGHT = "I'd prefer it not to fade, we must refuel it!",
		},
		EVERGREEN =
		{
			BURNING = "Au revoir, tree.",
			BURNT = "Crisp, no?",
			CHOPPED = "Sliced!",
			GENERIC = "A soldier of the exotic forest.",
		},
		EVERGREEN_SPARSE =
		{
			BURNING = "Au revoir, tree.",
			BURNT = "Crisp, no?",
			CHOPPED = "Sliced!",
			GENERIC = "A coneless arbre.",
		},
		EYEBRELLAHAT = "\"Eye\" like it!",
		TWIGGYTREE = 
		{
			BURNING = "Au revoir, stick-tree.",
			BURNT = "Crisp, no?",
			CHOPPED = "Sliced!",
			GENERIC = "A soldier of continued survival.",			
			DISEASED = "It must be raw.",
		},
		TWIGGY_NUT_SAPLING = "It's growing up well!",
        TWIGGY_OLD = "That tree is undercooked.",
		TWIGGY_NUT = "It'll be a thin tree someday.",
		EYEPLANT = "Alluring, no?",
		INSPECTSELF = "I ought to cook up something make me look younger.",
		EYETURRET = "This is my friend, Lazer Oeil!",
		EYETURRET_ITEM = "Wake up!",
		FARMPLOT =
		{
			BURNT = "Stayed in the oven a tad too long.",
			GENERIC = "I can grow my own ingredients!",
			GROWING = "Ah, couldn't be more fresh!",
			NEEDSFERTILIZER = "Needs to be fertilized.",
		},
		FEATHERFAN = "Why is it so big?",
		MINIFAN = "Like a cool ocean breeze.",
		FEATHERHAT = "What am I supposed to do with this?",
		FEATHER_CROW = "A bird's feather, in truffle black.",
		FEATHER_ROBIN = "A bird's feather, in cherry red.",
		FEATHER_ROBIN_WINTER = "A bird's feather, in tuna blue.",
		FEATHER_CANARY = "A bird's feather, in cheddar yellow.",
	    FEATHERPENCIL = "A proper writing tool! I may be able to start writing down recipes again!",
		FEM_PUPPET = "She's trapped!",
		FERTILIZER = "Sauce for my garden!",
		FIREFLIES =
		{
			GENERIC = "A dash of glow.",
			HELD = "My petit lightbulb pets.",
		},
		FIREHOUND = "Chien, on fire!",
		FIREPIT =
		{
			EMBERS = "That fire's almost out!",
			GENERIC = "To warm my fingers and roast sausages.",
			HIGH = "Maximum heat!",
			LOW = "It's getting low.",
			NORMAL = "Parfait.",
			OUT = "I like when it's warm and toasty.",
		},
		FIRESTAFF = "Oven on a stick!",
		FIRESUPPRESSOR =
		{
			LOWFUEL = "Shall I fuel it up?",
			OFF = "He's sleeping.",
			ON = "Make it snow!",
		},
		FISH = "Poisson!",
		FISHINGROD = "I believe I prefer the fish market.",
		FISHSTICKS = "Crunchy and golden outside, flaky and moist inside!",
		FISHTACOS = "Takes me south of the border!",
		FISH_COOKED = "Could use a squeeze of lemon...",
		FISH_RAW = "Doesn't even smell fishy it's so fresh!",
		FLINT = "Sharp as can be!",
		FLOWER = 
		{
            GENERIC = "Charmant.",
            ROSE = "That could help fancy up a dinner.",
        },
		FLOWER_WITHERED = "That flower's been burnt to crisp.",
		FLOWERHAT = "Who doesn't look good in this?!",
		FLOWERSALAD = "Edible art!",
		FLOWER_CAVE = "Ah, a light in the dark.",
		FLOWER_CAVE_DOUBLE = "Ah, a light in the dark.",
		FLOWER_CAVE_TRIPLE = "Ah, a light in the dark.",
		FLOWER_EVIL = "A terrible omen if I ever saw one.",
		FOLIAGE = "Feuillage.",
		FOOTBALLHAT = "Made from pork, to protect my melon.",
	    FOSSIL_PIECE = "Seems a bit too ancient to use for stock.",
        FOSSIL_STALKER =
        {
			GENERIC = "Some more ingredients are yet to be put into place.",
			FUNNY = "That's a mixed flavor meal.",
			COMPLETE = "Can we truly rebuild what was once lost?",
        },
		STALKER = "I can feel my feet shaking in my boots!",
		STALKER_ATRIUM = "I can't take the heat! Get me out of this kitchen!",
        STALKER_MINION = "That should not exist!",
		THURIBLE = "It's heated like a crock pot.",
        ATRIUM_OVERGROWTH = "I couldn't possibly decipher that.",
		FROG =
		{
			DEAD = "I'll eat your legs for dinner!",
			GENERIC = "Frog. A delicacy.",
			SLEEPING = "Bonne nuit, little snack.",
		},
		FROGGLEBUNWICH = "Ah, French cuisine!",
		FROGLEGS = "I am hopping with excitement!",
		FROGLEGS_COOKED = "Could use garlic and clarified butter...",
		FRUITMEDLEY = "Invigorating!",
		FURTUFT = "It's some frayed away fur.", 
		GEARS = "The insides of those naughty machines.",
		GEMSOCKET =
		{
			GEMS = "Gem it!",
			VALID = "Voilà!",
		},
		GHOST = "Could I offer you a ghost pepper?",
		GLOMMER = "I think I like it.",
		GLOMMERFLOWER =
		{
			DEAD = "What a waste.",
			GENERIC = "Tres beau!",
		},
		GLOMMERFUEL = "Looks like bubblegum, tastes like floor.",
		GLOMMERWINGS = "A tiny delicacy.",
		GOATMILK = "Can I make this into cheese?",
		GOLDENAXE = "A golden chopper!",
		GOLDENMACHETE = "Fancy slicer.",
		GOLDENPICKAXE = "That looks nice.",
		GOLDENPITCHFORK = "A golden fork for a giant, oui?",
		GOLDENSHOVEL = "Shiny.",
		GOLDNUGGET = "Yolk yellow, glowing gold!",
		GOOSE_FEATHER = "A plucked goose was here.",
		GRASS =
		{
			BARREN = "Could I get some fertilizer over here?",
			BURNING = "I never burn anything in the kitchen.",
			GENERIC = "A common ingredient for success around here.",
			PICKED = "Plucked clean!",
			WITHERED = "Too hot for you.",
		    DISEASED = "I must keep that plant away from my food!",
			DISEASING = "That plant appears to be spoiling.",
		},
		GRASSGEKKO = 
		{
			GENERIC = "I could cook up such unique things with you.",	
			DISEASED = "It would make me sick to use them in a meal.",
		},
		GRASS_UMBRELLA = "A bit of shade is better than none.",
		GREENAMULET = "For more savvy construction!",
		GREENGEM = "Ahh, a rare attraction!",
		GREENSTAFF = "I probably shouldn't stir soup with this.",
		GREEN_CAP = "Don't crowd the mushrooms.",
		GREEN_CAP_COOKED = "Could use a slathering of butter and chives...",
		GREEN_MUSHROOM =
		{
			GENERIC = "Little champignon!",
			INGROUND = "Did it eat itself...?",
			PICKED = "I eagerly await its rebirth!",
		},
		GUACAMOLE = "More like Greatamole!",
		GUANO = "Poop of the bat.",
		GUNPOWDER = "Boom!",
		HAMBAT = "Mmm, ham popsicle!",
		HAMMER = "For tenderizing boeuf!",
		HAWAIIANSHIRT = "When in Rome...",
		HEALINGSALVE = "Soothing.",
		HEATROCK =
		{
			COLD = "Still cold.",
			FROZEN = "Vanilla ice.",
			GENERIC = "A temperature stone.",
			HOT = "Hot!",
			WARM = "It's warming up nicely.",
		},
		HOME = "Who lives here?",
		HOMESIGN =
		{
			BURNT = "Overcooked.",
		    UNWRITTEN = "There nothing on it to be read.",
			GENERIC = "What's the use in a sign around here?",
		},
		ARROWSIGN_POST =
		{
			GENERIC = "It marks \"Thataway\".",
            UNWRITTEN = "Directional potential.",
			BURNT = "Crisp, no?",
		},
		ARROWSIGN_PANEL =
		{
			GENERIC = "It marks \"Thataway\".",
            UNWRITTEN = "Directional potential.",
			BURNT = "Crisp, no?",
		},
		HONEY = "Nectar of the gods!",
		HONEYCOMB = "Just add milk!",
		HONEYHAM = "Comfort food!",
		HONEYNUGGETS = "Junk food is my guilty pleasure. Shh!",
		HORN = "There's still some hairs inside.",
		HOTCHILI = "Spice up my life!",
		HOUND = "Angry chien!",
		HOUNDBONE = "Hmm, soup stock...",
		HOUNDFIRE = "Fire in the kitchen!",
		HOUNDMOUND = "It smells wet.",
		HOUNDSTOOTH = "Better to lose a tooth than your tongue!",
		ICE = "That's ice.",
		ICEBOX = "The ice box, my second-most loyal culinary companion.",
		ICECREAM = "The heat is sweetly beat!",
		ICEHAT = "Must I wear it?",
		ICEHOUND = "Away, frozen diable!",
		ICEPACK = "Now this I can use!",
		ICESTAFF = "It flash freezes poulet!",
		INSANITYROCK =
		{
			ACTIVE = "And I'm in!",
			INACTIVE = "Do not lick it. Your tongue will get stuck.",
		},
		JAMMYPRESERVES = "Simple, sweet, parfait.",
		KABOBS = "Opa!",
		KILLERBEE =
		{
			GENERIC = "Almost not worth the honey!",
			HELD = "So sassy!",
		},
		KNIGHT = "A tricky cheval!",
		KNIGHT_NIGHTMARE = "Effroyable!",
		KOALEFANT_SUMMER = "Ah, you have fattened up nicely!",
		KOALEFANT_WINTER = "You can't get attached to cute cuts of meat.",
		KRAMPUS = "What the devil!",
		KRAMPUS_SACK = "Infinite pocket space!",
		LANTERN = "It is my night light.",
		--LAVAPOOL = "Spicy!",	
		HUTCH = "You look mildly cute and inedible.",
        HUTCH_FISHBOWL =
        {
            GENERIC = "That's something to tell the folks.",
            WAITING = "Is it alive?",
        },
		LAVASPIT =
		{
			COOL = "The top has cooled like a barfy creme brulee!",
			HOT = "A chef-cuisinier never burns his fingers.",
		},
		LAVA_POND = "Spicy!",
		LAVAE_COCOON = "It appears to have cooled down.",
		LAVAE = "Too hot for eating.",
		LAVAE_PET = 
		{
			STARVING = "It's getting fiery.",
			HUNGRY = "I should like to share my food with it.",
			CONTENT = "A happy customer.",
			GENERIC = "Since it is not edible it shall make a good pet.",
		},
		LAVAE_EGG = 
		{
			GENERIC = "I can only imagine what my sous chef would think of it.",
		},
		LAVAE_EGG_CRACKED =
		{
			COLD = "The egg need proper insulation.",
			COMFY = "The eggs seems... pleased.",
		},
		LAVAE_TOOTH = "Tooth of an...egg.",

		LEIF = "I'm out of my element!",
		LEIF_SPARSE = "I'm out of my element!",
		LICHEN = "Really scraping the barrel for produce here.",
		LIGHTBULB = "Looks like candy.",
		LIGHTNINGGOAT =
		{
			CHARGED = "Goat milkshake!",
			GENERIC = "I had a goat once.",
		},
		LIGHTNINGGOATHORN = "For kabobs, perhaps?",
		LIGHTNING_ROD =
		{
			CHARGED = "Electricity!",
			GENERIC = "I do feel a bit safer now.",
		},
		LITTLE_WALRUS = "Oh, there's a little one!",
		LIVINGLOG = "Magic building blocks!",
		LIVINGTREE = "Tres suspicious...",
		LOCKEDWES = "I'll get you out, mon ami!",
		
		LOG =
		{
			BURNING = "Soon it won't be good for much.",
			GENERIC = "An important aspect of my art.",
		},
		LUREPLANT = "How alluring.",
		LUREPLANTBULB = "Growing meat from the ground? Now I've seen it all...",
		MANDRAKE =
		{
			DEAD = "I should like to get to the root of this mystery...",
			GENERIC = "Have I discovered a new root vegetable?!",
			PICKED = "Do not pick! Do not pick!",
		},
		MANDRAKESOUP = "What an otherworldly flavor!",
		MANDRAKE_COOKED = "Could use... an explanation...",
		MAPSCROLL = "No recipe in sight.",
		MARBLE = "Would make a nice counter top.",
		MARBLEBEAN = "I'll handle it with care.",
		MARBLEBEAN_SAPLING = "Simply unnatural.",
        MARBLESHRUB = "I don't quite understand it, but I'll let it pass.",
		MARBLEPILLAR = "I wonder how many counter tops I could get out of this...",
		MARSH_BUSH =
		{
			BURNING = "It burns like any other bush.",
			GENERIC = "A prickly customer.",
			PICKED = "Not sure I want to do that again.",
		},
		MARSH_PLANT = "I wonder if it is edible.",
		MARSH_PLANT_TROPICAL = "I wonder if it is edible.",
		MARSH_TREE =
		{
			BURNING = "You will not be missed.",
			BURNT = "The wood gives off a unique aroma when burned.",
			CHOPPED = "There. Now you cannot prick anyone.",
			GENERIC = "I am ever so glad I'm not a tree hugger.",
		},
		MAXWELL = "You! You... villain!",
	    MAXWELLHEAD = "He must eat massive sandwiches.",
		MAXWELLLIGHT = "A light is always welcome.",
		MAXWELLLOCK = "But where is the key?",
		MAXWELLPHONOGRAPH = "I wonder what is in his record collection?",
		MAXWELLTHRONE = "Heavy is the bum that sits on the throne...",
		MEAT = "I must remember to cut across the grain.",
		MEATBALLS = "I'm having a ball!",
		MEATRACK =
		{
			BURNT = "Too dry! Too dry!",
			DONE = "Ready to test on my teeth!",
			DRYING = "Not quite dry enough.",
			DRYINGINRAIN = "Now it is more like a rehydrating rack...",
			GENERIC = "Just like the chefs of the stone age!",
		},
		MEAT_DRIED = "Could use chipotle...",
		MERM = "Fishmongers!",
		MERMFISHER = "You bring the sea with you.",
		MERMHEAD =
		{
			BURNT = "I think it needs to burned again! Pee-eew!",
			GENERIC = "Its odor is not improving with time...",
		},
		MERMHOUSE =
		{
			BURNT = "That fire got the smell out.",
			GENERIC = "Fisherfolk live here. I can smell it.",
		},
		MINERHAT = "Aha! Now that is using my head!",
		MINOTAUR = "Stay away!",
		MINOTAURCHEST = "I appreciate the attention to its aesthetic detail.",
		MINOTAURHORN = "I wonder, if ground up into a powder...",
		MOLE =
		 {
		 	ABOVEGROUND = "Are you spying on me?",
		 	HELD = "Do you \"dig\" your new surroundings?",
		 	UNDERGROUND = "Something dwells beneath.",
		 },
		MOLEHAT = "Neat vision!",
		MOLEHILL = "It is a nice hill, but I won't make a mountain of it.",
		MONKEY = "A new species of irritation.",
		MONKEYBARREL = "An absolute madhouse.",
		MONSTERLASAGNA = "What a wasted effort...",
		MONSTERMEAT = "Hmmm, nice marbling...",
		MONSTERMEAT_DRIED = "Could use... better judgment...",
		MOOSE = "I wish you were a bit less moose-y and a lot more goose-y!",
		MOOSEEGG = "I think I'll leave this egg quite alone!",
		MOSQUITO =
		{
			GENERIC = "We disagree on where my blood is best used.",
			HELD = "I do not care to be this close to it! Vile!",
		},
		MOSQUITOSACK = "Ugh! It can only be filled with one thing.",
		MOSQUITOSACK_YELLOW = "Ugh! It can only be filled with one thing.",
		MOSQUITO_POISON = "You not only take, but you also give? Well, no thanks!",
	    MOSSLING = "Looking for your momma? Apologies, but I hope you do not find her.",
		MOUND =
		{
			DUG = "What have I become?",
			GENERIC = "I cannot help wondering what might be down there.",
		},
		MULTITOOL_AXE_PICKAXE = "Oh, I get it! Kind of like a spork!",
        MUSHROOMHAT = "Edible fashion!",
        MUSHROOM_LIGHT2 =
        {
            ON = "This food-light should keep us company!",
            OFF = "It could use a dash of freshly ground pepper... Is it still technically food?",
            BURNT = "Somebody overcooked it.",
        },
        MUSHROOM_LIGHT =
        {
            ON = "It's a very calming light, with an accompanying mushroom scent.",
            OFF = "Food can do wonders!",
            BURNT = "Crisp mushroom, I would have done better.",
        },
		SLEEPBOMB = "Don't inhale the spores!",
        MUSHROOMBOMB = "It's not my area of expertise, better keep a distance.",
        SHROOM_SKIN = "I'll have to think up a special recipe for this.",
        TOADSTOOL_CAP =
        {
            EMPTY = "An empty hole within the earth.",
            INGROUND = "I spot something moving about.",
            GENERIC = "I hoping that it doesn't contain any toxins.",
        },
        TOADSTOOL =
        {
            GENERIC = "Your meats must definitely be hazardous.",
            RAGE = "I wasn't intending to do so, but he seems to be cooking himself.",
        },
        MUSHROOMSPROUT =
        {
            GENERIC = "I'll not be cooking that!",
            BURNT = "Looks as if someone tried to cook it, but I wouldn't recommend using it in a stock.",
        },
        MUSHTREE_TALL =
        {
            GENERIC = "Oh, divine tree of mushrooms... what else can you teach me?",
            BLOOM = "I'll need some strong spices to cover the stench.",
        },
        MUSHTREE_MEDIUM =
        {
            GENERIC = "I have seen the light. Mushrooms do indeed grow on trees.",
            BLOOM = "I'll have to wait until it's well enough to use for soup.",
        },
        MUSHTREE_SMALL =
        {
            GENERIC = "Surely mushrooms do not grow on trees here?",
            BLOOM = "Best not to cook with it at the moment.",
        },
        MUSHTREE_TALL_WEBBED = "That's a sign of danger if I've ever seen one.",
        SPORE_TALL = "Such a calming seed.",
        SPORE_MEDIUM = "What a beautiful shade of red!",
        SPORE_SMALL = "Not for cooking of any sort.",
        SPORE_TALL_INV = "Don't fret, I shall not be using you for soup stock.",
        SPORE_MEDIUM_INV = "Don't fret, I shall not be using you for soup stock.",
        SPORE_SMALL_INV = "Don't fret, I shall not be using you for soup stock.",
		NEEDLESPEAR = "Who shall I stick it to?",
		NIGHTLIGHT = "And I thought fluorescent tubes were a bad invention!",
		NIGHTMAREFUEL = "Who in their right mind would want to fuel MORE nightmares?",
		NIGHTMARELIGHT = "Am I crazy or is this light not helping my situation?",
		NIGHTMARE_TIMEPIECE =
		 {
		 	CALM = "It appears that all is well.",
		 	DAWN = "This nightmare is almost over!",
		 	NOMAGIC = "Magicless.",
		 	STEADY = "Steady on.",
		 	WANING = "Subsiding.",
		 	WARN = "I feel some magic coming on!",
		 	WAXING = "Magic hour!",
		 },
		NIGHTSTICK = "I feel electric!",
		NIGHTSWORD = "This thing slices like a dream!",
		NITRE = "How curious.",
		OBSIDIAN = "Hot rock!",
		ONEMANBAND = "What a racket!",
		OASISLAKE = 
		{
			GENERIC = "It traps trinkets.",
			EMPTY = "Quite the sand pit... Strangely familiar.",
		},
		ORANGEAMULET = "Here one minute, gone the next!",
		ORANGEGEM = "I miss oranges...",
		ORANGESTAFF = "When I hold it it makes the world feel... fast.",
		OPALSTAFF = "Holding it would sure make one feel important.",
        OPALPRECIOUSGEM = "Such an elegant gem.",
		PANDORASCHEST = "It's quite magnificent.",
		PANFLUTE = "This will be music to something's ears.",
		PAPYRUS = "I could write down my recipes on this.",
		WAXPAPER = "Wax paper! Always useful in the kitchen.",
		PARROT = "I can't recall any parrot recipes...",
		PEACOCK = "Pea-ka-boo!",
		PENGUIN = "A cool customer.",
		PEROGIES = "Mmmmm, pockets of palate punching pleasure!",
		PETALS = "Great in salads.",
		PETALS_EVIL = "Not so great in salads.",
		PICKAXE = "For those tough to crack nuts.",
		PIGGUARD = "What are you guarding, besides your own deliciousness?",
		PIGGYBACK = "Cochon bag!",
		PIGHEAD =
		{
			BURNT = "Not even the cheeks are left...",
			GENERIC = "Ooh la la, the things I could do with you!",
		},
		PIGHOUSE =
		{
			BURNT = "Mmmm, barbecue!",
			FULL = "Looks like more than three little piggies in there.",
			GENERIC = "Can I blow this down?",
			LIGHTSOUT = "Yoo hoo! Anybody home?",
		},
		PIGKING = "Well, you've got the chops for it.",
		PIGMAN =
		{
			DEAD = "He wouldn't want himself to go to waste, would he?",
			FOLLOWER = "I do have a magnetic presence, do I not?",
			GENERIC = "Who bred you to walk upright like that? Deuced unsettling...",
			GUARD = "Alright, alright, moving along.",
			WEREPIG = "Aggression spoils the meat.",
		},
		PIGSKIN = "Crackling!",
		PIGTENT = "Sure to deliver sweet dreams.",
		PIGTORCH = "I wonder what it means?",
		PIKE_SKULL = "Yeeouch!",
		PINECONE = "Pine-scented!",
        PINECONE_SAPLING = "One day you'll be a tree.",
		LUMPY_SAPLING = "Despite the odds, it has produced life.",
		PITCHFORK = "Proper farm gear.",
		PLANTMEAT = "Meaty leaves? I'm so confused...",
		PLANTMEAT_COOKED = "Could use less oxymorons...",
		PLANT_NORMAL =
		{
			GENERIC = "The miracle of life!",
			GROWING = "That is it, just a little more...",
			READY = "Fresh-picked produce!",
			WITHERED = "Oh dear me, the crop has failed...",
		},
		POISONHOLE = "I smell trouble...",
		POMEGRANATE = "Wonderful!",
		POMEGRANATE_COOKED = "Could use tahini and mint...",
		POMEGRANATE_SEEDS = "Seedy seeds!",
		POND = "I can't see the bottom...",
		POND_ALGAE = "I can't see the bottom...",
		POOP = "The end result of a fine meal.",
		PORTABLECOOKPOT_ITEM = "What new culinary adventures shall we undertake, old friend.",
		PORTABLECOOKPOT =
		{
            --BURNT = "Nononononono whyyyyyyyyyyyyyyy!?",
			COOKING_LONG = "The flavors need time to meld.",
            COOKING_SHORT = "I threw that meal together!",
            DONE = "Pickup! Oh, old habits...",
            EMPTY = "I would never leave home without it!",
        },
	    GIFT = "Réchauffe le coeur...", --Warms the heart...
        GIFTWRAP = "I'm sure wrapping a gift is much like wrapping up leftovers.",
		POTTEDFERN = "Nature. Tamed.",
		SUCCULENT_POTTED = "Nature. Tamed.",
		SUCCULENT_PLANT = "Pretty plant produce.",
		SUCCULENT_PICKED = "How edible might this possibly be?",
		SENTRYWARD = "A structure for watching the area... Not my preferred choice of home décor.",
		TOWNPORTAL =
        {
			GENERIC = "I can easily gather everyone around for supper.",
			ACTIVE = "An easy-access route opens.",
		},
        TOWNPORTALTALISMAN = 
        {
			GENERIC = "Smells like an aged pepper.",
			ACTIVE = "Can I take a different route?",
		},
        WETPAPER = "I wouldn't recommend using this in the kitchen.",
        WETPOUCH = "What could have possibly been down there?",
		MOONROCK_PIECES = "It seems very... off-putting.",
		MOONBASE =
        {
            GENERIC = "I'd prefer not to get involved with any of that devilish magic.",
            BROKEN = "Astonishing ancient remains, broken to bits.",
            STAFFED = "A masterpiece takes time, but I'm not sure what we're waiting for.",
            WRONGSTAFF = "There must be an incorrect ingredient in there.",
			MOONSTAFF = "Some sort of magic is being powered here...",
        },
		MOONDIAL = 
        {
			GENERIC = "A sparkling water pan, to be used to watch the moon.",
			NIGHT_NEW = "A fresh new moon to begin anew.",
			NIGHT_WAX = "The moon is waxing.",
			NIGHT_FULL = "The moon is full, and still looks as cheesy as ever.",
			NIGHT_WANE = "The moon is waning.",
			CAVE = "The underground areas are blind to the glistening moon lights.",
        },
		POWCAKE = "I would not feed this to my worst enemies. Or would I...",
		PRIMEAPE = "You reek of mischief and other kinds of... reek.",
		PRIMEAPEBARREL = "Someone has a hoarding issue.",
		PUMPKIN = "I'm the pumpking of the world!",
		PUMPKINCOOKIE = "I've outdone myself this time.",
		PUMPKIN_COOKED = "Could use some pie crust and nutmeg...",
		PUMPKIN_LANTERN = "Trick 'r' neat!",
		PUMPKIN_SEEDS = "Seed saver!",
		PURPLEAMULET = "I must be crazy to fool around with this.",
		PURPLEGEM = "It holds deep secrets.",
		RABBIT =
		{
			GENERIC = "I haven't had rabbit in awhile...",
			HELD = "Your little heart is beating so fast.",
		},
		RABBITHOLE =
		{
			GENERIC = "Thump twice if you are fat and juicy.",
			SPRING = "What a pity rabbit season has ended.",
		},
		RABBITHOUSE =
		{
			BURNT = "That was no carrot!",
			GENERIC = "Do my eyes deceive me?",
		},
		RAFT = "Better than swimming, I suppose.",
		RAINCOAT = "For a foggy Paris evening.",
		RAINHAT = "Better than a newspaper.",
		RAINOMETER =
		{
			BURNT = "It measures nothing now...",
			GENERIC = "It measures moisture in the clouds.",
		},
		RATATOUILLE = "A veritable village of vegetables!",
		RAZOR = "If only I had aftershave.",
		REDBARREL = "Skull and cross bones is bad, yes?",
		REDGEM = "A deep fire burns within.",
		RED_CAP = "Could use cream and salt... And less poison.",
		RED_CAP_COOKED = "Perhaps I could make a good soup.",
		RED_MUSHROOM =
		{
			GENERIC = "Can't get fresher than that!",
			INGROUND = "It'll be hard to harvest like that.",
			PICKED = "There's nothing left.",
		},
		REEDS =
		{
			BURNING = "The fire took to those quite nicely.",
			GENERIC = "A small clump of reeds.",
			PICKED = "There's nothing left to pick.",
		},
		REFLECTIVEVEST = "Well, it should be hard to lose.",
		RESEARCHLAB = --Science Machine
		{
			BURNT = "That didn't cook very well.",
			GENERIC = "A centre for learning.",
		},
		RESEARCHLAB2 = --Alchemy Machine
		{
			BURNT = "The fire seemed to find it quite tasty.",
			GENERIC = "Oh, the things I'll learn!",
		},
		RESEARCHLAB3 = --Shadow Manipulator
		{
			BURNT = "The darkness is all burnt up.",
			GENERIC = "It boggles the mind.",
		},
		RESURRECTIONSTATUE =
		{
			BURNT = "It won't be much good now.",
			GENERIC = "Part of my soul is within.",
		},
		RESURRECTIONSTONE = "Looks like some sort of ritual stone.",
		ROBIN =
		{
		    GENERIC = "Good afternoon, sir or madam!",
		    HELD = "It's soft, and surprisingly calm.",
		},
		ROBIN_WINTER =
		{
		    GENERIC = "This little fellow seems quite frigid.",
		    HELD = "Let me lend you my warmth, feathered friend.",
		},
		ROBOT_PUPPET = "Surely no one deserves such treatment!",
		ROCK = "Don't you go rolling off on me.",
		ROCKS = "Bite-sized boulders.",
		ROCKY = "Hmm... I would have to be careful to not chip a tooth.",
	    PETRIFIED_TREE = "It has been turned into stone!",
		ROCK_PETRIFIED_TREE = "It has been turned into stone!",
		ROCK_PETRIFIED_TREE_OLD = "It has been turned into stone!",
		ROCK_ICE =
		{
			GENERIC = "Brr!",
			MELTED = "It's just liquid now.",
		},
		ROCK_ICE_MELTED = "It's just liquid now.",
		ROCK_LIGHT =
		{
		    GENERIC = "The lava has crusted over.",
			LOW = "Like a pie on a proverbial windowsill, it will soon cool.",
			NORMAL = "Nature's fiery fondue pot.",
			OUT = "It has no heat left to give.",
		},
		CAVEIN_BOULDER =
        {
            GENERIC = "Seems rollable.",
            RAISED = "It's in quite the jam.",
        },
		ROOK = "What a rude contraption.",
		ROOK_NIGHTMARE = "An utter monstrosity!",
		ROPE = "A bit too thick to tie up a roast.",
		ROTTENEGG = "Pee-eew!",
		ROYAL_JELLY = "Such a strong jelly.",
        JELLYBEAN = "They can't fill an entire appetite but they can fill your taste buds!",
		SADDLE_BASIC = "Is this proper animal riding equipment?",
        SADDLE_RACE = "Adds a little spice to my ride.",
        SADDLE_WAR = "To equip an animal for a war of sorts.",
        SADDLEHORN = "It's like a spatula for a saddle.",
		SALTLICK = "It's better tasting to the beefalo.",
        BRUSH = "For tidying unkempt beast hair.",
		RUBBLE = "Delicious destruction.",
		RUINSHAT = "Seems unnecessarily fancy.",
		RUINS_BAT = "I could tenderize some meat with this.",
		RUINS_RUBBLE = "Delicious destruction.",
		--RUINSRELIC_PLATE = "I might like to spruce this up before serving.",
		SANITYROCK =
		{
			ACTIVE = "It's tugging on my mind.",
			INACTIVE = "The darkness lurks within.",
		},
		SAPLING =
		{
			BURNING = "Those burn quite dramatically.",
			GENERIC = "Those could be key to my continued survival.",
			PICKED = "There is nothing left for me to grasp!",
			WITHERED = "It could use some love.",
			DISEASED = "It has reached its last cycle.",
			DISEASING = "It appears to be becoming brittle, best to not use it as filler.",
		},
       	SCARECROW = 
   		{
			GENERIC = "A classic! Protect my crops, sir!",
			BURNING = "Hm, the crows must be getting their revenge.",
			BURNT = "It's a very sad sight to behold.",
   		},
		SCULPTINGTABLE=
   		{
			EMPTY = "Sculpting and ceramics aren't really my area of expertise. But I'm open to new flavors!",
			BLOCK = "Never judge a piece before it's finished!",
			SCULPTURE = "Magnifique!",
			BURNT = "Ah, that's not right.",
   		},
 	    SCULPTURE_KNIGHTHEAD = "It's missing its other half, we ought to find it.",
		SCULPTURE_KNIGHTBODY = 
		{
			COVERED = "I'm not quite sure what purpose it serves.",
			UNCOVERED = "I think we're onto something here!",
			FINISHED = "Welcome back to the world, mon ami.",
			READY = "Something's cooking up in there.",
		},
        SCULPTURE_BISHOPHEAD = "To whom do you belong to?",
		SCULPTURE_BISHOPBODY = 
		{
			COVERED = "Hm, a strange aesthetic choice for this area.",
			UNCOVERED = "There's more to be discovered here.",
			FINISHED = "Ah, a finished masterpiece!",
			READY = "Something's cooking up in there.",
		},
        SCULPTURE_ROOKNOSE = "Could I get a hand here with this?",
		SCULPTURE_ROOKBODY = 
		{
			COVERED = "What a strange piece, very unnerving.",
			UNCOVERED = "Just a couple more touch-ups and it should be fini!",
			FINISHED = "All better now! Carry along!",
			READY = "Something's cooking up in there.",
		},
        GARGOYLE_HOUND = "Gah, I do not like staring at it for too long.",
        GARGOYLE_WEREPIG = "That is a very questionable choice in design.",
		
		SEEDS = "You may grow up to be delicious one day.",
		SEEDS_COOKED = "Could use smoked paprika...",
		SEWING_KIT = "Not exactly my specialty.",
		SEWING_TAPE = "Could fix up a patch or two.",
		SHOVEL = "I'm not the landscaping type.",
		SIESTAHUT =
		{
			BURNT = "Overcooked.",
			GENERIC = "Comes in handy after a big lunch.",
		},
		SILK = "Is that sanitary?",
		SKELETON = "I have a bone to pick with you.",
		SKULLCHEST = "What an ominous container.",
		SLURPER = "It is not polite to slurp.",
		SLURPERPELT = "Wear this? What in heavens for?",
		SLURPER_PELT = "Wear this? What in heavens for?",
		SLURTLE = "You would flavor a soup nicely. Your shell could be the bowl!",
		SLURTLEHAT = "Be the snail.",
		SLURTLEHOLE = "Yuck!",
		SLURTLESLIME = "Nature giveth, and nature grosseth.",
		SLURTLE_SHELLPIECES = "If only I had crazy glue.",
		SMALLBIRD =
		{
			GENERIC = "Hello food... uh, friend.",
			HUNGRY = "I suppose I could whip something up for you.",
			STARVING = "You look famished!",
		},
		SMALLMEAT = "Fresh protein!",
		SMALLMEAT_DRIED = "Could use a teriyaki glaze...",
		SNAKE = "Stay back or I'll turn you into something savory!",
		SNURTLE = "Escar-goodness gracious!",
		SPAT = "I'll have remember to properly wash your chops.",
		PHLEGM = "Ugh. Not food safe!",
		SPEAR = "For kebab-ing.",
		SPIDER =
		{
			DEAD = "Please no rain!",
			GENERIC = "You are not for eating.",
			SLEEPING = "It should make itself a silk pillow.",
		},
		SPIDERDEN = "A spider has to live somewhere, I suppose.",
		SPIDEREGGSACK = "This is probably a delicacy somewhere.",
		SPIDERGLAND = "Alternative medicine.",
		SPIDERHAT = "Well, it is on my head now. Best make the most of it.",
		SPIDERHOLE = "I have no reason to investigate any further.",
		SPIDERHOLE_ROCK = "I have no reason to investigate any further.",
		SPIDERQUEEN = "I will not bend the knee to the likes of you!",
		SPIDER_DROPPER = "Ah, the old \"drop from the ceiling and commit violent acts\" act.",
		SPIDER_HIDER = "A spider that turtles!",
		SPIDER_SPITTER = "So many spiders!",
		SPIDER_WARRIOR =
		{
			DEAD = "It knew the risks.",
			GENERIC = "Does this mean you are even more warlike than the others?",
			SLEEPING = "It is having a flashback to the spider war...",
		},
		SPOILED_FISH = "Such a shame...",
		SPOILED_FOOD = "It is a sin to waste food...",
		STAFFLIGHT = "Too much power to hold in one hand.",
		STAFFCOLDLIGHT = "Cold as ice!",
		STAFF_TORNADO = "Does nature like being tamed?",
		STALAGMITE = "I always get you upside down with stalactites...",
		STALAGMITE_FULL = "Rocks to be had.",
		STALAGMITE_LOW = "Rocks to be had.",
		STALAGMITE_MED = "Rocks to be had.",
		STALAGMITE_TALL = "Rocks to be had.",
		STALAGMITE_TALL_FULL = "Rocks to be had.",
		STALAGMITE_TALL_LOW = "Rocks to be had.",
		STALAGMITE_TALL_MED = "Rocks to be had.",
		LAVA_POND_ROCK = "Rocks to be had.",
		
		STATUEGLOMMER =
		{
			EMPTY = "Oops.",
			GENERIC = "Must have been a pretty important, uh, thingy...",
		},
		STAGEHAND =
        {
			AWAKE = "Keep away from me demon! I do not wish you any harm!",
			HIDING = "That rose is sending me bad omens... I do not like it one bit!",
        },
		STATUE_MARBLE = 
        {
        	GENERIC = "Now that's some fine décor.",
        	TYPE1 = "You appear to be missing a head, madam.",
        	TYPE2 = "Very meaningful décor, you wouldn't see this in any average restaurant.",
        	TYPE3 = "It reminds me of old fancy china, oh how I miss them.",
    	},
		STATUEHARP = "Headless harpsmen.",
		STATUEMAXWELL = "It takes time to thaw a heart of stone.",
		STEELWOOL = "Maybe I could fashion this into a kitchen sponge.",
		STINGER = "I will feel stung if I cannot find a use for this.",
		STRAWHAT = "Now I am on island time.",
        STUFFEDEGGPLANT = "Slightly smoky flesh, savory filling. Ah!",
		SUNKBOAT = "The sea claims all and does not bargain.",
		SWEATERVEST = "I feel so much better all of the sudden.",
		SWEET_POTATO = "Starch never tasted so sweet.",
		SWEET_POTATO_COOKED = "Could use touch of curry and creme freche...",
		SWEET_POTATO_PLANTED = "Starch never tasted so sweet.",
		SWEET_POTATO_SEEDS = "People often confuse yams and sweet potatoes. They're very different!",
		TAFFY = "I hope it never dislodges from my teeth!",
		TALLBIRD = "Leggy.",
		TALLBIRDEGG = "I wonder what its incubation period is?",
		TALLBIRDEGG_COOKED = "Could use sliced fried tomatoes and beans...",
		TALLBIRDEGG_CRACKED =
		{
			COLD = "Oh, you poor egg, you are so cold!",
			GENERIC = "There is activity!",
			HOT = "I hope you don't hardboil.",
			LONG = "This is going to take some dedication.",
			SHORT = "A hatching is in the offing!",
		},
		TALLBIRDNEST =
		{
			GENERIC = "No vacancy here.",
			PICKED = "Empty nest syndrome is setting in.",
		},
		TEENBIRD =
		{
			GENERIC = "You are sort of tall, I guess...",
			HUNGRY = "Teenagers, always hungry!",
			STARVING = "Are you trying to eat me out of base and home?",
		},
		TELEBASE =
		{
			GEMS = "It requires more purple gems.",
			VALID = "It is operational.",
		},
		TELEPORTATO_BASE =
		{
			ACTIVE = "Where shall we go, thing?",
			GENERIC = "It leads somewhere. And that is what I am afraid of.",
			LOCKED = "It denies my access.",
			PARTIAL = "It requires something additional.",
		},
		TELEPORTATO_BOX = "\"This\" likely connects to a \"that.\"",
		TELEPORTATO_CRANK = "Definitely for a cranking action of some kind.",
		TELEPORTATO_POTATO = "This, I do not even...",
		TELEPORTATO_RING = "One ring to teleport them all!",
		TELESTAFF = "Let us take a trip. I am not picky as to where.",
		TENT =
		{
			BURNT = "A good night's sleep, up in smoke.",
			GENERIC = "For roughing it.",
		},
		TENTACLE = "Calamari?",
		TENTACLESPIKE = "This would stick in my throat.",
		TENTACLESPOTS = "Would make a decent kitchen rag.",
		TENTACLE_GARDEN = "If only it were squid and not... whatever it is...",
		TENTACLE_PILLAR = "If only it were squid and not... whatever it is...",
		TENTACLE_PILLAR_ARM = "If only it were squid and not... whatever it is...",
		THULECITE = "Thule-... thulec-... it rolls off the tongue, does it not?",
		THULECITE_PIECES = "A pocketful of thule.",
		TOPHAT = "For a night out on the town...?",
		TORCH = "Not great for caramelizing creme brulee, but it will do for seeing.",
		TRAILMIX = "Energy food!",
		TRANSISTOR = "Positively charged to get my hands on one!",
		TRAP = "I do not wish to be so tricky, but the dinner bell calls me.",
		TRAP_TEETH = "This is not a cruelty-free trap.",
		TRAP_TEETH_MAXWELL = "I must remember where this is...",
		TREASURECHEST =
		{
			BURNT = "Its treasure-chesting days are over.",
			GENERIC = "A safe place to store non-perishables!", --Treasure!
		},
		TREASURECHEST_TRAP = "Hmmm, something does not feel right about this...",
		SACRED_CHEST = 
		{
			GENERIC = "I do not like this chest one bit!",
			LOCKED = "It appears to be judging me as if I were presented as a meal.",
		},
		TREECLUMP = "Someone or something does not want me to tree-spass.",
		TRINKET_1 = "Someone must have really lost their marbles.",
		TRINKET_2 = "I'll hum my own tune.",
		TRINKET_3 = "Some things can't be undone.",
		TRINKET_4 = "Somewhere there's a lawn that misses you.",
		TRINKET_5 = "A rocketship for ants?",
		TRINKET_6 = "These almost look dangerous.",
		TRINKET_7 = "A distraction of little substance.",
		TRINKET_8 = "Ah, memories of bathing.",
		TRINKET_9 = "Buttons that are not so cute.",
		TRINKET_10 = "Manmade masticators.",
		TRINKET_11 = "He doesn't seem trustworthy to me.",
		TRINKET_12 = "I know of no recipe that calls for this.",
		TRINKET_13 = "Somewhere there's a lawn that misses you.",
		TRINKET_14 = "It could use some tea to go with it.",
		TRINKET_15 = "There is no board around to use with this.",
		TRINKET_16 = "There is no board around to use with this.",
		TRINKET_17 = "This eating utensil is too used to be alongside a meal.",
		TRINKET_18 = "I should be careful with this.",
		TRINKET_19 = "An odd used little toy.",
		TRINKET_20 = "Keep this thing away from Wigfrid.",
		TRINKET_21 = "Ah, it's a sad day for I cannot fix this beautiful egg beater.",
		TRINKET_22 = "This yarn wasn't coddled.",
		TRINKET_23 = "I appreciate your help, but I will not be needing it.",
		TRINKET_24 = "Ah, maybe I could store treats in here for the kids.",
		TRINKET_25 = "That smells the opposite of minty-fresh.",
		TRINKET_26 = "I think it's past its ingredient days.",
		TRINKET_27 = "Maybe I could fashion some sort of utensil out of it.",
		TRINKET_28 = "I miss salt and pepper shakers...",
        TRINKET_29 = "I miss salt and pepper shakers...",
        TRINKET_30 = "A piece without a board.",
        TRINKET_31 = "A piece without a board.",		
		TRINKET_32 = "It could make some fine themed decoration.",
        TRINKET_33 = "It's best not to wear rings while in the kitchen.",
        TRINKET_34 = "I prefer not to be tricked any more than I already have.",
        TRINKET_35 = "A flask! I'll be sure to clean it up and give it a proper use!",
		TRINKET_36 = "Attempting to chew with such a commodity is not a good idea.",
		TRINKET_37 = "The only purpose it could serve is a nice camp fire stock.",
		TRINKET_38 = "How much could one really see from afar?", -- Binoculars Griftlands trinket
        TRINKET_39 = "I'd prefer a nice kitchen mitt.", -- Lone Glove Griftlands trinket
        TRINKET_40 = "Perfect for scaling your snails.", -- Snail Scale Griftlands trinket
        TRINKET_41 = "I'm not quite sure what it was. A blender perhaps?", -- Goop Canister Hot Lava trinket
        TRINKET_42 = "Someone's play-thing.", -- Toy Cobra Hot Lava trinket
        TRINKET_43= "There's not much substance to found here.", -- Crocodile Toy Hot Lava trinket
        TRINKET_44 = "You cannot fix everything I suppose.", -- Broken Terrarium ONI trinket
        TRINKET_45 = "Can it pick anything up? I'd like to order a meal.", -- Odd Radio ONI trinket
        TRINKET_46 = "Not the best way one could heat something up.", -- Hairdryer ONI trinket

		HALLOWEENCANDY_1 = "Oh, I had thought there was a whole apple hidden under the coating. But alas.",
        HALLOWEENCANDY_2 = "Bits of waxy fructose corn syrup. Just snacks to go.",
        HALLOWEENCANDY_3 = "Sweet-sweet corn! Albeit a more bite-sized version.",
        HALLOWEENCANDY_4 = "Sweet licorice! I pity those who reject it!",
        HALLOWEENCANDY_5 = "I can only hope its ingredients do not contain the catcoon.",
        HALLOWEENCANDY_6 = "My nose is smelling red flags on these.",
        HALLOWEENCANDY_7 = "Stop wasting these and throwing them out! They're good, just try one!",
        HALLOWEENCANDY_8 = "I feel like it's been years since I've had one of these.",
        HALLOWEENCANDY_9 = "High in calories as it is in taste!",
        HALLOWEENCANDY_10 = "Not too keen on tasting it, but my sweet tooth is demanding a taste!",
        HALLOWEENCANDY_11 = "Sweet blissful chocolate, we meet again!",
		HALLOWEENCANDY_12 = "I am relieved that it is not actual lice.", --ONI meal lice candy
        HALLOWEENCANDY_13 = "Quite the teeth cracker!", --Griftlands themed candy
        HALLOWEENCANDY_14 = "The perfect amount of spice for your life!", --Hot Lava pepper candy
        CANDYBAG = "A sack to carry our festive goodies in!",
		
		HALLOWEEN_ORNAMENT_1 = "One could hang this up someplace.",--Ghost
		HALLOWEEN_ORNAMENT_2 = "I've never been one for these festivities. Much too macabre for my tastes.",--Bat
		HALLOWEEN_ORNAMENT_3 = "I'd like not to step on you.",--Spider
		HALLOWEEN_ORNAMENT_4 = "Not much for eating, is it?",--Tentacle
		HALLOWEEN_ORNAMENT_5 = "I feel much safer knowing it cannot eat me.",--Dangling Spider
		HALLOWEEN_ORNAMENT_6 = "I might need to learn to eat a bit of you.",--Crow

		HALLOWEENPOTION_DRINKS_WEAK = "I cannot pair this with anything.",
		HALLOWEENPOTION_DRINKS_POTENT = "It's quite the hearty mixture!",
        HALLOWEENPOTION_BRAVERY = "I could use a sip of this every other day.",
		HALLOWEENPOTION_FIRE_FX = "Fire infused into a beautiful bottled light show!", 
		MADSCIENCE_LAB = "One must be mad to play around with such a thing.",
		LIVINGTREE_ROOT = "I believe there's a bit of root stuck in it.", 
		LIVINGTREE_SAPLING = "Let's give it space to grow.",
		
		DRAGONHEADHAT = "The most stunning part of the costume set.",
        DRAGONBODYHAT = "Not fit for the kitchen, but it is fit for festivities!",
        DRAGONTAILHAT = "Without it, there is no end.",
        PERDSHRINE =
        {
            GENERIC = "It hungers for something, not quite sure what.",
            EMPTY = "It could use some bait to make it worthwhile.",
            BURNT = "A terrible waste.",
        },
        LUCKY_GOLDNUGGET = "A crisp golden avocado!",
		FIRECRACKERS = "Like oil splattering in a hot pan.",
        REDLANTERN = "I do like festivals like this.",
        PERDFAN = "Like a cool ocean breeze.",
        REDPOUCH = "What might it contain?",
		WARGSHRINE = 
        {
            GENERIC = "It hungers for something, not quite sure what.",
            EMPTY = "It could use a torch to make it worthwhile.",
            BURNT = "A terrible waste.",
        },
        CLAYWARG = 
        {
        	GENERIC = "Definitely not edible!",
        	STATUE = "Even still, it hungers.",
        },
        CLAYHOUND = 
        {
        	GENERIC = "Sit! My meals are not for you!",
        	STATUE = "Might it eat clay kibble?",
        },
        HOUNDWHISTLE = "I'll be sure to use this if any mutts are eyeing my cooking.",
        CHESSPIECE_CLAYHOUND = "A very intimidating piece. I wouldn't recommend eating around it.",
        CHESSPIECE_CLAYWARG = "Not something I'd set up around for dinner. Not a very good omen.",
		PIGSHRINE =
		{
            GENERIC = "An inedible tribute.",
            EMPTY = "I know that hunger. It hungers for meat!",
            BURNT = "A touch overdone.",
		},
		PIG_TOKEN = "What might this craftsmanship be worth?",
		YOTP_FOOD1 = "Magnifique! Finally, a feast fit for me!",
		YOTP_FOOD2 = "Mon dieu! This is not fit for human consumption!",
		YOTP_FOOD3 = "Hm, this isn't anything to write home about.",
		PIGELITE1 = "You are quite the rude fellow.", --BLUE
		PIGELITE2 = "You'll be the one eating the signs here!", --RED
		PIGELITE3 = "Such dirty looks.", --WHITE
		PIGELITE4 = "Landing a sign on my back might land you on our barbecue!", --GREEN

		BISHOP_CHARGE_HIT = "Gah!",
		TRUNKVEST_SUMMER = "Fashionably refreshing.",
		TRUNKVEST_WINTER = "Toasty and trendy.",
		TRUNK_COOKED = "Could use... Hm... I'm stumped...",
		TRUNK_SUMMER = "This meat has a gamey odor.",
		TRUNK_WINTER = "Not the finest cut of meat.",
		TUMBLEWEED = "What secrets do you hold?",
		TURF_SANDY = "It's like an ingredient for the ground.",
		TURF_BADLANDS = "It's like an ingredient for the ground.",
		TURF_CARPETFLOOR = "Make fists with your toes...",
		TURF_CAVE = "It's like an ingredient for the ground.",
		TURF_CHECKERFLOOR = "It's like an ingredient for the ground.",
		TURF_DECIDUOUS = "It's like an ingredient for the ground.",
		TURF_DESERTDIRT = "It's like an ingredient for the ground.",
		TURF_DIRT = "It's like an ingredient for the ground.",
		TURF_FOREST = "It's like an ingredient for the ground.",
		TURF_FUNGUS = "It's like an ingredient for the ground.",
		TURF_FUNGUS_GREEN = "It's like an ingredient for the ground.",
		TURF_GRASS = "Will I need to cut this?",
		TURF_MARSH = "It's like an ingredient for the ground.",
		TURF_MUD = "It's like an ingredient for the ground.",
		TURF_ROCKY = "It's like an ingredient for the ground.",
		TURF_SAVANNA = "It's like an ingredient for the ground.",
		TURF_SINKHOLE = "It's like an ingredient for the ground.",
		TURF_SWAMP = "It's like an ingredient for the ground.",
		TURF_UNDERROCK = "It's like an ingredient for the ground.",
		TURF_WOODFLOOR = "It's like an ingredient for the ground.",
		TURKEYDINNER = "I'm getting sleepy just looking at it!",
		TWIGS = "The start of a good cooking fire.",
		UMBRELLA = "I will try to remember not to open indoors.",
		UNAGI = "More like \"umami\"! Ooooh, mommy!",
		UNIMPLEMENTED = "It appears unfinished.",
		WAFFLES = "Oh, brunch, I have missed you so!",
		WALL_HAY =
		{
			BURNT = "That is what I expected.",
			GENERIC = "Calling it a \"wall\" is kind of a stretch.",
		},
		WALL_HAY_ITEM = "Hay look, a wall!",
		WALL_RUINS = "Look at the carvings...",
		WALL_RUINS_ITEM = "The stories these tell... fascinating...",
		WALL_STONE = "Good stone work.",
		WALL_STONE_ITEM = "I feel secure behind this.",
		WALL_WOOD =
		{
			BURNT = "Wood burns. Who knew? ...Me!?",
			GENERIC = "Putting down stakes.",
		},
		WALL_WOOD_ITEM = "Delivers a rather wooden performance as a wall.",
		WALL_MOONROCK = "Quite the spacious wall.",
		WALL_MOONROCK_ITEM = "Where might I place this?",
		FENCE = "It's but a simple fence.",
        FENCE_ITEM = "Keeps things separated.",
        FENCE_GATE = "Like an oven door.",
        FENCE_GATE_ITEM = "The ingredients for a gate.",
		WALRUS = "They move faster than you'd think.",
		WALRUSHAT = "Smells a little musty...",
		WALRUS_CAMP =
		{
			EMPTY = "Yes, vacancy.",
			GENERIC = "Some outdoorsy types made this.",
		},
		WALRUS_TUSK = "It won't be needing this anymore.",
		WARDROBE = 
		{
			GENERIC = "For freshening up before a dinner meal.",
            BURNING = "Au revoir, wardrobe.",
			BURNT = "Tragique.",
		},
		WARG = "Leader of the pack.",
		WASPHIVE = "Not your average bees.",
		WATERBALLOON = "Plump and ready for throwing.",
		WATERMELON = "Despite its name, it is mostly filled with deliciousness!",
		WATERMELONHAT = "Aaaahhhhhh sweet relief...",
		WATERMELONICLE = "I feel like a kid again!",
		WATERMELON_COOKED = "Could use mint and feta...",
		WATERMELON_SEEDS = "More watermelon, anyone?",
		WEBBERSKULL = "Stop staring at me or I'll bury you!",
		WETGOOP = "I am thankful my sous chefs are not around to witness this abomination...",
		WHIP = "I prefer to whip up a good meal, not other mammals.",
		WINTERHAT = "I know when to don this, and not a minute sooner.",
		WINTEROMETER =
		{
			BURNT = "Foresight is 0/0.",
			GENERIC = "Splendid. I should like to know when the worm is going to turn.",
		},
		
		WINTER_TREE =
        {
			BURNT = "Festive décor in the kitchen can only lead to one thing...",
			BURNING = "It, oh, it appears to be on fire.",
			CANDECORATE = "Cheers to many years!",
			YOUNG = "I can almost taste the feast!",
        },
        WINTER_TREESTAND = "It requires a pine cone.",
        WINTER_ORNAMENT = "The beginning of festivities!",
        WINTER_ORNAMENTLIGHT = "Nothing like a small comforting light to keep the peace.",
		WINTER_ORNAMENTBOSS = "It's the rarest of ornaments!",
		WINTER_ORNAMENTFORGE = "It's quite the spicy ingredient.",
		WINTER_ORNAMENTGORGE = "I must have missed out on the meaning of this one.",
        
        WINTER_FOOD1 = "Gingerbread cookies? It's been years!", --gingerbread cookie
        WINTER_FOOD2 = "Light powdering on a finely cooked base? It truly is a Winter's Feast miracle!", --sugar cookie
        WINTER_FOOD3 = "My sweet tooth demands its peppermint-y greatness!", --candy cane
        WINTER_FOOD4 = "Fruitcakes usually contain dried candies and nuts, not evil.", --fruitcake
		WINTER_FOOD5 = "Season's greetings, season's eatings!", --yule log cake
        WINTER_FOOD6 = "Rich in flavor!", --plum pudding
        WINTER_FOOD7 = "Cider! Although, it's best for a side dish.", --apple cider
        WINTER_FOOD8 = "Could use bits of peppermint, and a melted chocolate glaze.", --hot cocoa
        WINTER_FOOD9 = "Could use some whipped cream with freshly ground cinnamon.", --eggnog

        KLAUS = "Thinking up recipes on such a monstrosity would be quite the challenge.",
        KLAUS_SACK = "Quite the goodie bag.",
		KLAUSSACKKEY = "Some sort of menacing key.",
		WORM =
		{
			DIRT = "Dirty.",
			PLANT = "I see nothing amiss here.",
			WORM = "Worm!",
		},
		WORMHOLE =
		{
			GENERIC = "That is no ordinary tooth-lined hole in the ground!",
			OPEN = "Am I really doing this?",
		},
		WORMHOLE_LIMITED = "These things can look worse?",
		WORMLIGHT = "Radiates deliciousness.",
		WORMLIGHT_LESSER = "A little wrinkle never hurt anybody.",
		WORMLIGHT_PLANT = "Some ingredients may be worth overlooking superstition!",
		YELLOWAMULET = "Puts some pep in my step!",
		YELLOWGEM = "I miss lemons...",
		YELLOWSTAFF = "I could stir a huge pot with this thing!",
		---- FRESHFRUITCREPES = "Is this not a thing of beauty?",
		
		MALE_PUPPET = "Free him!",
		MANRABBIT_TAIL = "The texture is exceptionally comforting.",
		MARBLETREE = "How supremely unnatural!",
		--MONSTERTARTARE = "This is a culinary abomination. I'm appalled.",
		PANDORASCHEST = "It's quite magnificent.",
		PERD = "A fellow with excellent taste.",
		RELIC =
		{
			BROKEN = "A piece of culinary history has been lost.",
			GENERIC = "Ancient kitchenware.",
		},
		RESEARCHLAB4 =
		{
			BURNT = "Nothing but ashes.",
			GENERIC = "I won't even try to pronounce it...",
		},

		ROOK_NIGHTMARE = "What a monstrosity!",
		RUBBLE = "Delicious destruction.",
		RUINS_RUBBLE = "Delicious destruction.",
		TURF_CAVE = "It's like an ingredient for the ground.",
		TURF_DECIDUOUS = "It's like an ingredient for the ground.",
		TURF_FUNGUS_RED = "It's like an ingredient for the ground.",
		TURF_ROAD = "It's like an ingredient for the ground.",
		TURF_DRAGONFLY = "This would do nicely as solid kitchen flooring.",
		
		REVIVER = "It must be soothing to apparitions.",
		SHADOWHEART = "That's.... That's very concerning.",
		ATRIUM_RUBBLE = 
        {
			LINE_1 = "The poor souls in this drawing, hungry.",
			LINE_2 = "Ah, it's a tad too brushed to make it out.",
			LINE_3 = "Some cooking oil seems to covered here.",
			LINE_4 = "Oh dear. Something appears to be popping out of them.",
			LINE_5 = "It appears to be a more advanced city than my own...",
		},
        ATRIUM_STATUE = "How real is this?",
        ATRIUM_LIGHT = 
        {
			ON = "The light to turn your mind and spoil your food.",
			OFF = "Must we power it?",
		},
        ATRIUM_GATE =
        {
			ON = "That should about do it... but at what cost?",
			OFF = "It requires a final ingredient.",
			CHARGING = "It's consuming dark energies...",
			DESTABILIZING = "It's about to blow this kitchen whole!",
			COOLDOWN = "It won't be functioning for quite a while longer.",
        },
        ATRIUM_KEY = "It activates a gateway to some place. Where? That is what I am afraid of.",
		LIFEINJECTOR = "Who shall I stick it to?",
		SKELETON_PLAYER =
		{
			MALE = "%s has been tragically overcooked by %s.",
			FEMALE = "%s has been tragically overcooked by %s.",
			ROBOT = "%s has been tragically overcooked by %s.",
			DEFAULT = "%s has been tragically overcooked by %s.",
		},
		HUMANMEAT = "I... I refuse to cook this.",
		HUMANMEAT_COOKED = "Could use... uh... I don't even...",
		HUMANMEAT_DRIED = "Could use... better judgement...",
		MOONROCKNUGGET = "Bite-sized moon boulders.",
		ROCK_MOON = "I wonder what salts it has.",
		MOONROCKCRATER = "It could use some touching up.",

        REDMOONEYE = "This fancy color-coded rock will help us keep track of this area.",
        PURPLEMOONEYE = "This will help mark various locations.",
        GREENMOONEYE = "A fancy color-coded rock to mark your whereabouts!",
        ORANGEMOONEYE = "It assists with keeping in contact on long travels with others!",
        YELLOWMOONEYE = "It will help make this wretched and unknown place a little more known, but still wretched.",
        BLUEMOONEYE = "It'll help me mark down where to be for dinner.",

		--v2 Winona
        WINONA_CATAPULT = 
        {
        	GENERIC = "Perhaps it flings pies as well.",
        	OFF = "It looks a bit peckish.",
        	BURNING = "Why would anyone want to flambé this?",
        	BURNT = "Nothing but ashes.",
        },
        WINONA_SPOTLIGHT = 
        {
        	GENERIC = "Like in-front of the most regal restaurants!",
        	OFF = "It looks a bit peckish.",
        	BURNING = "Why would anyone want to flambé this?",
        	BURNT = "Nothing but ashes.",
        },
        WINONA_BATTERY_LOW = 
        {
        	GENERIC = "I wouldn't recommend barbecuing on this.",
        	LOWPOWER = "It's getting low on power.",
        	OFF = "I suppose I should turn it on.",
        	BURNING = "Why would anyone want to flambé this?",
        	BURNT = "Nothing but ashes.",
        },
        WINONA_BATTERY_HIGH = 
        {
        	GENERIC = "Magic things and what have you.",
        	LOWPOWER = "It seems to be running low.",
        	OFF = "It looks a bit peckish.",
        	BURNING = "Why would anyone want to flambé this?",
        	BURNT = "Nothing but ashes.",
        },

]]
		--Island Adventures (Shipwrecked) Starts here
		--------------------------------------------------------
		
	--WILDBOREGUARD = "",
	SOLOFISH_DEAD = "Don't worry, mon amie. I will make you delicious.",
	FISH_MED_COOKED = "Could use fresh herbs and butter...",
	PURPLE_GROUPER = "It couldn't be any fresher!",
	PURPLE_GROUPER_COOKED = "Pan-fried grouper with pigeon peas! Delectable!",

	--GHOST_SAILOR = "",
	FLOTSAM = "Could be a piece of the ship...",
	SUNKBOAT = "The sea claims all and does not bargain.",
	SUNKEN_BOAT =
	{
		ABANDONED = "Where did he go?",
		GENERIC = "Hey fella, need a wing?",
	},
	SUNKEN_BOAT_BURNT = "Yikes! That boat had baaaad luck.",
	SUNKEN_BOAT_TRINKET_1 = "Excuse me?",
	SUNKEN_BOAT_TRINKET_2 = "It cannot help me.",
	SUNKEN_BOAT_TRINKET_3 = "Not much of a candle then, is it?",
	SUNKEN_BOAT_TRINKET_4 = "Sea-what?",
	SUNKEN_BOAT_TRINKET_5 = "Not my size.",
	-- BANANAPOP = "Perhaps not my most complicated dish, but no less tasty.",
	BISQUE = "Utterly divine!",
	-- CEVICHE = "Truly what I live for!",
	SEAFOODGUMBO = "Incredible! Just like Nana used to make!",
	SURFNTURF = "Mwah! Perfection.",
	SHARKFINSOUP = "I used Nana's secret recipe.",
	LOBSTERDINNER = "Being stranded is no reason not to eat well!",
	LOBSTERBISQUE = "I've truly outdone myself!",
	JELLYOPOP = "Hmmm... An interesting flavor.",

    ENCRUSTEDBOAT = "It's a bit wobbly.",
    BABYOX = "Worry not, mon chou, I've no interest in veal today.",
    BALLPHINHOUSE = "They're quite social creatures, no?",
    DORSALFIN = "I'd imagine that hurt.",
    NUBBIN = "No coral in sight. Perhaps later.",
    CORALLARVE = "Bonjour, mon petit amie.",
    RAINBOWJELLYFISH = "You might go well in a stew.",
    RAINBOWJELLYFISH_PLANTED = "I see no reason to bother it.",
    RAINBOWJELLYFISH_DEAD = "No sense letting it go to waste.",
    RAINBOWJELLYFISH_COOKED = "You can really taste the \"rainbow\".",
    RAINBOWJELLYJERKY = "The natural sea salt is a great flavor enhancer.",
    WALL_ENFORCEDLIMESTONE = "Good and strong.",
    WALL_ENFORCEDLIMESTONE_ITEM = "I could probably place this at sea without issue.",      
    CROCODOG = "I am not on the menu!",
    POISONCROCODOG = "Don't eat me! I'm not even cooked!",
    WATERCROCODOG = "You look much too hungry!",       
    QUACKENBEAK = "Imagine the meals it could've eaten with that thing!",
    QUACKERINGRAM = "Excuse me everyone, out of my way, please.",

    CAVIAR = "Eat it with a clamshell or the flavor will be ruined.",
    CORMORANT = "The caviar delivery service.",
	PIERROT_FISH = "How would you like to be a nice chowder?",
	NEON_QUATTRO = "Would you prefer to be scorched, or cracked?",
	PIERROT_FISH_COOKED = "Ah, I should have saved the head for soup!",
	NEON_QUATTRO_COOKED = "Sigh. It's not even seasoned.",

    FISH_FARM = 
    {
        	EMPTY = "I'll have to sacrifice caviar ingredients for this.",
			STOCKED = "Just think, market fresh fish every morning!",
			ONEFISH = "Should I make a fish stew with thyme and onion?",
			TWOFISH = "Oh! Boiled fish with celery and goat pepper?",
			REDFISH = "Maybe a chowder with hot pepper and shrimp stock!",
			BLUEFISH  = "Let the cook off begin!",
    },

    ROE = "I can make caviar with canapes!",
    ROE_COOKED = "Could use a squeeze of fresh lemon.",

    SEA_YARD = 
     {
            ON = "Is my boat in need of a touch up?",
            OFF = "Ah, I can't fix my boat right now.",
            LOWFUEL = "It seems to be running low.",
     },
    SEA_CHIMINEA =
     {
            EMBERS = "Worryingly low.",
            GENERIC = "Is this a fire hazard, or a boating hazard?",
            HIGH = "Goodness! It's a grease fire!",
            LOW = "Looks a bit dim.",
            NORMAL = "It's burning steady.",
            OUT = "I can't cook without a fire!",
     }, 

    TAR = "Adds a truly unique flavor to licorice.",
    TAR_EXTRACTOR =
        {
            ON = "It's extracting tar quite vigorously!",
            OFF = "I suppose I should turn it on.",
            LOWFUEL = "It looks a bit peckish.",
        },
    TAR_POOL = "I think there's tar down there.",

    TARLAMP = "What a rustic delight!",
    TARSUIT = "I hope there are no feathers around!",
    TAR_TRAP = "The slowed pace gives you time to enjoy the scenery.",

    TROPICALBOUILLABAISSE = "Such a decadent dish!",

    SEA_LAB = "Couldn't hurt to hit the books now and then.",
    WATERCHEST = "I probably shouldn't keep perishables in it.",
	
	ANTIVENOM = "Could come in very handy.",
    QUACKENDRILL = "It's tres heavy!",
    HARPOON = "Time to catch myself some dinner.",
    MUSSEL_BED = "Imagine! Fresh mussels, whenever I desire!",
	VENOMGLAND = "The worst kind of gland!",
	BLOWDART_POISON = "A coward's weapon. Suits me fine!",
	OBSIDIANMACHETE = "You could overheat swinging this thing too much.",
	SPEARGUN_POISON = "It would make me sick to use this on good meat.",
	OBSIDIANSPEARGUN = "Ready. Aim. Fire.",
	LUGGAGECHEST = "Please have fresh underwear inside!",
	PIRATIHATITATOR =
	{
		BURNT = "It played its last magic trick.",
		GENERIC = "This reminds me of something...",
	},
	COFFEE = "Magnifique!",
	COFFEEBEANS = "Glorious!",
	COFFEEBEANS_COOKED = "Could use hot water...!",
	--COFFEEBOT = "What a delight!",
	COFFEEBUSH =
	{
		BARREN = "Come back, coffee!",
		GENERIC = "Does that bush grow... coffee beans?!",
		PICKED = "I hope they grow back by tomorrow morning.",
		WITHERED = "Come back, coffee!",
	},
	MUSSEL = "Into my tummy you go! Good bi, valves.",
	MUSSEL_COOKED = "Could use shallots and lemongrass...",
	MUSSEL_FARM =
	{
		GENERIC = "A delightful seafood dinner dwells there.",
		STICKPLANTED = "Stick with me, mussels. I'll take you places!",
	},
	MUSSEL_STICK = "Mussels aren't strong enough to resist this stick!",
	LOBSTER = "Come to me, precious!",
	LOBSTERHOLE = "I am waiting for you!",
	SEATRAP = "I can trick some delicious crustaceans into this!",
	SANDCASTLE =
	{
		GENERIC = "How calming.",
		SAND = "It looks at home here.",
	},
	BOATREPAIRKIT = "A most sensible traveling companion.",

	BALLPHIN = "Chipper fellows.",
	BOATCANNON = "I cannon wait to use this!",
	BOTTLELANTERN = "Shine on!",
	BURIEDTREASURE = "What shall I find?",
	BUSH_VINE =
	{
		BURNING = "Perhaps I could smoke a nice cutlet on it?",
		BURNT = "That smoky aroma always makes me hungry...",
		CHOPPED = "How divine! It has been de-vined.",
		GENERIC = "I do wish those were grapevines...",
	},
	CAPTAINHAT = "I have been promoted!",
	COCONADE =
	{
		BURNING = "This will only burn for so long before...",
		GENERIC = "Weaponized food.",
	},
	CORAL = "What shall I make with you?",
	ROCK_CORAL = "A rainbow searock.",
	CRABHOLE = "Come out, come out!",
	CUTLASS = "En garde!",
	DUBLOON = "Golden ham, golden honey, golden coin.",
	FABRIC = "Soft and crisp, all at once.",
	FISHINHOLE = "Shining, sparkling snacks.",
	GOLDENMACHETE = "Fancy slicer.",
	JELLYFISH = "Electric meduse for dinner?",
	JELLYFISH_COOKED = "Could use sesame oil and chilis...",
	JELLYFISH_DEAD = "Ohh, its petit face.",
	JELLYFISH_PLANTED = "Meduse.",
	JELLYJERKY = "Could use garlic...",

	ROCK_LIMPET =
	{
		GENERIC = "A petit snail farm!",
		PICKED = "I have a soft spot for bivalves!",
	},
	BOAT_LOGRAFT = "These logs might be better suited to a fire...",
	MACHETE = "I could chop many an onion with this!",
	MESSAGEBOTTLEEMPTY = "I wonder what vintage used to be in this bottle...",
	MOSQUITO_POISON = "You not only take, but you also give? Well, no thanks!",
	OBSIDIANCOCONADE = "These are a blast!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "That fire's almost out!",
		GENERIC = "To warm my fingers and roast sausages.",
		HIGH = "Maximum heat!",
		LOW = "It's getting low.",
		NORMAL = "This fire's on fire!",
		OUT = "I like when it's warm and toasty.",
	},
	OX = "Here's the beef!",
	PIRATEHAT = "I do not throw in with these scoundrels. But I like the hat.",
	BOAT_RAFT = "Better than swimming, I suppose.",
	BOAT_ROW = "Free me from the shackles of this island!",
	SAIL_PALMLEAF = "This should speed things up.",
	SANDBAG_ITEM = "No potatoes here. Oh well.",
	SANDBAG = "I was hoping it would be full of potatoes.",
	SEASACK = "Wetter is better.",
	SEASHELL_BEACHED = "What a pretty shell.",
	SEAWEED = "I do not have much experience with this ingredient.",

	SEAWEED_PLANTED = "Sea produce!",
	SLOTMACHINE = "Maybe I'll win something tasty?",
	SNAKE_POISON = "I'll need to butcher you ever so carefully.",
	SNAKESKIN = "Would make a haute apron.",
	SNAKESKINHAT = "Très cool.",
	SOLOFISH = "You'll make a fine filet.",
	SPEARGUN = "Long-range kebab-ing.",
	SPOILED_FISH = "Such a shame...",
	SWORDFISH = "A deluxe, but dangerous ingredient!",
	TRIDENT = "That's one giant fork!",
	TRINKET_IA_13 = "I'd prefer switcha... With a piece of duff.",
	TRINKET_IA_14 = "Do they work with paring knives?",
	TRINKET_IA_15 = "I prefer the lute, myself.",
	TRINKET_IA_16 = "This has no business calling itself a plate.",
	TRINKET_IA_17 = "I wouldn't wear this, even if it were my size.",
	TRINKET_IA_18 = "I should be careful with this.",
	TRINKET_IA_19 = "An odd prescription.",
	TURBINE_BLADES = "Could work in a food processor.",
	TURF_BEACH = "It's like an ingredient for the ground.",
	TURF_JUNGLE = "It's like an ingredient for the ground.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It appears to be some kind of altar.",
		OPEN = "It accepts offerings, I think.",
	},
	VOLCANO_ALTAR_BROKEN = "Now there will be no pleasing this thing!",
	WHALE_BLUE = "Why the long fishface?",
	WHALE_CARCASS_BLUE = "That is quite a lot of dead whale.",
	WHALE_CARCASS_WHITE = "That is quite a lot of dead whale.",

	ARMOR_SNAKESKIN = "Function, fashion, and four less living snakes.",
	SAIL_CLOTH = "Now we're cooking!",
	DUG_COFFEEBUSH = "TCoffee to go!",
	LAVAPOOL = "Spicy!",
	BAMBOO = "Bamboo shoots are excellent on a nice bed of rice.",
	AERODYNAMICHAT = "Speeds me on my way.",
	POISONHOLE = "I smell trouble...",
	BOAT_LANTERN = "To \"sea\" what's coming!",
	SWORDFISH_DEAD = "The grand poisson!",
	LIMPETS = "They have a salty aroma.",
	OBSIDIANAXE = "You really build up a head of steam swinging this!",
	COCONUT = "Its packaging is tough to open.",
	COCONUT_SAPLING = "Evidence of a coconut uneaten. Sigh.",
	COCONUT_COOKED = "Could use rice and curry spices...",
	BERMUDATRIANGLE = "Shouldn't I boat away from these?",
	SNAKE = "Stay back or I'll turn you into something savory!",
	SNAKEOIL = "Why can't you be olive oil?",
	ARMORSEASHELL = "Seashell mail.",
	SNAKE_FIRE = "Only thing worse than a snake is a snake on fire.",

	PACKIM = "You have a big mouth, mister.",
	PACKIM_FISHBONE = "Picked clean...",

	ARMORLIMESTONE = "With this I will be a stone man.",
	TIGERSHARK = "I wish you were a tiger shrimp instead!",
	OBSIDIAN_WORKBENCH = "I believe it churns out volcanic doohickeys!",

	NEEDLESPEAR = "Who shall I stick it to?",
	LIMESTONENUGGET = "Made from petit fishy skeletons.",
	DRAGOON = "I do not like these fellows one bit.",

	ICEMAKER = 
	{
		HIGH = "Whistle while you work!",
		LOW = "It's still running.",
		NORMAL = "A small luxury.",
		OUT = "It's run dry.",
		VERYLOW = "Nearly out!",
	},

	DUG_BAMBOOTREE = "Shall I bring it back to life?",
	BAMBOOTREE =
	{
		BURNING = "Fricasseed!",
		BURNT = "A terrible waste.",
		CHOPPED = "More will sprout in time.",
		GENERIC = "Some chefs steam rice in bamboo stocks.",
	},
	JUNGLETREE =
	{
		BURNING = "Au revoir, tree.",
		BURNT = "Crisp, no?",
		CHOPPED = "Sliced!",
		GENERIC = "Gigantesque!",
	},
	SHARK_GILLS = "It won't be needing these anymore.",
	LEIF_PALM = "Let us not do anything we will regret, uh... sir...",
	OBSIDIAN = "Hot rock!",
	BABYOX = "Worry not, mon chou, I've no interest in veal today.",
	STUNGRAY = "Ew, smells like its insides have gone bad.",
	SHARK_FIN = "This looks rather bland.",
	FROG_POISON = "A poison hopper.",
	BOAT_ARMOURED = "I am comforted by its seaworthiness.",
	ARMOROBSIDIAN = "Heavy and hot.",
	BIOLUMINESCENCE = "Magnifique...",
	SPEAR_POISON = "It would make me sick to use this on good meat.",
	SPEAR_OBSIDIAN = "Pull the trigger and voila! Dinner is done!",
	SNAKEDEN =
	{
		BURNING = "Perhaps I could smoke a nice cutlet on it?",
		BURNT = "That smoky aroma always makes me hungry...",
		CHOPPED = "How divine! It has been de-vined.",
		GENERIC = "I do wish those were grapevines...",
	},
	TOUCAN = "You are all nose.",
	MESSAGEBOTTLE = "I wonder if it is a secret menu?",
	SAND = "Lots of tiny, tiny stones.",
	SANDDUNE = "The sand has formed a small pile.",
	PEACOCK = "Pea-ka-boo!",
	VINE = "Not a single grape on it...",
	SUPERTELESCOPE = "I knew sharks had an exceptional sense of smell, but their vision!",
	SEAGULL = "I know you're just after my cooking.",
	SEAGULL_WATER = "I know you're just after my cooking.",
	PARROT = "I can't recall any parrot recipes...",
	ARMOR_LIFEJACKET = "Better safe than sorry.",
	WHALE_BUBBLES = "What the deuce?",
	EARRING = "Fancy.",
	ARMOR_WINDBREAKER = "While it is rude to break wind in public, I will make an exception.",
	SEAWEED_COOKED = "Could use toasted sesame seeds...",
	BOAT_CARGO = "For long distance hauls.",
	GASHAT = "Anything to keep poison out of my dinner!",
	ELEPHANTCACTUS = "A big prickly pickle.",
	DUG_ELEPHANTCACTUS = "Shall I bring it back to life?",
	ELEPHANTCACTUS_ACTIVE = "Sword plant!",
	ELEPHANTCACTUS_STUMP = "The pickle will fruit again.",
	SAIL_FEATHER = "I mostly want to pet it.",
	WALL_LIMESTONE_ITEM = "Citrus-infused walls!",
	JUNGLETREESEED = "Cute, no?",
	JUNGLETREESEED_SAPLING = "Even cuter than the seed!",
	VOLCANO = "Oh, this gets better and better...",
	IRONWIND = "Zoom zoom!",
	SEAWEED_DRIED = "Could use Tamari...",
	TELESCOPE = "To see how \"near\" I am to \"far\".",
	
	DOYDOY = "I see potential in this poultry.",
	DOYDOYBABY = "I should let it grow into more food.",
	DOYDOYEGG = "Hello, breakfast.",
	DOYDOYFEATHER = "A feather from my feathered friend.",
	DOYDOYNEST = "It will become tastier with time.",
	DOYDOYEGG_CRACKED = "Spoiled egg?",

	PALMTREE =
	{
		BURNING = "Au revoir, tree.",
		BURNT = "Crisp, no?",
		CHOPPED = "Sliced!",
		GENERIC = "A good leaning tree.",
	},
	PALMLEAF = "These would work well in tamales.",
	CHIMINEA = "I wonder if this could be converted into a pizza oven?",
	DOUBLE_UMBRELLAHAT = "Ridiculous! I want one.",
	CRAB = 
	{
		GENERIC = "Soon you will be a crabcake.",
		HIDDEN = "I can smell you, my sweet!",
	},
	TRAWLNET = "Ah! The life of a fisherman!",
	TRAWLNETDROPPED =
	{
		GENERIC = "I hope the sea obliges my net with worthy catches.",
		SOON = "It is definitely filling up.",
		SOONISH = "It is close to full.",
	},
	VOLCANO_EXIT = "I will not let the door hit me on the way out!",
	SHARX = "Don't eat me, I'm not properly seasoned!",
	SEASHELL = "There's nothing edible left inside.",
	MAGMAROCK = "This rocks.",
	MAGMAROCK_GOLD = "Wonder if I could harvest goldleaf from this?",
	CORAL_BRAIN = "Are these truly brain bits?",
	CORAL_BRAIN_ROCK = "Chewy rock, with a clever finish.",
	SHARKITTEN = "The veal of the sea.",
	SHARKITTENSPAWNER = 
	{
		GENERIC = "That seems like something I should steer clear of.",
		INACTIVE = "A pile of sand like any other.",
	},
	LIVINGJUNGLETREE = "Pardon, but are you sleeping?",
	WALLYINTRO_DEBRIS = "This leaves a bad taste in my mouth...",
	MERMFISHER = "You bring the sea with you.",
	PRIMEAPE = "You reek of mischief and other kinds of... reek.",
	PRIMEAPEBARREL = "Someone has a hoarding issue.",
	BARREL_GUNPOWDER = "Skull and cross bones is bad, yes?",
	PORTAL_SHIPWRECKED = "Looks too rickety to ride to someplace.",
	MARSH_PLANT_TROPICAL = "I wonder if it is edible.",
	PIKE_SKULL = "Yeeouch!",
	PALMLEAF_HUT = "The great indoors!",
	FISH_SMALL_COOKED = "Could use fresh herbs and butter...",
	LOBSTER_DEAD = "One step closer to my mouth.",
	MERMHOUSE_FISHER = "Fisherfolk live here. I can smell it.",
	WILDBORE = "Does not look like a placid piggy.",
	PIRATEPACK = "This will straighten my back out.",
	TUNACAN = "Tuna, packed in oil!",
	MOSQUITOSACK_YELLOW = "Ugh! It can only be filled with one thing.",
	SANDBAGSMALL = "Helps keep my dry environment dry.",
	FLUP = "Ack! Away!",
	OCTOPUSCHEST = "Any cold drinks in there?",
	OCTOPUSKING = "Try not to think about his delicious tentacles...",
	GRASS_WATER = "Herbe at sea.",
	WILDBOREHOUSE = "How wild can they be if they live in houses?",
	FISH_SMALL = "I will honor this ingredient.",
	TURF_SWAMP = "It's like an ingredient for the ground.",
	FLAMEGEYSER = "Watch that flame!",
	KNIGHTBOAT = "Cannon fire! Time to pirate.",
	MANGROVETREE_BURNT = "I'd say its current water content is zero.",
	TIDAL_PLANT = "Inedible.",
	WALL_LIMESTONE = "Zesty wall.",
	FISH_MED = "Don't worry, mon amie. I will make you delicious.",
	LOBSTER_DEAD_COOKED = "Could use garlic-butter...",
	BLUBBERSUIT = "Desperate times call for desperate attire.",
	BLOWDART_FLUP = "How considerate of that dead thing!",
	TURF_MEADOW = "It's like an ingredient for the ground.",
	TURF_VOLCANO = "It's like an ingredient for the ground.",
	SWEET_POTATO = "Starch never tasted so sweet.",
	SWEET_POTATO_COOKED = "Could use touch of curry and crème fraîche...",
	SWEET_POTATO_PLANTED = "Starch never tasted so sweet.",
	SWEET_POTATO_SEEDS = "People often confuse yams and sweet potatoes. They're very different!",
	BLUBBER = "This lard would feed a hungry fire!",
	TELEPORTATO_SW_BASE = "It leads somewhere. And that is what I am afraid of.",
	TELEPORTATO_SW_BOX = "\"This\" likely connects to a \"that.\"",
	TELEPORTATO_SW_CRANK = "Definitely for a cranking action of some kind.",
	TELEPORTATO_SW_POTATO = "This, I do not even...",
	TELEPORTATO_SW_RING = "One ring to teleport them all!",
	VOLCANOSTAFF = "One must be careful with this.",
	THATCHPACK = "Thatch you very much!",
	SHARK_TEETHHAT = "Look upon your king!",
	TURF_ASH = "It's like an ingredient for the ground.",
	BOAT_TORCH = "It's a light so I might \"sea\".",
	MANGROVETREE = "I wonder what its water content is?",
	HAIL_ICE = "Like icecubes.",
	FISH_TROPICAL = "Catch of today!",
	TIDALPOOL = "It traps snacks.",
	WHALE_WHITE = "I have seen the devil!",
	VOLCANO_SHRUB = "I wonder what it used to be?",
	ROCK_OBSIDIAN = "Blast! I cannot mine it!",
	ROCK_CHARCOAL = "Barbecued.",
	DRAGOONDEN = "I do not like these fellows one bit.",
	TWISTER = "Nature's blender!",
	TWISTER_SEAL = "I bet it's delicious, but I just don't have the heart to find out.",
	MAGIC_SEAL = "It's practically dripping with magicks.",
	SAIL_STICK = "Might make a good stirring stick.",
	WIND_CONCH = "Oh, how I'm homesick for conch snacks.",
	BUOY = "A beacon to light my way.", 
	TURF_SNAKESKIN = "It's like an ingredient for the ground.",
	ARMORCACTUS = "If the enemies are pricked half as much as I was making it, it's worth it.",
	BIGFISHINGROD = "A prime ingredient-catcher.",
	BOOK_METEOR = "There's not a single recipe to be found within.",
	BRAINJELLYHAT = "I can feel inspiration seeping into me! Wait, that's brain juice.",
	COCONUT_HALVED = "Delectable.",
	CRATE = "I hope a rations shipment lies within.",
	DEPLETED_BAMBOOTREE = "Perhaps one day it will return.",
	DEPLETED_BUSH_VINE = "It's all used up... for now.",
	DEPLETED_GRASS_WATER = "Will you recover soon, little tuft?",
	DOYDOYEGG_COOKED = "Bon appetit!",
	DRAGOONEGG = "What use is an egg that you cannot eat?",
	DRAGOONHEART = "It is lifeless, yet surprisingly hot to touch.",
	DRAGOONSPIT = "Dangerous and disgusting!",
	DUG_BUSH_VINE = "Now I can put it wherever I want.",
	-- FRESHFRUITCREPES = "Is this not a thing of beauty?",
	KRAKEN = "I can't take the heat! Get me out of this kitchen!",
	KRAKENCHEST = "What treasures do you hold?",
	KRAKEN_TENTACLE = "My poisons do nothing!",
	MAGMAROCK_FULL = "This rocks.",
	MAGMAROCK_GOLD_FULL = "Wonder if I could harvest goldleaf from this?",
	MONKEYBALL = "Seems like a waste of a good banana. Cute though.",
	-- MONSTERTARTARE = "This is a culinary abomination. I'm appalled.", --
	MUSSELBOUILLABAISE = "The artistry in this dish lifts my spirits.", --
	MYSTERYMEAT = "That can't possibly be edible.",
	OXHAT = "Much more waterproof than a chef's hat.",
	OX_FLUTE = "It plays a lilting tune.",
	OX_HORN = "A lovely souvenir from a once powerful beast.",
	PARROT_PIRATE = "Such an amiable creature. Friends?",
	PEG_LEG = "Why on earth do I have this?",
	PIRATEGHOST = "He may be a nice fellow, but I don't intend to find out.",
	SANDBAGSMALL_ITEM = "I'll need to set these up before they do anything.",
	SHADOWSKITTISH_WATER = "Oh dear.",
	SHIPWRECKED_ENTRANCE = "Bonjour!",
	SHIPWRECKED_EXIT = "Au revoir.",
	SAIL_SNAKESKIN = "Perhaps I'll sail to a land of spices.",
	SPEAR_LAUNCHER = "Now we're cooking!",
	SWEETPOTATOSOUFFLE = "Food that feeds the soul and nourishes the body.", --
	SWIMMINGHORROR = "No need to come any closer, sir.",
	TIGEREYE = "Well, it's edible.",
	TRINKET_IA_20 = "It looks expectant.",
	TRINKET_IA_21 = "I'm afraid I won't fit.",
	TRINKET_IA_22 = "Perfect for a candlelit dinner!",
	TURF_MAGMAFIELD = "It's like an ingredient for the ground.",
	TURF_TIDALMARSH = "It's like an ingredient for the ground.",
	VOLCANO_ALTAR_TOWER = "Mon dieu!",
	WATERYGRAVE = "Let's open her up.",
	WHALE_TRACK = "My quarry is near!",
	WILBUR_CROWN = "Finally, the recognition I deserve. Does it get any bigger?",
	WILDBOREHEAD = "Is someone making a gourmet jerky?",
	BOAT_WOODLEGS = "Is that as fast as it goes?",
	WOODLEGSHAT = "It makes me feel... dangerous.",
	SAIL_WOODLEGS = "I'm ready to set sail!",
	SHIPWRECK = "It sails no more.",
	INVENTORYGRAVE = "Here's hoping the next life treats you better.",
	INVENTORYMOUND = "Here's hoping the next life treats you better.",
	LIMPETS_COOKED = "Smooth, salty, scrumptious.",
	RAWLING = "Your hair needs a brushing.",
	CALIFORNIAROLL = "Classic Japanese fusion!",
		
	},
--[[
	DESCRIBE_GENERIC = "It is what it is...",
	DESCRIBE_SMOLDERING = "I fear that that is about to cook itself.",
	DESCRIBE_TOODARK = "I cannot see a thing!",
    EAT_FOOD =
	{
		TALLBIRDEGG_CRACKED = "Fresh! Err... perhaps too fresh.",
	},
]]
	WARN_SAME_OLD =
	{ --when inspecting food that already has an active Repeat Meal Penalty
		"I'd rather have something different today.",
		"The taste still lingers on my tongue.",
		"My palette desperately needs more variety.",
	},
}%%+%%strings/wathgrithr.lua%%-%%return {
ACTIONSFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "My vessel is renewed!",
	},
},
ANNOUNCE_MAGIC_FAIL = "Its magicks have weakened!",
ANNOUNCE_OTHER_WORLD_PLANT = "Such a plant could never thrive in this realm!",

ANNOUNCE_BOAT_DAMAGED = "My vessel is wounded!",
ANNOUNCE_BOAT_SINKING = "The sea pulls me toward Hel!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "These black depths will soon claim me!",
ANNOUNCE_CRAB_ESCAPE = "It has vanished!",
ANNOUNCE_MAPWRAP_LOSECONTROL = "The currents are my master!",
ANNOUNCE_MAPWRAP_RETURN = "I hath emerged from the fog!",
ANNOUNCE_MAPWRAP_WARN = "I hath reached the edges of the world!",
ANNOUNCE_MORETREASURE = "I am smiled upon this day!",
ANNOUNCE_OTHER_WORLD_TREASURE = "This map describes another land.",
ANNOUNCE_SHARX = "Foes from the froth!",
ANNOUNCE_TRAWL_FULL = "My net has been filled with a marvelous bounty.",
ANNOUNCE_TREASURE = "The map tells of treasure!",
ANNOUNCE_VOLCANO_ERUPT = "Is Ragnarok upon me?!",
ANNOUNCE_WAVE_BOOST = "Carry me forth!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "A beast lurks beneath the waves...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "I have lost the beast's trail...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "I cannot read these rough waters...",
DESCRIBE = {

		-- PORTABLECOOKPOT_ITEM = "Cooking, a noble profession.",
	    CHEFPACK = "The companion of a wise chef.",
	    -- PORTABLECOOKPOT = 
	    -- {
			-- COOKING_LONG = "The chef's culinary patience is beyond my own.",
			-- COOKING_SHORT = "I can smell the victorious stench of fresh food coming!",
			-- DONE = "This refined pot cooks the mightiest meals!",
			-- EMPTY = "Nothing in there. Where's the chef!",
        -- },
	    -- WARLY = 
        -- {
	        -- GENERIC = "Good health and cooking to you, %s!",
	        -- ATTACKER = "Your honor wavers, %s.",
	        -- MURDERER = "May we meet again in Valhalla!",
	        -- REVIVER = "%s has Andhrímnir's blessing.",
	        -- GHOST = "Meditate on Andhrímnir's blessings, %s. I'll find a heart..",
	        -- FIRESTARTER = "Have you misplaced your cooking pot, %s?",
        -- },
	    --

		SEAWEED_STALK = "I have no use for it!", --copied from the Wikia because I couldn't find it in the game files. -M

		LEIF_PALM = "To arms!", --"That is an ancient woodland being."
		BIGFISHINGROD = "I will ensnare delicious fish meat.",
		COFFEEBOT = "The best machine under the sun.",
		DEPLETED_GRASS_WATER = "It is thoroughly vanquished.",
		INVENTORYGRAVE = "I will see thee in Valhalla!",
		INVENTORYMOUND = "I will see thee in Valhalla!",
		LIMPETS_COOKED = "Let us feast!",
		BOAT_WOODLEGS = "I would prefer a longship.",
		WOODLEGSHAT = "Pales in comparison to my helm.",
		SAIL_WOODLEGS = "A fearsome sheet.",
		SOLOFISH_DEAD = "Rest easy in Valhalla.",
		FISH_MED_COOKED = "Joy!",
        GHOST_SAILOR = "He must have been a valiant warrior.",
		PALMLEAF_UMBRELLA = "I dislike plants, but I dislike wet armor more.",
		-- BANANAPOP = "I've somehow found a way to make it even LESS appealing!",
		BISQUE = "Not a bad dish.",
		-- CEVICHE = "Fancy for my taste, but it'll do.",
		SEAFOODGUMBO = "A meal fit for a queen.",
		SURFNTURF = "Yuck! Turf!",
		SHARKFINSOUP = "Delicious!",
		LOBSTERDINNER = "I triumphed over my wobster foe.",
		LOBSTERBISQUE = "That's more like it.",
		JELLYOPOP = "I could go berserk on these!",
		CALIFORNIAROLL = "That's just a morsel of fish food.",
		AERODYNAMICHAT = "My head shall cut the air!",
		ANTIVENOM = "No venom shall flow through my veins!",
		ARMOR_LIFEJACKET = "Adventure offers no true safety!",
		ARMOR_SNAKESKIN = "Rain is bested!",
		ARMOR_WINDBREAKER = "I shall break the wind with every step!",
		ARMORLIMESTONE = "It's heft is reassuring on my bones.",
		ARMOROBSIDIAN = "Come at me now, fiends!",
		ARMORSEASHELL = "I shall not wash up on the shores of Valhalla wearing this!",
		BOAT_ARMOURED = "Now this is a vessel fit for a Viking!",
		BABYOX = "When you grow up you will become even more meat, meat.",
		BALLPHIN = "A blow struck may simply bounce off.",
		BALLPHINPOD = "A raiding party!",
		BAMBOO = "Sticks of great versatility.",
		BAMBOOTREE = "A very hearty weed.",
		BERMUDATRIANGLE = "Is this a plaything of Loki?",
		BIOLUMINESCENCE = "What magic is this?",
		BLOWDART_POISON = "To weaken from a distance. Odin forgive me...",
		BOAT_INDICATOR = "I shall launch my craft.",
		BOAT_LANTERN = "See me, foul beasts of the shadow seas!",
		BOATCANNON = "It smites mine enemies for me!?",
		BOATREPAIRKIT = "Most sensible cargo.",
		BOTTLELANTERN = "A most curious torch.",
		BURIEDTREASURE = "May luck smile on me this day.",
		SNAKEDEN = "You skulking wretch!",
		CANNONSHOT = "Sound and fury!",
		CAPTAINHAT = "It would be better with horns.",
		BOAT_CARGO = "A boat fit for a long journey.",
		CHIMINEA = "What kind of fire hides in a hole?",
		CIRCLINGSEAGULL = "Sky filth!",
		SAIL_CLOTH = "A fine sail.",
		COCONADE = "Fire that can be thrown.",
		COCONUT = "The hardest of fruits.",
		COCONUT_SAPLING = "The hard fruit gave way to a flimsy tree.",
		COFFEE = "Bitter and pulse-pounding.",
		COFFEEBEANS = "I take mine black.",
		
		COFFEEBUSH = "Just add water?",
		CORAL = "The sea bequeaths such strange gifts.",
		ROCK_CORAL = "A hard and brittle place. I like it.",
		CRAB = "Your armor cannot protect you, meat!",
		CRABHOLE = "Does shame drive them to this hole?",
		CUTLASS = "Oh, great sword of piscean death. I shall swing you with honor.",
		SWORDFISH_DEAD = "Onward to Valhalla, brave fish.",
		DEPLETED_BAMBOOTREE = "Have some respect for yourself.",
		DEPLETED_BUSH_VINE = "Not so viney now are you?",
		DOYDOY = "It shows no trace of fear for me!",
		DOYDOYBABY = "I honor you, young warrior of the DoyDoys.",
		DOYDOYEGG = "Within this egg grows a Viking of another feather.",
		
		DOYDOYFEATHER = "The treasured feather of a fallen bird warrior.",
		DOYDOYNEST = "The nest where more brave ones will hatch!",
		DUBLOON = "The spoils of the fallen!",
		DUG_BAMBOOTREE = "If I plant you, will you repay me?",
		DUG_BERRYBUSH2 = "My own personal fount of berries!",
		DUG_BUSH_VINE = "To vine or not to vine?",
		DUG_COFFEEBUSH = "Coffee to go.",
		EARRING = "This is not of my ear.",
		FABRIC = "Sewing is not warrior's work...",
		SAIL_FEATHER = "The brave birds gift me their swift feathers!",
		FIRERAIN = "True warrior's weather!",
		FIRERAINSHADOW = "By Odin!",
		FISHINHOLE = "Do you wish to surrender, fish?",
		FROG_POISON = "Back, foul reptilian scourge!",
		GASHAT = "Armor of sorts for my nose and throat!",
		GOLDENMACHETE = "I shall swing you with pride.",
		ICEMAKER = "Reminds me of home.",
		IRONWIND = "This contraption runs on Odin's steeds!",
		JELLYFISH = "You are much too small to be a sea monster.",
		JELLYFISH_COOKED = "The sea monster cooks up well!",
		JELLYFISH_DEAD = "The sea monster rides to Valhalla!",
		JELLYFISH_PLANTED = "I expected sea monsters to be bigger.",
		JELLYJERKY = "My teeth shall do battle with you.",
		LAVAPOOL = "A puddle of fire!",
		LIMESTONENUGGET = "Hard as an unripe fruit.",
		LIMPETS = "Rock meat!",
		
		LOBSTER = "You are dressed for battle, sea-dweller.",
		LOBSTERHOLE = "The armored ones dwell here...",
		BOAT_LOGRAFT = "You will not carry me far, but you will carry me.",
		MACHETE = "A fine length of blade.",
		MESSAGEBOTTLE = "A message from Valhalla?",
		MESSAGEBOTTLEEMPTY = "Empty of both messages and drink. Pity.",
		MOSQUITO_POISON = "Poison! The work of a coward!",
		MUSSEL = "You don't look strong.",
		MUSSEL_STICK = "The foolish mussels shall climb this stick.",
		OBSIDIAN = "Pebbles from the fire mountain!",
		OBSIDIAN_WORKBENCH = "Fire forge!",
		OBSIDIANAXE = "Now THIS is an axe!",
		OBSIDIANCOCONADE = "Throwing fire is the coward's way. But such fun!",
		OBSIDIANFIREPIT =
		{
			EMBERS = "The fire's nearly dead.",
			GENERIC = "A fire fit for a Viking!",
			HIGH = "The fire roars!",
			LOW = "The fire's slowly dying.",
			NORMAL = "Warm fire, warm Wigfrid.",
			OUT = "And the light flickers out.",
		},
		OBSIDIANMACHETE = "A tool for cutting. A tool for burning.",
		SPEAR_OBSIDIAN = "Feel the burn.",
		OBSIDIANSPEARGUN = "I normally prefer to set fires up close.",
		OX = "Praise Odin for this bountiful hoofed feast!",
		PACKIM = "Will you follow me to Valhalla?",
		PACKIM_FISHBONE = "A curious bauble.",
		PALMLEAF = "A Viking-sized leaf!",
		PALMTREE =
		{
			BURNING = "The wood's ablaze!",
			BURNT = "Loge took that one.",
			CHOPPED = "Chopped by the warrior of the woods!",
			GENERIC = "Do you forsake branches, tree?",
		},
		PALMTREE_BURNT = "I smell burnt coconut.",
		PALMTREE_STUMP = "You will be fueling my hearth in Valhalla.",
		PARROT = "Hold your tongue, bird!",
		PEACOCK = "It will be a shame to ruin those feathers, meat.",
		PIRATEHAT = "This hat confuses my character... I mean, my soul.",
		PIRATIHATITATOR = "This contraption has the smell of Loki about it...",
		POISONHOLE = "The ground belches with sickness!",
		BOAT_RAFT = "A Viking fears not dampness!",
		BOAT_ROW = "Rowing is in my blood.",
		SAIL_PALMLEAF = "A curious sail, but it shall do.",
		SAND = "You are a very clean dirt.",
		SANDCASTLE = "A scale model of my future keep.",
		SANDBAG = "Bagged sand.",
		SANDBAG_ITEM = "Keeps the floods at bay.",
		SANDDUNE = "I will not make a mountain out of a sandhill.",
		SEAGULL = "Vile bird!",
		SEAGULL_WATER = "You foul the water you float upon!",
		SEASACK = "Disgusting, but useful in its way.",
		SEASHELL = "The currency of the sea.",
		SEASHELL_BEACHED = "A tiny elf shield?",
		SEATRAP = "Bring me spoils of the sea!",
		SEAWEED = "Watery plant filth!",
		
		SEAWEED_PLANTED = "A weed I cannot crush under my boot.",
		SHARK_FIN = "A token from a fallen warrior.",
		SHARX = "Ah, a worthy sea opponent!",
		SLOTMACHINE = "A machine of fate and misery.",
		SNAKE = "Never trust those who slither.",
		SNAKE_FIRE = "They speak with the volcano's mouth!",
		SNAKE_POISON = "Keep your foul fangs from my hide!",
		SNAKESKIN = "A snake has slipped its skin. With a little help...",
		SNAKESKINHAT = "Shall I wear the serpent?",
		SOLOFISH = "It seems the sea is offering me a feast.",
		SPEAR_POISON = "This spear awards a coward's victory.",
		SPEARGUN = "A coward's weapon.",
		SPEARGUN_POISON = "I am not some sneak hiding in the shadows! Am I?",
		SPOILED_FISH = "You smell of your failure.",
		STUNGRAY = "Have you no honor, stinky ones?",
		SUPERTELESCOPE = "Odin has lent me his eye!",
		SWORDFISH = "Now you are a fish after my heart!",
		TELESCOPE = "What trickery is this?",
		TIGERSHARK = "Take me to Valhalla, devil of the sea!",
		TIGERSHARKSHADOW = "The shadow of the beast!",
		TORNADO = "The wind has taken furious form!",
		TOUCAN = "Fight with me, long-nosed bird! Together we shall dine in Valhalla!",
		TRAWLNET = "I shall ransack the sea!",
		TRAWLNETDROPPED = "And now to see about my loot!",
		TRIDENT = "A weapon fit for a god!",
		TRINKET_IA_13 = "What foul mead is this?",
		TRINKET_IA_14 = "The toy of a babe. Or is it?",
		TRINKET_IA_15 = "A weapon of annoyance.",
		TRINKET_IA_16 = "A piece of armor?",
		TRINKET_IA_17 = "A warrior walks to Valhalla barefoot...",
		TRINKET_IA_18 = "I don't recognize the craftsmanship.",
		TRINKET_IA_19 = "It is always clear skies for a righteous warrior.",
		TURBINE_BLADES = "What sort of strange sword is this?",
		TURF_BEACH = "Feels good between my toes.",
		TURF_JUNGLE = "You could lose yourself in this...",
		TWISTER = "You hide beneath wind, villain!",
		VENOMGLAND = "The source of the fevers.",
		VINE = "What can you do for me?",
		VOLCANO = "A mountain of fire!",
		VOLCANO_ALTAR = "I must appease the fire god that lives inside this mountain.",
		VOLCANO_ALTAR_BROKEN = "Senseless destruction of a weapon forge...",
		VOLCANO_EXIT = "I weary of this infernal realm.",
		VOLCANOSTAFF = "Call down the wrath of fire mountain!",
		WALL_LIMESTONE = "Fine work.",
		WALL_LIMESTONE_ITEM = "Will you stand with me?",
		WHALE_BLUE = "I will end your moping, giant!",
		WHALE_CARCASS_BLUE = "I will toast you in Valhalla.",
		WHALE_CARCASS_WHITE = "Oh, how the mighty stink.",
		WHALE_WHITE = "It would be an honor to kill you.",
		NEEDLESPEAR = "Tis truly a wondrous war lance!",
		ARMORCACTUS = "It will make of me a friend to the cactus.",
		BAMBOOTREE =
		{
			BURNT = "Your hollow sorcery could not save you from fire.",
			CHOPPED = "You could not hack it!",
			GENERIC = "What sorcery is this? Wood that is hollow?",
		},
		BLOWDART_FLUP = "A coward's weapon, dropped by a pitiful, sneaking creature.",
		BLUBBER = "This is much prized by my people!",
		BLUBBERSUIT = "Rue my suit of fat, moisture!",
		BOAT_TORCH = "The night sea is alight!",
		BRAINJELLYHAT = "My brain has the might of my sword!",
		BUOY = "It buoys my spirits to see it above the waves.",
		BUSH_VINE =
		{
			BURNT = "It's burnt. No sense vine-ing about it.",
			CHOPPED = "It needed a haircut.",
			GENERIC = "This bush has helm head.",
		},
		COCONADE =
		{
			BURNING = "The nut will spew its fire soon!",
			GENERIC = "This is no ordinary nut!",
		},
		COCONUT_COOKED = "I shall feast on this large nut.",
		COCONUT_HALVED = "I have cleaved the nut and it has shown me its insides!",
		COFFEEBEANS_COOKED = "It smells energizing.",
		COFFEEBUSH =
		{
			BARREN = "Did you even put up a fight?",
			GENERIC = "It bears strange volcano fruits.",
			PICKED = "Its fruits must be reborn.",
			WITHERED = "Weakling bush!",
		},
		CORAL_BRAIN = "If I eat of it will I gain its knowledge?",
		CORAL_BRAIN_ROCK = "A mystical, all-knowing water rock!",
		CRAB =
		{
			GENERIC = "Do battle with me, armored one!",
			HIDDEN = "Un-bury thyself, coward!",
		},
		CRATE = "Yield your secrets, box!",
		DOUBLE_UMBRELLAHAT = "What kind of strange helm is this?",
		DOYDOYEGG_COOKED = "I shall eat of this fearless bird's bounty.",
		DOYDOYEGG_CRACKED = "Its fearlessness leaks out.",
		DRAGOON = "A fellow berserker whose belly is full of fire!",
		DRAGOONDEN = "A berserker has to live somewhere.",
		DRAGOONEGG = "I can hear the beating heart of a warrior within!",
		DRAGOONHEART = "My fallen foe has given me a gift!",
		DRAGOONSPIT = "I wish I could spit fire...",
		DUG_ELEPHANTCACTUS = "I shall get to the point. You belong to me now.",
		ELEPHANTCACTUS = "I sense the spirit of a berserker within you, plant.",
		ELEPHANTCACTUS_ACTIVE = "Finally the earth sprouts a worthy adversary!",
		ELEPHANTCACTUS_STUMP = "Coward!",
		FISH_MED = "This sea meat will serve me well.",
		FISH_SMALL = "This sea meat will serve me well.",
		FISH_SMALL_COOKED = "This meat will swim in my belly!",
		FLAMEGEYSER = "The ground belches fire!",
		FLOTSAM = "I must fish it from the sea if I'm to learn its secrets.",
		FLUP = "You cowardly mudlurker!",
		-- FRESHFRUITCREPES = "So light and airy!",
		GRASS_WATER = "Grass I can pick from my longship!",
		HAIL_ICE = "The sky is throwing ice!",
		ICEMAKER =
		{
			HIGH = "The machine is fired up!",
			LOW = "It is spitting considerably less ice forth.",
			NORMAL = "Ice from fire!",
			OUT = "It needs more fire!",
			VERYLOW = "Its fire is about to go out.",
		},
		-- JUNGLETREE = "A mighty tree!",
		-- JUNGLETREE_BURNT = "Goodbye, giant.",
		-- JUNGLETREE_STUMP = "I will see you in Valhalla, tree.",
		JUNGLETREESEED = "The strength of the tree, in a seed.",
        JUNGLETREESEED_SAPLING = "It will grow mightily.",
		JUNGLETREE =
		{
			BURNING = "The tree burns.",
			BURNT = "The tree is no more.",
			CHOPPED = "A strong tree, but not so strong as my axe.",
			GENERIC = "There are no trees like this where I sail from.",
		},
		KNIGHTBOAT = "My longship speeds me to war!",
		KRAKEN = "I'll return you to Hel herself!",
		KRAKENCHEST = "Spoils of war!",
		KRAKEN_TENTACLE = "The arm of the beast!",
		ROCK_LIMPET =
		{
			GENERIC = "The meat stone!",
			PICKED = "The stone is meatless for now...",
		},
		TROPICALFAN = "The luxuries of camp, on the go.",
		LIVINGJUNGLETREE = "I do not like your face, tree!",
		LOBSTER_DEAD = "Sleep in Valhalla, armored one.",
		LOBSTER_DEAD_COOKED = "Your armor hides tasty meat.",
		LUGGAGECHEST = "I hope I am spoiled by these spoils of the sea!",
		MAGIC_SEAL = "I shall wield this with proper respect for the mighty warrior wizard that left it.",
		MAGMAROCK = "What can I use to roll these rocks?",
		MAGMAROCK_FULL = "What can I use to roll these rocks?",
		MAGMAROCK_GOLD = "It shimmers...",
		MAGMAROCK_GOLD_FULL = "It shimmers...",
		MANGROVETREE = "I have never felled a tree from my longship before!",
		MANGROVETREE_BURNT = "Everything above the water is char.",
		MARSH_PLANT_TROPICAL = "A meager plant.",
		MERMFISHER = "I quarrel not with fisherfolk, so long as they do not take up arms.",
		MERMHOUSE_FISHER = "The fisherfolk dwell here.",
		MONKEYBALL = "A bit of monkey merriment.",
		-- MONSTERTARTARE = "Still quivering.",
		MOSQUITOSACK_YELLOW = "The pest dropped its sack of sickness.",
		MUSSELBOUILLABAISE = "Thin, but warming.",
		MUSSEL_COOKED = "Strong taste.",
		MUSSEL_FARM =
		{
			GENERIC = "It builds mussels.",
			STICKPLANTED = "Become one with the stick...",
		},
		MYSTERYMEAT = "The food of my enemy's children is... what to me?",
		OCTOPUSCHEST = "The chest holds offerings.",
		OCTOPUSKING = "He seems open to bartering.",
		OXHAT = "This helm will keep my scalp dry.",
		OX_FLUTE = "I have no rhythm...",
		OX_HORN = "Ah, a fine mug it would make!",
		PALMLEAF_HUT = "Keeps the rain off my helm.",
		PARROT_PIRATE = "You talk too much!",
		PEG_LEG = "This leg will make a fine basher!",
		PIKE_SKULL = "Reminds me of home.",
		PIRATEGHOST = "To Hel, spirit!",
		PIRATEPACK = "Builds chest muscles.",
		PIRATIHATITATOR =
		{
			BURNT = "Its magic has floated away as embers.",
			GENERIC = "What awkward sorcery is this?",
		},
		PORTAL_SHIPWRECKED = "This longship looks unfit for a warrior.",
		PRIMEAPE = "You are as amusing as you are hairy.",
		PRIMEAPEBARREL = "By this mess I would say a Viking lives here.",
		RAWLING = "Finally! Someone to rehearse with.",
		BARREL_GUNPOWDER = "This cask packs a punch!",
		ROCK_CHARCOAL = "Rocks burn?",
		ROCK_OBSIDIAN = "Lava stone!",
		SAIL_STICK = "I command the wind!",
		SANDBAGSMALL = "This bag of sand battles the water!",
		SANDBAGSMALL_ITEM = "Water crashes against it feebly!",
		SANDCASTLE =
		{
			GENERIC = "I want to pretend I'm a giant and crush it!",
			SAND = "Time has crushed it.",
		},
		SEAWEED_COOKED = "Sea snack.",
		SEAWEED_DRIED = "It is chewy...",
		SHADOWSKITTISH_WATER = "An enemy looms!",
		SHARKITTEN = "It is your momma I want...",
		SHARKITTENSPAWNER =
		{
			GENERIC = "Something lies in wait!",
			INACTIVE = "Just sand... for now...",
		},
		SHARK_GILLS = "Shark gills!",
		SHARK_TEETHHAT = "A helm after my warriors heart!",
		SHIPWRECKED_ENTRANCE = "A new land to plunder and pillage!",
		SHIPWRECKED_EXIT = "Off to a new land...",
		SNAKEDEN =
		{
			BURNT = "It's burnt. No sense vine-ing about it.",
			CHOPPED = "It needed a haircut.",
			GENERIC = "This bush has helm head.",
		},
		SNAKEOIL = "What powerful properties does this bestow?",
		SAIL_SNAKESKIN = "A sail made of murder!",
		SPEAR_LAUNCHER = "A gift from Odin!",
		SUNKEN_BOAT =
		{
			ABANDONED = "The sea claims another!",
			GENERIC = "He has something to say!",
		},
		SUNKEN_BOAT_BURNT = "A Viking funeral has taken place...",
		SUNKEN_BOAT_TRINKET_1 = "Some kind of crude weapon?", 
		SUNKEN_BOAT_TRINKET_2 = "A child's longship.", 
		SUNKEN_BOAT_TRINKET_3 = "Soggy candle.", 
		SUNKEN_BOAT_TRINKET_4 = "Sea sorcery.", 
		SUNKEN_BOAT_TRINKET_5 = "Not my size.",
		SWEETPOTATOSOUFFLE = "It is filled with delicious air!",
		SWEET_POTATO = "I have never heard of a potato that is sweet! ...Gross!",
		SWEET_POTATO_COOKED = "I won't eat it, but I appreciate the color.",
		SWEET_POTATO_PLANTED = "There are inedible plantsweets in the ground!",
		SWEET_POTATO_SEEDS = "These will grow sweetly.",
		SWIMMINGHORROR = "Are you here to give me a Viking's funeral?",
		TELEPORTATO_SW_BASE = "It is missing things.",
		TELEPORTATO_SW_BOX = "It is part of something.",
		TELEPORTATO_SW_CRANK = "It cranks. But for what?",
		TELEPORTATO_SW_POTATO = "What strange contraption is this?",
		TELEPORTATO_SW_RING = "Is it valuable?",
		THATCHPACK = "I hope my spear doesn't poke a hole in it.",
		TIDALPOOL = "A tiny lake!",
		TIDAL_PLANT = "Soggy plant.",
		TIGEREYE = "I've got the eye of the tigershark!",
		TRAWLNETDROPPED =
		{
			GENERIC = "Plunderful!",
			SOON = "The plunder will sink soon.",
			SOONISH = "I think my plunder will sink soon.",
		},
		TRINKET_IA_20 = "Some kind of crude weapon?", 
		TRINKET_IA_21 = "A child's longship.",
		TRINKET_IA_22 = "Soggy candle.", 
		TRINKET_IA_23 = "A broken something.", 
		FISH_TROPICAL = "Inside it is the color of meat!",
		TUNACAN = "Food that can survive a voyage!",
		TURF_ASH = "A piece of the battlefield.",
		TURF_MAGMAFIELD = "A piece of the battlefield.",
		TURF_MEADOW = "A piece of the battlefield.",
		TURF_SNAKESKIN = "My enemy's hide feels good beneath my feet!",
		TURF_SWAMP = "A piece of the battlefield.",
		TURF_TIDALMARSH = "A piece of the battlefield.",
		TURF_VOLCANO = "A piece of the battlefield.",
		TWISTER_SEAL = "You were the little guy doing all that huffing and puffing?!?",
		VOLCANO_ALTAR =
		{
			GENERIC = "The altar of the fire gods sleeps.",
			OPEN = "It is ready to receive sacrifice!",
		},
		VOLCANO_ALTAR_TOWER = "An altar to the fire gods!",
		VOLCANO_SHRUB = "You look burnt out.",
		WALLYINTRO_DEBRIS = "Is this the wreckage of my longship?",
		WATERYGRAVE = "Plunder under!",
		WHALE_BUBBLES = "Something lurks beneath.",
		WHALE_TRACK = "I shall whale on you!",
		WILBUR_CROWN = "I plunder what this is?",
		WILBUR_UNLOCK = "I kneel to no king, even adorable ones!",
		WILDBORE = "I sense a kindred spirit!",
		WILDBOREHEAD = "Save a mug in Valhalla for me.",
		WILDBOREHOUSE = "A terrible place to live!",
		WIND_CONCH = "I feel a breeze...",
		WOODLEGS_CAGE = "A locked cage!",
		WOODLEGS_KEY1 = "What might this open?",
		WOODLEGS_KEY2 = "Another key!",
		WOODLEGS_KEY3 = "A strange key!",
		SHIPWRECK = "Longships litter the path to Valhalla.",
        BOAT_ENCRUSTED = "It's no Viking longship, but it will carry me.",    
        BABYOX = "What cute meat.",
        BALLPHINHOUSE = "A gathering place for swimming meat.",
        DORSALFIN = "No more will it crest the waves.",     
        NUBBIN = "No Excalibur juts from its center.",
        CORALLARVE = "Be you meat?",
        RAINBOWJELLYFISH = "Hail, fish of jelly!",
        RAINBOWJELLYFISH_PLANTED = "Blessed with beauty by Freyr herself.",
        RAINBOWJELLYFISH_DEAD = "To swim, to sting no more.",
        RAINBOWJELLYFISH_COOKED = "Ah, a proper meal!",
        RAINBOWJELLYJERKY = "A feast!",
        WALL_ENFORCEDLIMESTONE = "No wall can hold my warrior's spirit!",
        WALL_ENFORCEDLIMESTONE_ITEM = "To build ",    
        CROCODOG = "Finally, a worthy foe!",
        POISONCROCODOG = "What venom flows through thy veins?",
        WATERCROCODOG = "My, what big teeth you have!",     
        QUACKENBEAK = "The remains of a thrilling battle.",
        QUACKERINGRAM = "I will knock down all who stand in my path!",
        CAVIAR = "I would have rathered the fish.",
        CORMORANT = "A beast of both sky and sea!",
        PURPLE_GROUPER = "Aegir shall not save you this day.",
        PIERROT_FISH = "I wish this meat did not have such large eyes.",
        NEON_QUATTRO = "Thou shalt swim no more.",
        PURPLE_GROUPER_COOKED = "Thank Njord for this gift!",
        PIERROT_FISH_COOKED = "Thank you, fish, for the gift of thy meat.",
        NEON_QUATTRO_COOKED = "Njord gives me my fill this day.",

        FISH_FARM = 
        {
        	EMPTY = "The goddess Ran has blessed me with her net.",
			STOCKED = "Now I wait for Ran to smile upon me!",
			ONEFISH = "The meat has sprouted!",
			TWOFISH = "The swimming meat flourishes!",
			REDFISH = "A thriving oasis of swimming meat!",
			BLUEFISH  = "Thank Njord for this meaty bounty!",
        },
        ROE = "One day you may be true meat.",
        ROE_COOKED = "You shall never be true meat now.",
        
        SEA_YARD = 
        {
            ON = "An altar to Njord!",
            OFF = "There will be no mending my longship this day.",
            LOWFUEL = "I need more fuel!",
        },
        
        SEA_CHIMINEA =
        {
            EMBERS = "Fire, fire, why dost thou burnest low?",
            GENERIC = "To protect my fires from Aegir's grasp.",
            HIGH = "Loge's power repels the night!",
            LOW = "I might stoke thine fire.",
            NORMAL = "A humble flame.",
            OUT = "The fire has lost its fight.",
        }, 

        TAR = "Surely a substance of pure evil.",
        TAR_EXTRACTOR =
        {
            ON = "It is exorcising evil from the sea.",
            OFF = "I have halted its dark work for now.",
            LOWFUEL = "The machine shall not hold much longer.",
        },
        TAR_POOL = "Something vile bubbles from beneath.",

        TARLAMP = "A light to guide mine longship!",
        TARSUIT = "This shall repel Aegir's clammy touch.",
        TAR_TRAP = "To ensnare mine enemies!",
        TROPICALBOUILLABAISSE = "Tis a fish feast!",
        
        SEA_LAB = "Aegir, bless me with thy wisdom!",
        WATERCHEST = "Spares my effects from the sea's dark depths.",
        QUACKENDRILL = "To thrust into the heart of the sea!",
        HARPOON = "I shalt bring the hunt to the seas!",
        MUSSEL_BED = "Sea meat in the making.",
},
}
%%+%%strings/waxwell.lua%%-%%return {
ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "Not right now.",
	},
	READ =
	{
		--Maxwell can't get Birds Of The World in SW, but he can in DST. Improvise why Hurricane blocks this! -M
		NOBIRDS = "Drat! Those blasted birds refuse to come down.",
	},
},

ANNOUNCE_MAGIC_FAIL = "Such magic does not belong here.",
ANNOUNCE_OTHER_WORLD_PLANT = "I can't possibly plant this here.",
ANNOUNCE_MESSAGEBOTTLE =
{
	"The penmanship is atrocious. I can't make it out.",
},
ANNOUNCE_BOAT_DAMAGED = "My vessel is sustaining damage.",
ANNOUNCE_BOAT_SINKING = "I fear I've sprung a leak.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "After everything, is this how it ends?!",
ANNOUNCE_CRAB_ESCAPE = "Crafty crustacean...",
ANNOUNCE_MAPWRAP_LOSECONTROL = "I am consumed by the abyss!",
ANNOUNCE_MAPWRAP_RETURN = "Thank goodness.",
ANNOUNCE_MAPWRAP_WARN = "I want nothing to do with mists and fogs.",
ANNOUNCE_MORETREASURE = "Ah. Another guide to a lost treasure.",
ANNOUNCE_OTHER_WORLD_TREASURE = "I don't believe this treasure is located nearby.",
ANNOUNCE_SHARX = "It seems I'm being pursued.",
ANNOUNCE_TRAWL_FULL = "The net is full to bursting!",
ANNOUNCE_TREASURE = "It appears I can follow this to some sort of... treasure.",
ANNOUNCE_VOLCANO_ERUPT = "There's no need for such outbursts.",
ANNOUNCE_WAVE_BOOST = "Truly!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Pursue the beast!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Foiled by a fish!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "I've lost sight of the whale!",

DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "An instrument of the dark culinary arts.",
	CHEFPACK = "It puts its contents into hibernation.",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "A true culinarian has patience when cooking like none other.",
		-- COOKING_SHORT = "Warly's cooking is nearly plated.",
		-- DONE = "Finally, some quality grub.",
		-- EMPTY = "Just the thought makes my mouth water.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "Good day, Mr. %s.",
        -- ATTACKER = "%s is stirring up trouble...",
        -- MURDERER = "Murderous fiend! Taste my wrath!",
        -- REVIVER = "%s has excellent command of the dark culinary arts.",
        -- GHOST = "You know the price of revival as well as I do, %s.",
		-- FIRESTARTER = "That is not where cooking fires go, %s.",
    -- },

	SEAWEED_STALK = "So much work for some wet weeds.", --copied from the Wikia because I couldn't find it in the game files. -M

	LEIF_PALM = "Cease this nonsense!", --"Disgusting creature!",
	-- BANANAPOP = "Hm... I don't know what I was expecting.",
	BISQUE = "Excellent food, but the ambiance could be improved.",
	-- CEVICHE = "A delightful, cultured dish.",
	SEAFOODGUMBO = "It looks passable.",
	SURFNTURF = "A very balanced meal, I suppose.",
	SHARKFINSOUP = "My refined palate relishes the taste of endangerment.",
	LOBSTERDINNER = "And here I forgot my bib.",
	LOBSTERBISQUE = "Ah, I do enjoy the finer things.",
	JELLYOPOP = "Hm... I don't think this meshes well with my cultivated look.",
	TROPICALFAN = "Is it windy out or is it just my fan?",
	PALMLEAF_UMBRELLA = "It serves its purpose.",
	SOLOFISH_DEAD = "Stay.",
	FISH_MED_COOKED = "It still stinks.",
	GHOST_SAILOR = "He reminds me of someone...",
	AERODYNAMICHAT = "Quite sleek, if not elegant.",
	ANTIVENOM = "A cure to what ails you.",
	ARMORCACTUS = "Nothing says \"stay away\" quite like this.",
	ARMORLIMESTONE = "It renders me... sluggish.",
	ARMOROBSIDIAN = "I've bent the flame to my will.",
	ARMORSEASHELL = "Perhaps not the sturdiest, but it will conceal my vulnerabilities.",
	ARMOR_LIFEJACKET = "Sadly my cultured countenance must take a backseat to sensibility.",
	ARMOR_SNAKESKIN = "Quite dapper!",
	ARMOR_WINDBREAKER = "Sigh.",
	BOAT_ARMOURED = "This boat knows how to take a hit like a champion.",
	BABYOX = "Stop chewing my cufflinks, wretched cur.",
	BALLPHIN = "They're much craftier than they appear at first glance.",
	BAMBOO = "I have several ideas in mind for this.",
	BAMBOOTREE =
	{
		BURNT = "It will not be returning.",
		CHOPPED = "It needs time to replenish.",
		GENERIC = "It can grow through just about anything.",
	},
	BERMUDATRIANGLE = "It's calling to me to dive in.",
	BIGFISHINGROD = "Perhaps I'll have better luck with the swimming meat now.",
	BIOLUMINESCENCE = "Quite otherworldly, no?",
	BLOWDART_FLUP = "This is quite a stunning contraption.",
	BLOWDART_POISON = "I've turned the venom of this world against itself.",
	BLUBBER = "I believe I can... eat it...",
	BLUBBERSUIT = "This is undignified.",
	BOATCANNON = "It's about time I got my hands on one of these.",
	BOATREPAIRKIT = "It will hold off my vessel's inevitable decay.",
	BOAT_LANTERN = "It lends an eerie glow to all around it.",
	BOAT_TORCH = "Sailing at night seems unsafe, but this makes it somewhat better.",
	BOTTLELANTERN = "Their lives have found purpose in servitude.",
	BRAINJELLYHAT = "I feel inspired.",
	BUOY = "It floats with ease.",
	BURIEDTREASURE = "Ah, what's this then?",
	BUSH_VINE =
	{
		BURNT = "It's met its end.",
		CHOPPED = "Used up, for now.",
		GENERIC = "These have taken over the island.",
	},
	CAPTAINHAT = "It makes me feel commanding.",
	BOAT_CARGO = "Ah, plenty of room to breathe.",
	CHIMINEA = "Safe keeping for my hard earned fires.",
	SAIL_CLOTH = "It will aid in my travels.",
	COCONADE =
	{
		BURNING = "I may want to take cover.",
		GENERIC = "I foresee death in the future.",
	},
	COCONUT = "Could do considerable damage to a person's noggin.",
	COCONUT_SAPLING = "It can't hurt anyone anymore.",
	COCONUT_COOKED = "It will last me for now.",
	COCONUT_HALVED = "I made one coconut into two... Magic!",
	COFFEE = "I look forward to this.",
	COFFEEBEANS = "It's strange to see them this color.",
	COFFEEBEANS_COOKED = "Better than raw, but perhaps there's a better way to prepare them?",
	COFFEEBOT = "It will do my coffee-related bidding.",
	COFFEEBUSH =
	{
		BARREN = "Barren.",
		GENERIC = "Delightful coffee beans.",
		PICKED = "I've picked them all.",
		WITHERED = "Decay has overtaken it.",
	},
	CORAL = "It's quite lovely.",
	ROCK_CORAL = "This could likely support a wide array of life.",
	CORAL_BRAIN = "Now I can harness its thoughtpower for myself.",
	CORAL_BRAIN_ROCK = "I wonder what it's thinking?",
	CRAB =
	{
		GENERIC = "An edible crustacean.",
		HIDDEN = "The crabbit is hiding.",
	},
	CRABHOLE = "It can't hide forever.",
	CRATE = "Perhaps I could pry it open.",
	CUTLASS = "A gentleman's weapon.",
	SWORDFISH_DEAD = "Perhaps it should have taken more fencing lessons.",
	DEPLETED_BAMBOOTREE = "It's gone.",
	DEPLETED_BUSH_VINE = "No more.",
	DEPLETED_GRASS_WATER = "That was all there was.",
	DEVTOOL = "How odd.",
	DEVTOOL_NODEV = "I fear I cannot grasp it.",
	DOUBLE_UMBRELLAHAT = "This looks silly.",
	DOYDOY = "This sad creature has no hope of survival.",
	DOYDOYBABY = "Now there will be more of them.",
	DOYDOYEGG = "Hmm, propagate a dying species or enjoy a light snack?",
	DOYDOYEGG_COOKED = "A light snack is always the best option.",
	DOYDOYEGG_CRACKED = "Whoops.",
	DOYDOYFEATHER = "It would look dashing tucked in a Sunday hat.",
	DOYDOYNEST = "What are their chances, you think?",
	DRAGOON = "Don't you know who I am?",
	DRAGOONDEN = "I see no reason to disturb them.",
	DRAGOONEGG = "It radiates an oppressive heat.",
	DRAGOONHEART = "Hearts only bring pain anyway.",
	DRAGOONSPIT = "Quite uncouth.",
	DUBLOON = "The clinking sound when they rub together is intensely satisfying.",
	DUG_BAMBOOTREE = "I suppose I should find a place for this.",
	DUG_BUSH_VINE = "I should find a proper place for this.",
	DUG_COFFEEBUSH = "This is worth replanting.",
	DUG_ELEPHANTCACTUS = "I'd better not run with it.",
	EARRING = "I would look quite dashing in it, were my ear pierced.",
	ELEPHANTCACTUS = "It won't be shooting anyone like this.",
	ELEPHANTCACTUS_ACTIVE = "Take cover!",
	ELEPHANTCACTUS_STUMP = "Good riddance.",
	FABRIC = "I've fashioned the bamboo into something useful.",
	SAIL_FEATHER = "I suppose it's better than paddling.",
	FISHINHOLE = "They would be much more content in my stomach.",
	FISH_MED = "Could use a touch of fire.",
	FISH_SMALL = "Have I been reduced to this?",
	FISH_SMALL_COOKED = "...Bottoms up.",
	FLAMEGEYSER = "That puts on quite a spectacle.",
	FLOTSAM = "Perhaps I could reel it in somehow.",
	FLUP = "That thing is quite beneath me.",
	-- FRESHFRUITCREPES = "Deserves to be eaten with fine silverware. Sadly, I've just my hands.",
	FROG_POISON = "I had better teach it some manners.",
	GASHAT = "Cleans the stench away.",
	GOLDENMACHETE = "I've always wanted to hack things in luxury.",
	GRASS_WATER = "It is partially submerged.",
	HAIL_ICE = "Slightly chilly.",
	HOUNDFIRE = "A biting flame!",
	ICEMAKER =
	{
		HIGH = "It's working hard to make ice for me.",
		LOW = "I'd better fill it up.",
		NORMAL = "It appears to be doing its job.",
		OUT = "It's not doing its job.",
		VERYLOW = "It's on its last legs.",
	},
	IRONWIND = "Thank goodness, I have places to be!",
	JELLYFISH = "What a strange little creature.",
	JELLYFISH_COOKED = "It will do, I suppose.",
	JELLYFISH_DEAD = "I like it better dead.",
	JELLYFISH_PLANTED = "It's quite shocking.",
	JELLYJERKY = "I actually don't mind this?",
	JUNGLETREE =
	{
		BURNING = "It is not long for this world.",
		BURNT = "In another lifetime, perhaps.",
		CHOPPED = "I have used it for my own purposes.",
		GENERIC = "I believe it wants me to chop it down.",
	},
	JUNGLETREESEED = "I could replant this, theoretically.",
	JUNGLETREESEED_SAPLING = "Good. I was right.",
	KNIGHTBOAT = "Obey me, fool!",
	KRAKEN = "You will bow to me.",
	KRAKENCHEST = "Now for my reward.",
	KRAKEN_TENTACLE = "How dare you touch me?",
	LAVAPOOL = "Exceptionally toasty.",
	LIMESTONENUGGET = "Perhaps this sealife's death will find use after all.",
	ROCK_LIMPET =
	{
		GENERIC = "Could be used as a food source in a pinch.",
		PICKED = "Just a rock now.",
	},
	LIMPETS = "Slimy and vaguely ingestible.",
	LIMPETS_COOKED = "A delicacy? Really?",
	LIVINGJUNGLETREE = "Nothing out of the ordinary here.",
	LOBSTER = "Now that looks like a proper meal.",
	LOBSTERHOLE = "Show yourself, delicious critters.",
	LOBSTER_DEAD = "Excellent.",
	LOBSTER_DEAD_COOKED = "I forgot my bib.",
	BOAT_LOGRAFT = "It seems like there should be regulations against this.",
	LUGGAGECHEST = "Quite a dapper briefcase if I do say so.",
	MACHETE = "Truthfully I was always a hack.",
	MAGIC_SEAL = "I sense a powerful force within it.",
	MAGMAROCK = "Well, it's a rock.",
	MAGMAROCK_FULL = "Well, it's a rock.",
	MAGMAROCK_GOLD = "This rock is much more luxurious.",
	MAGMAROCK_GOLD_FULL = "This rock is much more luxurious.",
	MANGROVETREE = "A tree like any other... but wet.",
	MANGROVETREE_BURNT = "It has been destroyed.",
	MARSH_PLANT_TROPICAL = "Not of much use to me.",
	MERMFISHER = "I have no quarrel with him.",
	MERMHOUSE_FISHER = "I suppose everyone needs to live somewhere...",
	MESSAGEBOTTLE = "What is this primitive communication?",
	MESSAGEBOTTLEEMPTY = "Given enough time I could build a ship inside.",
	MONKEYBALL = "What am I supposed to do with this?",
	-- MONSTERTARTARE = "It's less than appetizing.",
	MOSQUITOSACK_YELLOW = "I'll be taking that blood back, thank you.",
	MOSQUITO_POISON = "I would like to avoid being bitten by this one.",
	MUSSEL = "They're a delicacy... somewhere.",
	MUSSELBOUILLABAISE = "I truly look forward to a full meal.",
	MUSSEL_COOKED = "Looks to be less of a health hazard now.",
	MUSSEL_FARM =
	{
		GENERIC = "It appears to be a convenient gathering of food.",
		STICKPLANTED = "They're oblivious to their approaching death.",
	},
	MUSSEL_STICK = "The mussels won't be able to resist.",
	MYSTERYMEAT = "Rather disgusting.",
	NEEDLESPEAR = "Exceedingly sharp.",
	OBSIDIAN = "What a delightful color.",
	OBSIDIANAXE = "It seems to work best when alight.",
	OBSIDIANCOCONADE = "This is definitely overkill.",
	OBSIDIANFIREPIT =
	{
		EMBERS = "I should attend to that.",
		GENERIC = "The stone was born for this.",
		HIGH = "A roaring fire.",
		LOW = "It's getting low.",
		NORMAL = "It's burning in style.",
		OUT = "It's gone cold.",
	},
	OBSIDIANMACHETE = "This seems like a dangerous thing to farm with.",
	OBSIDIANSPEARGUN = "Projectile flame. I quite like it.",
	OBSIDIAN_WORKBENCH = "This workstation ignites a spark of creativity in my heart...",
	OCTOPUSCHEST = "It looks... rotten.",
	OCTOPUSKING = "I could use his generosity to my advantage.",
	OX = "It is smelly and very stupid.",
	OXHAT = "Sometimes one must sacrifice form for function.",
	OX_FLUTE = "Goodness. It's been awhile since I played.",
	OX_HORN = "The beast stood no chance.",
	PACKIM = "His irritating appearance is tempered by his usefulness and willing servitude.",
	PACKIM_FISHBONE = "I think I should hold onto it.",
	PALMLEAF = "Now I just need servants to fan my glorious self!",
	PALMLEAF_HUT = "Phew.",
	PALMTREE =
	{
		BURNING = "It is not long for this world.",
		BURNT = "In another lifetime, perhaps.",
		CHOPPED = "I have used it for my own purposes.",
		GENERIC = "How luxurious.",
	},
	PARROT = "Hm. Colorful.",
	PARROT_PIRATE = "Perhaps I can shut him up.",
	PEACOCK = "This creature understands showmanship.",
	PEG_LEG = "Good for whacking.",
	PIKE_SKULL = "Drab.",
	PIRATEGHOST = "I'll not be meeting the same fate!",
	PIRATEHAT = "Is this amusing?",
	PIRATEPACK = "I suppose it will do.",
	PIRATIHATITATOR =
	{
		BURNT = "Ashes to ashes.",
		GENERIC = "Such a fascinating device.",
	},
	POISONHOLE = "I can see it just fine from here... No need to get closer.",
	PORTAL_SHIPWRECKED = "Useless!",
	PRIMEAPE = "This pitiful creature possesses only a modicum of intelligence.",
	PRIMEAPEBARREL = "Keep me away from that.",
	BOAT_RAFT = "Much too precarious for my liking.",
	RAWLING = "Oh good. A talking sack of stuffing.",
	BARREL_GUNPOWDER = "It's bursting with potential.",
	ROCK_CHARCOAL = "I can't help but admire the natural formations.",
	ROCK_OBSIDIAN = "It refuses to bend to my tools.",
	BOAT_ROW = "Manually operated. A pity.",
	SAIL_PALMLEAF = "It will be smooth sailing with this at my back.",
	SAIL_STICK = "A stick, presumably for sailing.",
	SAND = "Rocks so thoroughly beaten down they are no longer recognizable.",
	SANDBAG = "A bag of dirt that keeps water out.",
	SANDBAGSMALL = "A bag of dirt that keeps water out.",
	SANDBAGSMALL_ITEM = "A bag of dirt I can carry.",
	SANDBAG_ITEM = "A bag of dirt I can carry.",
	SANDDUNE = "A little mound of yellow sand.",
	SANDCASTLE =
	{
		GENERIC = "I found that wholly unenjoyable. I swear.",
		SAND = "Decorative sand.",
	},
	SEAGULL = "It is loud and irritating.",
	SEAGULL_WATER = "Rather uncivil.",
	SEASACK = "It won't make me stronger, but it'll give me more pockets.",
	SEASHELL = "Holding it makes me feel like a tourist.",
	SEASHELL_BEACHED = "A little kitschy for my taste.",
	SEATRAP = "The curiosity will get the best of you eventually.",
	SEAWEED = "Sea garbage.",
	SEAWEED_COOKED = "I'm loathe to eat this.",
	SEAWEED_DRIED = "Ugh.",
	SEAWEED_PLANTED = "It thrives here.",
	SHADOWSKITTISH_WATER = "Oh dear.",
	SHARKITTEN = "A charming monstrosity.",
	SHARKITTENSPAWNER =
	{
		GENERIC = "The pile stirs when I mention treats.",
		INACTIVE = "An ordinary pile of sand.",
	},
	SHARK_FIN = "A trophy from a most excellent kill.",
	SHARK_GILLS = "I suppose they're worth hanging on to.",
	SHARK_TEETHHAT = "I respect this fashion choice.",
	SHARX = "It's not a question of \"if\" I will conquer it, but when.",
	SHIPWRECKED_ENTRANCE = "I hope you're prepared.",
	SHIPWRECKED_EXIT = "Farewell.",
	SLOTMACHINE = "I admittedly have a penchant for tempting fate.",
	SNAKE = "A cruel yet elegant beastie.",
	SNAKEDEN =
	{
		BURNT = "It's met its end.",
		CHOPPED = "Used up, for now.",
		GENERIC = "These have taken over the island.",
	},
	SNAKEOIL = "Perhaps I could turn a profit with this.",
	SNAKESKIN = "The texture is delectable.",
	SNAKESKINHAT = "Quite dashing, actually.",
	SAIL_SNAKESKIN = "For ease of travel.",
	SNAKE_FIRE = "Something's got that snake heated.",
	SNAKE_POISON = "Perhaps I'll give that one a wide berth.",
	SOLOFISH = "It smells like wet dog.",
	SPEARGUN = "This projectile flinger may come in handy.",
	SPEARGUN_POISON = "I've made sure it packs an extra wallop.",
	SPEAR_LAUNCHER = "This projectile flinger may come in handy.",
	SPEAR_OBSIDIAN = "I've made sure it packs a fiery wallop.",
	SPEAR_POISON = "I've made sure it packs an extra wallop.",
	SPOILED_FISH = "I believe I should dispose of this.",
	STUNGRAY = "It smells quite atrocious.",
	SUNKEN_BOAT =
	{
		ABANDONED = "It's ferociously guarded.",
		GENERIC = "It will never sail again.",
	},
	SUNKEN_BOAT_BURNT = "All things are doomed in time.",
	SUNKEN_BOAT_TRINKET_1 = "Exactly what it looks like. Err... What does it look like?",
	SUNKEN_BOAT_TRINKET_2 = "I feel as though it is mocking my situation.",
	SUNKEN_BOAT_TRINKET_3 = "It has no apparent function.",
	SUNKEN_BOAT_TRINKET_4 = "An advanced little gadget.",
	SUNKEN_BOAT_TRINKET_5 = "It was probably hideous before soaking in bilgewater.",
	SUPERTELESCOPE = "This may help me get the lay of the land.",
	SWEETPOTATOSOUFFLE = "Why, this looks halfway palatable!",
	SWEET_POTATO = "Ready for cooking.",
	SWEET_POTATO_COOKED = "Storebought just doesn't taste the same.",
	SWEET_POTATO_PLANTED = "I've eaten worse things. Much worse.",
	SWEET_POTATO_SEEDS = "Perhaps something will grow if I shove these in the ground.",
	SWIMMINGHORROR = "I've had enough of your kind, fiend.",
	SWORDFISH = "Ah, a sparring partner!",
	TELEPORTATO_SW_BASE = "I see the makings of something quite handsome.",
	TELEPORTATO_SW_BOX = "Another piece of the puzzle.",
	TELEPORTATO_SW_CRANK = "Excellent. Not long now.",
	TELEPORTATO_SW_POTATO = "I do admit it's a little ridiculous.",
	TELEPORTATO_SW_RING = "Ah, another piece.",
	TELESCOPE = "This may help me get the lay of the land.",
	THATCHPACK = "Not much, but the extra space is better than nothing.",
	TIDALPOOL = "Much deeper than it lets on.",
	TIDAL_PLANT = "It's a bit of a runt.",
	TIGEREYE = "Not something a gentleman handles without gloves.",
	TIGERSHARK = "Aptly named.",
	TOUCAN = "Colorful vermin.",
	TRAWLNET = "I see no downside to using this.",
	TRAWLNETDROPPED =
	{
		GENERIC = "Just think of the meals I'll make.",
		SOON = "Into the depths...",
		SOONISH = "It's working its way down.",
	},
	TRIDENT = "A fork fit for ocean royalty.",
	TRINKET_IA_13 = "A welcome change from seawater.",
	TRINKET_IA_14 = "This seems like bad voodoo.",
	TRINKET_IA_15 = "It only has four strings.",
	TRINKET_IA_16 = "Letters and numbers... some sort of secret code?",
	TRINKET_IA_17 = "It was probably hideous before soaking in bilgewater.",
	TRINKET_IA_18 = "A little superglue and it would make a lovely centerpiece.",
	TRINKET_IA_19 = "Neither red nor blue.",
	TRINKET_IA_20 = "Exactly what it looks like. Err... What does it look like?",
	TRINKET_IA_21 = "Might be nice in a hot bath...",
	TRINKET_IA_22 = "Looks like something one would find at a backwater flea market.",
	TRINKET_IA_23 = "It's not communicating with anyone now.",
	FISH_TROPICAL = "It belongs on a skewer.",
	TUNACAN = "Fish is presumably contained inside.",
	TURBINE_BLADES = "It appears expertly engineered.",
	TURF_ASH = "It appears to be some turf.",
	TURF_BEACH = "It appears to be some turf.",
	TURF_JUNGLE = "It appears to be some turf.",
	TURF_MAGMAFIELD = "It appears to be some turf.",
	TURF_MEADOW = "It appears to be some turf.",
	TURF_SNAKESKIN = "It appears to be some turf.",
	TURF_SWAMP = "It appears to be some turf.",
	TURF_TIDALMARSH = "It appears to be some turf.",
	TURF_VOLCANO = "It appears to be some turf.",
	TWISTER = "I would rather not get sucked into that.",
	TWISTER_SEAL = "It's, uh... cute?",
	VENOMGLAND = "Could this be the cure?",
	VINE = "It's twisted and gnarled.",
	VOLCANO = "I respect its power.",
	VOLCANOSTAFF = "It feels at home in my hands.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It appears to be a place of offering.",
		OPEN = "Do I dare play with more forces beyond my control?",
	},
	VOLCANO_ALTAR_BROKEN = "A true pity.",
	VOLCANO_ALTAR_TOWER = "What a captivating structure.",
	VOLCANO_EXIT = "I must take my leave.",
	VOLCANO_SHRUB = "Had I any pity, I would give it to this tree.",
	WALLYINTRO_DEBRIS = "What nonsense is this now?",
	WALL_LIMESTONE = "It will hold.",
	WALL_LIMESTONE_ITEM = "Where should I begin building my fortress?",
	WATERYGRAVE = "Not all find a final resting place.",
	WHALE_BLUE = "Surrender to me.",
	WHALE_BUBBLES = "You've given yourself away, pal.",
	WHALE_CARCASS_BLUE = "Size truly doesn't matter!",
	WHALE_CARCASS_WHITE = "I triumphed over it!",
	WHALE_TRACK = "I'm in hot pursuit!",
	WHALE_WHITE = "We meet again.",
	WILBUR_CROWN = "The inside is filthy.",
	WILBUR_UNLOCK = "Well I suppose there's no sending you back now.",
	WILDBORE = "I'll easily dispose of that swinish brute.",
	WILDBOREHEAD = "Lovely ambiance.",
	WILDBOREHOUSE = "Is this what passes for architecture around here?",
	WIND_CONCH = "Beautiful on the outside, destructive on the inside.",
	BOAT_WOODLEGS = "Seems dependable.",
	WOODLEGSHAT = "Swashbuckling...",
	SAIL_WOODLEGS = "A fine sail.",
	WOODLEGS_CAGE = "We are all trapped, in one way or another.",
	WOODLEGS_KEY1 = "Brittle.",
	WOODLEGS_KEY2 = "A key of fine gold.",
	WOODLEGS_KEY3 = "Just common iron.",
	SHIPWRECK = "It stood no chance.",
	CALIFORNIAROLL = "We meet again, crabbit.",

	--- 5C DLC ------------------------------------------------------------------------------------------------
	
	BOAT_ENCRUSTED = "It seems sturdy enough to carry me.",
	BABYOX = "You'll get no special treatment from me, beast.",
	BALLPHINHOUSE = "Ah. I need a castle like that.",
	DORSALFIN = "I could build a decent castle with this.",
	NUBBIN = "It's not bald! It's distinguished!",
	CORALLARVE = "You're not cute.",
	RAINBOWJELLYFISH = "Such extraneous colors...",
	RAINBOWJELLYFISH_PLANTED = "Hm. It's very fond of bioluminescence.",
	RAINBOWJELLYFISH_DEAD = "That one's not getting back up.",
	RAINBOWJELLYFISH_COOKED = "Done, like dinner.",
	RAINBOWJELLYJERKY = "Not the easiest on my teeth.",
	WALL_ENFORCEDLIMESTONE = "About as well constructed as sea trash can be.",
	WALL_ENFORCEDLIMESTONE_ITEM = "I suppose I could place this on the water.",
	CROCODOG = "Oh great, another abomination.",
	POISONCROCODOG = "It won't obey me.",
	WATERCROCODOG = "Smells like wet dog.",
	QUACKENBEAK = "Just look at the size of that thing.",
	QUACKERINGRAM = "Quacker before me!! Uh, I mean quiver...!",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "A meal fitting of my stature.",
	CORMORANT = "Unlike me, it has no trouble surviving out here.",

	PURPLE_GROUPER = "Truly an ugly creature.",
	PIERROT_FISH = "Delightfully pinstriped.",
	NEON_QUATTRO = "Don't you ever blink?",

	PURPLE_GROUPER_COOKED = "Purple on the outside, pink in the middle.",
	PIERROT_FISH_COOKED = "I'll be picking bones out of my teeth for weeks.",
	NEON_QUATTRO_COOKED = "Don't worry, there's plenty of them in the sea.",

	FISH_FARM = 
	{
		EMPTY = "I need some fish eggs if I want fish.",
		STOCKED = "I put the eggs in. Where are my fish?",
		ONEFISH = "Success! A fish.",
		TWOFISH = "The more the merrier!",
		REDFISH = "I better not see any rowdiness, fish.",
		BLUEFISH  = "Who would ever need this many fish?",
	},

	ROE = "Raw fish eggs. Fantastic.",
	ROE_COOKED = "The fish eggs are cooked now.",
	
	SEA_YARD = 
	{
		ON = "Much needed ship maintenance.",
		OFF = "Out of commission. For now.",
		LOWFUEL = "This maintenance machine needs maintaining.",
	},

	SEA_CHIMINEA =
	{
		EMBERS = "A flame not long for this world.",
		GENERIC = "It will protect the flames from the waves.",
		HIGH = "I may have overdone it.",
		LOW = "There's barely any heat.",
		NORMAL = "It's burning just fine.",
		OUT = "Out like a light.",
	}, 

	TAR = "Congealed evil.",
	TAR_EXTRACTOR =
	{
		ON = "It's doing its job.",
		OFF = "It's no use to me if it's off.",
		LOWFUEL = "The contraption needs replenishing.",
	},
	TAR_POOL = "Something foul festers beneath.",

	TARLAMP = "A little light in the dark.",
	TARSUIT = "I hope this won't tar-nish my dapper image.",
	TAR_TRAP = "Slow going.",

	TROPICALBOUILLABAISSE = "Hm... Needs more fish.",

	SEA_LAB = "There are watery mysteries to be unlocked yet.",
	WATERCHEST = "My suits had best not get moldy in there.",
	QUACKENDRILL = "I will quack open the sea itself.",
	HARPOON = "How barbaric.",
	MUSSEL_BED = "They'll grow where I tell them to.",
},
}
%%+%%strings/webber.lua%%-%%return {
ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "No need. It already floats our boat.",
	},
},
ANNOUNCE_MAGIC_FAIL = "I don't think this thing likes it here.",
ANNOUNCE_MESSAGEBOTTLE =
{
	"Eight eyes isn't enough to read this.",
},
ANNOUNCE_OTHER_WORLD_PLANT = "We can't grow this here.",
ANNOUNCE_BOAT_DAMAGED = "Our boat's hurt!",
ANNOUNCE_BOAT_SINKING = "Down, down, down we go!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "Help! We can't swim!",
ANNOUNCE_CRAB_ESCAPE = "You slippery snail... er, crabbit!",
ANNOUNCE_MAPWRAP_LOSECONTROL = "We're trembling in our pantaloons!",
ANNOUNCE_MAPWRAP_RETURN = "That was scary!",
ANNOUNCE_MAPWRAP_WARN = "I don't like this...",
ANNOUNCE_MORETREASURE = "Yay! Another treasure hunt!",
ANNOUNCE_OTHER_WORLD_TREASURE = "I don't think I can find this treasure here.",
ANNOUNCE_SHARX = "Mean sea hounds! Leave us alone!",
ANNOUNCE_TRAWL_FULL = "Let's pull'er up!",
ANNOUNCE_TREASURE = "A map! We should follow it!",
ANNOUNCE_VOLCANO_ERUPT = "It's raining fire!",
ANNOUNCE_WAVE_BOOST = "Weee!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "We're on the trail!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "It went home...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "It's so choppy!",
DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "Makes yummies!",
	CHEFPACK = "It doesn't fit on our head, only on our back.",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "Warly says to wait for dinner.",
		-- COOKING_SHORT = "Almost ready!",
		-- DONE = "Warly's cooked us supper!",
		-- EMPTY = "Warly doesn't like us touching it without his supervision.",
    -- },
	-- WARLY = 
    -- {
	    -- GENERIC = "Hello Mr. %s!",
	    -- ATTACKER = "Uhh, Mr. %s might have other things on the menu tonight...",
	    -- MURDERER = "Take it easy, %s! Is dinner cancelled?",
	    -- REVIVER = "Mr. %s makes good meals for us! They're tasty!",
	    -- GHOST = "Don't worry Mr. %s, we'll find you a heart!",
	    -- FIRESTARTER = "%s, what are you cooking this time?",
    -- },

	SEAWEED_STALK = "We should plant this somewhere in the ocean.", --copied from the Wikia because I couldn't find it in the game files. -M

	INVENTORYGRAVE = "They're just sleeping.",
	INVENTORYMOUND = "They're just sleeping.",
	SOLOFISH_DEAD = "All dogfish go to heaven, right?",
	FISH_MED_COOKED = "Flaky and moist. Delicious.",
	GHOST_SAILOR = "He looks kind of sad.",
	TROPICALFAN = "This thing is huge!",
	PALMLEAF_UMBRELLA = "It won't keep us from playing in puddles!",
	-- BANANAPOP = "Yaaay! Popsicle, popsicle!",
	BISQUE = "We lift our pinkies when we eat it.",
	-- CEVICHE = "Yucky!",
	SEAFOODGUMBO = "We could eat it forever!",
	SURFNTURF = "Eww, healthy!",
	SHARKFINSOUP = "Yum, yum, soup!",
	LOBSTERDINNER = "We have to eat it with our eyes closed. Too many legs!",
	LOBSTERBISQUE = "We want to pour it all over our tongues!",
	JELLYOPOP = "Yummy!",
	AERODYNAMICHAT = "We feel light on our feet.",
	ANTIVENOM = "This is medicine?",
	ARMOR_LIFEJACKET = "It pays to be safe.",
	ARMOR_SNAKESKIN = "Rain will bead off this reptilian coat.",
	ARMOR_WINDBREAKER = "Wind can't hold us back!",
	ARMORLIMESTONE = "Our back hurts...",
	ARMOROBSIDIAN = "Our enemies will feel the heat!",
	ARMORSEASHELL = "We feel like a knight in not-so-shiny armor.",
	BOAT_ARMOURED = "It provides peace of mind at sea.",
	BABYOX = "Hey lil fella!",
	BALLPHIN = "Playful rubber blobs. We'll watch from afar.",
	BALLPHINPOD = "Why don't they like us!",
	BAMBOO = "Such a useful stick-type thing.",
	BAMBOOTREE = "Such a small but helpful tree.",
	BERMUDATRIANGLE = "How unsettling!",
	BERRYBUSH2_SNAKE = "Ripe for the pickin'.",
	BERRYBUSH_SNAKE = "Ripe for the pickin'.",
	BIOLUMINESCENCE = "Wooow! Pretty water lights!",
	BLOWDART_POISON = "A sneaky weapon...",
	BOAT_LANTERN = "Seeing where we're going is sure handy!",
	BOATCANNON = "With this we can make a warship!",
	BOATREPAIRKIT = "Never leave home without one.",
	BOTTLELANTERN = "Hey in there, thanks for the light!",
	BURIEDTREASURE = "Treasure, treasure, treasure!",
	BUSH_VINE = "What a crazy looking plant.",
	CAPTAINHAT = "Just like a real boatguy!",
	BOAT_CARGO = "Ah, we can stretch all our legs...",
	CHIMINEA = "Our fires can stay safe from the wind's clutches.",
	CIRCLINGSEAGULL = "Don't poop on us!",
	SAIL_CLOTH = "Now we can harness the wind!",
	COCONADE = "We should throw this very much far away from ourselves.",
	COCONUT = "Food! From a tree!",
	COCONUT_SAPLING = "Aw. It's so little.",
	COFFEE = "Bitter.",
	COFFEEBEANS = "These smell very... adult.",
	
	COFFEEBUSH = "These don't look tasty.",
	CORAL = "Pretty colors.",
	ROCK_CORAL = "A coral party!",
	CRABHOLE = "The sixlegger lives underground.",
	CUTLASS = "There's something fishy about this sword.",
	SWORDFISH_DEAD = "Should we eat it or use it?",
	DEPLETED_BAMBOOTREE = "Come back, bamboos.",
	DEPLETED_BUSH_VINE = "Will the vines come back?",
	DOYDOY = "Nothing behind the eyes...",
	DOYDOYBABY = "Aww, it's a lil dummy.",
	DOYDOYEGG = "Where dumb life begins.",
	
	DOYDOYFEATHER = "Hmmm, it dropped this.",
	DOYDOYNEST = "The lil dummies come from these.",
	DUBLOON = "Shiny coins!",
	DUG_BAMBOOTREE = "We're a gardening expert!",
	DUG_BUSH_VINE = "Where should we put this?",
	DUG_COFFEEBUSH = "With a little love it could grow again.",
	EARRING = "This belonged to a pirate!",
	FABRIC = "We could make a new blankie. Or not.",
	SAIL_FEATHER = "A feathery sail makes for swift travel.",
	FIRERAIN = "It's raining fire!",
	FIRERAINSHADOW = "Duck and cover!",
	FISHINHOLE = "Fishies for the taking!",
	FROG_POISON = "If we get licked by those we'll get sick.",
	GASHAT = "We are protected from sick smells.",
	GOLDENMACHETE = "What a beautiful blade!",
	ICEMAKER = "Ice is useful in this heat.",
	IRONWIND = "Who needs a sail!",
	LEIF_PALM = "Mean tree!",
	JELLYFISH = "That blob is alive!",
	JELLYFISH_COOKED = "We hoped it would be more... solid.",
	JELLYFISH_DEAD = "It's not jelly or fish. It's also not alive.",
	JELLYJERKY = "We'll try anything once.",
	JELLYFISH_PLANTED = "The sea is full of such weird junk.",
	JUNGLETREE =
	{
		BURNING = "What a senseless waste of firewood.",
		BURNT = "That's one less place for snakes to slither from.",
		CHOPPED = "Bye-bye, big tree.",
		GENERIC = "Oh neat, a big tree.",
	},
	JUNGLETREESEED = "Hard to believe such a big tree comes from this!",
	JUNGLETREESEED_SAPLING = "Grow, grow, grow!",
	LAVAPOOL = "Blazing hot!",
	LIMESTONENUGGET = "So bumpy!",
	ROCK_LIMPET =
	{
		GENERIC = "This rock is covered in food things!",
		PICKED = "Come back, yumyums.",
	},
	LIMPETS = "Do we have to eat these?",
	LIMPETS_COOKED = "Tastes like ocean.",
	
	LOBSTER = "This meat wears armor!",
	LOBSTERHOLE = "That is where the armored meat goes during the day.",
	BOAT_LOGRAFT = "This does not look swift.",
	MACHETE = "Hyah! Hyah!",
	MESSAGEBOTTLE = "Maybe there's a comic book in here!",
	MESSAGEBOTTLEEMPTY = "We wish it was filled with soda pop.",
	MOSQUITO_POISON = "These ones leave a gift when they bite.",
	
	MUSSEL = "Maybe one day I'll have big mussels.",
	MUSSEL_STICK = "The mussels do pull-ups on this.",
	OBSIDIAN = "Volcano rocks rock!",
	OBSIDIAN_WORKBENCH = "We forge the fire items here!",
	OBSIDIANAXE = "We'll be unstoppable!",
	OBSIDIANCOCONADE = "The weather will be bomb-y!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "We should put something on the fire before it goes out.",
		GENERIC = "We made the fire stones into a fire home!",
		HIGH = "That fire is huge!",
		LOW = "The fire's getting a touch low.",
		NORMAL = "The toastiest of fires.",
		OUT = "Well, that's done. But not forever!",
	},
	OBSIDIANMACHETE = "It cooks with each cut!",
	SPEAR_OBSIDIAN = "One jab makes'em burn up!",
	OBSIDIANSPEARGUN = "Like shooting fireworks!",
	OX = "Cool horns.",
	PACKIM = "Hello, large-mouthed friend!",
	PACKIM_FISHBONE = "We wonder what this is?",
	PALMLEAF = "Big leaf.",
	PALMTREE = 
	{
		BURNING = "What a senseless waste of firewood.",
		BURNT = "It's dropped its last coconut.",
		CHOPPED = "Goodbye, Tree of Palms.",
		GENERIC = "This tree has presents!",
	},
	PARROT = "Aren't you a chatty fellow!",
	PEACOCK = "Such pretty feathers!",
	PIRATEHAT = "Aaargh, we feel so salty!",
	PIRATIHATITATOR = "With this pirate hat we'll harness dark, cursed stuff.",
	POISONHOLE = "Yikes! The ground is farting!",
	BOAT_RAFT = "Do we think this is sturdy enough?",
	BOAT_ROW = "How's that old song go?",
	SAIL_PALMLEAF = "This'll give us a push!",
	SAND = "It's nice to feel it beneath our many feet.",
	SANDCASTLE = "Look what we built!",
	SANDBAG = "Sand pillows!",
	SANDDUNE = "Wish we had a bucket and a shovel.",
	SEAGULL = "We want to throw something at you.",
	SEAGULL_WATER = "It must be nice to fly... and eat garbage.",
	SEASACK = "Eww, it's wet and squishy.",
	SEASHELL = "Sea litter.",
	SEATRAP = "Things swim in. Dinner comes out.",
	SEAWEED = "The salad of the sea.",
	
	SEAWEED_PLANTED = "We should weed that out, maybe.",
	SHARK_FIN = "Do we touch it?",
	SHARX = "Sh...Sh...SHARK!!!!!",
	SLOTMACHINE = "I think I'm too young for this.",
	SNAKE = "We should keep our distance from those ones.",
	SNAKE_FIRE = "Aaaah, fire-breathing volcano thingies!",
	SNAKE_POISON = "These ones have a sick bite!",
	SNAKESKIN = "The skin of a snake!",
	SNAKESKINHAT = "Does snakeskin make us look tough?",
	SOLOFISH = "Say, there's a lot of meat on you!",
	SPEAR_POISON = "One jab'll do ya.",
	SPEARGUN = "We shoot it!",
	SPEARGUN_POISON = "I better point this away from myself.",
	STUNGRAY = "Aren't you cute! Hey, what's that smell...",
	SUPERTELESCOPE = "Helps us see better than with all our eyes, combined!",
	SWORDFISH = "We like your sword face, fish!",
	TELESCOPE = "I can see so far!",
	TIGERSHARK = "Out of the water!",
	TIGERSHARKSHADOW = "We're scared...",
	TORNADO = "We don't like this...",
	TOUCAN = "What a colorful beak you have!",
	TRAWLNET = "I wonder what we'll drag up.",
	TRAWLNETDROPPED = "What goodies are inside!",
	TRIDENT = "We feel like a god with this in our hands!",
	TRINKET_IA_13 = "Is it our birthday!",
	TRINKET_IA_14 = "Reminds me of Teddy.",
	TRINKET_IA_15 = "I wonder if it's in tune.",
	TRINKET_IA_16 = "Where's the automobile?",
	TRINKET_IA_17 = "Too big for us.",
	TRINKET_IA_18 = "This is a lot older than we are.",
	TRINKET_IA_19 = "What's a brain cloud?",
	TURBINE_BLADES = "Weird.",
	TURF_BEACH = "Some ground we dug up.",
	TURF_JUNGLE = "Some ground we dug up.",
	TWISTER = "Nature hates us!",
	VENOMGLAND = "The key to feeling better if we get sick.",
	VINE = "This stuff is wild.",
	VOLCANO = "Is that a... oh my...",
	VOLCANO_ALTAR = "We can feed the hungry volcano! But what does it like to eat?",
	VOLCANO_ALTAR_BROKEN = "That is a burning shame.",
	VOLCANO_EXIT = "We can escape the heat here.",
	VOLCANOSTAFF = "The volcano does our bidding!",
	WALL_LIMESTONE = "Is this wall made of limes?",
	WALL_LIMESTONE_ITEM = "Why is it called limestone? It's not even green.",
	WHALE_BLUE = "Buck up, big fella!",
	WHALE_CARCASS_BLUE = "Its suffering is over now.",
	WHALE_CARCASS_WHITE = "This is a very big dead thing.",
	WHALE_WHITE = "His eyes burn with hatred!",

	ARMORCACTUS = "Weaponized hugs!",
	BAMBOOTREE =
	{
		BURNT = "It's bamburnt.",
		CHOPPED = "It has a bamboo-boo.",
		GENERIC = "Cute little bamboo.",
	},
	BIGFISHINGROD = "Perhaps we'll hook something good.",
	BLOWDART_FLUP = "I can't imagine this would hurt very much.",
	BLUBBER = "Fat and happy.",
	BLUBBERSUIT = "A boy inside a spider inside a whale.",
	BOAT_TORCH = "It will light my way!",
	BRAINJELLYHAT = "It feels smart and squishy on our head.",
	BUOY = "I'm a little buoy too!",
	BUSH_VINE =
	{
		BURNT = "All burned up.",
		CHOPPED = "We took it all.",
		GENERIC = "It's a nice bush.",
	},
	COCONADE =
	{
		BURNING = "Fire in the hole!",
		GENERIC = "This will be so fun!",
	},
	COCONUT_COOKED = "Just needs a tiny umbrella.",
	COCONUT_HALVED = "Now there's one for each of us.",
	COFFEEBEANS_COOKED = "These make me feel funny.",
	COFFEEBOT = "The machine that makes the hyper juice!",
	COFFEEBUSH =
	{
		BARREN = "No more mean beans.",
		GENERIC = "It's covered in the happy beans.",
		PICKED = "We took them all.",
		WITHERED = "The bean bush looks sad.",
	},
	CORAL_BRAIN = "Yummy headmeats!",
	CORAL_BRAIN_ROCK = "I want to poke it, but I'm afraid our hand will get stuck.",
	CRAB =
	{
		CRAB = "One, two... s-six legs. Aw, we thought maybe you were a friend.",
		HIDDEN = "Come out, come out, wherever you are!",
	},
	CRATE = "Wow, a crate.",
	DEPLETED_GRASS_WATER = "All gone.",
	DOUBLE_UMBRELLAHAT = "One for each of us!",
	DOYDOYEGG_COOKED = "To make an omelette you have to endanger a few species.",
	DOYDOYEGG_CRACKED = "It cracked under the pressure.",
	DRAGOON = "It's a trailblazer!",
	DRAGOONDEN = "Maybe we'll leave that alone.",
	DRAGOONEGG = "Will it hatch soon?",
	DRAGOONHEART = "It's strangely hot.",
	DRAGOONSPIT = "Keep your bodily fluids to yourself!",
	DUG_ELEPHANTCACTUS = "Now I can use it.",
	ELEPHANTCACTUS = "It's withered, but still hurts to touch.",
	ELEPHANTCACTUS_ACTIVE = "It's made of hurt!",
	ELEPHANTCACTUS_STUMP = "Are you sleeping in there?",
	FISH_MED = "It would probably be better cooked.",
	FISH_SMALL = "It's a little fishy.",
	FISH_SMALL_COOKED = "Boney.",
	FLAMEGEYSER = "The ground is angry.",
	FLOTSAM = "There must be a way to grab it.",
	FLUP = "Why is it so aggressive!",
	-- FRESHFRUITCREPES = "Cripes! We can't wait for these crepes!",
	GRASS_WATER = "It's going for a swim.",
	HAIL_ICE = "Brrr!",
	HOUNDFIRE = "It's gonna burn away all our spider hair!",
	ICEMAKER =
	{
		HIGH = "It's running pretty good!",
		LOW = "I think it needs our help.",
		NORMAL = "Looks alright to us.",
		OUT = "Dead.",
		VERYLOW = "This thing's on its last legs. Maybe it can borrow some of ours?",
	},
	JUNGLETREE =
	{
		BURNING = "Too hot!",
		BURNT = "It's not green anymore.",
		CHOPPED = "We cut it up!",
		GENERIC = "Not a bad tree.",
	},
	KNIGHTBOAT = "It's mean!",
	KRAKEN = "Run away!",
	KRAKENCHEST = "Let's open it!",
	KRAKEN_TENTACLE = "Leave me alone!",
	ROCK_LIMPET =
	{
		GENERIC = "It's covered in limpets.",
		PICKED = "All gone.",
	},
	LIVINGJUNGLETREE = "Nothing out of the ordinary here.",
	LOBSTER_DEAD = "It's not moving anymore.",
	LOBSTER_DEAD_COOKED = "Yum, yum, yum!",
	LUGGAGECHEST = "Better finish packing.",
	MAGIC_SEAL = "Woah, magic-y!",
	MAGMAROCK = "It's a bunch of stony stones.",
	MAGMAROCK_FULL = "It's a bunch of stony stones.",
	MAGMAROCK_GOLD = "It's a bunch of shiny stones.",
	MAGMAROCK_GOLD_FULL = "It's a bunch of shiny stones.",
	MANGROVETREE = "It would be a cool place for a treehouse.",
	MANGROVETREE_BURNT = "So no treehouse, then.",
	MARSH_PLANT_TROPICAL = "It looks like a weed.",
	MERMFISHER = "Half-human, half-animal. Too weird.",
	MERMHOUSE_FISHER = "Can I come in?",
	MONKEYBALL = "We've made a friend!",
	-- MONSTERTARTARE = "Looks amazing!",
	MOSQUITOSACK_YELLOW = "The backside of a mosquito.",
	MUSSELBOUILLABAISE = "About as appetizing as they get.",
	MUSSEL_COOKED = "Still kind of gross.",
	MUSSEL_FARM =
	{
		GENERIC = "Yuck.",
		STICKPLANTED = "Is it done yet?",
	},
	MYSTERYMEAT = "It's a big goopy mess.",
	NEEDLESPEAR = "This could really hurt someone.",
	OCTOPUSCHEST = "Let's look inside!",
	OCTOPUSKING = "It looks friendly.",
	OXHAT = "How do we look?",
	OX_FLUTE = "It's just begging to be played!",
	OX_HORN = "We could put these on something to make it sharp.",
	PALMLEAF_HUT = "Almost as good as a spider nest.",
	PARROT_PIRATE = "As far as birds go, this one's very fashionable.",
	PEG_LEG = "This be our smackin' leg.",
	PIKE_SKULL = "We don't like that!",
	PIRATEGHOST = "As if normal pirates weren't scary enough!",
	PIRATEPACK = "A booty bundle.",
	PIRATIHATITATOR =
	{
		BURNT = "All burned up!",
		GENERIC = "This is definitely a thing. A magic pirate thing.",
	},
	PORTAL_SHIPWRECKED = "No one's going through this.",
	PRIMEAPE = "My best frenemy.",
	PRIMEAPEBARREL = "Too many monkeys.",
	RAWLING = "We like the wild ball man.",
	BARREL_GUNPOWDER = "Boom-material!",
	ROCK_OBSIDIAN = "This rock is pretty tough.",
	SAIL_STICK = "It's a stick!",
	SANDBAGSMALL = "Keeps the wet stuff out.",
	SANDBAGSMALL_ITEM = "Remember to lift with your legs... all eight of them!",
	SANDBAG = "Remember to lift with your legs... all eight of them!",
	SANDBAG_ITEM = "Remember to lift with your legs... all eight of them!",
	SANDCASTLE =
	{
		GENERIC = "That was fun!",
		SAND = "We wish we could live inside.",
	},
	SEASHELL_BEACHED = "We can hear the ocean with these. We can also hear it without them.",
	SEAWEED_COOKED = "Very salty.",
	SEAWEED_DRIED = "It sticks to the roof of our mouth!",
	SHADOWSKITTISH_WATER = "Eep!",
	SHARKITTEN = "Here kitty, kitty!",
	SHARKITTENSPAWNER =
	{
		GENERIC = "Maybe some kitties will come out and play?",
		INACTIVE = "Bland sand.",
	},
	SHARK_GILLS = "A big fish's breathing bits.",
	SHARK_TEETHHAT = "A smile to wear on our forehead!",
	SHIPWRECKED_ENTRANCE = "Let the adventure begin!",
	SHIPWRECKED_EXIT = "Bye-bye!",
	SNAKEDEN =
	{
		BURNT = "All burned up.",
		CHOPPED = "We took it all.",
		GENERIC = "It's a nice bush.",
	},
	SNAKEOIL = "It really works!",
	SAIL_SNAKESKIN = "With our sheet of gross skins, we're ready for adventure.",
	SPEAR_LAUNCHER = "Why would anyone launch a spear? Someone might get hurt.",
	SPOILED_FISH = "It's no good to anyone now.",
	SUNKBOAT = "So close, so far away.",
	SUNKEN_BOAT =
	{
		ABANDONED = "Maybe it's time to abandon ship, birdie.",
		GENERIC = "It's not much to look at.",
	},
	SUNKEN_BOAT_BURNT = "Hard to believe this thing was ever seaworthy.",
	SUNKEN_BOAT_TRINKET_1 = "It's very shiny.",
	SUNKEN_BOAT_TRINKET_2 = "Yaaaay!",
	SUNKEN_BOAT_TRINKET_3 = "We probably can't light that.",
	SUNKEN_BOAT_TRINKET_4 = "Is this a toy?",
	SUNKEN_BOAT_TRINKET_5 = "We'll boil this if we get desperate.",
	SWEETPOTATOSOUFFLE = "It's so dainty.",
	SWEET_POTATO = "You say \"po-tat-o\", I say \"dinner\"!",
	SWEET_POTATO_COOKED = "Orange foodmush.",
	SWEET_POTATO_PLANTED = "We want to eat that!",
	SWEET_POTATO_SEEDS = "We could plant these to grow more sweet potatoes.",
	SWIMMINGHORROR = "AHH!",
	TELEPORTATO_SW_BASE = "Can we eat off this?",
	TELEPORTATO_SW_BOX = "Someone's got a screw loose.",
	TELEPORTATO_SW_CRANK = "It's weird!",
	TELEPORTATO_SW_POTATO = "Aw, it's not even edible.",
	TELEPORTATO_SW_RING = "Maybe it's for hulahooping?",
	THATCHPACK = "Helps carry goodies!",
	TIDALPOOL = "It's like a fishbowl... without the bowl!",
	TIDAL_PLANT = "A little shrub.",
	TIGEREYE = "What're you looking at?",
	TRAWLNETDROPPED =
	{
		GENERIC = "What a tangled web we weave!",
		SOON = "It's going down!",
		SOONISH = "It's going down. Slowly.",
	},
	TRINKET_IA_20 = "It's very shiny.",
	TRINKET_IA_21 = "Yaaaay!",
	TRINKET_IA_22 = "What was in the bottle?",
	TRINKET_IA_23 = "Where did the words go?",
	FISH_TROPICAL = "It's pretty!",
	TUNACAN = "We left our can opener at home.",
	TURF_ASH = "Some ground that we dug up.",
	TURF_MAGMAFIELD = "Some ground that we dug up.",
	TURF_MEADOW = "Some ground that we dug up.",
	TURF_SNAKESKIN = "Some ground that we dug up.",
	TURF_SWAMP = "Some ground that we dug up.",
	TURF_TIDALMARSH = "Some ground that we dug up.",
	TURF_VOLCANO = "Some ground that we dug up.",
	TWISTER_SEAL = "Its cheeks look so pinchable!",
	VOLCANO_ALTAR =
	{
		GENERIC = "We can't use it right now.",
		OPEN = "The altar is ready for presents!",
	},
	VOLCANO_ALTAR_TOWER = "It's big!",
	VOLCANO_SHRUB = "I think it's speaking to me.",
	WALLYINTRO_DEBRIS = "Where's the rest of the ship?",
	WATERYGRAVE = "Blub blub.",
	WHALE_BUBBLES = "Which end are those coming from?",
	WHALE_TRACK = "Follow that whale!",
	WILBUR_CROWN = "We want to wear it.",
	WILBUR_UNLOCK = "He will make a nice friend.",
	WILDBORE = "I don't think he's friendly.",
	WILDBOREHEAD = "He doesn't look too happy.",
	WILDBOREHOUSE = "Muffled oinking is coming from inside.",
	WIND_CONCH = "A nice ocean breeze waits inside this shell. Well, maybe not so nice.",
	BOAT_WOODLEGS = "Ready for the open seas!",
	WOODLEGSHAT = "Yarr! Haha.",
	SAIL_WOODLEGS = "One fancy piece of cloth.",
	WOODLEGS_CAGE = "He needs our help!",
	WOODLEGS_KEY1 = "What will it open?",
	WOODLEGS_KEY2 = "This key's probably worth more than what it unlocks.",
	WOODLEGS_KEY3 = "A thing for opening other things.",
	SHIPWRECK = "A reminder to respect the sea.",
	CALIFORNIAROLL = "Hmm, something smells fishy about this!",

	--- 5C DLC ------------------------------------------------------------------------------------------------

	BOAT_ENCRUSTED = "Ready to set sail!",     
	BABYOX = "Pat pat.",
	BALLPHINHOUSE = "We'll just stay over here... and watch...",
	DORSALFIN = "Probably as close as I can get to these guys.",      
	NUBBIN = "It'll grow some hair soon.",
	CORALLARVE = "Aw, hi there.",
	RAINBOWJELLYFISH = "What do you think it eats?",
	RAINBOWJELLYFISH_PLANTED = "You look really nice!",
	RAINBOWJELLYFISH_DEAD = "Sorry, fishy.",
	RAINBOWJELLYFISH_COOKED = "I love brightly colored food!",
	RAINBOWJELLYJERKY = "Tough to chew, even with our big fangs!",
	WALL_ENFORCEDLIMESTONE = "Maybe the rubber blobs would like a playpen!",
	WALL_ENFORCEDLIMESTONE_ITEM = "We could put this down on the water.",      
	CROCODOG = "Ohh, oh no, uh, fetch??",
	POISONCROCODOG = "Leave us alone!",
	WATERCROCODOG = "Don't mind us, Mr. Dog!",     
	QUACKENBEAK = "Can it still eat me?",
	QUACKERINGRAM = "Everyone get out of our way!!",
	
	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "So fancy!",
	CORMORANT = "That's a big bird!",

	PURPLE_GROUPER = "Haha! What a silly face.",
	PIERROT_FISH = "It's slippery!",
	NEON_QUATTRO = "You're so slimy!",

	PURPLE_GROUPER_COOKED = "He likes the fish heads. I don't.",
	PIERROT_FISH_COOKED = "It's not as cute anymore.",
	NEON_QUATTRO_COOKED = "Mmm, smells good!",

	FISH_FARM = 
	{
		EMPTY = "No fishies.",
		STOCKED = "We drew the sign ourself.",
		ONEFISH = "A fish! It looks lonely.",
		TWOFISH = "Fish friends!",
		REDFISH = "So many fish!",
		BLUEFISH  = "A whole school! Let's give them homework.",
	},

	ROE = "These aren't spider eggs.",
	ROE_COOKED = "Not the kind of eggs we're used to.",
	
	SEA_YARD = 
	{
		ON = "It's making the boats feel better!",
		OFF = "It won't work again until we fuel it.",
		LOWFUEL = "We gotta fill it up soon.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "It's not very hot.",
		GENERIC = "We used coral to corral the fire!",
		HIGH = "Woah! It's so hot!",
		LOW = "The fire's kinda low.",
		NORMAL = "The fire's burning alright.",
		OUT = "Fire's gone!",
	}, 

	TAR = "Eww! It's stuck in our fur!",
	TAR_EXTRACTOR =
	{
		ON = "It's running real good!",
		OFF = "It's off right now.",
		LOWFUEL = "It's running out of juice.",
															
												   
	},
	TAR_POOL = "The yucky stuff down there might be useful.",

	TARLAMP = "We could burn some tar for light.",
	TARSUIT = "Oh, oh yuck! We'll never get that out of our fur!",
	TAR_TRAP = "Yuck! It's sticky!",

	TROPICALBOUILLABAISSE = "Mmm! Tastes like food!",

	SEA_LAB = "We keep dropping our tools in the water by accident.",
	WATERCHEST = "We could keep our bath toys in it!",	
	QUACKENDRILL = "It might help us find more tar.",
	HARPOON = "It's awful sharp.",
	MUSSEL_BED = "They'd be happier in the water.",	
},
}
%%+%%strings/wendy.lua%%-%%return {
ACTIONFAIL =
{
	REPAIRBOAT =
	{
		GENERIC = "It's already in better shape than I am.",
	},
},
ANNOUNCE_MAGIC_FAIL = "It's not doing anything. Sigh.",
ANNOUNCE_OTHER_WORLD_PLANT = "It doesn't belong here. Just like me.",
ANNOUNCE_MESSAGEBOTTLE =
{
	"All things fade, in time...",
},
ANNOUNCE_BOAT_DAMAGED = "This vessel is damaged. I can relate.",
ANNOUNCE_BOAT_SINKING = "I will soon face a watery grave.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "I surrender myself to the depths!",
ANNOUNCE_CRAB_ESCAPE = "It eluded death another day.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Watch as I sail straight into the maw of death!",
ANNOUNCE_MAPWRAP_RETURN = "I return once again to this world.",
ANNOUNCE_MAPWRAP_WARN = "Perhaps I'll sail from the edge of the earth.",
ANNOUNCE_TREASURE = "A treasure map... How exciting!",
ANNOUNCE_MORETREASURE = "Another map... Less exciting!",
ANNOUNCE_OTHER_WORLD_TREASURE = "This is a guide to a faraway land.",
ANNOUNCE_SHARX = "I am pursued by miscreants!",
ANNOUNCE_TRAWL_FULL = "The sea offers up its bounty.",
ANNOUNCE_VOLCANO_ERUPT = "Not with a bang, but with an ERUPTION!",
ANNOUNCE_WAVE_BOOST = "Joy...",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "The behemoth reveals itself!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Like Ishmael, my hunt is doomed.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "I will find you, beast!",

DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "For when the hunger gnaws at my tiny stomach...",
	CHEFPACK = "Only a true chef knows its tricks.",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "Whatever's in there isn't dead yet.",
		-- COOKING_SHORT = "It needs to boil.",
		-- DONE = "Finally, food.",
		-- EMPTY = "As empty as my soul.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "How are you coping, %s?",
        -- ATTACKER = "I don't trust %s. Fear makes people dangerous.",
        -- MURDERER = "%s, this is the end... for you!",
        -- REVIVER = "Abigail likes you, %s. I like your food.",
        -- GHOST = "We'll get a heart, but are you sure you want to come back, %s?",
		-- FIRESTARTER = "You must have used too much fire for your cooking, %s.",
    -- },

	SEAWEED_STALK = "They desire a watery grave.", --copied from the Wikia because I couldn't find it in the game files. -M

	LEIF_PALM = "Oh... no...", -- "A lumbering beast.",
	INVENTORYGRAVE = "Would they mind if I crawled in with them?",
	INVENTORYMOUND = "Would they mind if I crawled in with them?",
	LIMPETS_COOKED = "Depressing.",
	TROPICALFAN = "When I am still, it is as lifeless as Abigail.",
	PALMLEAF_UMBRELLA = "The sun beats down.",
	FISH_MED_COOKED = "A proper grilling puts a stop to the flopping.",
	SOLOFISH_DEAD = "It has shed its earthly tether.",
	GHOST_SAILOR = "He has found no respite.",
	-- BANANAPOP = "I used to eat these with Abigail...",
	BISQUE = "Feed the body, starve the soul...",
	-- CEVICHE = "All I taste is my sadness...",
	SEAFOODGUMBO = "A sea once teeming with life. No more.",
	SURFNTURF = "It could be worse.",
	SHARKFINSOUP = "It's tasted a mortal escape. I'll be tasting it.",
	LOBSTERDINNER = "Its death will give me life.",
	LOBSTERBISQUE = "I would like a spoon.",
	JELLYOPOP = "Death comes to us all. Sometimes on a stick.",
	CALIFORNIAROLL = "Crabbit, dressed up in a seaweed jacket.",
	AERODYNAMICHAT = "I cut through the air!",
	ANTIVENOM = "A potion to stave off the sickness.",
	ARMOR_LIFEJACKET = "I'd prefer a dry grave, thank you.",
	ARMOR_SNAKESKIN = "A jacket of dead flesh. Fashionable.",
	ARMOR_WINDBREAKER = "The wind's tendrils cannot hold me!",
	ARMORLIMESTONE = "Heavy...",
	ARMOROBSIDIAN = "Is it wise to don a suit of fire stone?",
	ARMORSEASHELL = "Armor made of the homes of dead goo.",
	BOAT_ARMOURED = "A boat that can take a bite or two.",
	BABYOX = "Youth is but a grain of sand, slipping through the hourglass.",
	BALLPHIN = "What a chipper little fellow. Does he know life has no meaning?",
	BALLPHINPOD = "Does swimming in pods stave off the loneliness of existence?",
	BAMBOO = "Green sticks... who cares...",
	BAMBOOTREE = "A long blade could part you from your life.",
	BERMUDATRIANGLE = "Dark energy courses through these mysterious portals...",
	BERRYBUSH2_SNAKE = "A snack, perchance?",
	BERRYBUSH_SNAKE = "A snack, perchance?",
	BIOLUMINESCENCE = "Life takes such curious forms! Yet death claims them all.",
	BLOWDART_POISON = "Sending ill will with a whisper.",
	BOAT_INDICATOR = "Where shall I launch my hopeless craft?",
	BOAT_LANTERN = "To see the vast nothingness in the black of night.",
	BOATCANNON = "It brings low death to high seas!",
	BOATREPAIRKIT = "This could save a boat from destruction, and me with it.",
	BOTTLELANTERN = "The light of life. Trapped.",
	BURIEDTREASURE = "Dead people's stuff.",
	BUSH_VINE = "They look as if they want to choke something.",
	SNAKEDEN = "They look as if they want to choke something.",
	CAPTAINHAT = "No living soul commands the sea...",
	BOAT_CARGO = "This transports more junk to nowhere.",
	CHIMINEA = "This shall protect a fire from the wind's prying fingers.",
	CIRCLINGSEAGULL = "Stay in the air, flying meat. There is nothing worth landing for.",
	SAIL_CLOTH = "With sail in hand I shall beat a hasty escape. But to where?",
	COCONADE = "A coconut filled with hot, fiery death.",
	COCONUT = "What secrets must this fruit hide beneath its armor?",
	COCONUT_SAPLING = "I was expecting a darker secret.",
	COFFEE = "Dark. Bitter...",
	COFFEEBEANS = "These look stimulating.",
	
	COFFEEBUSH = "This plant takes nourishment from fiery death.",
	CORAL = "The sea gives them life, and yet they stretch to escape it.",
	ROCK_CORAL = "The coral grows to escape the sea.",
	CRAB = "There is soft meat beneath that hard shell.",
	CRABHOLE = "A hole is just a grave that has yet to be covered.",
	CUTLASS = "It will feel no guilt from the kill. It is but a tool.",
	SWORDFISH_DEAD = "Its sword face couldn't save it...",
	DEPLETED_BAMBOOTREE = "It clings to life. Barely.",
	DEPLETED_BUSH_VINE = "The strangling vines have themselves been strangled.",
	DOYDOY = "This bird seems too stupid to be alive.",
	DOYDOYBABY = "How cute. And dumb.",
	DOYDOYEGG = "What a dumb egg.",
	
	DOYDOYNEST = "With each of these the island gets dumber. And meatier.",
	DUBLOON = "The currency of scallywags.",
	DUG_BAMBOOTREE = "Will you wither, or live?",
	DUG_BUSH_VINE = "Planting you again would be the true cruelty.",
	DUG_COFFEEBUSH = "Do you wish to return to the ground?",
	EARRING = "But no ear...",
	FABRIC = "I wonder if the bamboo finds this new form agreeable?",
	SAIL_FEATHER = "Those dumb birds sure make a speedy sail.",
	FIRERAIN = "Death from above!",
	FIRERAINSHADOW = "That can't be good.",
	FISHINHOLE = "The meat swims round and round. Oblivious.",
	FROG_POISON = "A poisonous lick from that and this nightmare will end.",
	GASHAT = "This hat prevents me from breathing in death.",
	GOLDENMACHETE = "What a fancy blade to ruin bamboo with!",
	ICEMAKER = "My heart makes ice too.",
	IRONWIND = "If I'm lucky I'll sail off the edge of the earth.",
	JELLYFISH = "How can such a curious thing even live?",
	JELLYFISH_COOKED = "It's sort of like gelatin.",
	JELLYFISH_DEAD = "It was a painless death. The beast had no nervous system.",
	JELLYFISH_PLANTED = "The sting isn't deadly. Only painful.",
	JELLYJERKY = "So... tough.",
	JUNGLETREESEED = "It's a parcel of potential.",
	JUNGLETREESEED_SAPLING = "There's no going back, now.",
	LAVAPOOL = "This pool churns with the volcano's anger!",
	LIMESTONENUGGET = "When coral dies it hardens into stone.",
	LIMPETS = "They eat of the rock. I eat of them.",
	
	LOBSTER = "It would taste excellent dead and smothered in butter.",
	LOBSTERHOLE = "A lobster dinner lives there.",
	BOAT_LOGRAFT = "This looks heavy, slow and dangerous.",
	MACHETE = "This is a lot of blade.",
	MESSAGEBOTTLE = "The last, desperate act of a doomed soul. In a bottle.",
	MESSAGEBOTTLEEMPTY = "Empty. Like my soul.",
	MOSQUITO_POISON = "As if bloodsucking wasn't low enough, this one leaves you sick.",
	MUSSEL = "You cannot hide beneath the waves, meat!",
	MUSSEL_STICK = "The mussels cling to this stick. Fools.",
	OBSIDIAN = "A stone forged of fire.",
	OBSIDIAN_WORKBENCH = "Ah, this is where fiery items are forged.",
	OBSIDIANAXE = "It cuts and burns.",
	OBSIDIANCOCONADE = "The tree's children will raze the world.",
	OBSIDIANFIREPIT =
	{
		EMBERS = "Don't give up, little flame!",
		GENERIC = "A flame to keep the horrors at bay.",
		HIGH = "This fire burns with passion!",
		LOW = "It's losing the will to go on.",
		NORMAL = "It burns with the anger of its maker.",
		OUT = "I'd better relight this.",
	},
	OBSIDIANMACHETE = "The blade both bites and burns.",
	SPEAR_OBSIDIAN = "Jabbing with fire.",
	OBSIDIANSPEARGUN = "I deliver fire with the pull of a trigger.",
	OX = "You are heavy with meat. Let me lighten your load.",
	PACKIM = "I would not trust him with a fish, but perhaps my junk...",
	PACKIM_FISHBONE = "A dead fish thingy. Looks important.",
	PALMLEAF = "I bet this leaf mourns its fallen tree.",
	PALMTREE =
	{
		BURNING = "I should probably step back.",
		BURNT = "It's turned a beautiful shade of black.",
		CHOPPED = "What lovely destruction.",
		GENERIC = "Its fruit bestows life, but only if I kill it.",
	},
	PALMTREE_BURNT = "It met a fiery end.",
	PALMTREE_STUMP = "Its tree torment is over.",
	PARROT = "Is it my ears, or does the creature chatter a lonesome monologue?",
	PEACOCK = "Such pretty feathers hiding tasty meat!",
	PIRATEHAT = "That hat of a cutthroat killer. I admire it.",
	PIRATIHATITATOR = "This is but a step from madness.",
	POISONHOLE = "The ground belches death.",
	BOAT_RAFT = "Perhaps if I ride upon the waves I shall join my sister.",
	BOAT_ROW = "I wonder how many leagues this can convey me?",
	SAIL_PALMLEAF = "Harness the wind and fly to... nowhere.",
	SAND = "I wonder if the sand knows of its own insignificance?",
	SANDCASTLE = "I suppose this diversion brings some comfort.",
	SANDBAG = "They hold back ruin. For a time...",
	SANDDUNE = "This looks impermanent.",
	SEAGULL = "The scavengers of land and sea.",
	SEAGULL_WATER = "As if it weren't bad enough that they foul the air.",
	SEASACK = "It slows the rot and decay.",
	SEASHELL = "Whatever used to live in this is probably dead now.",
	SEATRAP = "Come, creatures of the sea! Enjoy a lovely snack!",
	SEAWEED = "Even the sea is infested by weeds.",
	
	SEAWEED_PLANTED = "A hearty weed.",
	SHARK_FIN = "It won't be needing this anymore.",
	SHARX = "Terror of the sea!",
	SLOTMACHINE = "Ah, this seems a sensible test of fate.",
	SNAKE = "Devoid of arms or legs. I'd be angry too.",
	SNAKE_FIRE = "The children of the volcano. They breath its fire.",
	SNAKE_POISON = "The only thing worse than a snake is a poison one.",
	SNAKESKIN = "It shed its skin, with my assistance.",
	SNAKESKINHAT = "A hat of trophies, wrenched from the dead!",
	SOLOFISH = "Such graceful swimming. Such tasty flesh.",
	SPEAR_POISON = "One jab and they'll be retching.",
	SPEARGUN = "It deals death from a distance!",
	SPEARGUN_POISON = "Each shot inflicts a suffocating sickness.",
	STUNGRAY = "They fly to escape their own hideousness.",
	SUPERTELESCOPE = "I can see so much more useless nothing.",
	SWORDFISH = "This fish cuts death with its face!",
	TELESCOPE = "To peer over the horizon with an unabiding longing.",
	TIGERSHARK = "Orange striped death on water!",
	TIGERSHARKSHADOW = "Peril!",
	TORNADO = "Nature's ravenous wrath!",
	TOUCAN = "It sings a tortured song.",
	TRAWLNET = "A way to wrest items from the sea's grip.",
	TRAWLNETDROPPED = "I wonder what this net pulled from the sea?",
	TRIDENT = "The peoples that forged this are long dead.",
	TRINKET_IA_13 = "Maybe if I drank this stuff I'd return to my sister.",
	TRINKET_IA_14 = "If I pushed a pin into this doll, who would feel it?",
	TRINKET_IA_15 = "Whoever this belonged to isn't walking anymore.",
	TRINKET_IA_16 = "Whatever this belonged to met a bad end.",
	TRINKET_IA_17 = "Whoever wore this is surely dead.",
	TRINKET_IA_18 = "A remnant of a civilization lost at sea.",
	TRINKET_IA_19 = "The owner's brain has surely clouded for good by now.",
	TURBINE_BLADES = "No longer turning.",
	TURF_BEACH = "Sand does not make good grave fill.",
	TURF_JUNGLE = "A gnarled and twisted surface.",
	TWISTER = "Nature is very angry!",
	VENOMGLAND = "Their dead drop the cure to their sickness.",
	VINE = "Unruly life.",
	VOLCANO = "The mountain that spews death to the heavens!",
	VOLCANO_ALTAR = "The will of the volcano flows through this shrine!",
	VOLCANO_ALTAR_BROKEN = "Shame. No more weapons of fire to forge.",
	VOLCANO_EXIT = "Shall I leave this place of hot death?",
	VOLCANOSTAFF = "The fiery breath of the volcano is mine to command!",
	WALL_LIMESTONE = "A wall of the dead to beat back the living.",
	WALL_LIMESTONE_ITEM = "A wall made of living coral... No longer.",
	WHALE_BLUE = "It looks sad.",
	WHALE_CARCASS_BLUE = "Something this big and dead will surely stink.",
	WHALE_CARCASS_WHITE = "It is very big. And very dead.",
	WHALE_WHITE = "There is the hate of life burning in its eyes!",
	WOODLEGS_CAGE = "At least his soul escaped.",
	VOLCANO_SHRUB = "A wretched shadow of its former self.",
	ROCK_OBSIDIAN = "Do you burn to the touch?",
	ROCK_CHARCOAL = "I can't tell what you used to be.",
	DRAGOONDEN = "Cruel hearts dwell within.",

	ARMORCACTUS = "It makes me as prickly outside as I am inside!",
	BAMBOOTREE =
	{
		BURNT = "So it goes.",
		CHOPPED = "I've won this round.",
		GENERIC = "I can bend it to my will.",
	},
	BIGFISHINGROD = "Ye be warned, creatures of the sea. Death cometh to you.",
	BLOWDART_FLUP = "Now when I shoot someone a look it'll pack a punch!",
	BLUBBER = "The perfect meal for a blubbering fool.",
	BLUBBERSUIT = "Disturbing, but cozy.",
	BOAT = "It's a boat.",
	BOAT_TORCH = "How illuminating.",
	BRAINJELLYHAT = "Does this make my brain look big?",
	BUOY = "Float on, little friend.",
	BUSH_VINE =
	{
		BURNT = "I think it looks better like this.",
		CHOPPED = "Your sacrifice will not be in vain.",
		GENERIC = "It's quite pretty.",
	},
	COCONADE =
	{
		BURNING = "Fire in the hole!",
		GENERIC = "I hold someone's explosive death in my hands.",
	},
	COCONUT_COOKED = "It's a little sweet.",
	COCONUT_HALVED = "Two halves that were once whole. Where are you now, Abigail?",
	COFFEEBEANS_COOKED = "Who knew the will to live came in bean form?",
	COFFEEBOT = "I take mine black.",
	COFFEEBUSH =
	{
		BARREN = "It could use a pick me up.",
		GENERIC = "A beany gift from the heavens.",
		PICKED = "All wounds heal in time, little bush.",
		WITHERED = "I feel the same way.",
	},
	CORAL_BRAIN = "Is that what I look like inside?",
	CORAL_BRAIN_ROCK = "That's one smart-looking plant.",
	CRAB =
	{
		GENERIC = "This island has a crustacean infestation.",
		HIDDEN = "You can't hide from your problems forever. I've tried.",
	},
	CRATE = "It's just a box.",
	DEPLETED_GRASS_WATER = "No more.",
	DOUBLE_UMBRELLAHAT = "This seems excessive.",
	DOYDOYEGG_COOKED = "Not extinct yet, though not from lack of trying.",
	DOYDOYEGG_CRACKED = "This is probably a mercy.",
	DOYDOYFEATHER = "A spot of color in a dreary world.",
	DRAGOON = "Would make a lovely pet, if not for the whole \"murder\" thing.",
	DRAGOONEGG = "Hard to imagine this would birth forth such a horrific monster.",
	DRAGOONHEART = "This heart's as dead as my own, although much warmer.",
	DRAGOONSPIT = "Yuck!",
	DUG_ELEPHANTCACTUS = "Do I have to carry it?",
	ELEPHANTCACTUS = "It's sad and painful.",
	ELEPHANTCACTUS_ACTIVE = "This plant doesn't want anyone to touch it.",
	ELEPHANTCACTUS_STUMP = "It's hiding below.",
	FISH_MED = "It's been decapitated.",
	FISH_SMALL = "There are other fish in the sea. Bigger ones, hopefully.",
	FISH_SMALL_COOKED = "It will... tide... me over for now.",
	FLAMEGEYSER = "It's hot!",
	FLOTSAM = "I can't quite reach it.",
	FLUP = "That's too many eyes!",
	-- FRESHFRUITCREPES = "Could I get this a la mode?",
	GRASS_WATER = "Damp.",
	HAIL_ICE = "Frozen like my heart.",
	ICEMAKER =
	{
		HIGH = "It's in great shape.",
		LOW = "It seems a little depressed.",
		NORMAL = "It's feeling okay.",
		OUT = "It gave up.",
		VERYLOW = "It's running on fumes.",
	},
	JUNGLETREE =
	{
		BURNING = "I should probably step back.",
		BURNT = "It's turned a beautiful shade of black.",
		CHOPPED = "What lovely destruction.",
		GENERIC = "A jungle tree.",
	},
	KNIGHTBOAT = "That thing has anger issues!",
	KRAKEN = "Kneel to me, foul beast!",
	KRAKENCHEST = "What wonders lie within?",
	KRAKEN_TENTACLE = "Oh gee, I'm Quacken in my boots.",
	ROCK_LIMPET =
	{
		GENERIC = "Those look edible... sort of.",
		PICKED = "I picked it clean.",
	},
	LIVINGJUNGLETREE = "This unassuming tree looks exactly how I feel.",
	LOBSTER_DEAD = "It's met its maker. I've met my lunch.",
	LOBSTER_DEAD_COOKED = "It's a feast!",
	LUGGAGECHEST = "A very dapper item storage system.",
	MAGIC_SEAL = "It pulses with unknown power.",
	MAGMAROCK = "The earth's guts, cooled and ready for mining.",
	MAGMAROCK_FULL = "The earth's guts, cooled and ready for mining.",
	MAGMAROCK_GOLD = "The earth's guts, cooled and ready for mining.",
	MAGMAROCK_GOLD_FULL = "The earth's guts, cooled and ready for mining.",
	MANGROVETREE = "It's quite elegant.",
	MANGROVETREE_BURNT = "What a shame.",
	MARSH_PLANT_TROPICAL = "What a pathetic sprout.",
	MERMFISHER = "I commend this creature's commitment to cannibalism.",
	MERMHOUSE_FISHER = "How quaint.",
	MONKEYBALL = "It makes me feel less alone. Plus I can throw it.",
	-- MONSTERTARTARE = "Looks good, tastes horrible.",
	MOSQUITOSACK_YELLOW = "What a lovely shade of puke-yellow.",
	MUSSELBOUILLABAISE = "My mouth's watering just looking at it.",
	MUSSEL_COOKED = "I sure strongarmed this mussel.",
	MUSSEL_FARM =
	{
		GENERIC = "They don't look that tough to me.",
		STICKPLANTED = "Ha!",
	},
	MYSTERYMEAT = "That's grotesque.",
	NEEDLESPEAR = "One could end it all with this.",
	OCTOPUSCHEST = "That doesn't look like a reliable place to store things.",
	OCTOPUSKING = "I envy his contentment.",
	OXHAT = "Dashing.",
	OX_FLUTE = "That I might play a tune to soothe my troubled heart.",
	OX_HORN = "It's been severed from its owner.",
	PALMLEAF_HUT = "A welcome respite.",
	PARROT_PIRATE = "If I whispered my secrets to it, would it keep them safe?",
	PEG_LEG = "But where's the rest of the peg-person?",
	PIKE_SKULL = "I guess he chose Not-To-Be.",
	PIRATEGHOST = "A future friend of Abigail's?",
	PIRATEPACK = "This should help me carry more junk.",
	PIRATIHATITATOR =
	{
		BURNT = "Whatever it was, it's burnt now.",
		GENERIC = "I don't know what this is.",
	},
	PORTAL_SHIPWRECKED = "Like my beloved sister, I can never return.",
	PRIMEAPE = "His joviality is almost endearing. Almost.",
	PRIMEAPEBARREL = "Looks filthy.",
	RAWLING = "It speaks to me.",
	BARREL_GUNPOWDER = "This is a safety hazard. Good.",
	SAIL_STICK = "It's... a stick.",
	SANDBAGSMALL = "Dense and heavy.",
	SANDBAGSMALL_ITEM = "A bag of dirt I can carry.",
	SANDBAG_ITEM = "Looks like a back injury waiting to happen.",
	SANDCASTLE =
	{
		GENERIC = "Its beauty will undoubtedly succumb to the tide.",
		SAND = "If only molding the sands of time were so easy.",
	},
	SEASHELL_BEACHED = "She sells seashells... oh, what's the point.",
	SEAWEED_COOKED = "Better, but it's still a weed.",
	SEAWEED_DRIED = "It keeps longer like this. Tastes better too.",
	SHADOWSKITTISH_WATER = "Yikes.",
	SHARKITTEN = "I could see myself growing old with a houseful of these.",
	SHARKITTENSPAWNER =
	{
		GENERIC = "I smell... kitty litter?",
		INACTIVE = "A sizable sandpile.",
	},
	SHARK_GILLS = "No one's breathing through these now.",
	SHARK_TEETHHAT = "Chic, yet fearsome.",
	SHIPWRECKED_ENTRANCE = "Curiouser and curiouser.",
	SHIPWRECKED_EXIT = "Onward to the next adventure.",
	SNAKEDEN =
	{
		BURNT = "I think it looks better like this.",
		CHOPPED = "Your sacrifice will not be in vain.",
		GENERIC = "It's quite pretty.",
	},
	SNAKEOIL = "This fills me with a sense of mistrust.",
	SAIL_SNAKESKIN = "Gross, but efficient.",
	SPEAR_LAUNCHER = "Why throw a spear when you can shoot it?",
	SPOILED_FISH = "Farewell, chum.",
	SUNKEN_BOAT =
	{
		ABANDONED = "Are you all alone?",
		GENERIC = "Oh, the stories this ship could tell.",
	},
	SUNKEN_BOAT_BURNT = "A poetic end.",
	SUNKEN_BOAT_TRINKET_1 = "I just use it as a paperweight.",
	SUNKEN_BOAT_TRINKET_2 = "What sort of simple mind would be amused by this?",
	SUNKEN_BOAT_TRINKET_3 = "It's completely drenched.",
	SUNKEN_BOAT_TRINKET_4 = "I have no idea what that is.",
	SUNKEN_BOAT_TRINKET_5 = "What a cliche.",
	SWEETPOTATOSOUFFLE = "Delicate, but delicious.",
	SWEET_POTATO = "Sweet. Just like me.",
	SWEET_POTATO_COOKED = "Would that my despair tasted half so sweet.",
	SWEET_POTATO_PLANTED = "That looks like lunch.",
	SWEET_POTATO_SEEDS = "Perhaps these could give new life.",
	SWIMMINGHORROR = "I want to put some distance between myself and that!",
	TELEPORTATO_SW_BASE = "It's missing something.",
	TELEPORTATO_SW_BOX = "Looks a little screwy.",
	TELEPORTATO_SW_CRANK = "It seems incomplete.",
	TELEPORTATO_SW_POTATO = "What possible use could this have?",
	TELEPORTATO_SW_RING = "This ring's probably not for wearing.",
	THATCHPACK = "I was always destined to carry a heavy load.",
	TIDALPOOL = "When I gaze into this limpid pool I dream I can see Abigail.",
	TIDAL_PLANT = "It's sharp.",
	TIGEREYE = "Tyger, tyger, burning bright...",
	TRAWLNETDROPPED =
	{
		GENERIC = "What creatures will this wrest from the ocean?",
		SOON = "Its journey is almost at an end.",
		SOONISH = "It's started its journey into the depths.",
	},
	TRINKET_IA_20 = "I just use it as a paperweight.",
	TRINKET_IA_21 = "What sort of simple mind would be amused by this?",
	TRINKET_IA_22 = "Very DIY.",
	TRINKET_IA_23 = "How unfortunate.",
	FISH_TROPICAL = "It's offensively bright.",
	TUNACAN = "This is plainly false advertising.",
	TURF_ASH = "It's just ground.",
	TURF_MAGMAFIELD = "It's just ground.",
	TURF_MEADOW = "It's just ground.",
	TURF_SNAKESKIN = "It's just ground.",
	TURF_SWAMP = "It's just ground.",
	TURF_TIDALMARSH = "It's just ground.",
	TURF_VOLCANO = "It's just ground.",
	TWISTER_SEAL = "It has no awareness of the ills of this world.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It's closed for business.",
		OPEN = "Let the sacrifice begin!",
	},
	VOLCANO_ALTAR_TOWER = "A beautiful altar of death.",
	WALLYINTRO_DEBRIS = "The ship has been obliterated.",
	WATERYGRAVE = "I'm not above raiding a grave for loot.",
	WHALE_BUBBLES = "Looks like a fish with a gas problem.",
	WHALE_TRACK = "Whale, ho!",
	WILBUR_CROWN = "Monarchs must have tiny heads.",
	WILBUR_UNLOCK = "His finery does nothing to mask the smell.",
	WILDBORE = "What's it got to be angry about?",
	WILDBOREHEAD = "What lovely decor.",
	WILDBOREHOUSE = "Hopefully they won't invite me in.",
	WIND_CONCH = "A terrifying force of nature contained within a delicate shell.",
	BOAT_WOODLEGS = "A seaworthy vessel if ever there was one!",
	WOODLEGSHAT = "Haughty seadog couture.",
	SAIL_WOODLEGS = "I adore the design.",
	WOODLEGS_KEY1 = "What unfortunate soul donated their bones for this?",
	WOODLEGS_KEY2 = "It probably unlocks something fancy.",
	WOODLEGS_KEY3 = "What do you open?",
	SHIPWRECK = "Its crew is probably dead...",

	BOAT_ENCRUSTED = "A vessel of aquatic death.",
	BABYOX = "Cold, vacant eyes...",
	BALLPHINHOUSE = "A wretched den of joviality.",
	DORSALFIN = "Remnants of destruction.",
	NUBBIN = "Bare and completely devoid of life.",
	CORALLARVE = "What a foul worm.",
	RAINBOWJELLYFISH = "This jellyfish is much more vibrant than the others.",
	RAINBOWJELLYFISH_PLANTED = "It seems so content.",
	RAINBOWJELLYFISH_DEAD = "Death has come for it.",
	RAINBOWJELLYFISH_COOKED = "Beautiful, even in death.",
	RAINBOWJELLYJERKY = "Its death means my life.",
	WALL_ENFORCEDLIMESTONE = "Slimy on top.",
	WALL_ENFORCEDLIMESTONE_ITEM = "It would be more useful if I placed it.",
	CROCODOG = "If I stuck my head in its jaws, that would be the end.",
	POISONCROCODOG = "Pierce me with your venomous fangs...",
	WATERCROCODOG = "A damp death awaits me...",
	QUACKENBEAK = "Its gnashing days are over.",
	QUACKERINGRAM = "I can be assertive, when need be.",

	CAVIAR = "I took their life to sustain my own.",
	CORMORANT = "She is surely an ill omen.",

	PURPLE_GROUPER = "A pitiful creature.",
	PIERROT_FISH = "The stripes symbolize its emotional imprisonment.",
	NEON_QUATTRO = "It misses its watery home.",

	PURPLE_GROUPER_COOKED = "Rest now, fish spirit.",
	PIERROT_FISH_COOKED = "Don't lose your head.",
	NEON_QUATTRO_COOKED = "I've... eaten worse...",

	FISH_FARM = 
	{
		EMPTY = "Life can't come from nothing... I need something...",
		STOCKED = "Life needs time to blossom.",
		ONEFISH = "Look, Abby. We have a visitor.",
		TWOFISH = "Abby... There's more now...",
		REDFISH = "Do they know I'm watching?",
		BLUEFISH  = "They shall never taste freedom.",
	},

	ROE = "The beginnings of life...",
	ROE_COOKED = "I spared them the pain of hatching.",
	
	SEA_YARD = 
	{
		ON = "It wards off the inevitable decay.",
		OFF = "Decay will surely come for my ships now.",
		LOWFUEL = "It is close to giving up, just like me.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "It will soon be snuffed out.",
		GENERIC = "Afloat upon its own demise.",
		HIGH = "A healthy fire rages within.",
		LOW = "It tenuously clings to this world.",
		NORMAL = "It burns, for now.",
		OUT = "Its warmth and light were fleeting.",
	}, 

	TAR = "Thick, with a stench of corruption.",
	TAR_EXTRACTOR =
	{
		ON = "It is pulling sludge from the depths.",
		OFF = "It's off...",
		LOWFUEL = "It won't last much longer. Me neither.",
	},
	TAR_POOL = "Corruption oozes from beneath.",

	TARLAMP = "It takes vileness and makes it light.",
	TARSUIT = "To make my outside match my inside.",
	TAR_TRAP = "A recipe for a slow painful death.",
	TROPICALBOUILLABAISSE = "A brief respite from the hunger.",

	SEA_LAB = "Do I dare plumb the sea's dark knowledge?",
	WATERCHEST = "Treasures suspended over the bottomless abyss.",
	QUACKENDRILL = "Corruption spills forth from the depths.",
	HARPOON = "It brings naught but death.",
	MUSSEL_BED = "They yearn for the deep.",
},
}
%%+%%strings/wickerbottom.lua%%-%%return {
ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "Tip top!",
	},
	READ =
	{
		NOBIRDS = "The birds are not keen on this weather.",
	},
},
ANNOUNCE_OTHER_WORLD_PLANT = "This environment does not meet the basic conditions for this plant to thrive.",
ANNOUNCE_MESSAGEBOTTLE =
{
	"Illegible chickenscratch.",
},
ANNOUNCE_BOAT_DAMAGED = "My vessel is deteriorating!",
ANNOUNCE_BOAT_SINKING = "I do believe this boat is sinking.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "I had best head for shore! Now!",
ANNOUNCE_CRAB_ESCAPE = "Clever crustacean!",
ANNOUNCE_MAPWRAP_LOSECONTROL = "I'm unsure of the results of this venture.",
ANNOUNCE_MAPWRAP_RETURN = "That confirms it! This world is indeed round.",
ANNOUNCE_MAPWRAP_WARN = "The fog's inhabitants remain shrouded in \"mist\"-ery. Ho ho!",
ANNOUNCE_MORETREASURE = "My, what an excess of treasure!",
ANNOUNCE_OTHER_WORLD_TREASURE = "These coordinates do not pertain to this world.",
ANNOUNCE_SHARX = "Houndus Selachii! What a fascinating nuisance.",
ANNOUNCE_TRAWL_FULL = "The net can contain no more.",
ANNOUNCE_TREASURE = "Behold! Gold.",
ANNOUNCE_VOLCANO_ERUPT = "The earth's mantle is churning!",
ANNOUNCE_WAVE_BOOST = "Prime oceanic oscillations!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "What lies past those bubbles?!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Hmm, the creature has retreated into the depths.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "I've lost the trail in these turbulent waters!",

DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "It will be nice to eat some properly prepared food.",
	CHEFPACK = "Perfectly insulated.",
	-- PORTABLECOOKPOT = 
	-- {
        -- COOKING_LONG = "It's got a bit to go before it's ready.",
        -- COOKING_SHORT = "I'll tell Warly his cooking is nearing completion.",
        -- DONE = "Supper time!",
        -- EMPTY = "It's one of the more sanitary kitchenware I've seen. Apt to cook a fine meal.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "Ah, greetings dear %s!",
        -- ATTACKER = "You're not cooking up trouble, are you %s?",
        -- MURDERER = "I will defend myself from you, foul cad!",
        -- REVIVER = "I appreciate your commitment to group survival, %s.",
        -- GHOST = "%s, don't watch that crock pot of yours too closely now. Tsk.",
		-- FIRESTARTER = "Lighting fires are we now, %s? Keep your crock pot enclosed.",
    -- },

	SEAWEED_STALK = "I've always wanted to become a water-based horticulturist.", --copied from the Wikia because I couldn't find it in the game files. -M

    LEIF_PALM = "Fascinating... it's become bipedal!", --"I... don't even know.",
	BABYOX = "The young's odor wards off predators. And myself.",
	-- BANANAPOP = "Well, isn't that refreshing?",
	BISQUE = "Just what I needed.",
	-- CEVICHE = "Could use a little more sauce.",
	SEAFOODGUMBO = "I can feel the heartburn already!",
	SURFNTURF = "The perfect dish.",
	SHARKFINSOUP = "I may have meddled with a delicate ecosystem to make this.",
	LOBSTERDINNER = "How decadent.",
	LOBSTERBISQUE = "I'd almost forgotten what real food tasted like.",
	JELLYOPOP = "Takes me back to my youth. Sort of.",
	TROPICALFAN = "Its aerodynamic principals are astonishing.",
	PALMLEAF_UMBRELLA = "A leafy parasol that will provide moderate protection.",

	SOLOFISH_DEAD = "A shame.",
	FISH_MED_COOKED = "Beautifully grilled.",
	WHALE_WHITE = "A white whale! If only there were a book about such a thing!",

	AERODYNAMICHAT = "Somewhat prehistoric looking.",
	ANTIVENOM = "The contents should make a most useful antidote.",
	ARMORCACTUS = "This allows for anonymity among the cacti.",
	ARMORLIMESTONE = "A suit of skeletal fragments from the ocean floor.",
	ARMOROBSIDIAN = "Be careful, it's sharp!",
	ARMORSEASHELL = "Prevents infirmity from venomous bites.",
	ARMOR_LIFEJACKET = "Safety first!",
	ARMOR_SNAKESKIN = "Fauna-inspired rainwear.",
	ARMOR_WINDBREAKER = "Pink is not really my color.",
	BOAT_ARMOURED = "A strong vessel.",
	BALLPHIN = "What an adorable cetacean!",
	BAMBOO = "A useful material of high tensile strength.",
	BAMBOOTREE =
	{
		BURNT = "Pity.",
		CHOPPED = "Shall we see how fast it regenerates?",
		GENERIC = "Bamboo is among the fastest growing plants in the world.",
	},
	BERMUDATRIANGLE = "I don't believe in mysterious occurrences.",
	BIGFISHINGROD = "Access to the aquatic food chain.",
	BIOLUMINESCENCE = "Fascinating, beautiful marine biology.",
	BLOWDART_FLUP = "I prefer the flup in this form.",
	BLOWDART_POISON = "To destroy my foes from the inside out.",
	BLUBBER = "A buoyant and lipid-rich substance.",
	BLUBBERSUIT = "My mother would have been proud, I've put so much meat on my bones!",
	BOAT = "Where did this vessel come from?",
	BOATCANNON = "For combat at sea, I presume.",
	BOATREPAIRKIT = "Extends the life of aquatic vessels.",
	BOAT_LANTERN = "My oceanic night light.",
	BOAT_TORCH = "To better observe the nocturnal sea life.",
	BOOK_METEOR = "Rainus Magmus!",
	BOTTLELANTERN = "A portable source of illumination.",
	BRAINJELLYHAT = "Bright ideas shape the future!",
	BUOY = "Provides a bit of comfort out at sea, does it not?",
	BURIEDTREASURE = "My curiosity is getting the better of me!",
	BUSH_VINE =
	{
		BURNT = "Charred matter.",
		CHOPPED = "The stems will grow with time.",
		GENERIC = "A scandent flora.",
	},
	CAPTAINHAT = "The cap of a true boatswoman.",
	BOAT_CARGO = "I can store a few extra books aboard.",
	CHIMINEA = "Invented by an astute meteorologist!",
	SAIL_CLOTH = "An organic form of transportation.",
	COCONADE =
	{
		BURNING = "Count down to combustion!",
		GENERIC = "Explosives make me a tad uneasy.",
	},
	COCONUT = "The seed of Arecaceae. Enormous!",
	COCONUT_SAPLING = "Arecaceae has taken root.",
	COCONUT_COOKED = "Coconut flesh, quite delicious.",
	COCONUT_HALVED = "I managed to pry past its outer defenses.",
	COFFEE = "I do love a cup of coffee and a good book.",
	COFFEEBEANS = "Very high in caffeine.",
	COFFEEBEANS_COOKED = "Ahh, that roast smells delightful.",
	COFFEEBOT = "It produces coffee.",
	COFFEEBUSH =
	{
		BARREN = "It is not flowering at this time.",
		GENERIC = "Coffea genus.",
		PICKED = "Bean gone awhile now.",
		WITHERED = "It is too hot for the Coffea plant.",
},
	CORAL = "A chunk of calcium carbonate.",
	ROCK_CORAL = "I adore marine invertebrates!",
	CORAL_BRAIN = "Ingenious!",
	CORAL_BRAIN_ROCK = "Mussidae Brainus.",
	CRAB =
	{
		GENERIC = "Crabbits have an abnormally thick exoskeleton.",
		HIDDEN = "Attention please, crabbit!",
	},
	CRABHOLE = "A burrowing creature resides here.",
	CRATE = "What's inside?",
	CUTLASS = "Careful, it's sharp.",
	SWORDFISH_DEAD = "Looks a tad less ferocious this way.",
	DEPLETED_BAMBOOTREE = "Future regrowth is not an impossibility.",
	DEPLETED_BUSH_VINE = "Future regrowth is not an impossibility.",
	DEPLETED_GRASS_WATER = "Future regrowth is not an impossibility.",
	DOUBLE_UMBRELLAHAT = "Two tiers of shelter!",
	DOYDOY = "What a fascinating species!",
	DOYDOYBABY = "Reproduction has begun.",
	DOYDOYEGG = "Nature always finds a way.",
	DOYDOYEGG_COOKED = "Green eggs and ham.",
	DOYDOYEGG_CRACKED = "I'm so curious...",
	DOYDOYFEATHER = "A bit of plumage.",
	DOYDOYNEST = "Is it a decoy device?",
	DRAGOON = "These reptiles can withstand great temperatures.",
	DRAGOONDEN = "Could use a little tidying up.",
	DRAGOONEGG = "What could be living within this igneous rock?",
	DRAGOONHEART = "Dissection complete.",
	DRAGOONSPIT = "Mind yourself on that!",
	DUBLOON = "Aha! The currency of pirates.",
	DUG_BAMBOOTREE = "It requires soil to grow.",
	DUG_BUSH_VINE = "It requires soil to grow.",
	DUG_COFFEEBUSH = "It requires soil to grow.",
	DUG_ELEPHANTCACTUS = "It requires soil to grow.",
	EARRING = "Not my style.",
	ELEPHANTCACTUS = "A succulent atop the volcano! Most interesting.",
	ELEPHANTCACTUS_ACTIVE = "Its defenses are up!",
	ELEPHANTCACTUS_STUMP = "This plant is hibernating.",
	FABRIC = "A very fine weave.",
	SAIL_FEATHER = "Sail plumage.",
	FISHINHOLE = "I spy aquatic ectothermic creatures below!",
	FISH_MED = "An odorous slab of fish meat.",
	FISH_SMALL = "Fish flesh.",
	FISH_SMALL_COOKED = "Most nutritious.",
	FLAMEGEYSER = "What a stunning display!",
	FLOTSAM = "How might I retrieve that?",
	FLUP = "Keep that tongue to yourself!",
	-- FRESHFRUITCREPES = "Sticky fingers will ensue.",
	FROG_POISON = "Watch out!",
	GASHAT = "The calcium carbonate purifies the surrounding air particles.",
	GOLDENMACHETE = "The most malleable of metals, but let's see how it slices.",
	GRASS_WATER = "I can see the roots below the water.",
	HAIL_ICE = "Some storms have produced hail the size of cantaloupes.",
	HOUNDFIRE = "High temperatures! Take caution!",
	ICEMAKER =
	{
		HIGH = "Icetastic!",
		LOW = "Its pace is dropping.",
		NORMAL = "The output is quite regular.",
		OUT = "It's out of energy.",
		VERYLOW = "Nearly empty.",
	},
	INVENTORYGRAVE = "The pockets of explorers past.",
	INVENTORYMOUND = "The pockets of explorers past.",
	IRONWIND = "Now this is boating!",
	JELLYFISH = "Jellyfish, the most ancient of multi-organ creatures.",
	JELLYFISH_COOKED = "I have made it edible with a controlled chemical reaction.",
	JELLYFISH_DEAD = "Mind you don't step in that.",
	JELLYFISH_PLANTED = "Polyp-y.",
	JELLYJERKY = "What an inventive preserve.",
	JUNGLETREE =
	{
		BURNING = "It is burning.",
		BURNT = "A carbonized tree.",
		CHOPPED = "It has been harvested.",
		GENERIC = "This species grows to great heights!",
	},
	JUNGLETREESEED = "A seed, indeed.",
	JUNGLETREESEED_SAPLING = "It is thriving.",
	KNIGHTBOAT = "What a puzzling, mechanical sea horse!",
	KRAKEN = "Octopodes have numerous defensive strategies.",
	KRAKENCHEST = "I could take a calculated guess at what's within. But only a guess.",
	KRAKEN_TENTACLE = "Mind the muscular hydrostats!",
	LAVAPOOL = "I won't be wading in that pool.",
	LIMESTONENUGGET = "Commonly used in architecture.",
	ROCK_LIMPET =
	{
		GENERIC = "This boulder is home to various gastropods.",
		PICKED = "The snails have already been harvested.",
	},
	LIMPETS = "Patella vulgata.",
	LIMPETS_COOKED = "Cooked Patella vulgata.",
	LIVINGJUNGLETREE = "Magic botany at its finest.",
	LOBSTER = "A most interesting invertebrate.",
	LOBSTERHOLE = "Home to the arthropod.",
	LOBSTER_DEAD = "I might as well eat it now.",
	LOBSTER_DEAD_COOKED = "Dinner is served!",
	BOAT_LOGRAFT = "Crude nautical transport.",
	LUGGAGECHEST = "Someone has lost their luggage.",
	MACHETE = "Used for hacking through the brush.",
	MAGIC_SEAL = "The young seal has left a gift!",
	MAGMAROCK = "What lies beneath?",
	MAGMAROCK_FULL = "What lies beneath?",
	MAGMAROCK_GOLD = "This formation contains veins of gold.",
	MAGMAROCK_GOLD_FULL = "This formation contains veins of gold.",
	MANGROVETREE = "This tree species is salt tolerant!",
	MANGROVETREE_BURNT = "It will not regrow at this stage.",
	MARSH_PLANT_TROPICAL = "Plantae greenus.",
	MERMFISHER = "This one has sophisticated harvesting skills.",
	MERMHOUSE_FISHER = "An amphibious shack.",
	MESSAGEBOTTLE = "I am intrigued!",
	MESSAGEBOTTLEEMPTY = "I do like when there is a manuscript inside.",
	MONKEYBALL = "My primate decoy.",
	-- MONSTERTARTARE = "Monster meat, dressed up fancy.",
	MOSQUITOSACK_YELLOW = "A healing substance.",
	MOSQUITO_POISON = "The sting of that insect injects a nasty poison.",
	MUSSEL = "Clamus wetus. Very nutritious.",
	MUSSELBOUILLABAISE = "Clam soup.",
	MUSSEL_COOKED = "Don't eat the shell, dear.",
	MUSSEL_FARM =
	{
		GENERIC = "I can't quite reach them from here.",
		STICKPLANTED = "And now we wait! Nature will take its course.",
	},
	MUSSEL_STICK = "To harvest mollusks.",
	MYSTERYMEAT = "Regurgitated sea life. None for me, thanks.",
	NEEDLESPEAR = "Think like a cactus.",
	OBSIDIAN = "A derivative of volcanic lava.",
	OBSIDIANAXE = "This tool generates its own heat.",
	OBSIDIANCOCONADE = "A very powerful explosive projectile.",
	OBSIDIANFIREPIT =
	{
		GENERIC = "To keep quite warm.",
		OUT = "I can re-light it.",
		EMBERS = "The fire has almost self-extinguished.",
		LOW = "The fire could use some more fuel.",
		NORMAL = "Perfect light for reading a book.",
		HIGH = "That fire is burning at an alarming rate.",
	},
	OBSIDIANMACHETE = "This tool generates its own heat.",
	OBSIDIANSPEARGUN = "This tool generates its own heat.",
	OBSIDIAN_WORKBENCH = "Just the spot to learn volcanic craftsmanship.",
	OCTOPUSCHEST = "Looks as though it's been sitting at the bottom of a reef.",
	OCTOPUSKING = "He is the center of this ecosystem.",
	OX = "They do become a bit smelly when wet.",
	OXHAT = "A sturdy head covering.",
	OX_FLUTE = "Its music stirs Mother Nature.",
	OX_HORN = "The lumbering mammal dropped this horn.",
	PACKIM = "Hello, feathered apprentice!",
	PACKIM_FISHBONE = "What sort of fish was this?",
	PALMLEAF = "It fell from the palm.",
	PALMLEAF_HUT = "Refreshing relief from the sun's relentless gaze.",
	PALMTREE =
	{
		CHOPPED = "It has been harvested.",
		BURNING = "The tree is burning.",
		BURNT = "A carbonized tree.",
		GENERIC = "I'd like to sit underneath it with a good book.",
	},
	PARROT = "It is a colorful tropical bird.",
	PARROT_PIRATE = "I wonder if he can read?",
	PEACOCK = "Pavo cristatus.",
	PEG_LEG = "What a curious choice of object for use as a weapon!",
	PIKE_SKULL = "Skeletal remains.",
	PIRATEGHOST = "Paranormal pirate activity.",
	PIRATEHAT = "When in Rome!",
	PIRATEPACK = "A treasure carrying case.",
	PIRATIHATITATOR =
	{
		BURNT = "Not very useful now, is it?",
		GENERIC = "It's a research machine, fueled by the nautical sciences.",
	},
	POISONHOLE = "Keep your distance. Airborne toxins spew out in regular intervals.",
	PORTAL_SHIPWRECKED = "I sense magic here.",
	PRIMEAPE = "These little apes are very cunning.",
	PRIMEAPEBARREL = "A monkey habitat.",
	BOAT_RAFT = "Bamboo how-to.",
	RAWLING = "Mr. Chatty Pants.",
	BARREL_GUNPOWDER = "An explosive chemical reaction will occur when its triggered.",
	ROCK_CHARCOAL = "A carbon rich resource.",
	ROCK_OBSIDIAN = "Now this is a tough nut to crack.",
	BOAT_ROW = "My vessel for marine research.",
	SAIL_PALMLEAF = "For wind-powered travel.",
	SAIL_STICK = "I can use this to my advantage in a storm.",
	SAND = "Sand always seems to find its way into my books.",
	SANDBAG = "Most absorbent.",
	SANDBAGSMALL = "Most absorbent.",
	SANDBAGSMALL_ITEM = "A flood prevention tactic.",
	SANDBAG_ITEM = "A flood prevention tactic.",
	SANDDUNE = "The dune's iconic shape is formed by the winds.",
	SANDCASTLE =
	{
		GENERIC = "I modeled it after a classic European castellum.",
		SAND = "I modeled it after a classic European castellum.",
	},
	SEAGULL = "A scavenger of the Laridae Birdus family.",
	SEAGULL_WATER = "A scavenger of the Laridae Birdus family.",
	SEASACK = "Keeps my books and provisions cool!",
	SEASHELL = "This was once the covering of a marine invertebrate.",
	SEASHELL_BEACHED = "Look what the tide brought in!",
	SEATRAP = "Place it near the creature's den.",
	SEAWEED = "I'll admit, I'm not much of a phycologist.",
	SEAWEED_COOKED = "Very high in protein.",
	SEAWEED_DRIED = "I've dried the algae.",
	SEAWEED_PLANTED = "Marine algae.",
	SHADOWSKITTISH_WATER = "Supernatural apparitions are beginning to take shape...",
	SHARKITTEN = "The offspring seem quite harmless. And cute.",
	SHARKITTENSPAWNER =
	{
		GENERIC = "I do wonder how deep the chamber goes.",
		INACTIVE = "Hibernation season.",
	},
	SHARK_FIN = "The dorsal fin functions as an aquatic stabilizer.",
	SHARK_GILLS = "Gills remove oxygen from the water. Wonderful biomechanics!",
	SHARK_TEETHHAT = "A crown of teeth.",
	SHARX = "Keep your voice down!",
	SHIPWRECKED_ENTRANCE = "A special ship for transcending worlds.",
	SHIPWRECKED_EXIT = "Is it time to depart from this tropical paradise?",
	SLOTMACHINE = "I'd wager the outcome is chancy.",
	SNAKE = "Stay back, serpent!",
	SNAKEDEN =
	{
		BURNT = "Charred matter.",
		CHOPPED = "The stems will grow with time.",
		GENERIC = "A scandent flora.",
	},
	SNAKEOIL = "The usefulness of this substance remains uncertain.",
	SNAKESKIN = "A layer of snake.",
	SNAKESKINHAT = "Rain repellent headwear!",
	SAIL_SNAKESKIN = "A sail of serpent hide.",
	SNAKE_FIRE = "It's hot!",
	SNAKE_POISON = "Beware its venomous bite.",
	SOLOFISH = "Canis fishus.",
	SPEARGUN = "I appreciate the advantage of a ranged gadget.",
	SPEARGUN_POISON = "I appreciate the advantage of a poisonous ranged gadget.",
	SPEAR_LAUNCHER = "I appreciate the advantage of a ranged gadget.",
	SPEAR_OBSIDIAN = "This tool generates its own heat.",
	SPEAR_POISON = "Now I can administer a toxic bite!",
	SPOILED_FISH = "That fish matter is becoming a biohazard.",
	STUNGRAY = "Look at that wingspan!",
	SUNKEN_BOAT =
	{
		ABANDONED = "It appears this boat did not fare well.",
		GENERIC = "What say you, Avifauna?",
	},
	SUNKEN_BOAT_BURNT = "Only blackened matter remains.",
	SUNKEN_BOAT_TRINKET_1 = "A device for taking measurements.",
	SUNKEN_BOAT_TRINKET_2 = "A lovely, tiny boat.",
	SUNKEN_BOAT_TRINKET_3 = "Appears well used.",
	SUNKEN_BOAT_TRINKET_4 = "Looks like a useful mechanical piece.",
	SUNKEN_BOAT_TRINKET_5 = "It is an old boot. I wonder where the other is?",
	SUPERTELESCOPE = "Uncovering new horizons!",
	SWEETPOTATOSOUFFLE = "Quite delicious.",
	SWEET_POTATO = "Kumara!",
	SWEET_POTATO_COOKED = "Grilled kumara.",
	SWEET_POTATO_PLANTED = "A root vegetable.",
	SWEET_POTATO_SEEDS = "To grow another root vegetable.",
	SWIMMINGHORROR = "Oh dear, I'm seeing things...",
	SWORDFISH = "Don't upset the broadbill!",
	TELEPORTATO_SW_BASE = "It is an invitation for restoration!",
	TELEPORTATO_SW_BOX = "What might this attach to?",
	TELEPORTATO_SW_CRANK = "A straw lever.",
	TELEPORTATO_SW_POTATO = "Perplexing hardware...",
	TELEPORTATO_SW_RING = "An organic nut to a bolt?",
	TELESCOPE = "It collects visible light to better my vision.",
	THATCHPACK = "I can store a few books in here.",
	TIDALPOOL = "Tidal pools are fascinating micro ecosystems!",
	TIDAL_PLANT = "A multicellular eukaryote.",
	TIGEREYE = "The ocular lens of a large creature.",
	TIGERSHARK = "Selachii Felidae. A very large one!",
	TOUCAN = "A species known for its brightly colored bill.",
	TRAWLNET = "For collecting debris at sea.",
	TRAWLNETDROPPED =
	{
		GENERIC = "Unpack the contents!",
		SOON = "It looks to be sinking.",
		SOONISH = "That net will be sunk within moments.",
	},
	TRIDENT = "A tool of ancient legend.",
	TRINKET_IA_13 = "A soda beverage can.",
	TRINKET_IA_14 = "A tribal artifact.",
	TRINKET_IA_15 = "How melodic.",
	TRINKET_IA_16 = "What does this inscription mean?",
	TRINKET_IA_17 = "It is an old boot. I wonder where the other is?",
	TRINKET_IA_18 = "It is adorned with markings.",
	TRINKET_IA_19 = "Curious...",
	TRINKET_IA_20 = "A device for taking measurements.",
	TRINKET_IA_21 = "A lovely, tiny boat.",
	TRINKET_IA_22 = "Appears well used.",
	TRINKET_IA_23 = "Don't step on it!",
	FISH_TROPICAL = "How colorful.",
	TUNACAN = "Preserved fish.",
	TURBINE_BLADES = "I'll have to research what I can do with these!",
	TURF_ASH = "The ground. You step on it.",
	TURF_BEACH = "The ground. You step on it.",
	TURF_JUNGLE = "The ground. You step on it.",
	TURF_MAGMAFIELD = "The ground. You step on it.",
	TURF_MEADOW = "The ground. You step on it.",
	TURF_SNAKESKIN = "The ground. You step on it.",
	TURF_SWAMP = "The ground. You step on it.",
	TURF_TIDALMARSH = "The ground. You step on it.",
	TURF_VOLCANO = "The ground. You step on it.",
	TWISTER = "A vortex of unyielding energy!",
	TWISTER_SEAL = "Now how did you cause all that trouble?",
	VENOMGLAND = "A useful substance for poison prevention.",
	VINE = "A common jungle vine.",
	VOLCANO = "Tectonic activity at its finest!",
	VOLCANOSTAFF = "I can feel it rumbling with volcanic pressure.",
	VOLCANO_ALTAR =
	{
		GENERIC = "A link to the volcano's core.",
		OPEN = "What shall I present it with?",
	},
	VOLCANO_ALTAR_BROKEN = "It appears permanently disabled.",
	VOLCANO_ALTAR_TOWER = "A grand structure.",
	VOLCANO_EXIT = "The return to more comfortable temperatures!",
	VOLCANO_SHRUB = "This tree has been scorched from the heat.",
	WALLYINTRO_DEBRIS = "Remains of a sea vessel.",
	WALL_LIMESTONE = "A bit of protection.",
	WALL_LIMESTONE_ITEM = "For limestone construction.",
	WATERYGRAVE = "I wonder how long it's been drifting at sea?",
	WHALE_BLUE = "I do love marine mammals!",
	WHALE_BUBBLES = "Something big lies beneath.",
	WHALE_CARCASS_BLUE = "Break down begins.",
	WHALE_CARCASS_WHITE = "There is a harpoon still stuck inside.",
	WHALE_TRACK = "Follow the path of this cetacean!",
	WILBUR_CROWN = "Who might this have belonged to?",
	WILBUR_UNLOCK = "Excuse me, monkey, do you require assistance?",
	WILDBORE = "Suidae swine is looking grim.",
	WILDBOREHEAD = "It appears a dissection took place here.",
	WILDBOREHOUSE = "A shelter for the bore.",
	WIND_CONCH = "With a song that moves atmospheric pressures.",
	BOAT_WOODLEGS = "A pirate ship.",
	WOODLEGSHAT = "It would better suit a pirate than I.",
	SAIL_WOODLEGS = "A pirate sail.",
	WOODLEGS_CAGE = "How did you get in there, scruffy sir?",
	WOODLEGS_KEY1 = "A skull key...",
	WOODLEGS_KEY2 = "Which lock does this activate?",
	WOODLEGS_KEY3 = "A key of great curiosity.",
	SHIPWRECK = "This ship got caught in a storm. Now it belongs to the sea.",
	CALIFORNIAROLL = "Delicious makizushi.",

	--- 5C DLC ------------------------------------------------------------------------------------------------
 
	BOAT_ENCRUSTED = "Large surface area and natural buoyancy make it an excellent vessel.",
	BABYOX = "Aren't you a handsome widdle gentleman!",
	BALLPHINHOUSE = "The den of a marine mammal pod.",
	DORSALFIN = "The dorsal fin of a friendly cetacean.",
	NUBBIN = "The base of a future coral bloom.",
	CORALLARVE = "The polyp of a marine invertebrate.",
	RAINBOWJELLYFISH = "A rather vibrant member of the Mudesozoa subphylum.",
	RAINBOWJELLYFISH_PLANTED = "I believe it feeds on the local bioluminescence.",
	RAINBOWJELLYFISH_DEAD = "A deceased Medusozoa.",
	RAINBOWJELLYFISH_COOKED = "A thoroughly cooked Medusozoa specimen.",
	RAINBOWJELLYJERKY = "A reliable source of desert island protein.",
	WALL_ENFORCEDLIMESTONE = "The seaweed is just decorative. Like a doily.",
	WALL_ENFORCEDLIMESTONE_ITEM = "Ready for placement.",
	CROCODOG = "You had best behave!",
	POISONCROCODOG = "Its saliva contains a nasty venom.",
	WATERCROCODOG = "I am wholly unfamiliar with the species.",
	QUACKENBEAK = "If that brute can't hold its mouth then I will.",
	QUACKERINGRAM = "Sometimes brute force is necessary.",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "Differentiated from roe chiefly by the jar.",
	CORMORANT = "What a handsome Phalacrocoracidae!",

	PURPLE_GROUPER = "Part of the Epinephelinae family.",
	PIERROT_FISH = "Hmm... I can't seem to identify this species.",
	NEON_QUATTRO = "Closely related to Paracheirodon innesi.",

	PURPLE_GROUPER_COOKED = "Eating unprepared fish just wouldn't be safe.",
	PIERROT_FISH_COOKED = "Fish are host to all sorts of parasites, you know.",
	NEON_QUATTRO_COOKED = "A cousin of Paracheirodon innesi, ready for dinner.",

	FISH_FARM = 
	{
		EMPTY = "I must find roe if I'm to raise captive fish.",
		STOCKED = "The fish roe will mature soon.",
		ONEFISH = "Domestication was a success!",
		TWOFISH = "It seems to be doing quite well.",
		REDFISH = "My, what a yield!",
		BLUEFISH  = "How studious. They've formed a whole school.",
	},

	ROE = "The first stage in the fish life cycle.",
	ROE_COOKED = "The first and last stages of this life cycle.",
	
	SEA_YARD = 
	{
		ON = "It's at peak performance.",
		OFF = "I must procure a new fuel source.",
		LOWFUEL = "The fuel is running quite low.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "I risk losing my fire without more fuel.",
		GENERIC = "That should serve my purposes nicely.",
		HIGH = "Quite the blaze!",
		LOW = "It's getting a touch low.",
		NORMAL = "It's burning quite well.",
		OUT = "It will need to be relit.",
	}, 

	TAR = "Historically used for waterproofing ships.",
	TAR_EXTRACTOR =
	{
		ON = "I must remember to switch it off when done.",
		OFF = "I must switch it on to begin tar extraction.",
		LOWFUEL = "I'll need to refuel it if I want more tar.",
	},
	TAR_POOL = "It appears to be a natural tar well.",

	TARLAMP = "Tar ought to combust quite well in this.",
	TARSUIT = "Effective, but not very durable.",
	TAR_TRAP = "Well, anyone ensnared will preserve quite nicely.",

	TROPICALBOUILLABAISSE = "An inventive twist on a traditional Marseille dish.",

	SEA_LAB = "A dedicated scholar can study anywhere.",
	WATERCHEST = "A buoy I repurposed as a storage device.",
	QUACKENDRILL = "An implement of deepwater drilling.",
	HARPOON = "I do hope my throwing arm's not rusty.",
	MUSSEL_BED = "These mollusks will be sure to thrive once planted.",
},
}
%%+%%strings/wilbur.lua%%-%%return {
DESCRIBE_TOODARK = "Eee! Eee! Eee!",
DESCRIBE = 
{
	CAVE_BANANA = "'Nanas!",
	CAVE_BANANA_COOKED = "'Nanas!",
	CAVE_BANANA_TREE = "'Nanas!",
	CAVE_BANANA_BURNT = "'Nonos!",
	BANANAPOP = "'Nonos!",
},
}
%%+%%strings/willow.lua%%-%%return {
ACTIONFAIL =
{
	REPAIRBOAT =
	{
		GENERIC = "Ugh, why would I do that now?",
	},
},
ANNOUNCE_MAGIC_FAIL = "Why won't it work!!",
ANNOUNCE_VOLCANO_ERUPT = "The fiery mountain speaks!",
ANNOUNCE_TREASURE = "\"X\" marks the spot!",
ANNOUNCE_CRAB_ESCAPE = "Shoot! It got away!",
ANNOUNCE_SHARX = "Hey! Stop splashing around out there!",
ANNOUNCE_MORETREASURE = "This day just got better.",
ANNOUNCE_OTHER_WORLD_TREASURE = "This doesn't look like a map of this place.",
ANNOUNCE_OTHER_WORLD_PLANT = "It won't grow. Maybe I should burn it instead.",
ANNOUNCE_MAPWRAP_WARN = "That fog looks pretty dense.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Uh oh. Which way was I going again?",
ANNOUNCE_MAPWRAP_RETURN = "I couldn't see a thing in there!",
ANNOUNCE_MESSAGEBOTTLE =
{
	"The message is faded. I can't read it.",
},
ANNOUNCE_BOAT_DAMAGED = "My boat is wounded!",
ANNOUNCE_BOAT_SINKING = "I'm going down!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "Goodbye cruel world!",
ANNOUNCE_TRAWL_FULL = "My trawl is ready to reel in.",
ANNOUNCE_WAVE_BOOST = "Weeee!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Ooo, there's a big fishie nearby.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Grr, I lost it!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "The water's too rough to see!",

DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "Just a dumb pot.",
	CHEFPACK = "A chef hat for a backpack!",
	-- PORTABLECOOKPOT = 
	-- {
        -- COOKING_LONG = "Don't tell Warly, but I'm gonna put things in the fire!",
		-- COOKING_SHORT = "The fire is doing its thing!",
		-- DONE = "Fire makes everything better. Mmm!",
		-- EMPTY = "All food must be cleansed with fire.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "Hi %s!",
        -- ATTACKER = "You're only fueling the fire, %s!",
        -- MURDERER = "Burn the murderer! And take his food!",
        -- REVIVER = "Who do ghosts call? %s! For a some good food!",
        -- GHOST = "Hey %s, I'll get you a heart if you let me use your crock pot!",
		-- FIRESTARTER = "Now that's how you start a cooking fire, %s!",
    -- },

	SEAWEED_STALK = "A bunch of soggy weeds.", --copied from the Wikia because I couldn't find it in the game files. -M

	LEIF_PALM = "I don't like you. You don't like me.", --"He looks flammable!",
	BIGFISHINGROD = "It's big.",
	INVENTORYGRAVE = "Not everyone has what it takes out here.",
	INVENTORYMOUND = "Not everyone has what it takes out here.",
	TROPICALFAN = "I dunno... it could put out some fires...",
	PALMLEAF_UMBRELLA = "It's so nice!",
	PALMTREE =
	{
		BURNING = "Wooow! So much fire!",
		BURNT = "A major improvement.",
		CHOPPED = "That took a few swings.",
		GENERIC = "You have a curious lack of branches.",
	},
	SOLOFISH_DEAD = "Time to chuck it in the fire!",
	FISH_MED_COOKED = "It actually looks kinda edible.",
	GHOST_SAILOR = "He'd probably be happier if he could make fire.",
	AERODYNAMICHAT = "Brisk movement snuffs fires.",
	ARMOR_LIFEJACKET = "But will it keep my lighter dry?",
	ARMOR_SNAKESKIN = "This coat makes me feel dangerous.",
	ARMOR_WINDBREAKER = "Wind is the enemy of fire.",
	ARMORLIMESTONE = "It's so... heavy.",
	ARMOROBSIDIAN = "Hit me and BURN!",
	ARMORSEASHELL = "Try me, baddies.",
	BOAT_ARMOURED = "Nothing's gonna take a bite out of this boat.",
	BABYOX = "You may be small, but you smell big.",
	BALLPHIN = "You don't look particularly flammable.",
	BALLPHINPOD = "A family of bouncy things.",
	BAMBOOTREE = "A stick-y shrub.",
	BERRYBUSH2_SNAKE = "Mmmmm. Berries.",--I don't think these should have diff name or examine text
	BERRYBUSH_SNAKE = "Mmmmm. Berries.",--I don't think these should have diff name or examine text
	BIOLUMINESCENCE = "It's a cold light. Not like a flame at all.",
	BLOWDART_POISON = "A sick kiss.",
	BOAT_LANTERN = "Light without a flame. I don't like it one bit.",
	BOTTLELANTERN = "The light is so cold and alien.",
	BURIEDTREASURE = "If I don't like the treasure I'll just set the chest on fire.",
	BUSH_VINE = "I bet these crackle and pop when they burn.",
	SNAKEDEN = "I bet these crackle and pop when they burn.",--I don't think these should have diff name or examine text
	CANNONSHOT = "Fire!",
	CAPTAINHAT = "I no longer have that sinking feeling.",
	BOAT_CARGO = "I can carry so many flammables on this.",
	CHIMINEA = "Do you like your house, fire? You're welcome.",
	CIRCLINGSEAGULL = "Fly into the sun, jerks.",
	SAIL_CLOTH = "Nice stitching.",
	COCONUT = "An edible tree thing.",
	COCONUT_SAPLING = "Hurry up and grow, I want the shade.",
	COCONUT_COOKED = "Mmmm, toasty.",
	COFFEE = "I suddenly feel motivated.",
	COFFEEBEANS = "These could use fire.",
	COFFEEBEANS_COOKED = "Ahhh, that aroma.",
	COFFEEBUSH = "This bush flourishes near the volcano's fire!",
	CORAL = "Pretty colors.",
	ROCK_CORAL = "I wish I had a snorkel.",
	CUTLASS = "This sword smells.",
	SWORDFISH_DEAD = "Ugh, fire would get rid of that smell.",
	DEPLETED_BAMBOOTREE = "Anymore bamboos? Helloooo?",
	DEPLETED_BUSH_VINE = "Come back!",
	DOYDOY = "There is no spark behind its eyes.",
	DOYDOYBABY = "You poor little dummy.",
	DOYDOYEGG = "Dumb egg.",
	DOYDOYEGG_COOKED = "Cooking this dumb egg was smart of me.",
	DOYDOYEGG_CRACKED = "The planet just got a little dumber.",
	DOYDOYFEATHER = "This would burn.",
	DOYDOYNEST = "A dummy is born every second.",
	DUBLOON = "Pirate monies!",
	DUG_BAMBOOTREE = "You need ground, fast.",
	DUG_BERRYBUSH2 = "Would you like to live again?",
	DUG_BUSH_VINE = "Would you like to go back into the ground?",
	DUG_COFFEEBUSH = "I know just what to do with you.",
	EARRING = "So shiny!",
	FABRIC = "Amazing what you can do with bamboo.",
	SAIL_FEATHER = "Gotta hand it to those dumdums... they make good sails!",
	FIRERAIN = "Let it rain!",
	FIRERAINSHADOW = "Here it comes!",
	FISHINHOLE = "Why here, fishies?",
	GASHAT = "I like not smelling smelly smells.",
	GOLDENMACHETE = "I don't want to scuff it up.",
	ICEMAKER = "It turns fire into ice. Boo.",
	IRONWIND = "Now we're gettin' somewhere.",
	JELLYFISH = "It's shriveling up.",
	JELLYFISH_DEAD = "Won't be stingin' anyone now.",
	JELLYFISH_COOKED = "It actually looks edible.",
	JELLYFISH_PLANTED = "I'll call you \"Jerald\".",
	JELLYJERKY = "Looks chewy.",
	JUNGLETREESEED = "A future forest fire.",
	JUNGLETREESEED_SAPLING = "A not-so-distant future forest fire.",
	LAVAPOOL = "What marvelous heat and fury!",
	LIMESTONENUGGET = "It's made of crushed, dead fishies.",
	LIMPETS = "A little lick of flame and you'll be tasty.",
	LIMPETS_COOKED = "Pretty good!",
	LOBSTERHOLE = "The happy lobster home.",
	BOAT_LOGRAFT = "Campfire wood has other uses, apparently!",
	MOSQUITO_POISON = "Shoo! Away!",
	MUSSEL = "Open up, fella.",
	MUSSEL_COOKED = "The fire opens their shells.",
	MUSSEL_STICK = "The mussels like this stick for some reason.",
	OBSIDIAN = "A fire rock!",
	OBSIDIAN_WORKBENCH = "Fire items can be forged here!",
	OBSIDIANAXE = "Such an axe! It cuts AND burns?!",
	OBSIDIANCOCONADE = "I get more \"boom\" for my buck with obsidian.",
	OBSIDIANFIREPIT =
	{
		EMBERS = "Uh oh. It's almost gone!",
		GENERIC = "I could watch it for hours.",
		HIGH = "BURN! BURN FASTER!",
		LOW = "This fire is small and boring.",
		NORMAL = "I feel so pampered!",
		OUT = "I should make the fire come back.",
	},
	OBSIDIANMACHETE = "A fire machete is a girl's best friend!",
	SPEAR_OBSIDIAN = "I poke. They burn!",
	OBSIDIANSPEARGUN = "I'll give it my best fiery shot!",
	PACKIM = "Friend or foe?",
	PACKIM_FISHBONE = "This looks meaningful.",
	PALMLEAF = "You'll burn.",
	PALMTREE_BURNT = "What a lovely smell.",
	PALMTREE_STUMP = "Another one bites the dust.",
	PARROT = "What a fiery color of red you are.",
	PIRATEHAT = "I feel so piratey.",
	PIRATIHATITATOR = "Cursed pirate magic?",
	POISONHOLE = "Nature is so gross.",
	BOAT_RAFT = "It would be unwise to light this on fire while at sea.",
	BOAT_ROW = "Rowing? Really?",
	SAIL_PALMLEAF = "It makes use of the wind.",
	SAND = "Big deal, it's sand.",
	SANDBAG = "A bag of sand.",
	SANDBAG_ITEM = "So I put this on the ground?",
	SANDDUNE = "Oh, look! It's some sand.",
	SEAGULL = "Does it fear fire? It should.",
	SEASACK = "I have to wear this soggy thing on my back?",
	SEASHELL = "Just some stupid seashell.",
	SEASHELL_BEACHED = "Just some stupid seashell.",
	SEATRAP = "C'mon, swim inside! It's cozy in there!",
	SEAWEED = "Soggy sea grass.",
	SEAWEED_COOKED = "Not bad once you add fire.",
	SEAWEED_DRIED = "Healthy jerky.",
	SEAWEED_PLANTED = "Soggy sea grass.",
	SHARX = "Jerks that swim.",
	SLOTMACHINE = "This seems like a waste of time.",
	SNAKE = "Jerks that slither.",
	SNAKE_FIRE = "We share similar interests, monster thing.",
	SNAKESKIN = "Leathery.",
	SNAKESKINHAT = "Water just runs right off it.",
	SPEAR_POISON = "I hope I don't jab myself.",
	SPEARGUN = "A handy tool upon the waves.",
	SPEARGUN_POISON = "This is almost too naughty.",
	STUNGRAY = "Now I've smelled everything.",
	SUPERTELESCOPE = "I can see to the ends of the earth.",
	SWORDFISH = "En garde!",
	TELESCOPE = "You can't hide from me now, islands!",
	TIGERSHARK = "My nightmares have come true!",
	TIGERSHARKSHADOW = "Not good! Not good!",
	TOUCAN = "I like your nose.",
	TRAWLNET = "I'll catch a bunch of wet stuff with this.",
	TRAWLNETDROPPED = "Everything is going to be wet in there.",
	TRIDENT = "This is all wet.",
	TRINKET_IA_13 = "Is this fire water? It's orange.",
	TRINKET_IA_14 = "I don't have any pins...",
	TRINKET_IA_15 = "Oh, this would burn.",
	TRINKET_IA_16 = "Litter is a terrible thing.",
	TRINKET_IA_17 = "Not my style.",
	TRINKET_IA_18 = "I wonder if this is worth anything?",
	TRINKET_IA_19 = "Brain cloud? Sounds tragic.",
	TURBINE_BLADES = "What do these do?",
	TURF_BEACH = "The ground is boring.",
	TURF_JUNGLE = "The ground is boring.",
	VENOMGLAND = "Gross! I wish I had gloves.",
	VINE = "I could use this for something. Or I could just burn it.",
	VOLCANO = "The biggest, fieriest fire in all the land!",
	VOLCANO_ALTAR = "Why would I wanna appease the volcano? Then it wouldn't shoot fire!",
	VOLCANO_ALTAR_BROKEN = "There's no way to quench the volcano's hunger now!",
	VOLCANO_EXIT = "I'd hate to leave this place...",
	VOLCANOSTAFF = "I am the goddess of fiery destruction!",
	WALL_LIMESTONE = "It's all bumpy.",
	WALL_LIMESTONE_ITEM = "You don't look like you would burn easily.",
	WHALE_BLUE = "I didn't know they even made fish that big.",
	WHALE_CARCASS_BLUE = "It's starting to spoil. Gross.",
	WHALE_CARCASS_WHITE = "Victory doesn't smell very good...",
	WHALE_WHITE = "I see fire in its eyes!",
	CRABHOLE = "Come out and play with me!",
	CRAB =
	{
		GENERIC = "Stop running away!",
		HIDDEN = "I'm pretty sure a crabbit is hiding there.",
	},
	BERMUDATRIANGLE = "I feel kinda dizzy looking at it.",
	BOATCANNON = "I wonder if I can start fires with this?",
	BOATREPAIRKIT = "This should patch up any little leaks.",
	MACHETE = "Or I could just burn my way through.",
	LUGGAGECHEST = "Ooo! I hope there are useful items inside.",
	DRAGOON = "If only I could figure out how to train one.",
	ANTIVENOM = "This'll help if I'm poisoned.",
	BAMBOO = "Looks flammable.",
	FROG_POISON = "Yuck! Stay away from me.",
	OX = "You look pretty sturdy.",
	PEACOCK = "Pretty!",
	SEAGULL_WATER = "\"Squawk\" yourself.",
	SNAKE_POISON = "Those are some pointy fangs.",
	SOLOFISH = "Doesn't seem very smart.",
	SPOILED_FISH = "Gross.",
	TWISTER = "Stay away from my precious flames!",
	SANDCASTLE =
	{
		GENERIC = "It's cute, I guess.",
		SAND = "It's a castle made of sand. A sandcastle.",
	},
	SNAKEOIL = "I'm not convinced.",
	LOBSTER = "Come here, you!",
	MESSAGEBOTTLE = "Bottled paper!",
	MESSAGEBOTTLEEMPTY = "It's a bottle.",
	SHARK_FIN = "The fin fell off.",
	VOLCANO_ALTAR =
	{
		GENERIC = "An altar to the sate the fire gods!",
		OPEN = "Ready to consume the fire!",
	},
	ELEPHANTCACTUS = "Don't rub up against me!",
	ELEPHANTCACTUS_ACTIVE = "Yowch!",
	ELEPHANTCACTUS_STUMP = "And stay down!",
	DOUBLE_UMBRELLAHAT = "If I bought this in a store I'd feel burned.",
	MUSSEL_FARM =
	{
		GENERIC = "Just out of reach.",
		STICKPLANTED = "You will be mine soon.",
	},
	WOODLEGS_CAGE = "He seems a little cagey.",

	 PIRATIHATITATOR =
	 {
		GENERIC = "This is just ridiculous.",
		BURNT = "Now it's more my style.",
	 },
	 COFFEEBUSH =
	 {
		BARREN = "It's dripped its last drop.",
		PICKED = "Aw, but I wanted another cup...",
		WITHERED = "It needs ash and love. Mostly just ash.",
		GENERIC = "Hot java from hot lava!",
	 },
	 DUG_ELEPHANTCACTUS = "I don't have to water you, right?",
	 WHALE_BUBBLES = "What's making those bubbles?",

	ARMORCACTUS = "This way I won't get burned by those cacti.",
	BAMBOOTREE =
	{
		BURNT = "Aww, can I burn it again?",
		CHOPPED = "It'll come back.",
		GENERIC = "Kindling!",
	},
	BLOWDART_FLUP = "This blows.",
	BLUBBER = "I bet this burns bright!",
	BLUBBERSUIT = "It squishes when I move...",
	BOAT = "Must. Not. Burn...!",
	BOAT_TORCH = "Strangely not for torching boats.",
	BRAINJELLYHAT = "I feel smarter, but also grosser...",
	BUOY = "Buoy, I'm glad I have this.",
	BUSH_VINE =
	{
		BURNT = "Those are fun to burn!",
		CHOPPED = "That's how you untangle them.",
		GENERIC = "I bet these crackle and pop when they burn.",
	},
	COCONADE =
	{
		BURNING = "Here we go...",
		GENERIC = "First it booms, then it burns.",
	},
	COCONUT_HALVED = "Aha! Now you're food!",
	COFFEEBOT = "It makes coffee!",
	CORAL_BRAIN = "I could learn to love the taste...",
	CORAL_BRAIN_ROCK = "Genius idea, hiding out with these dumb regular corals.",
	CRATE = "If I burn it, whatever's inside burns too...",
	DEPLETED_GRASS_WATER = "It's taking a little rest.",
	DRAGOONDEN = "A bunch of hotheads live there.",
	DRAGOONEGG = "I think this hot rock is actually a hot egg.",
	DRAGOONHEART = "Nothing like a hot meal.",
	DRAGOONSPIT = "A burning puddle of hork.",
	FISH_MED = "Needs fire!",
	FISH_SMALL = "I like sushi, but I prefer it flame-broiled.",
	FISH_SMALL_COOKED = "Fish and fire go well together.",
	FLAMEGEYSER = "Glorious...",
	FLOTSAM = "It's out there, but I'm over here.",
	FLUP = "Flup off!",
	-- FRESHFRUITCREPES = "Ooo la la.",
	GRASS_WATER = "This doesn't need to be watered.",
	HAIL_ICE = "Ugh, just melt already.",
	ICEMAKER =
	{
		HIGH = "It's fully fueled!",
		LOW = "It needs more fuel.",
		NORMAL = "Make that ice.",
		OUT = "It's out of fuel.",
		VERYLOW = "It's nearly out of fuel.",
	},
	JUNGLETREE =
	{
		BURNING = "Wow! So much fire!",
		BURNT = "A major improvement.",
		CHOPPED = "That took a few swings.",
		GENERIC = "That's a whole lot of tree to burn!",
	},
	KNIGHTBOAT = "Check out your boat, mate.",
	KRAKEN = "Kill it with fire!",
	KRAKENCHEST = "Don't mind if I do.",
	KRAKEN_TENTACLE = "Eww, stay away!",
	ROCK_LIMPET =
	{
		GENERIC = "That gross food is trying to eat that rock.",
		PICKED = "The rock won't be bothered by those suckers for a bit.",
	},
	LIVINGJUNGLETREE = "There's something odd about this tree.",
	LOBSTER_DEAD = "Edible in a pinch.",
	LOBSTER_DEAD_COOKED = "Lobster for dinner! Pinch me!",
	MAGIC_SEAL = "It's so glowy.",
	MAGMAROCK = "Magma-nificent!",
	MAGMAROCK_FULL = "Magma-nificent!",
	MAGMAROCK_GOLD = "Magma-nificent!",
	MAGMAROCK_GOLD_FULL = "Magma-nificent!",
	MANGROVETREE = "No need to water this guy.",
	MANGROVETREE_BURNT = "Burned right down to the, uh, water.",
	MARSH_PLANT_TROPICAL = "Plant-y.",
	MERMFISHER = "Ugh, bet you never get that fish smell out.",
	MERMHOUSE_FISHER = "Fish mongers.",
	MONKEYBALL = "I bet the monkeys would have a ball with this thing.",
	-- MONSTERTARTARE = "Gross!",
	MOSQUITOSACK_YELLOW = "Something disgusting dropped this.",
	MUSSELBOUILLABAISE = "Mmm, smells good!",
	MYSTERYMEAT = "Parenting is gross.",
	NEEDLESPEAR = "I could jabber on about this all day.",
	OCTOPUSCHEST = "It's filled with sea treats!",
	OCTOPUSKING = "He looks kinda dozy.",
	OXHAT = "Ox-cellent!",
	OX_FLUTE = "I hear a storm a-coming.",
	OX_HORN = "I could use an ox-tra one of these.",
	PALMLEAF_HUT = "Keeps the elements away, but it would burn so easy.",
	PARROT_PIRATE = "You're a skreechy scallywag.",
	PEG_LEG = "I haven't pegged down what this does yet.",
	PIKE_SKULL = "Nasty.",
	PIRATEGHOST = "What \"arrrr\" you?",
	PIRATEPACK = "Carrying this will build chest muscles.",
	PORTAL_SHIPWRECKED = "Time to get outta here.",
	PRIMEAPE = "Hey lil buddy, do you like to play with fire too?",
	PRIMEAPEBARREL = "What a monkey sty.",
	RAWLING = "He keeps me company.",
	BARREL_GUNPOWDER = "My favorite type of barrel!",
	ROCK_CHARCOAL = "It drops burned things!",
	ROCK_OBSIDIAN = "This rock makes me so excited, I just want to explode!",
	SAIL_STICK = "I'm the queen of this boooooat!",
	SANDBAGSMALL = "Keeps the home fires burning.",
	SANDBAGSMALL_ITEM = "Keeps the home fires burning.",
	SHADOWSKITTISH_WATER = "What's that??",
	SHARKITTEN = "Hey cutie, where's your mom?",
	SHARKITTENSPAWNER =
	{
		GENERIC = "My shark radar is burning.",
		INACTIVE = "Why is this sand dune here?",
	},
	SHARK_GILLS = "I guess it doesn't need to breathe with these anymore.",
	SHARK_TEETHHAT = "Wearing this gives me a toothy grin.",
	SHIPWRECKED_ENTRANCE = "Here goes!",
	SHIPWRECKED_EXIT = "I'm outta here.",
	SNAKEDEN =
	{
		BURNT = "Those were fun to burn!",
		CHOPPED = "That's how you untangle them.",
		GENERIC = "I bet these crackle and pop when they burn.",
	},
	SAIL_SNAKESKIN = "What a morbid sail.",
	SPEAR_LAUNCHER = "Only thing better than a spear is the gun that shoots them.",
	SUNKEN_BOAT =
	{
		ABANDONED = "Where'd they go?",
		GENERIC = "Someone out there is all wet.",
	},
	SUNKEN_BOAT_BURNT = "Double whammy.",
	SUNKEN_BOAT_TRINKET_1 = "I can't say that word!",
	SUNKEN_BOAT_TRINKET_2 = "I've put away childish things.",
	SUNKEN_BOAT_TRINKET_3 = "It wants to meet my lighter.",
	SUNKEN_BOAT_TRINKET_4 = "No idea what that is.",
	SUNKEN_BOAT_TRINKET_5 = "Not my size.",
	SWEETPOTATOSOUFFLE = "Cooked to perfection!",
	SWEET_POTATO = "A welcome change from red berries.",
	SWEET_POTATO_COOKED = "The flames definitely improved it.",
	SWEET_POTATO_PLANTED = "It would be cuter on fire!",
	SWEET_POTATO_SEEDS = "Seeds. Sweet.",
	SWIMMINGHORROR = "You can swim? Horrible!",
	TELEPORTATO_SW_BASE = "Seems like it's missing a thing or two.",
	TELEPORTATO_SW_BOX = "A part for something.",
	TELEPORTATO_SW_CRANK = "For cranking?",
	TELEPORTATO_SW_POTATO = "Wonder what it does?",
	TELEPORTATO_SW_RING = "This goes with something else, I think.",
	THATCHPACK = "Thatch you very much.",
	TIDALPOOL = "I wonder which way it would swirl if you flushed it?",
	TIDAL_PLANT = "It's a plant.",
	TIGEREYE = "Don't look at me like that!",
	TRAWLNETDROPPED =
	{
		GENERIC = "What's in the baaaag?",
		SOON = "It's going to sink soon!",
		SOONISH = "I believe that bag is sinking.",
	},
	TRINKET_IA_20 = "I can't say that word!",
	TRINKET_IA_21 = "I've put away childish things.",
	TRINKET_IA_22 = "It wants to meet my lighter.",
	TRINKET_IA_23 = "Broken what?",
	FISH_TROPICAL = "Such pretty colors.",
	TUNACAN = "Aw, but I like mine with Ballphin!",
	TURF_ASH = "Ashy.",
	TURF_MAGMAFIELD = "Explosive!",
	TURF_MEADOW = "Serene.",
	TURF_SNAKESKIN = "Gross.",
	TURF_TIDALMARSH = "Squelchy.",
	TURF_VOLCANO = "Hot footin'.",
	TWISTER_SEAL = "I've been burned by cute things before.",
	VOLCANO_ALTAR_TOWER = "A monument to fire!",
	VOLCANO_SHRUB = "You come pre-burnt!",
	WALLYINTRO_DEBRIS = "Did I do that?",
	WATERYGRAVE = "Something's fishy here.",
	WHALE_TRACK = "Where there's bubbles there's fire!",
	WILBUR_CROWN = "You'd have to have a tiny little head to fit this.",
	WILBUR_UNLOCK = "Fancy monkey.",
	WILDBORE = "Not wild about being close to this guy.",
	WILDBOREHEAD = "Blech!",
	WILDBOREHOUSE = "Add fire and you'd get BBQ!",
	WIND_CONCH = "Hope no fires get blown out.",
	BOAT_WOODLEGS = "A fine ship.",
	WOODLEGSHAT = "I don't think it was made for me.",
	SAIL_WOODLEGS = "This sail looks like it would be special to someone.",
	WOODLEGS_KEY1 = "A key to what?",
	WOODLEGS_KEY2 = "Something must be locked up somewhere.",
	WOODLEGS_KEY3 = "Another key.",
	SHIPWRECK = "Someone has regrets.",
	CALIFORNIAROLL = "Oh, goody. Fish rolled in seaweed.",
	-- BANANAPOP = "This is the opposite of burning.",
	BISQUE = "I guess I could eat that.",
	-- CEVICHE = "It's still slimy.",
	SEAFOODGUMBO = "Ew, what IS this?",
	SURFNTURF = "Ugh. This is old person food!",
	SHARKFINSOUP = "And I didn't even burn it!",
	LOBSTERDINNER = "Yummmmmmm!",
	LOBSTERBISQUE = "I'm gonna eat this entire thing!",
	JELLYOPOP = "I want twenty!",
	VOLCANO_SHRUB = "No fair! I didn't get to burn you!",
	ROCK_OBSIDIAN = "The... most... beautiful rock... I've ever... seen...",
	ROCK_CHARCOAL = "Charrific!",



	--- 5C DLC ------------------------------------------------------------------------------------------------

	BOAT_ENCRUSTED = "Crumbly.",
	BABYOX = "You stink.",
	BALLPHINHOUSE = "It's the castle of the bouncy things... A bouncy castle.",
	DORSALFIN = "It's, like... a fin, I guess?",
	NUBBIN = "Nice bald spot, rock.",
	CORALLARVE = "Haha, gross.",
	RAINBOWJELLYFISH = "Haha, it's squishy.",
	RAINBOWJELLYFISH_PLANTED = "Hey fancyfish, get over here!",
	RAINBOWJELLYFISH_DEAD = "It's still moving.",
	RAINBOWJELLYFISH_COOKED = "I wonder if the colors add flavor.",
	RAINBOWJELLYJERKY = "How is it STILL moving?!",
	WALL_ENFORCEDLIMESTONE = "I feel like this is not the most safe.",
	WALL_ENFORCEDLIMESTONE_ITEM = "I could put it down, I guess.",
	CROCODOG = "You don't look that tough.",
	POISONCROCODOG = "Back off!",
	WATERCROCODOG = "I'm watching you!",
	QUACKENBEAK = "Never stick your beak where is doesn't belong.",
	QUACKERINGRAM = "Can't stop me now!",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "Fish eggs in a jar. Great.",
	CORMORANT = "It's got its butt in my water.",

	PURPLE_GROUPER = "You look kinda dumb.",
	PIERROT_FISH = "Found you!",
	NEON_QUATTRO = "Is living underwater as awful as it sounds?",

	PURPLE_GROUPER_COOKED = "Fire burned the grossest bits right off.",
	PIERROT_FISH_COOKED = "I burned it just right.",
	NEON_QUATTRO_COOKED = "The fire got rid of most of the fish smell.",

	FISH_FARM = 
	{
		EMPTY = "I gotta put something in there to grow fish.",
		STOCKED = "Still no fish yet.",
		ONEFISH = "Yesss! A fish!",
		TWOFISH = "Three fish are better than one.",
		REDFISH = "I feel like there could be more, though.",
		BLUEFISH  = "I'm swimming in fish!",
	},
	
	ROE = "Ughh! That's nasty!!",
	ROE_COOKED = "I cooked them, but they're still nasty.",
	
	SEA_YARD = 
	{
		ON = "It's a fixin' machine.",
		OFF = "Just a big hunka junk without fuel.",
		LOWFUEL = "Running low.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "That doesn't even count as a fire!",
		GENERIC = "Burn the sea!!",
		HIGH = "Yess!! Burn!!!",
		LOW = "That's barely even a fire!",
		NORMAL = "It's burning alright.",
		OUT = "Quick!! Relight it!",
	}, 

	TAR = "I bet that burns real good!",
	TAR_EXTRACTOR =
	{
		ON = "It's getting me fuel for burnin'! Heheheh.",
		OFF = "I guess I should turn it back on.",
		LOWFUEL = "That's gonna need more fuel.",
	},
	TAR_POOL = "There's something flammable down there.",

	TARLAMP = "I knew that goopy stuff'd burn good!",
	TARSUIT = "This might not be the safest thing to light fires in.",
	TAR_TRAP = "Would be better as a fire trap.",

	TROPICALBOUILLABAISSE = "Ughh, is there anything besides fish out here??",
	
	SEA_LAB = "Can things burn at sea?",
	WATERCHEST = "I keep all my best stuff in there.",
	QUACKENDRILL = "I can use this drill at sea.",
	HARPOON = "Just need something to throw it at.",
	MUSSEL_BED = "Guess I should chuck'em in the ocean.",
},
}
%%+%%strings/winona.lua%%-%%--Putting this here and will update over time so it doesn't get corrupted again.
return {

ACTIONFAIL =
{
	REPAIRBOAT = 
	{
		GENERIC = "No further repairs needed.",
	},
	EMBARK = 
	{
		INUSE = "Ah, someone got to the dinghy before me.",
	},
	INSPECTBOAT = 
	{
		INUSE = GLOBAL.STRINGS.CHARACTERS.GENERIC.ACTIONFAIL.STORE.INUSE
	},
},

ANNOUNCE_MAGIC_FAIL = "I don't get this magic stuff.",

ANNOUNCE_SHARX = "Something sounds wet and hungry out there.",

ANNOUNCE_TREASURE = "Buried treasure!",
ANNOUNCE_MORETREASURE = "I'm spoiled, more treasure!",
ANNOUNCE_OTHER_WORLD_TREASURE = "Doesn't look like anywhere I've been.",
ANNOUNCE_OTHER_WORLD_PLANT = "I thinks this needs a different kinda soil.",

ANNOUNCE_MESSAGEBOTTLE =
{
	"I thought *my* handwriting was bad. Ha.",
},
ANNOUNCE_VOLCANO_ERUPT = "Uh... that wasn't the antlion, was it?",
ANNOUNCE_MAPWRAP_WARN = "Lil' hazy over there.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "I can't see where I'm going!",
ANNOUNCE_MAPWRAP_RETURN = "Where am I? Oh, still here.",
ANNOUNCE_CRAB_ESCAPE = "The crab buggered off.",
ANNOUNCE_TRAWL_FULL = "My net's full, time to collect!",
ANNOUNCE_BOAT_DAMAGED = "I should tape these holes up.",
ANNOUNCE_BOAT_SINKING = "I don't think tape will be enough now.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "That's a lotta damage!",
ANNOUNCE_WAVE_BOOST = "Whoo nelly!",

ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "I see something blubbery over there!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Drat. I lost the trail.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "I can't see the bubbles over the waves.",


DESCRIBE = {
	 --SWC
	-- PORTABLECOOKPOT_ITEM = "I'm ready for some good cookin'!",
	CHEFPACK = "It'll keep all those fancy ingredients cool.",
	-- -- FRESHFRUITCREPES = "These are some fancy good eats, chef!",
	-- -- MONSTERTARTARE = "I have some complaints for the chef.",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "Still got a bit of a wait.",
		-- COOKING_SHORT = "Get Warly! His cooking's almost ready!",
		-- DONE = "Soup's on!",
		-- EMPTY = "Good to have some extra hands cookin' around here.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "Hey there, %s. Cookin' anything good up?",
        -- ATTACKER = "%s's food must be going all to their head.",
        -- MURDERER = "Butcher! Get'em!",
        -- REVIVER = "You got a good head on your shoulders, chef.",
        -- GHOST = "Shake it off, %s, we got grub to eat!",
		-- FIRESTARTER = "Your cooking skills don't advance to forest fires, do they %s?",
    -- },
    --
	WILDBOREGUARD = "All I need's a red cape and I can have some fun. Ha!",
	SOLOFISH_DEAD = "Sorry, fella.",
	FISH_MED_COOKED = "Bone-free. I hope.",
	PURPLE_GROUPER = "What a stupid lookin' face.",
	PURPLE_GROUPER_COOKED = "Face-free.",

	GHOST_SAILOR = "Looks like that dog stayed salty. Ha!",

	FLOTSAM = "A cautionary tale of bad craftsmanship.",

	SUNKEN_BOAT = 
	{
		GENERIC = "You built this ship? No wonder it's sunk, ha!",
		ABANDONED = "Some things even I can't fix.",
	},
	SUNKEN_BOAT_BURNT = "There was nothing left for it anyway.",
	SUNKEN_BOAT_TRINKET_1 = "I don't know how to use this doohickey.", --sextant
	SUNKEN_BOAT_TRINKET_2 = "Looks like Willow's bear might get outta here.", --toy boat
	SUNKEN_BOAT_TRINKET_3 = "A light that won't light.", --candle
	SUNKEN_BOAT_TRINKET_4 = "I, uh, uhm... huh?", --sea worther
	SUNKEN_BOAT_TRINKET_5 = "A workboot with no worker attached.", --boot
	SUNKBOAT = "It's beyond my help.",
	-- BANANAPOP = "I'm used to eating bananas without sticks.",
	BISQUE = "Cold soup's on!",
	-- CEVICHE = "Delicious!",
	SEAFOODGUMBO = "Just like ma used to make.",
	SURFNTURF = "The steak's really chewy.",
	SHARKFINSOUP = "Waiter, there's a shark in my soup!",
	LOBSTERDINNER = "Pass the butter!",
	LOBSTERBISQUE = "Who knew lobster made a good soup?",
	JELLYOPOP = "The stinging's been cooked outta it.",

	BOAT_ENCRUSTED = "A naturally armored ship.",
	BABYOX = "I'm surprised it can stay above the water.",
	BALLPHINHOUSE = "I'd love to know how they built that.",
	DORSALFIN = "I hope nobody needed this.",
	NUBBIN = "It's a nub of a reef.",
	CORALLARVE = "So you're the one who built them rocks.",
	RAINBOWJELLYFISH = "Not a stinger, I guess.",
	RAINBOWJELLYFISH_PLANTED = "That guy had a bright idea. Ha!",
	RAINBOWJELLYFISH_DEAD = "Hope it's safe to eat.",
	RAINBOWJELLYFISH_COOKED = "Taste the rainbow.",
	RAINBOWJELLYJERKY = "No more glow-y stuff left.",
	WALL_ENFORCEDLIMESTONE = "I like where it is current-ly. Ha!",
	WALL_ENFORCEDLIMESTONE_ITEM = "Not as pretty as the reefs, but it's more useful.",
	CROCODOG = "Heheh. I can't take those squeaks seriously.",
	POISONCROCODOG = "Chew on this, ya mutt!",
	WATERCROCODOG = "You can't be that naturally wet.",
	QUACKENBEAK = "I've seen uglier chompers in the factory.",
	QUACKERINGRAM = "I wish I had this in city traffic!",

	CAVIAR = "I don't get the hubbub. They're just fish eggs.",
	CORMORANT = "Loud guy.",

	PURPLE_GROUPER = "What a stupid lookin' face.",
	PIERROT_FISH = "It's a flounder, isn't it?",
	NEON_QUATTRO = "Cool fish. No really, it's chilly.",

	PURPLE_GROUPER_COOKED = "Face-free.",
	PIERROT_FISH_COOKED = "It learned what a fire was.",
	NEON_QUATTRO_COOKED = "It's warmer than before.",

	FISH_FARM = 
	{
		EMPTY = "No farms work without fuel.",
		STOCKED = "The fish hasn't hatched yet.",
		ONEFISH = "Ooh, I see the little guy!",
		TWOFISH = "There's a few more!",
		REDFISH = "It's close to bursting!",
		BLUEFISH  = "It can't hold any more, time to harvest.",
	},

	ROE = "Bit small for eatin'.",
	ROE_COOKED = "Not the kinda fried eggs I'm used to.",
	
	SEA_YARD =
	{
		ON = "Now this is efficiency!",
		OFF = "Maybe I should build an automatic fueler too.",
		LOWFUEL = "I should top it off.",
	},

	SEA_CHIMINEA = 
	{
		EMBERS = "It's almost kaput.",
		GENERIC = "Keeps the fire nice and dry on the sea.",
		HIGH = "Roarin' high.",
		LOW = "It'll be out soon.",
		NORMAL = "It's nice to dry off by.",
		OUT = "I can always light it again.",
	}, 

	TAR = "Glad I'm handling this stuff with gloves.",
	TAR_EXTRACTOR =
	{
		ON = "Is there anything heavy machinery can't do?",
		OFF = "It's better to leave that thing runnin'.",
		LOWFUEL = "It needs a lil fuel.",
	},
	TAR_POOL = "The sea isn't supposed to be black, right?",

	TARLAMP = "That's a handy lil light.",
	TARSUIT = "I know it's water resistant, but come on.",
	TAR_TRAP = "Anyone have a sponge?",

	TROPICALBOUILLABAISSE = "It has different tastes each bite.",
	
	SEA_LAB = "Good thing water doesn't affect this doohickey.",
	WATERCHEST = "It looks like it's gonna sink any moment.",
	QUACKENDRILL = "Is there nothing engineering can't do?",
	HARPOON = "Looking sharp!",
	MUSSEL_BED = "These lil' workers need a new home.",
	ANTIVENOM = "Bleh, tastes like castor oil.",
	VENOMGLAND = "Haha, gross.",
	BLOWDART_POISON = "Best not breathe in while using this.",
	OBSIDIANMACHETE = "It's powered by hard work. My kind of tool.",
	SPEARGUN_POISON = "High velocity poisoning.",
	OBSIDIANSPEARGUN = "By definition, this is a flame-thrower now. Ha!",
	LUGGAGECHEST = "Could be some good loot in there.",
	PIRATIHATITATOR =
	{
		GENERIC = "That lever is STILL there...",
		BURNT = "I'll make this one over.",
	},
	COFFEEBEANS = "I should toss them over a fire.",
	COFFEE = "Essential for any hard worker!",
	COFFEEBEANS_COOKED = "Ah, the smell of coffee beans in the morning!",
	COFFEEBUSH =
	{
		BARREN = "Buddy needs some ash.",
		WITHERED = "What happened here?",
		GENERIC = "Oh, mama!",
		PICKED = "There's no beans left, aw man.",
	},
	COFFEEBOT = "The pinnacle of engineering.",
	MUSSEL = "The food's on the inside.",
	MUSSEL_FARM =
	{
		 GENERIC = "Looks like some shells from here.",
		 STICKPLANTED = "Work smarter, not harder."
	},

	MUSSEL_STICK = "Sticks can become mussels with enough work.",
	LOBSTER = "Don't get snappy with me.",
	LOBSTERHOLE = "Seems easy to make with those kinda claws.",
	SEATRAP = "It's a fancy dinner catcher.",
	SANDCASTLE =
	{
		SAND = "It definitely is a sand castle.",
		GENERIC = "Now isn't that cute."
	},
	BOATREPAIRKIT = "Who needs glue? My tape is sticky enough.",

	BALLPHIN = "Intelligent little guy.",
	BOATCANNON = "Excavation crew is here!",
	BOTTLELANTERN = "Where's the power source?",
	BURIEDTREASURE = "Today's my lucky day!",
	BUSH_VINE =
	{
		BURNING = "Oh. Welp.",
		BURNT = "Not much that crispy vines can do.",
		CHOPPED = "It's on break.",
		GENERIC = "It's real tangle-y.",
	},
	CAPTAINHAT = "Look at me, I am the captain now. Ha!",
	COCONADE =
	{
		BURNING = "Fire in the hole!",
		GENERIC = "It's definitely creative, I'll give it that.",
	},
	CORAL = "I never built with this stuff before.",
	ROCK_CORAL = "Yup, it's a colorful rock.",
	CRABHOLE = "Those crabs sure know a lot about burying themselves.",
	CUTLASS = "Clean cut on that huge schnoz.",
	
	DUBLOON = "It's not much, but at least I'm being paid.",
    FABRIC = "Glad I didn't have to tear my clothes for this.",
    FISHINHOLE = "A school of fish, getting them ready for work.",
    GOLDENMACHETE = "This just made my job easier.",
    JELLYFISH = "If you hit it, it hits back. That's the worker class!",
    JELLYFISH_DEAD = "This one won't be doing any work anymore.",
    JELLYFISH_COOKED = "Looks like a bunch of cut up onions now.",
    JELLYFISH_PLANTED = "Blob away, jelly!",
    JELLYJERKY = "Dried under the sun.",

    ROCK_LIMPET =
    {
        GENERIC = "It's full of the little grubs!",
        PICKED = "No one left to tell the story.",
    },
    BOAT_LOGRAFT = "I could do better...",
    MACHETE = "Hack and slash! Working's always fun.",
    MESSAGEBOTTLEEMPTY = "No more letters left for me.",
    MOSQUITO_POISON = "Can't afford getting bitten by this one.",
    OBSIDIANCOCONADE = "Too much fire can lead to accidents...",
    OBSIDIANFIREPIT =
    {
        EMBERS = "On its last legs.",
        GENERIC = "Like a factory furnace.",
        HIGH = "Properly roaring.",
        LOW = "It's gonna go out soon.",
        NORMAL = "About as cozy as it gets out here.",
        OUT = "My sister was afraid of the dark.",
    },-------------------------------------left off-------------------------------------
	OX = "These creatures seem reasonable.",
	PIRATEHAT = "Fit for a cutthroat scallywag. Or me.",
	BOAT_RAFT = "This looks adequate.",
	BOAT_ROW = "It runs on elbow grease.",
	SAIL_PALMLEAF = "This should really transform my boating experience.",
	SANDBAG_ITEM = "Sand technology, on the go.",
	SANDBAG = "Keeps the water at bay.",
	SEASACK = "I hate when food has that not-so-fresh taste.",
	SEASHELL_BEACHED = "Sea refuse.",
	SEAWEED = "A weed. Of the sea.",

	SEAWEED_PLANTED = "Is that what passes for food around here?",
	SLOTMACHINE = "I suppose I could linger for a moment or two.",
	SNAKE_POISON = "Even worse than a regular snake!",
	SNAKESKIN = "I'm intrigued AND repelled.",
	SNAKESKINHAT = "It should repel the rain from my hair.",
	SOLOFISH = "It has that wet-dog smell.",
	SPEARGUN = "Requires extra assembly.",--done
	SPOILED_FISH = "I'm not terribly curious about the smell.",
	SWORDFISH = "And I thought my landlord's nose was big. Ha!",--done
	TRIDENT = "I wonder how old this artifact is?",
	TRINKET_IA_13 = "What is this substance?",
	TRINKET_IA_14 = "This thing gives me the creeps...",
	TRINKET_IA_15 = "Incredible! This guitar has undergone shrinkification!",
	TRINKET_IA_16 = "How did this get all the way out here?",
	TRINKET_IA_17 = "Where's the other one?",
	TRINKET_IA_18 = "A relic of a bygone era!",
	TRINKET_IA_19 = "Clouding of the brain. Never heard of it...",
	TURBINE_BLADES = "Perhaps this powered that beastly storm?",
	TURF_BEACH = "Sandy ground.",
	TURF_JUNGLE = "Very gnarled ground.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It appears to be closed.",
		OPEN = "The altar is open and ready to accept offerings!",
	},
	VOLCANO_ALTAR_BROKEN = "Er, that won't be a problem, will it?",
	WHALE_BLUE = "That whale has emotional issues.",
	WHALE_CARCASS_BLUE = "Gross. I think the bloating has begun.",
	WHALE_CARCASS_WHITE = "Gross. I think the bloating has begun.",

	ARMOR_SNAKESKIN = "How fashionable!",
	SAIL_CLOTH = "That wind isn't getting away now!",
	DUG_COFFEEBUSH = "This belongs in the ground!",
	LAVAPOOL = "A bit hot for my tastes.",
	BAMBOO = "Maybe I can bamboozle my enemies with this?",
	AERODYNAMICHAT = "It really cuts through the air!",
	POISONHOLE = "I think I'll stay away from that.",
	BOAT_LANTERN = "This will do wonders for my night vision!",
	SWORDFISH_DEAD = "I better not run with this.",
	LIMPETS = "Maybe starving wouldn't be so bad.",
	OBSIDIANAXE = "A winning combination!",
	COCONUT = "It requires a large nut hacker.",
	COCONUT_SAPLING = "It doesn't need my help to grow anymore.",
	COCONUT_COOKED = "Now I just need a cake.",
	BERMUDATRIANGLE = "Gives me an uneasy feeling.",
	SNAKE = "I wonder if it'll sell me some oil?",
	SNAKEOIL = "The label says \"Jay's Wondrous Snake Oil!\"",
	ARMORSEASHELL = "Arts and crafts!",
	SNAKE_FIRE = "Is that snake smoldering?",
	MUSSEL_COOKED = "I cook a mean mussel.",

	PACKIM_FISHBONE = "This seems like something I should carry around.",
	PACKIM = "I bet I could pack'im full of stuff.",

	ARMORLIMESTONE = "I'm sure this will hold up great!",
	TIGERSHARK = "Well that's terrifying.",
	WOODLEGS_KEY1 = "Something, somewhere must be locked.",
	WOODLEGS_KEY2 = "This key probably unlocks something.",
	WOODLEGS_KEY3 = "That's a key.",
	WOODLEGS_CAGE = "That seems like an excessive amount of locks.",
	OBSIDIAN_WORKBENCH = "I feel inspired.",

	NEEDLESPEAR = "I'm glad I didn't step on this.",
	LIMESTONENUGGET = "Could be a useful building material.",
	DRAGOON = "You're a quick one, aren't you?",

	ICEMAKER = 
	{
		OUT = "It needs more fuel.",
		VERYLOW = "I can hear it sputtering.",
		LOW = "It seems to be slowing down.",
		NORMAL = "It's putting along.",
		HIGH = "It's running great!",
	},

	DUG_BAMBOOTREE = "I need to plant this.",
	BAMBOOTREE =
	{
		BURNING = "Bye bye, bamboo.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "Golly, it's even floatier than wood!", --"Looks pretty sturdy.", -Mob
	},
	
	JUNGLETREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "That tree needs a hair cut.",
	},
	SHARK_GILLS = "I wish I had gills.",
	LEIF_PALM = "Someone gimme a hand with this palm!",
	OBSIDIAN = "It's a fire rock.",
	BABYOX = "It's a tiny meat beast.",
	STUNGRAY = "I think I'll keep my distance.",
	SHARK_FIN = "A sleek fin.",
	FROG_POISON = "It looks meaner than usual.",
	BOAT_ARMOURED = "That is one durable boat.",
	ARMOROBSIDIAN = "I'm the fire hazard!",--done
	BIOLUMINESCENCE = "These make a soothing glow.",
	SPEAR_POISON = "Now it's extra deadly.",
	SPEAR_OBSIDIAN = "This will leave a mark.",
	SNAKEDEN =
	{
		BURNING = "Whoops.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "It's all viney!",
	},
	TOUCAN = "I tou-can't catch him.",
	MESSAGEBOTTLE = "Someone wrote me a note!",
	SAND = "A handy pile of pocket sand.",
	SANDDUNE = "You better stay out of my shoes.",
	PEACOCK = "Nothing more than a dressed up thief.",
	VINE = "Maybe I can tie stuff up with this.",
	SUPERTELESCOPE = "I can see forever!",
	SEAGULL = "Shoo! Find some other land!",
	SEAGULL_WATER = "Shoo! Find some other water!",
	PARROT = "I find myself fresh out of crackers.",
	ARMOR_LIFEJACKET = "Keeps me afloat, without my boat!",
	WHALE_BUBBLES = "Something's underwater here.",
	EARRING = "The fewer holes in my body, the better.",
	ARMOR_WINDBREAKER = "The wind doesn't stand a chance!",
	SEAWEED_COOKED = "Crispy.",
	BOAT_CARGO = "It has room for all my stuff!",
	GASHAT = "Sucks all the stink out.",
	ELEPHANTCACTUS = "Yikes! I could poke an eye out!",
	DUG_ELEPHANTCACTUS = "A portable poker plant.",
	ELEPHANTCACTUS_ACTIVE = "That cactus seems abnormally pokey.",
	ELEPHANTCACTUS_STUMP = "It'll sprout pokers again eventually.",
	SAIL_FEATHER = "It's feather-light!",
	WALL_LIMESTONE_ITEM = "These would do more good if I placed them.",
	JUNGLETREESEED = "I can hear the hissing of tiny snakes.",
	JUNGLETREESEED_SAPLING = "It will grow into a nice jungle tree.",
	VOLCANO = "My scientific know-how tells me that's a perfectly safe mountain!",
	IRONWIND = "This is how a scientist should travel.",
	SEAWEED_DRIED = "Salty!",
	TELESCOPE = "I spy with my little eye...",
	
	DOYDOY = "I feel oddly protective of this dumb bird.",
	DOYDOYBABY = "What a cute little, uh, thing.",
	DOYDOYEGG = "Maybe I should have let it hatch.",
	DOYDOYEGG_CRACKED = "Oh well. I'm sure there are lots more!",
	DOYDOYFEATHER = "Soft AND endangered!",

	PALMTREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "How tropical.",
	},
	PALMLEAF = "I'm fond of these fronds.",
	CHIMINEA = "Keeps the fires from gettin' winded. Ha!",--done
	DOUBLE_UMBRELLAHAT = "The second umbrella keeps the first umbrella dry.",
	CRAB = 
	{
		GENERIC = "Don't get snappy with me, mister.",
		HIDDEN = "I wonder where that crabbit went?",
	},
	TRAWLNET = "Nothing but net.",
	TRAWLNETDROPPED = 
	{
		SOON = "It is definitely sinking.",
		SOONISH = "I think it's sinking.",
		GENERIC = "It's bulging with potential!",
	},
	VOLCANO_EXIT = "There's a cool breeze blowing in from outside.",
	SHARX = "These things sure are persistent.",
	SEASHELL = "Maybe I could sell these.",
	WHALE_BUBBLES = "Something down there has bad breath.",
	MAGMAROCK = "I can dig it.",
	MAGMAROCK_GOLD = "I see a golden opportunity.",
	CORAL_BRAIN_ROCK = "I wonder what it's plotting...",
	CORAL_BRAIN = "Food for thought.",
	SHARKITTEN = "You've got to be kitten me!",
	SHARKITTENSPAWNER = 
	{
		GENERIC = "Is that sand pile purring?",
		INACTIVE = "That is a rather large pile of sand.",
	},
	LIVINGJUNGLETREE = "Just like any other tree.",
	WALLYINTRO_DEBRIS = "Part of a wrecked ship.",
	MERMFISHER = "You better not try anything fishy.",
	PRIMEAPE = "Those things are going to be the end of me.",
	PRIMEAPEBARREL = "Here be evil.",
	BARREL_GUNPOWDER = "How original.",
	PORTAL_SHIPWRECKED = "It's broken.",
	MARSH_PLANT_TROPICAL = "Planty.",
	TELEPORTATO_SW_POTATO = "Seems like it was made with a purpose in mind.",
	PIKE_SKULL = "Ouch.",
	PALMLEAF_HUT = "Shade, sweet shade.",
	FISH_SMALL_COOKED = "A small bit of cooked fish.",
	LOBSTER_DEAD = "You should cook up nicely.",
	MERMHOUSE_FISHER = "Doesn't smell very good.",
	WILDBORE = "Looks aggressive.",
	PIRATEPACK = "I can keep my booty in here.",
	TUNACAN = "Where did this can come from?",
	MOSQUITOSACK_YELLOW = "Part of a yellow mosquito.",
	SANDBAGSMALL = "This should keep the water out.",
	FLUP = "Leave me alone!",
	OCTOPUSKING = "I'm a sucker for this guy.",
	OCTOPUSCHEST = "I hope that thing is waterproof.",
	GRASS_WATER = "I hope you're thirsty, grass.",
	WILDBOREHOUSE = "What a bore-ing house.",
	FISH_SMALL = "A small bit of fish.",
	TURF_SWAMP = "Swampy turf.",
	FLAMEGEYSER = "Maybe I should stand back.",
	KNIGHTBOAT = "Get off the waterway, you maniac!",
	MANGROVETREE_BURNT = "I wonder how that happened.",
	TIDAL_PLANT = "Look. A plant.",
	WALL_LIMESTONE = "Sturdy.",
	FISH_MED = "A chunk of fish meat.",
	LOBSTER_DEAD_COOKED = "I can't wait to eat you.",
	BLUBBERSUIT = "Well, it's something.",
	BLOWDART_FLUP = "Eye see.",
	TURF_MEADOW = "Meadow-y turf.",
	TURF_VOLCANO = "Volcano-y turf.",
	SWEET_POTATO = "Looks yammy!",
	SWEET_POTATO_COOKED = "Looks even yammier!",
	SWEET_POTATO_PLANTED = "That's an odd looking carrot.",
	SWEET_POTATO_SEEDS = "My very own plant eggs.",
	BLUBBER = "Squishy.",
	TELEPORTATO_SW_RING = "Looks like I could use this.",
	TELEPORTATO_SW_BOX = "It looks like a part for something.",
	TELEPORTATO_SW_CRANK = "I wonder what this is used for.",
	TELEPORTATO_SW_BASE = "I think it's missing some parts.",
	VOLCANOSTAFF = "The label says \"Keep out of reach of children.\"",
	THATCHPACK = "I call it a thatchel.",
	SHARK_TEETHHAT = "What a dangerous looking hat.",
	TURF_ASH = "Ashy turf.",
	BOAT_TORCH = "This'll keep my hands free.",
	MANGROVETREE = "I wonder if it's getting enough water?",
	HAIL_ICE = "Chilling.",
	FISH_TROPICAL = "What a tropical looking fish.",
	TIDALPOOL = "A pool, left by the tides.",
	WHALE_WHITE = "Looks like a fighter.",
	VOLCANO_SHRUB = "You look ashen.",
	ROCK_OBSIDIAN = "Blast it! It won't be mined!",
	ROCK_CHARCOAL = "Would need an awfully big stocking for that.",
	DRAGOONDEN = "Even goons gotta sleep.",
	WILBUR_UNLOCK = "He looks kind of regal.",
	WILBUR_CROWN = "It's oddly monkey-sized.",
	TWISTER = "I thought it was strangely windy around here.",
	TWISTER_SEAL = "D'awww.",
	MAGIC_SEAL = "This is a powerful artifact.",
	SAIL_STICK = "There must be a scientific explanation for this.",
	WIND_CONCH = "I can hear the wind trapped within.",
	DRAGOONEGG = "Do I hear cracking?",
	BUOY = "Awww yaaaaa buoy!", 
	TURF_SNAKESKIN = "Sssstylish ssssstatement.",
	DOYDOYNEST = "It's for doydoy eggs, dummy.",
	ARMORCACTUS = "The best defense is a good offense.",
	BIGFISHINGROD = "To catch a big fish, you need a big rod.",
	BRAINJELLYHAT = "Two brains means double the ideas!",
	COCONUT_HALVED = "When I click them together, they make horsey sounds.",
	CRATE = "There must be a way to open it.",
	DEPLETED_BAMBOOTREE = "Will it grow again?",
	DEPLETED_BUSH_VINE = "One day it may return.",
	DEPLETED_GRASS_WATER = "Farewell, sweet plant.",
	DOYDOYEGG_COOKED = "A controlled chemical reaction has made this egg matter more nutritious.",
	DRAGOONHEART = "Where the dragoon once stored its feelings.",
	DRAGOONSPIT = "It's SPITacularly disgusting!",
	DUG_BUSH_VINE = "I suppose I should pick it up.",
	KRAKEN = "Now's not the time for me to be Quacken wise!",
	KRAKENCHEST = "To the victor, the spoils.",
	KRAKEN_TENTACLE = "A beast that never sleeps.",
	MAGMAROCK_FULL = "I can dig it.",
	MAGMAROCK_GOLD_FULL = "I see a golden opportunity.",
	MONKEYBALL = "I have a strange desire to name it after myself.",
	MUSSELBOUILLABAISE = "Imagine the experiments I could run on it!",
	MYSTERYMEAT = "I'm not dissecting that.",
	OXHAT = "Nice and dry. This helmet will protect me from the elements.",
	OX_FLUTE = "Is it dripping...?",
	OX_HORN = "I grabbed the ox by the horn.",
	PARROT_PIRATE = "I try not to eat anything with a name.",
	PEG_LEG = "I can perform amputations if anyone'd like to wear it for real.",
	PIRATEGHOST = "He met a terrible end. I will too if I don't get out of here.",
	SANDBAGSMALL_ITEM = "A bag full of sand. Does science know no bounds?",
	SHADOWSKITTISH_WATER = "Yikes!",
	SHIPWRECKED_ENTRANCE = "Ahoy!",
	SHIPWRECKED_EXIT = "And so, I sail away into the horizon!",
	SAIL_SNAKESKIN = "Scale it and sail it!",
	SPEAR_LAUNCHER = "Science takes care of me.",
	SWEETPOTATOSOUFFLE = "Sweet potato souffles are a rising trend.",
	SWIMMINGHORROR = "Yikes! Get me back to land!",
	TIGEREYE = "More eyes means better sight... right?",
	TRINKET_IA_20 = "I'm not sure what it is, but it makes me feel smarter!",
	TRINKET_IA_21 = "I ought to measure it to ensure it's to scale.",
	TRINKET_IA_22 = "I'm sure someone would like this.",
	TURF_MAGMAFIELD = "Lava-y floor.",
	TURF_TIDALMARSH = "Marsh-y floor.",
	VOLCANO_ALTAR_TOWER = "How scary!",
	WATERYGRAVE = "Sure, I could fish it out of there. But should I?",
	WHALE_TRACK = "Whale, ho!",
	WILDBOREHEAD = "It smells as bad as it looks.",
	BOAT_WOODLEGS = "A vessel fit for a scallywag.",
	WOODLEGSHAT = "Not too keen on being a pirate.", --SWC
	SAIL_WOODLEGS = "The quintessential pirate sail.",
	SHIPWRECK = "Poor little boat.",
	INVENTORYGRAVE = "There was someone here before me!",
	INVENTORYMOUND = "There was someone here before me!",
	LIMPETS_COOKED = "Escargotcha!",
	RAWLING = "It's my buddy!",
	CALIFORNIAROLL = "But I don't have chopsticks.",
},
}
%%+%%strings/wolfgang.lua%%-%%return {
ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "Small boat has no damages to repair! Wolfgang could punch it?",
	},
},
ANNOUNCE_OTHER_WORLD_PLANT = "Not mighty enough to grow here! Unlike Wolfgang!",
ANNOUNCE_MAGIC_FAIL = "Is not making the magics now. Why?",
ANNOUNCE_BOAT_DAMAGED = "Ship is weak! Needs fixingtimes.",
ANNOUNCE_BOAT_SINKING = "I will fight sea!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "Wolfgang will punch death!",
ANNOUNCE_CRAB_ESCAPE = "Crabbit has fled. I do not blame it.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Boat not listen to mighty Wolfgang!",
ANNOUNCE_MAPWRAP_RETURN = "Wolfgang cannot be stopped!",
ANNOUNCE_MAPWRAP_WARN = "Is getting scary!",
ANNOUNCE_MORETREASURE = "Wolfgang find more shinies!",
ANNOUNCE_OTHER_WORLD_TREASURE = "Treasure does not look close by.",
ANNOUNCE_SHARX = "Wolfgang has made new friends!",
ANNOUNCE_TRAWL_FULL = "Net is fat with treasures!",
ANNOUNCE_TREASURE = "Wolfgang sees presents!",
ANNOUNCE_VOLCANO_ERUPT = "Ha ha! Time to fight MOUNTAIN!",
ANNOUNCE_WAVE_BOOST = "I am mighty!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Wolfgang will find you, big fishie!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Argh! Big fishie outsmart Wolfgang!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "Wolfgang cannot follow big fishie!",
ANNOUNCE_MESSAGEBOTTLE =
{
	"Eh... Wolfgang can not read.",
},


DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "Chef will cook good meal for friends, meal like home!",
	CHEFPACK = "Is funny chef hat.",
	-- PORTABLECOOKPOT = 
	-- {
 		-- COOKING_LONG = "This take long time.",
		-- COOKING_SHORT = "Is almost cook!",
		-- DONE = "Is time to eat!",
		-- EMPTY = "Chef man cooks good meals for friends, meals like home!",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "Is tiny chef man, %s! Hello!",
        -- ATTACKER = "Ha ha! %s should not pick fight with dumb food!",
        -- MURDERER = "%s is killer!",
        -- REVIVER = "%s is nice, cooks good grub for Wolfgang.",
        -- GHOST = "Do not hurt, chef man. Wolfgang get heart!",
		-- FIRESTARTER = "Please keep burny fires in pot!",
    -- },

	SEAWEED_STALK = "Squishy.", --copied from the Wikia because I couldn't find it in the game files. -M

	LEIF_PALM = "Wood man! Fight me!",
	BABYOX = "He will grow very strong. Or she?",
	BIGFISHINGROD = "Is catching big fish?",
	BLOWDART_POISON = "Is like many tiny punches!",
	COFFEEBOT = "Is hard worker.",
	DEPLETED_GRASS_WATER = "Maybe grass just need to eat.",
	DEPLETED_BAMBOOTREE = "Bush is done for.",
	DEPLETED_BUSH_VINE = "Vine bush is look pathetic!",
	MUSSELBOUILLABAISE = "It belongs in Wolfgang's mouth.",
	OBSIDIANSPEARGUN = "Not as fun as punches, but still very good!",
	SPEARGUN_POISON = "My sickness shooter!",
	SUPERTELESCOPE = "Make eyes strong!",
	SWEETPOTATOSOUFFLE = "Wolfgang will eat!",
	BOAT_WOODLEGS = "Is very bad boat.",
	WOODLEGSHAT = "Is head clothes.",
	SAIL_WOODLEGS = "Is scary sail!",
	TROPICALFAN = "Ha! Is as big as head!",
	SOLOFISH_DEAD = "Is dead.",
	FISH_MED_COOKED = "Meat from water still make Wolfgang strong.",
	GHOST_SAILOR = "Eeeeeeeeeeee!",
	WOODLEGS_CAGE = "Is locked.",
	AERODYNAMICHAT = "Keeps mighty legs free to run!",
	ANTIVENOM = "Wolfgang will flex poison out of veins!",
	ARMORCACTUS = "Hah! Try hit Wolfgang now.",
	ARMORLIMESTONE = "This mighty armor will protect me!",
	ARMOROBSIDIAN = "Is cheap trick, but Wolfgang like!",
	ARMORSEASHELL = "Try your dirty tricks now, poison creatures.",
	ARMOR_LIFEJACKET = "Big seawater will not take Wolfgang now!",
	ARMOR_SNAKESKIN = "Is made to show my mighty muscles.",
	ARMOR_WINDBREAKER = "Wolfgang master of breaking wind!",
	BOAT_ARMOURED = "You are mighty, just like me.",
	BALLPHIN = "Come and fight with me, sea-friends!", 
	BAMBOO = "Very mighty building material!",
	BAMBOOTREE =
	{
		BURNT = "Is not very mighty now.",
		CHOPPED = "I hope is fast growing.",
		GENERIC = "I will harvest you soon, mighty plant!",
	},
	BERMUDATRIANGLE = "Is give me uneasy feelings.",
	BIOLUMINESCENCE = "Pretty sea-lights!",
	BLOWDART_FLUP = "Is workout for my powerful lungs!",
	BLUBBER = "Is not muscle.",
	BLUBBERSUIT = "Would rather wear a muscle suit!",
	BOAT = "Mighty vessel fights the waters.",
	BOATCANNON = "Is the mightiest weapon!",
	BOATREPAIRKIT = "Restore my mighty vessel!",
	BOAT_LANTERN = "Is safer light.",
	BOAT_TORCH = "Flame on boat is good idea!",
	BOTTLELANTERN = "Is good way to keep darkness back.",
	BRAINJELLYHAT = "Agh! Is making Wolfgang think!",
	BUOY = "Ahhh, is marking something.",
	BURIEDTREASURE = "Is mine!",
	BUSH_VINE =
	{
		BURNT = "Ash.",
		CHOPPED = "I won. You lost.",
		GENERIC = "This is bush. Of vines.",
	},
	CAPTAINHAT = "Look at Wolfgang! He is captain now!",
	BOAT_CARGO = "What a mighty storage hold!",
	CHIMINEA = "Be safe from wind, little fire.",
	SAIL_CLOTH = "I will capture you, wind!",
	COCONADE =
	{
		BURNING = "Is burning up quickly.",
		GENERIC = "So much power!",
	},
	COCONUT = "Wolfgang will crush with bare hands.",
	COCONUT_SAPLING = "Is tiny tree! Very small!",
	COCONUT_COOKED = "Coconut is cooked.",
	COCONUT_HALVED = "Wolfgang had no problem smacking hard shell apart.",
	COFFEE = "Strong, like Wolfgang!",
	COFFEEBEANS = "Tiny beans give Wolfgang strength!",
	COFFEEBEANS_COOKED = "Is bitter beans!",
	COFFEEBUSH =
	{
		BARREN = "Where did all tasty beans go?",
		GENERIC = "Coffee bush is proud, strong.",
		PICKED = "Rest now, friend.",
		WITHERED = "Is on death's door.",
	},
	CORAL = "Is very pretty! Will it crush?",
	ROCK_CORAL = "Is so fragile!",
	CORAL_BRAIN = "Heh heh. It squish under Wolfgang's touch.",
	CORAL_BRAIN_ROCK = "Wolfgang's brain will punch this brain.",
	CRAB =
	{
		GENERIC = "If I punch it, it will be food.",
		HIDDEN = "Dun be shellfish.",
	},
	CRABHOLE = "Crabbit is coward.",
	CRATE = "I could smash.",
	CUTLASS = "Wolfgang is ready for battle!",
	SWORDFISH_DEAD = "It was a good fight.",
	DOUBLE_UMBRELLAHAT = "Two umbrellas is better than one.",
	DOYDOY = "Small dumb bird!",
	DOYDOYBABY = "Protect dumb friend, love dumb friend.",
	DOYDOYEGG = "Eat raw, good for mighty muscles!",
	DOYDOYEGG_COOKED = "Stupidly tasty protein.",
	DOYDOYEGG_CRACKED = "I should eat fast before stupid bird comes out.",
	DOYDOYFEATHER = "To remember nice bird by.",
	DOYDOYNEST = "Where dumb friends sleep.",
	DRAGOON = "Is time for flexing contest?",
	DRAGOONDEN = "Wolfgang approves.",
	DRAGOONEGG = "Hatch so we might fight!",
	DRAGOONHEART = "Is mush in my hand.",
	DRAGOONSPIT = "Ha! Wolfgang spit much farther.",
	DUBLOON = "It dents when crushed between Wolfgang's powerful jaws!",
	DUG_BAMBOOTREE = "I will take it with me.",
	DUG_BUSH_VINE = "I will take it with me.",
	DUG_COFFEEBUSH = "It will grow no strong beans like this.",
	DUG_ELEPHANTCACTUS = "I will pick it up with bare hands.",
	EARRING = "Someone drop this, maybe?",
	ELEPHANTCACTUS = "Ouch! Is still sharp.",
	ELEPHANTCACTUS_ACTIVE = "Puny cactus wants to fight me!",
	ELEPHANTCACTUS_STUMP = "It is not dead, only sleeping.",
	FABRIC = "Flimsy cloth-stuffs.",
	SAIL_FEATHER = "Wolfgang is master of sea!",
	FISHINHOLE = "Is good place to fish for... fish.",
	FISH_MED = "Lump of stinky protein.",
	FISH_SMALL = "Fish lump for eating.",
	FISH_SMALL_COOKED = "Looks better now.",
	FLAMEGEYSER = "Watch Wolfgang walk over this!",
	FLOTSAM = "Is not a mighty ship.",
	FLUP = "Flup off!",
	-- FRESHFRUITCREPES = "Manly midmorning brunch.",
	FROG_POISON = "Coward frog!",
	GASHAT = "Little hat is very colorful.",
	GOLDENMACHETE = "Hoighty toighty knife!",
	GRASS_WATER = "Is thirsty grass.",
	HAIL_ICE = "Is cold.",
	ICEMAKER =
	{
		HIGH = "Machine is doing very good job!",
		LOW = "Little machine looks tired.",
		NORMAL = "Thank you for good ice, machine.",
		OUT = "Small machine is out of juice.",
		VERYLOW = "Machine will not last much longer.",
	},
	INVENTORYGRAVE = "A tiny man came through here.",
	INVENTORYMOUND = "A tiny man came through here.",
	IRONWIND = "Spinny sail!",
	JELLYFISH = "If I punch jelly, it will become jam.",
	JELLYFISH_COOKED = "Jelly looks tasty now.",
	JELLYFISH_DEAD = "It stood no chance against Wolfgang.",
	JELLYFISH_PLANTED = "Can it arm wrestle?",
	JELLYJERKY = "Jerky is tough, like Wolfgang!",
	JUNGLETREE =
	{
		BURNING = "I broke it.",
		BURNT = "Is small and broken now.",
		CHOPPED = "Ha! I win!",
		GENERIC = "Tree is strong and magnificent.",
	},
	JUNGLETREESEED = "It might become tree.",
	JUNGLETREESEED_SAPLING = "It has better chance of being tree now.",
	KNIGHTBOAT = "Let us fight!",
	KRAKEN = "Crummy breadeater!",
	KRAKENCHEST = "It dropped something.",
	KRAKEN_TENTACLE = "You have many arms!",
	LAVAPOOL = "Sad. I forget swim trunks.",
	LIMESTONENUGGET = "Corals were crushed to make tiny rock.",
	ROCK_LIMPET =
	{
		GENERIC = "Looks like tiny snails for eating!",
		PICKED = "Tiny snails are gone for now.",
	},
	LIMPETS = "Is snail? Maybe.",
	LIMPETS_COOKED = "It is slimy going down.",
	LIVINGJUNGLETREE = "Looks like ordinary tree.",
	LOBSTER = "Wolfgang respects shellbeast's powerful claws.",
	LOBSTERHOLE = "Is home for shellbeasts.",
	LOBSTER_DEAD = "Wolfgang wish he had fearsome hand claws!",
	LOBSTER_DEAD_COOKED = "Is ready to eat now.",
	BOAT_LOGRAFT = "This raft is... not so mighty.",
	LUGGAGECHEST = "Wolfgang will smash and get treasures!",
	MACHETE = "Ah! Very good!",
	MAGIC_SEAL = "Why is sticky?",
	MAGMAROCK = "Is rock left by angry volcano.",
	MAGMAROCK_FULL = "Is rock left by angry volcano.",
	MAGMAROCK_GOLD = "Is shiny volcano rock.",
	MAGMAROCK_GOLD_FULL = "Is shiny volcano rock.",
	MANGROVETREE = "Is very thirsty.",
	MANGROVETREE_BURNT = "Could not withstanding even small heat!",
	MARSH_PLANT_TROPICAL = "Puny shrub.",
	MERMFISHER = "Let us fight!",
	MERMHOUSE_FISHER = "Ugly house!",
	MESSAGEBOTTLE = "Wolfgang can't fit meaty hands inside.",
	MESSAGEBOTTLEEMPTY = "Is just a bottle.",
	MONKEYBALL = "Ha ha! Stupid monkey men.",
	MOSQUITOSACK_YELLOW = "Is yellow punching bag.",
	MOSQUITO_POISON = "Fight like real man!",
	MUSSEL = "My muscles are much bigger!",
	MUSSEL_COOKED = "Mussels become protein for muscles!",
	MUSSEL_FARM =
	{
		GENERIC = "Strangely named. They have no muscles.",
		STICKPLANTED = "Pathetic creatures, conquered by my stick!",
	},
	MUSSEL_STICK = "Mussels love little stick.",
	MYSTERYMEAT = "My mighty stomach can handle it!",
	NEEDLESPEAR = "The weapon of a mighty plant!",
	OBSIDIAN = "There is strong fire in this stone.",
	OBSIDIANAXE = "The mightiest of axes!",
	OBSIDIANCOCONADE = "Even more might!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "The darkness is coming!",
		GENERIC = "Wolfgang did good job!",
		HIGH = "Is too much fire!",
		LOW = "The fire is not hot enough.",
		NORMAL = "Hearty fire warms Wolfgang's bones.",
		OUT = "Uh oh. It turned off.",
	},
	OBSIDIANMACHETE = "Is so sharp!",
	OBSIDIAN_WORKBENCH = "Is fire table.",
	OCTOPUSCHEST = "Give Wolfgang your treasures!",
	OCTOPUSKING = "Strong creature! Give Wolfgang many good things!",
	OX = "What a mighty beast!",
	OXHAT = "I have become more mighty!",
	OX_FLUTE = "Wolfgang will play lusty tune.",
	OX_HORN = "Horn of strong ox!",
	PACKIM = "Hello, robust friend!",
	PACKIM_FISHBONE = "Is bone. I like it.",
	PALMLEAF = "Big green leaf.",
	PALMLEAF_HUT = "The great Wolfgang deserves comfort.",
	PALMTREE =
	{
		BURNING = "I broke it.",
		BURNT = "Is small and broken now.",
		CHOPPED = "Ha! I win!",
		GENERIC = "Such jovial tree.",
	},
	PARROT = "Chatty bird!",
	PARROT_PIRATE = "It could maybe be friend?",
	PEACOCK = "Bird is showing off.",
	PEG_LEG = "Is best battle trophy!",
	PIKE_SKULL = "Wolfgang not afraid!",
	PIRATEGHOST = "Aaaaaaaaaaahrrrr!!",
	PIRATEHAT = "Ha ha! I like!",
	PIRATEPACK = "Sounds like jingles.",
	PIRATIHATITATOR =
	{
		BURNT = "It does nothing.",
		GENERIC = "Strange contraption.",
	},
	POISONHOLE = "Cowardly hole!",
	PORTAL_SHIPWRECKED = "Where do you go?",
	PRIMEAPE = "Does not look like even match for me.",
	PRIMEAPEBARREL = "Home of tiny monkey men.",
	BOAT_RAFT = "How will tiny plank support Wolfgang?",
	RAWLING = "Wolfgang plays ball!",
	BARREL_GUNPOWDER = "Do not poke barrel.",
	ROCK_CHARCOAL = "Wolfgang rubs it under eyes to scare foes!",
	ROCK_OBSIDIAN = "Very strong rock. Wolfgang would like to have it.",
	BOAT_ROW = "I will row with powerful arms!",
	SAIL_PALMLEAF = "Wolfgang will take to the seas.",
	SAIL_STICK = "Stick makes good sailing!",
	SAND = "When Wolfgang holds it it slips through his large, strong hands.",
	SANDBAG = "Bag soaks up waters.",
	SANDBAGSMALL = "Little bag soaks up waters.",
	SANDBAGSMALL_ITEM = "Is big bag of dirt.",
	SANDBAG_ITEM = "Bag is full of dirt.",
	SANDDUNE = "Tiny, crushable hill.",
	SANDCASTLE =
	{
		GENERIC = "Good for stomping!",
		SAND = "Is more sand than castle.",
	},
	SEAGULL = "It has large mouth. Like me!",
	SEAGULL_WATER = "Resting after good fights, friend?",
	SEASACK = "Wolfgang can carry even more things!",
	SEASHELL = "Tiny shell would crush easily.",
	SEASHELL_BEACHED = "Wolfgang keep bowl of these on table at home.",
	SEATRAP = "Little pincher does not stand a chance.",
	SEAWEED = "A weed, from the sea.",
	SEAWEED_COOKED = "Wolfgang's strong stomach will destroy this!",
	SEAWEED_DRIED = "Is edible.",
	SEAWEED_PLANTED = "Strange leaves from sea.",
	SHADOWSKITTISH_WATER = "I do not like it!",
	SHARKITTEN = "Wolfgang is dog person.",
	SHARKITTENSPAWNER =
	{
		GENERIC = "Is time for cat nap?",
		INACTIVE = "Is just sand.",
	},
	SHARK_FIN = "I lost rest of shark.",
	SHARK_GILLS = "Maybe now Wolfgang breathe underwater? Maybe not.",
	SHARK_TEETHHAT = "Wolfgang's favorite hat!",
	SHARX = "I do not trust these sea-doggies.",
	SHIPWRECKED_ENTRANCE = "Is magical portal. Very sandy...",
	SHIPWRECKED_EXIT = "Is magical portal. Very grassy...",
	SLOTMACHINE = "Wolfgang is gambling man!",
	SNAKE = "I am ready to fight!",
	SNAKEDEN =
	{
		BURNT = "Ash.",
		CHOPPED = "I won. You lost.",
		GENERIC = "This is bush. Of vines.",
	},
	SNAKEOIL = "Good for shining Wolfgang's muscles!",
	SNAKESKIN = "I will use as bandana.",
	SNAKESKINHAT = "Very good.",
	SAIL_SNAKESKIN = "Skin of dead snake will help me sail.",
	SNAKE_FIRE = "You are slippery snake!",
	SNAKE_POISON = "Poison is weapon of cowards!",
	SOLOFISH = "Face me, fish!",
	SPEARGUN = "Spears will shoot now!",
	SPEAR_LAUNCHER = "Punch from a great distance!",
	SPEAR_OBSIDIAN = "Very strong, warm spear.",
	SPEAR_POISON = "Is not cowardly if I use it.",
	SPOILED_FISH = "Is good no more.",
	STUNGRAY = "Looks smooth. I will pet it!",
	SUNKEN_BOAT =
	{
		ABANDONED = "No one home.",
		GENERIC = "Where is captain?",
	},
	SUNKEN_BOAT_BURNT = "Pile of burnt wood.",
	SUNKEN_BOAT_TRINKET_1 = "Wolfgang loves these!",
	SUNKEN_BOAT_TRINKET_2 = "Wolfgang will not fit!",
	SUNKEN_BOAT_TRINKET_3 = "It is the perfect amount of dampness.",
	SUNKEN_BOAT_TRINKET_4 = "Metal doodad is fun for playtimes.",
	SUNKEN_BOAT_TRINKET_5 = "Tough leather is hard to chew.",
	-- BANANAPOP = "Wolfgang can eat in one bite!",
	BISQUE = "It will fuel powerful punches!",
	-- CEVICHE = "It will be better in Wolfgang's belly!",
	SEAFOODGUMBO = "This will make very strong Wolfgang!",
	SURFNTURF = "Very good.",
	SHARKFINSOUP = "Is small shark inside?",
	-- MONSTERTARTARE = "Blech!",
	LOBSTERDINNER = "A meal fit for Wolfgang!",
	LOBSTERBISQUE = "Seems fancy.",
	JELLYOPOP = "Looks like candy, but tastes like meat!",
	SWEET_POTATO = "Very sweet!",
	SWEET_POTATO_COOKED = "Is ready to eat!",
	SWEET_POTATO_PLANTED = "Potato is strange color inside.",
	SWEET_POTATO_SEEDS = "Seeds would taste better if they were a potato.",
	SWIMMINGHORROR = "If it's a fight you want, Wolfgang will oblige!",
	SWORDFISH = "Wolfgang challenges you to duel!",
	TELEPORTATO_SW_BASE = "Wolfgang must fix it.",
	TELEPORTATO_SW_BOX = "What use is tiny box? Wolfgang would like to know.",
	TELEPORTATO_SW_CRANK = "Wolfgang will hold on to this.",
	TELEPORTATO_SW_POTATO = "Hello, spuddy.",
	TELEPORTATO_SW_RING = "I will carry you.",
	TELESCOPE = "I see far!",
	THATCHPACK = "Wolfgang can carry more on powerful shoulders!",
	TIDALPOOL = "Fishies nibble toes when I stick them in.",
	TIDAL_PLANT = "Is plant.",
	TIGEREYE = "Is giving me dirty look.",
	TIGERSHARK = "I will take you to POUND!",
	TOUCAN = "Bird flees at the sight of Wolfgang.",
	TRAWLNET = "Wolfgang will trap you in his net!",
	TRAWLNETDROPPED =
	{
		GENERIC = "What fishes will I find?",
		SOON = "Is really sinking.",
		SOONISH = "Is sinking.",
	},
	TRIDENT = "I feel like king of sea.",
	TRINKET_IA_13 = "Wolfgang would not like to drink.",
	TRINKET_IA_14 = "Wolfgang does not like that.",
	TRINKET_IA_15 = "It does not fit in Wolfgang's big hands.",
	TRINKET_IA_16 = "I do not know what this is.",
	TRINKET_IA_17 = "Tough leather is hard to chew.",
	TRINKET_IA_18 = "Is broken.",
	TRINKET_IA_19 = "Wolfgang is not eat loose pills.",
	TRINKET_IA_20 = "Wolfgang loves these!",
	TRINKET_IA_21 = "Wolfgang will not fit!",
	TRINKET_IA_22 = "Looks much too dry.",
	TRINKET_IA_23 = "Is very broken.",
	FISH_TROPICAL = "Is yummy looking.",
	TUNACAN = "I will open with bare hands!",
	TURBINE_BLADES = "Blade that does not cut.",
	TURF_ASH = "Step stones.",
	TURF_BEACH = "Step stones.",
	TURF_JUNGLE = "Step stones.",
	TURF_MAGMAFIELD = "Step stones.",
	TURF_MEADOW = "Step stones.",
	TURF_SNAKESKIN = "Step stones.",
	TURF_SWAMP = "Step stones.",
	TURF_TIDALMARSH = "Step stones.",
	TURF_VOLCANO = "Step stones.",
	TWISTER = "What might!",
	TWISTER_SEAL = "Ha ha! Is good friend.",
	VENOMGLAND = "Is weapon of cowards.",
	VINE = "For string enemies together.",
	VOLCANO = "Is calling me to fight!",
	VOLCANOSTAFF = "Power of fire mountain is in Wolfgang's hands!",
	VOLCANO_ALTAR =
	{
		GENERIC = "Is not wanting anything right now.",
		OPEN = "Wolfgang is afraid to use.",
	},
	VOLCANO_ALTAR_BROKEN = "This is no more.",
	VOLCANO_ALTAR_TOWER = "Is scary looking.",
	VOLCANO_EXIT = "Goodbye!",
	VOLCANO_SHRUB = "Tree was too weak. Dead now.",
	WALLYINTRO_DEBRIS = "It's lost its battle.",
	WALL_LIMESTONE = "Good, sturdy wall.",
	WALL_LIMESTONE_ITEM = "I will make strong wall.",
	WATERYGRAVE = "I do not like this. Is creepy.",
	WHALE_BLUE = "I will eat you!",
	WHALE_BUBBLES = "Large fishie is underneath.",
	WHALE_CARCASS_BLUE = "Well fought, large fish!",
	WHALE_CARCASS_WHITE = "Not-so-great white.",
	WHALE_TRACK = "Massive fish cannot escape me!",
	WHALE_WHITE = "Great white! Fight Wolfgang!",
	WILBUR_CROWN = "Crown is falling apart!",
	WILBUR_UNLOCK = "Welcome, friend! Ha ha!",
	WILDBORE = "I will wrestle you.",
	WILDBOREHEAD = "Very gross!",
	WILDBOREHOUSE = "Puny house could not hold me.",
	WIND_CONCH = "Shell makes scary sounds!",
	WOODLEGS_KEY1 = "Spooky key!",
	WOODLEGS_KEY2 = "Pretty key!",
	WOODLEGS_KEY3 = "Boring key!",
	SHIPWRECK = "Not mighty enough to float.",
	CALIFORNIAROLL = "Get in Wolfgang's stomach!",

	--- 5C DLC ------------------------------------------------------------------------------------------------

	BOAT_ENCRUSTED = "Tiny boat will hold all of Wolfgang?",
	BABYOX = "He will grow very strong! Or is she?",
	BALLPHINHOUSE = "Friends of Wolfgang live inside.",
	DORSALFIN = "Where is rest of fish?",
	NUBBIN = "Haha. Rock is bald.",
	CORALLARVE = "Is small and harmless.",
	RAINBOWJELLYFISH = "Ah! Is pretty jelly!",
	RAINBOWJELLYFISH_PLANTED = "Very pretty jelly!",
	RAINBOWJELLYFISH_DEAD = "Good looking jelly is no look so good.",
	RAINBOWJELLYFISH_COOKED = "Food is many pretty colors!",
	RAINBOWJELLYJERKY = "Tough food makes Wolfgang tough!",
	WALL_ENFORCEDLIMESTONE = "Is sea wall now!",
	WALL_ENFORCEDLIMESTONE_ITEM = "Wolfgang will build sea wall!",
	CROCODOG = "Hairless puppy!",
	POISONCROCODOG = "Hairless puppy is yellow!",
	WATERCROCODOG = "Hairless puppy is blue!",
	QUACKENBEAK = "Wolfgang is very proud of bird souvenir!",
	QUACKERINGRAM = "SMASH!",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "Little eggs make Wolfgang feel like big, important man.",
	CORMORANT = "Bird smells like fish eggs.",

	PURPLE_GROUPER = "Wolfgang wish he swim like fish.",
	PIERROT_FISH = "Little fish is very dry!",
	NEON_QUATTRO = "Ha ha! Scales is chilly!",

	PURPLE_GROUPER_COOKED = "Wolfgang will eat tasty fish!",
	PIERROT_FISH_COOKED = "Little fish will make Wolfgang mighty!",
	NEON_QUATTRO_COOKED = "Toasty fish is good muscle fuel.",

	FISH_FARM = 
	{
		EMPTY = "Need little fishie eggs!",
		STOCKED = "Fishes is growing.",
		ONEFISH = "Wolfgang has fish!",
		TWOFISH = "More fishes for Wolfgang!",
		REDFISH = "Many fishes means fancy fish soup!",
		BLUEFISH  = "Wolfgang will eat ALL fishes!",
	},
	
	ROE = "Is eggy.",
	ROE_COOKED = "Little eggs is stink less now.",
	
	SEA_YARD = 
	{
		ON = "Will make boats mighty again!",
		OFF = "Is not working.",
		LOWFUEL = "Need fuel for running.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "Fire is sick, maybe?",
		GENERIC = "Wolfgang will make fire at sea.",
		HIGH = "Mighty fire for mighty Wolfgang!",
		LOW = "Little sea fire is look wimpy.",
		NORMAL = "Fire is okay.",
		OUT = "Wolfgang needs new fire.",
	}, 

	TAR = "Icky sticky black goo!",
	TAR_EXTRACTOR =
	{
		ON = "Machine is run strong.",
		OFF = "Is need on-switching.",
		LOWFUEL = "Floaty machine needs food.",
											
											 
	},
	TAR_POOL = "Is bubbling.",

	TARLAMP = "Lamp is so little, dainty.",
	TARSUIT = "Water not get Wolfgang now.",
	TAR_TRAP = "Goo cannot stop mighty Wolfgang feet!",
	
	TROPICALBOUILLABAISSE = "Wolfgang does not know what to call this.",
	
	SEA_LAB = "Wolfgang will learn many splishy splashy things!",
	WATERCHEST = "Is for holding seastuff!",
	QUACKENDRILL = "Wolfgang will punch bottom of ocean!",
	HARPOON = "Even Wolfgang's throws is mighty!",
	MUSSEL_BED = "Tiny mussels should be in water!",
},
}
%%+%%strings/woodie.lua%%-%%return {
ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "I'm afraid I can't.",
	},
},
ANNOUNCE_MAGIC_FAIL = "That won't work here, eh.",
ANNOUNCE_OTHER_WORLD_PLANT = "Wrong kind of soil for this, eh?",
ANNOUNCE_BOAT_DAMAGED = "My boat's pretty banged up, eh?",
ANNOUNCE_BOAT_SINKING = "I'm aboot to sink!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "We're goin' down!",
ANNOUNCE_CRAB_ESCAPE = "It got away.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Into waters unknown!",
ANNOUNCE_MAPWRAP_RETURN = "That was unwise!",
ANNOUNCE_MAPWRAP_WARN = "I'm leaving charted waters...",
ANNOUNCE_MESSAGEBOTTLE =
{
	"The sea has washed away the message.",
},
ANNOUNCE_MORETREASURE = "There's more gold to be had!",
ANNOUNCE_OTHER_WORLD_TREASURE = "I don't believe I can find this here.",
ANNOUNCE_SHARX = "There's a fish nearby... and it's hungry!",
ANNOUNCE_TRAWL_FULL = "It's time to reel it in!",
ANNOUNCE_TREASURE = "Here comes the gold rush!",
ANNOUNCE_VOLCANO_ERUPT = "Ooh, that's some bad weather, eh?",
ANNOUNCE_WAVE_BOOST = "For the North!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "I was born to track beasts!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "I lost the trail. Sorry!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "Where did the whale go?!",

DESCRIBE = {
	-- PORTABLECOOKPOT_ITEM = "Sure makes the camp smell nice.",
	CHEFPACK = "Good for long hikes.",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "Warly says not to watch a boiling pot, eh?",
		-- COOKING_SHORT = "Oh boy! I smell supper!",
		-- DONE = "Time for supper!",
		-- EMPTY = "Someone get the chef to cook us up some grub.",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "%s! How ya doin', buddy?",
        -- ATTACKER = "%s could learn some manners...",
        -- MURDERER = "This is gonna be a clear cut!",
        -- REVIVER = "%s, you're an alright guy.",
        -- GHOST = "With a heart you'll be tip-top in no time, %s.",
		-- FIRESTARTER = "I'm no expert but that is not how you start cooking.",
    -- },

	SEAWEED_STALK = "Should plant this somewhere.", --copied from the Wikia because I couldn't find it in the game files. -M

	LEIF_PALM = "I've angered the beach!", -- "I'm sorry aboot all of those trees!",
	TROPICALFAN = "I'm not used to the heat in this place!",
	PALMLEAF_UMBRELLA = "I think I did a pretty good job on this 'breller.",
	SOLOFISH_DEAD = "It wants to be dinner.",
	FISH_MED_COOKED = "I wish I had some chips.",
	GHOST_SAILOR = "Not a bad beard for a dead guy.",
	-- BANANAPOP = "I'd prefer maple taffy...",
	BISQUE = "Hearty.",
	-- CEVICHE = "I'd be loonie not to eat this.",
	SEAFOODGUMBO = "We don't have this back home.",
	SURFNTURF = "Good eating, that.",
	SHARKFINSOUP = "He'll swim in my stomach from now on.",
	LOBSTERDINNER = "I'd prefer salmon.",
	LOBSTERBISQUE = "Looks pretty good for desert island food.",
	JELLYOPOP = "I guess this is a dessert island, eh?",
	WOODLEGS_CAGE = "Are you okay in there, buddy?",

	TWISTER = "Mother Nature's throwing a tantrum!",
	WIND_CONCH = "I can hear the chime of twenty-nine bells.",

	AERODYNAMICHAT = "It's a speed toque.",
	ANTIVENOM = "Tastes awful, but it works!",
	ARMORCACTUS = "Pretty prickly protection, eh?",
	ARMORLIMESTONE = "Makes me feel sorta tough.",
	ARMOROBSIDIAN = "Hot stuff, eh?",
	ARMORSEASHELL = "This doesn't seem very hardy.",
	ARMOR_LIFEJACKET = "A lil reassurance.",
	ARMOR_SNAKESKIN = "I feel suave in it.",
	ARMOR_WINDBREAKER = "I feel right at home in this, eh.",
	BOAT_ARMOURED = "That's aboot as safe as it gets on the sea.",
	BABYOX = "Hey, little buddy!",
	BALLPHIN = "Hey buddy, you know any tricks?",
	BAMBOO = "It's like diet wood, eh?",
	BAMBOOTREE =
	{
		BURNT = "Burnt like bacon, eh?",
		CHOPPED = "That was some good chopping!",
		GENERIC = "Lucy's got too much kick for this.",
	},
	BERMUDATRIANGLE = "Kinda spooky, eh?",
	BIGFISHINGROD = "Walk tall and carry a big rod.",
	BIOLUMINESCENCE = "Just like the Northern Lights.",
	BLOWDART_FLUP = "Eye'll get you!",
	BLOWDART_POISON = "Aim for a main vein, eh?",
	BLUBBER = "Quit your blubbering.",
	BLUBBERSUIT = "It's not very flattering.",
	BOATCANNON = "This'll blow'em up real good!",
	BOATREPAIRKIT = "Patch'er up, eh?",
	BOAT_LANTERN = "It's a boat light.",
	BOAT_TORCH = "I can go night fishing.",
	BOTTLELANTERN = "You okay in there, glowing buddies?",
	BRAINJELLYHAT = "I feel like a keener when I put it on.",
	BUOY = "Floating through life. Got the right idea there.",
	BURIEDTREASURE = "Time to get digging!",
	BUSH_VINE =
	{
		BURNT = "Welp, that's not coming back.",
		CHOPPED = "Not as fun as a tree, but it was good chopping nonetheless.",
		GENERIC = "It's just asking to be chopped.",
	},
	CAPTAINHAT = "I hope I don't have to go down with the ship.",
	BOAT_CARGO = "I'd prefer cargo shorts.",
	CHIMINEA = "It's like armor for fire.",
	SAIL_CLOTH = "This should help me get around.",
	COCONADE =
	{
		BURNING = "Time to run!",
		GENERIC = "I'm gonna do some serious damage with this.",
	},
	COCONUT = "It's just a coconut.",
	COCONUT_SAPLING = "Now it's a tiny palm tree.",
	COCONUT_COOKED = "Ready to eat.",
	COCONUT_HALVED = "One for me and one for Lucy.",
	COFFEE = "Good old joe.",
	COFFEEBEANS = "I should cook these up.",
	COFFEEBEANS_COOKED = "Canadians love their coffee.",
	COFFEEBOT = "Makes coffee, don't it.",
	COFFEEBUSH =
	{
		BARREN = "You look a little down, bud.",
		GENERIC = "Coffee beans!",
		PICKED = "I wish it had more beans.",
		WITHERED = "It could use good cuppa joe.",
	},
	CORAL = "Maybe I could crush it down to make something new.",
	ROCK_CORAL = "Ripe for the picking.",
	CORAL_BRAIN = "How brainy.",
	CORAL_BRAIN_ROCK = "What're you, some sort of keener?",
	CRAB =
	{
		GENERIC = "Maybe we could be buds?",
		HIDDEN = "Can't hide forever, bud.",
	},
	CRABHOLE = "That's where my crabbit buddies live.",
	CRATE = "That there's a box.",
	CUTLASS = "That's a pretty neat little cutter, eh?",
	SWORDFISH_DEAD = "Sorry, guy.",
	DEPLETED_BAMBOOTREE = "Grow so I can chop you down again!",
	DEPLETED_BUSH_VINE = "I guess it'll regrow.",
	DEPLETED_GRASS_WATER = "I don't like waiting.",
	DEVTOOL_NODEV = "What a curious thing.",
	DOUBLE_UMBRELLAHAT = "Double the protection!",
	DOYDOY = "Not too sure how this awful thing survives.",
	DOYDOYBABY = "It's filthy.",
	DOYDOYEGG = "Looks like good eating to me.",
	DOYDOYEGG_COOKED = "Could use a side of Canadian bacon.",
	DOYDOYEGG_CRACKED = "Well, can't do nothing aboot it now.",
	DOYDOYFEATHER = "It's nothing like the plumage of the proud Canadian goose.",
	DOYDOYNEST = "Those filthy birds breed here.",
	DRAGOON = "Seems a little hot under the toque!",
	DRAGOONDEN = "That doesn't look like a beaver dam.",
	DRAGOONEGG = "That looks a little suspicious to me.",
	DRAGOONHEART = "The heart of the beast.",
	DRAGOONSPIT = "Rude.",
	DUBLOON = "I've struck gold!",
	DUG_BAMBOOTREE = "You're coming with me!",
	DUG_BUSH_VINE = "Are you ready to go on a little trip?",
	DUG_COFFEEBUSH = "I'm going to take you everywhere with me.",
	DUG_ELEPHANTCACTUS = "Are you headed my way?",
	EARRING = "Shouldn't there be two?",
	ELEPHANTCACTUS = "It's prickly, eh?",
	ELEPHANTCACTUS_ACTIVE = "Watch out! That plant's gonna give'r!",
	ELEPHANTCACTUS_STUMP = "This cactus gave'r. Now it's tired.",
	FABRIC = "How do I dye it plaid?",
	SAIL_FEATHER = "I guess touching all those gross feathers was worth it.",
	FISHINHOLE = "If only it were a little colder, would be perfect for ice fishin'!",
	FISH_MED = "I'd prefer salmon.",
	FISH_SMALL = "I hope I don't attract bears.",
	FISH_SMALL_COOKED = "Looks good to me.",
	FLAMEGEYSER = "Woah, cool it!",
	FLOTSAM = "Justa bunch of junk.",
	FLUP = "Gross.",
	-- FRESHFRUITCREPES = "I can get maple syrup on that?",
	FROG_POISON = "Keep your poison spit to yourself, eh!",
	GASHAT = "Nothin' stinks when I got this on.",
	GOLDENMACHETE = "It chops AND sparkles!",
	GRASS_WATER = "A bit damp, eh?",
	HAIL_ICE = "You think this is cold? How cute.",
	HOUNDFIRE = "It burns so mightily!",
	ICEMAKER =
	{
		HIGH = "Furiously icy! Reminds me of home.",
		LOW = "Gettin' low.",
		NORMAL = "It's pumping along nicely.",
		OUT = "It's hooped.",
		VERYLOW = "It'll give out any second.",
	},
	INVENTORYGRAVE = "Someone was here. Not anymore.",
	INVENTORYMOUND = "Someone was here. Not anymore.",
	IRONWIND = "Looks speedy.",
	JELLYFISH = "That's a jellyfish, don'tcha know.",
	JELLYFISH_COOKED = "I think this is as edible as it gets.",
	JELLYFISH_DEAD = "The life's all but drained out of it, eh?",
	JELLYFISH_PLANTED = "A little jellyfish buddy.",
	JELLYJERKY = "Jerky! The food of my people.",
	JUNGLETREE =
	{
		BURNING = "Waste of a good chopping stump.",
		BURNT = "What a waste.",
		CHOPPED = "Those were good times.",
		GENERIC = "The tree's call fills my ears!",
	},
	JUNGLETREESEED = "This could grow into a good chopping tree.",
	JUNGLETREESEED_SAPLING = "Now we wait.",
	KNIGHTBOAT = "That guy's got an attitude problem!",
	KRAKEN = "For Lucy!",
	KRAKENCHEST = "Show me the loot!",
	KRAKEN_TENTACLE = "A bit grabby, don'tcha think?",
	LAVAPOOL = "I'm breaking a sweat just looking at it.",
	LIMESTONENUGGET = "I crushed up that pretty coral to make this.",
	ROCK_LIMPET =
	{
		GENERIC = "I could make a snack out of those.",
		PICKED = "Just a big rock, eh?",
	},
	LIMPETS = "Some sort of water-dwelling snail.",
	LIMPETS_COOKED = "Dinner's on.",
	LIVINGJUNGLETREE = "It wants me to cut it down, I can tell.",
	LOBSTER = "A little melted butter and it'd be delicious.",
	LOBSTERHOLE = "Come on out, little guy.",
	LOBSTER_DEAD = "He's thoroughly hooped.",
	LOBSTER_DEAD_COOKED = "Good eats!",
	BOAT_LOGRAFT = "My specialty!",
	LUGGAGECHEST = "Anything good inside?",
	MACHETE = "Ooh, that's a thing for chopping.",
	MAGIC_SEAL = "It's pulsing with power.",
	MAGMAROCK = "A little rearranging and it'd make a nice inukshuk.",
	MAGMAROCK_FULL = "A little rearranging and it'd make a nice inukshuk.",
	MAGMAROCK_GOLD = "That looks worth digging into.",
	MAGMAROCK_GOLD_FULL = "That looks worth digging into.",
	MANGROVETREE = "Looks tasty!",
	MANGROVETREE_BURNT = "Hurts my hoser heart to look at.",
	MARSH_PLANT_TROPICAL = "That's a little plant.",
	MERMFISHER = "I don't know aboot that guy.",
	MERMHOUSE_FISHER = "I'd prefer a log cabin.",
	MESSAGEBOTTLE = "Is someone trying to talk to me?",
	MESSAGEBOTTLEEMPTY = "What was in it?",
	MONKEYBALL = "What're you smiling at?",
	-- MONSTERTARTARE = "Isn't there anything else to eat?",
	MOSQUITOSACK_YELLOW = "It smells a little sour.",
	MOSQUITO_POISON = "It's dripping with disease.",
	MUSSEL = "Those look like good eating.",
	MUSSELBOUILLABAISE = "Best meal I've seen in awhile, eh?",
	MUSSEL_COOKED = "These look tasty.",
	MUSSEL_FARM =
	{
		GENERIC = "They want to be food.",
		STICKPLANTED = "I predict a mussel dinner in my future.",
	},
	MUSSEL_STICK = "The mussels can't get enough of this thing.",
	MYSTERYMEAT = "What on earth is that!",
	NEEDLESPEAR = "Hoo-boy. That's sharp.",
	OBSIDIAN = "It's a little toasty.",
	OBSIDIANAXE = "Watch out Lucy, you've got competition! (Just kidding!)",
	OBSIDIANCOCONADE = "It packs a major punch.",
	OBSIDIANFIREPIT =
	{
		EMBERS = "I should go chop some wood for that, eh?",
		GENERIC = "Looks like the perfect place to light a fire.",
		HIGH = "I'm using too much wood too fast!",
		LOW = "There should be some wood around here somewhere.",
		NORMAL = "Mmmm. Smells woody.",
		OUT = "If only I had some wood.",
	},
	OBSIDIANMACHETE = "It singes everything it touches.",
	OBSIDIANSPEARGUN = "It lights stuff on fire, eh.",
	OBSIDIAN_WORKBENCH = "I can make some fiery tools here.",
	OCTOPUSCHEST = "Thanks for the stuff, guy!",
	OCTOPUSKING = "How you holding up out here, guy?",
	OX = "Poor guy's the butt of every yoke.",
	OXHAT = "This is a hat befitting a Northerner.",
	OX_FLUTE = "I'm more of a guitar player.",
	OX_HORN = "It used to be attached to an ox.",
	PACKIM = "I can tolerate him.",
	PACKIM_FISHBONE = "This better not attract any feathered vermin.",
	PALMLEAF = "I use it for fanning myself.",
	PALMLEAF_HUT = "The best shelter a woodcutter could ask for.",
	PALMTREE =
	{
		BURNING = "Waste of a good chopping stump.",
		BURNT = "What a waste.",
		CHOPPED = "Those were good times.",
		GENERIC = "Makes me pine for the lumber yards.",
	},
	PARROT = "Shoo, filthy featherbag!",
	PARROT_PIRATE = "I'd rather not smalltalk with a birdbrain.",
	PEACOCK = "What a ridiculous thing. Bah!",
	PEG_LEG = "Can I chop this?",
	PIKE_SKULL = "Well that there's a tacky decoration.",
	PIRATEGHOST = "Maybe he's friendly?",
	PIRATEHAT = "It's the pirate's life for me now.",
	PIRATEPACK = "A bag for my booty.",
	PIRATIHATITATOR =
	{
		BURNT = "Not so funny anymore.",
		GENERIC = "That's a funny lookin' contraption.",
	},
	POISONHOLE = "I think I'll give that a wide berth.",
	PORTAL_SHIPWRECKED = "Looks hooped to me.",
	PRIMEAPE = "This guy's a bit of a keener.",
	PRIMEAPEBARREL = "Where the keeners sleep.",
	BOAT_RAFT = "Pitiful little boat.",
	RAWLING = "What a nutter!",
	BARREL_GUNPOWDER = "That looks dangerous.",
	ROCK_CHARCOAL = "It makes my hands all sooty.",
	ROCK_OBSIDIAN = "There's a fire burning within it.",
	BOAT_ROW = "Powered by elbow grease.",
	SAIL_PALMLEAF = "I've got the wind in my sails.",
	SAIL_STICK = "The Northern winds are at my disposal.",
	SAND = "Sandy.",
	SANDBAG = "Building dams is my specialty.",
	SANDBAGSMALL = "Building dams is my specialty.",
	SANDBAGSMALL_ITEM = "A tiny, portable dam.",
	SANDBAG_ITEM = "A portable dam.",
	SANDDUNE = "It's a big pile of sand.",
	SANDCASTLE =
	{
		GENERIC = "Who knew sand could look so good.",
		SAND = "Looks good.",
	},
	SEAGULL = "Vermin of the sky.",
	SEAGULL_WATER = "Vermin of the sea.",
	SEASACK = "It's for holding my treasures.",
	SEASHELL = "It makes me want to get back into arts and crafts.",
	SEASHELL_BEACHED = "A pretty shell.",
	SEATRAP = "I'm looking forward to a wobster dinner.",
	SEAWEED = "It's slimy.",
	SEAWEED_COOKED = "It has a weird texture.",
	SEAWEED_DRIED = "It sort of sticks to my tongue.",
	SEAWEED_PLANTED = "That's some seaweed, eh?",
	SHADOWSKITTISH_WATER = "Hoo-boy!",
	SHARKITTEN = "Just a big sweet kitty cat.",
	SHARKITTENSPAWNER =
	{
		GENERIC = "I think I hear meowing...?",
		INACTIVE = "Looks like just a bunch of sand to me, eh?",
	},
	SHARK_FIN = "I'm sure the shark won't miss this.",
	SHARK_GILLS = "Fish lungs.",
	SHARK_TEETHHAT = "It's a hat made of teeth.",
	SHARX = "Not gonna make a buddy of that one, that's for sure.",
	SHIPWRECKED_ENTRANCE = "I'm ready for adventure, eh!",
	SHIPWRECKED_EXIT = "See ya later, bud.",
	SLOTMACHINE = "The spirit of the North guides my fate.",
	SNAKE = "It's an alright sort, as far as snakes go.",
	SNAKEDEN =
	{
		BURNT = "Welp, that's not coming back.",
		CHOPPED = "Not as fun as a tree, but it was good chopping nonetheless.",
		GENERIC = "It's just asking to be chopped.",
	},
	SNAKEOIL = "I'm not falling for this.",
	SNAKESKIN = "I'm sure the snake didn't need this.",
	SNAKESKINHAT = "Now would this be a \"touque\" or a \"tuque\"?",
	SAIL_SNAKESKIN = "Sailin' in style.",
	SNAKE_FIRE = "It's looking a little heated.",
	SNAKE_POISON = "I'd rather not get bitten by that.",
	SOLOFISH = "Nice doggy.",
	SPEARGUN = "This is one skookum weapon!",
	SPEARGUN_POISON = "This skookum weapon poisons my enemies!",
	SPEAR_LAUNCHER = "This is one skookum weapon!",
	SPEAR_OBSIDIAN = "This is one fiery spear.",
	SPEAR_POISON = "This spear has a little extra bite.",
	SPOILED_FISH = "I think it's time to throw this out.",
	STUNGRAY = "Smells worse than a waterlogged moose!",
	SUNKEN_BOAT =
	{
		ABANDONED = "Waste of good wood.",
		GENERIC = "Hey buddy.",
	},
	SUNKEN_BOAT_BURNT = "That there won't float no more.",
	SUNKEN_BOAT_TRINKET_1 = "That's a little too fancy for my liking.",
	SUNKEN_BOAT_TRINKET_2 = "That boat seems a little on the small side.",
	SUNKEN_BOAT_TRINKET_3 = "I can't imagine this having a use.",
	SUNKEN_BOAT_TRINKET_4 = "A toy for a keener.",
	SUNKEN_BOAT_TRINKET_5 = "Not my size, that.",
	SUPERTELESCOPE = "As easy as looking over the plains of Alberta.",
	SWEETPOTATOSOUFFLE = "Pretty extravagant!",
	SWEET_POTATO = "I'll cook this up good.",
	SWEET_POTATO_COOKED = "Could use some marshmallows.",
	SWEET_POTATO_PLANTED = "Looks like some sorta fancy potato.",
	SWEET_POTATO_SEEDS = "These would be of more use to me planted.",
	SWIMMINGHORROR = "I don't want nothin' to do with that, eh!",
	SWORDFISH = "That there's one pointy fish.",
	TELEPORTATO_SW_BASE = "Nothing some duct tape wouldn't fix.",
	TELEPORTATO_SW_BOX = "There must be a use for this, eh?",
	TELEPORTATO_SW_CRANK = "I should keep a hold of this.",
	TELEPORTATO_SW_POTATO = "Doesn't look anything like a potato. And I know potatoes.",
	TELEPORTATO_SW_RING = "Some sort of ring?",
	TELESCOPE = "Helps my eyesight, eh?",
	THATCHPACK = "Now I can carry more delicious wood.",
	TIDALPOOL = "Seems like a popular hangout spot for fishes.",
	TIDAL_PLANT = "No wood to be had from that thing.",
	TIGEREYE = "Don'tcha know it's rude to stare?",
	TIGERSHARK = "Might be cute if it didn't want to eat me.",
	TOUCAN = "That thing looks shifty.",
	TRAWLNET = "The fishes should swim right into this.",
	TRAWLNETDROPPED =
	{
		GENERIC = "Come to me, fishes!",
		SOON = "Nearly there!",
		SOONISH = "It's on its way down.",
	},
	TRIDENT = "Get a load of this massive fork, eh?!",
	TRINKET_IA_13 = "Is this safe for consumption?",
	TRINKET_IA_14 = "Is that my face?",
	TRINKET_IA_15 = "This guitar is tiny!",
	TRINKET_IA_16 = "It's just a little sheet of metal, eh?",
	TRINKET_IA_17 = "Not my size.",
	TRINKET_IA_18 = "It's broken.",
	TRINKET_IA_19 = "Who knows what this does?",
	TRINKET_IA_20 = "That's a little too fancy for my liking.",
	TRINKET_IA_21 = "That boat seems a little on the small side.",
	TRINKET_IA_22 = "Not very useful looking.",
	TRINKET_IA_23 = "I got no idea what that is.",
	FISH_TROPICAL = "Are you ready to become fish'n'chips?",
	TUNACAN = "Lucy'll open'er up.",
	TURBINE_BLADES = "Makes my head spin.",
	TURF_ASH = "Just some ground, eh?",
	TURF_BEACH = "Just some ground, eh?",
	TURF_JUNGLE = "Just some ground, eh?",
	TURF_MAGMAFIELD = "Just some ground, eh?",
	TURF_MEADOW = "Just some ground, eh?",
	TURF_SNAKESKIN = "Just some ground, eh?",
	TURF_SWAMP = "Just some ground, eh?",
	TURF_TIDALMARSH = "Just some ground, eh?",
	TURF_VOLCANO = "Just some ground, eh?",
	TWISTER_SEAL = "Cute little fella.",
	VENOMGLAND = "It smells kind of funny.",
	VINE = "Sigh. Not a tree.",
	VOLCANO = "That's a doozy!",
	VOLCANOSTAFF = "The power of the volcano is in my hand.",
	VOLCANO_ALTAR =
	{
		GENERIC = "Nothing to do aboot that.",
		OPEN = "I feel like it wants something from me.",
	},
	VOLCANO_ALTAR_BROKEN = "Thoroughly broke, that.",
	VOLCANO_ALTAR_TOWER = "That's a creepy-lookin' hunk of rock, that.",
	VOLCANO_EXIT = "Time to scoot.",
	VOLCANO_SHRUB = "Well, it's definitely not an evergreen.",
	WALLYINTRO_DEBRIS = "Where am I?",
	WALL_LIMESTONE = "That's a wall.",
	WALL_LIMESTONE_ITEM = "Why build walls when we could build bridges?",
	WATERYGRAVE = "I hope to never end up in one of those.",
	WHALE_BLUE = "Give'r!",
	WHALE_BUBBLES = "I know you're down there, buddy.",
	WHALE_CARCASS_BLUE = "That's a big guy, eh.",
	WHALE_CARCASS_WHITE = "Well, he's dead now.",
	WHALE_TRACK = "I'm hot on the trail.",
	WHALE_WHITE = "It's strong, and very free.",
	WILBUR_CROWN = "Luxurious.",
	WILBUR_UNLOCK = "I made a new buddy.",
	WILDBORE = "Looks like a total hoser.",
	WILDBOREHEAD = "Tough luck, buddy.",
	WILDBOREHOUSE = "Looks like a house fulla hosers.",
	BOAT_WOODLEGS = "Fancy, but it seems a little slow.",
	WOODLEGSHAT = "Could do with a pair of woolly earflaps.",
	SAIL_WOODLEGS = "Pretty stylish sail, that.",
	WOODLEGS_KEY1 = "What might this open?",
	WOODLEGS_KEY2 = "Key to what?",
	WOODLEGS_KEY3 = "I should hold on to this, eh?",
	SHIPWRECK = "A waste of good wood.",
	CALIFORNIAROLL = "I feel like a regular Vancouverite.",

	--- 5C DLC ------------------------------------------------------------------------------------------------

	BOAT_ENCRUSTED = "More \"crusty\" than \"encrusted\".",
	BABYOX = "He's all beard.",
	BALLPHINHOUSE = "Not quite as nice as a seaside cabin, but it'll do.",
	DORSALFIN = "Definitely not ballphin-free.",
	NUBBIN = "Uncomfortably smooth.",
	CORALLARVE = "What a tiny little hoser.",
	RAINBOWJELLYFISH = "Are you edible, little buddy?",
	RAINBOWJELLYFISH_PLANTED = "Floating along.",
	RAINBOWJELLYFISH_DEAD = "I don't think my little buddy's getting up anytime soon.",
	RAINBOWJELLYFISH_COOKED = "As good of eating as anything around here.",
	RAINBOWJELLYJERKY = "Wish it was salmon jerky.",
	WALL_ENFORCEDLIMESTONE = "Good looking sea wall.",
	WALL_ENFORCEDLIMESTONE_ITEM = "Just plop'r down wherever.",
	CROCODOG = "Those're some nasty chompers.",
	POISONCROCODOG = "Woah now, buddy.",
	WATERCROCODOG = "Really has that \"wet dog\" smell.",
	QUACKENBEAK = "A nightmare made real.",
	QUACKERINGRAM = "I've turned the seabird's evil against it!",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "Whew, that's salty.",
	CORMORANT = "Filthy scoundrel.",

	PURPLE_GROUPER = "Looks like dinner.",
	PIERROT_FISH = "Always did like fishing.",
	NEON_QUATTRO = "Nice colours on that one.",

	PURPLE_GROUPER_COOKED = "Caught and cooked it myself.",
	PIERROT_FISH_COOKED = "Mmm, roast fish.",
	NEON_QUATTRO_COOKED = "Looks like I'll be eating for a day.",

	FISH_FARM = 
	{
		EMPTY = "Need to get ahold of fish eggs for that.",
		STOCKED = "Now we wait, eh, Lucy?",
		ONEFISH = "Hey Lucy, look. We've got a fish.",
		TWOFISH = "Those oughta cook up real good.",
		REDFISH = "More of 'em, eh?",
		BLUEFISH  = "Can't even count'em all anymore.",
	},
	
	ROE = "A handful of future fish, eh?",
	ROE_COOKED = "Better eat'em before they go bad.",
	
	SEA_YARD = 
	{
		ON = "Open for business.",
		OFF = "It's run clean dry, eh?",
		LOWFUEL = "Needs topping up.",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "It's aboot to go right out.",
		GENERIC = "Lil water never stopped a woodsman.",
		HIGH = "Burning like mad!",
		LOW = "Gettin' a touch low.",
		NORMAL = "Steady going.",
		OUT = "Needs a good log.",
	}, 

	TAR = "Stickier than tree sap, that.",
	TAR_EXTRACTOR =
	{
		ON = "It's running like a dream.",
										
		OFF = "It's off.",
		LOWFUEL = "Fuel's low.",
								   
	},
	TAR_POOL = "Yep. There's tar down there.",

	TARLAMP = "Simple little light, that.",
	TARSUIT = "You do what you gotta to survive.",
	TAR_TRAP = "Slower going than Toronto traffic.",

	TROPICALBOUILLABAISSE = "It's a bit fishy.",
	
	SEA_LAB = "Doesn't seem like the best place, but here I am.",
	WATERCHEST = "How's it stay afloat when it's full?",
	QUACKENDRILL = "Could loosen some good tar with that right there.",
	HARPOON = "You could throw an axe just as good, hey?",
	MUSSEL_BED = "Not doin' me any good unplanted.",
},
}
%%+%%strings/woodlegs.lua%%-%%return
{

ACTIONFAIL =
{
	REPAIRBOAT =
	{
		GENERIC = "It be jus'like new!",
	},
	SHAVE =
	{
		AWAKEBEEFALO = "Woodlegs ain't no fool!",
		GENERIC = "It don't be shave day.",
		NOBITS = "Thar don't be nuthin'ta shave.",
	},
	STORE =
	{
		GENERIC = "It b'full.",
		NOTALLOWED = "Thet don't b'longin'thar.",
	},
	RUMMAGE =
	{	
		GENERIC = "No need! Yarrr!",	
	},
	COOK =
	{
		GENERIC = "This be not th'time fer cookin'!",
		TOOFAR = "'Tis leagues away!",
	},
	GIVE =
	{
		DEAD = "It be dead.",
		SLEEPING = "It be sleepin'.",
		BUSY = "It be ignorin' ol'Woodlegs!",
	},
	WRITE =
	{
		GENERIC = "Alls I can write be an \"X\"!",
	},
	CHANGEIN =
	{
		GENERIC = "Woodlegs'll not be changin' t'day!",
		BURNING = "'Tis a roarin' fire!",
	},
	TEACH =
	{
		KNOWN = "Arrrr.",
		CANTLEARN = "Yarrrrrr!",
	},
},
ACTIONFAIL_GENERIC = "Me can'ts be doin' thet.",
ANNOUNCE_MAGIC_FAIL = "Thet's not fer this land!",
ANNOUNCE_ACCOMPLISHMENT = "Glory fer ol'Woodlegs!",
ANNOUNCE_ACCOMPLISHMENT_DONE = "If only me shipmates could see me now!",
ANNOUNCE_ADVENTUREFAIL = "Thet didn't go by plans. Might'n try again.",
ANNOUNCE_BEES = "Back ye tiny winged devils!",
ANNOUNCE_BOAT_DAMAGED = "She's takin' on water!",
ANNOUNCE_BOAT_SINKING = "She be goin' doooon!",
ANNOUNCE_BOAT_SINKING_IMMINENT = "Be this th'day th'sea claims me?",
ANNOUNCE_BOOMERANG = "Infernal weapon!",
ANNOUNCE_BURNT = "Ouch!",
ANNOUNCE_CANFIX = "\nI can fix this, methinks.",
ANNOUNCE_CHARLIE = "Whut'n th'blazes was thet!",
ANNOUNCE_CHARLIE_ATTACK = "I be bitten!",
ANNOUNCE_COLD = "ArrrrrrBrrrrrrr!",
ANNOUNCE_CRAB_ESCAPE = "Where'd th'lil devil go?",
ANNOUNCE_CBOAT_RAFTING_FAIL = "I be missin' th'needed parrrts.",
ANNOUNCE_DAMP = "Me britches be soaked!",
ANNOUNCE_DEERCLOPS = "Some big devil be upon me!",
ANNOUNCE_DUSK = "It be gettin' late. Dark be on th'horizon.",
ANNOUNCE_EAT =
{
	GENERIC = "Arrr thet be good.",
	INVALID = "Me won't be eatin' thet.",
	PAINFUL = "Me don't feel so good.",
	SPOILED = "Thet don't be agreein' wit' me guts.",
	STALE = "Thet were past th'freshness date.",
},
ANNOUNCE_ENTER_DARK = "It be dark!",
ANNOUNCE_ENTER_LIGHT = "I's can see again!",
ANNOUNCE_FREEDOM = "I be free!",
ANNOUNCE_HIGHRESEARCH = "Ol'Woodlegs noggin' be workin' today!",
ANNOUNCE_HOT = "Needs me a... ice chip er two...",
ANNOUNCE_HOUNDS = "Whut be thet noise signallin'?",
ANNOUNCE_HUNGRY = "I be hungry...",
ANNOUNCE_HUNT_BEAST_NEARBY = "Th'tracks be fresh. Th'devil be near hereabouts.",
ANNOUNCE_HUNT_LOST_TRAIL = "Th'trail be lost.",
ANNOUNCE_HUNT_LOST_TRAIL_SPRING = "Th'trail be washed out.",
ANNOUNCE_INSUFFICIENTFERTILIZER = "De ye need more poop, plant?",
ANNOUNCE_INV_FULL = "I can't be luggin' anymore things!",
ANNOUNCE_KNOCKEDOUT = "Arrrr me head...",
ANNOUNCE_LIGHTNING_DAMAGE_AVOIDED = "Ye didn't get ol'Woodlegs, sky bolts!",
ANNOUNCE_LOWRESEARCH = "This ol'dawg didn't be learnin' any new tricks thar.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Into th'murk and mist wit' me...",
ANNOUNCE_MAPWRAP_RETURN = "Ta th'edge o'th'world and back!",
ANNOUNCE_MAPWRAP_WARN = "A veil o'mist approaches...",
ANNOUNCE_MESSAGEBOTTLE =
{
	"Th' message be faded...",
},
ANNOUNCE_MORETREASURE = "Treasure! More'n more treasure!!!",
ANNOUNCE_MOSQUITOS = "Back ye blood-sucking devils!",
ANNOUNCE_NODANGERSIESTA = "This ain't be th'time fer nappin'.",
ANNOUNCE_NODANGERSLEEP = "This ain't be th'time fer snoozin'.",
ANNOUNCE_NODAYSLEEP = "It be too bright ta shut me eye.",
ANNOUNCE_NODAYSLEEP_CAVE = "Me ain't be tired.",
ANNOUNCE_NOHUNGERSIESTA = "I be too hungry fer a nap.",
ANNOUNCE_NOHUNGERSLEEP = "Me tummy be grumblin' too loud ta sleep.",
ANNOUNCE_NONIGHTSIESTA = "Night be fer slumber not fer siestas.",
ANNOUNCE_NONIGHTSIESTA_CAVE = "This ain't th'sorta place fer nappin'.",
ANNOUNCE_NOSLEEPONFIRE = "Me don't likes th'idea o'a burnin' bed.",
ANNOUNCE_NO_TRAP = "No trouble!",
ANNOUNCE_OTHER_WORLD_PLANT = "I don't be thinkin' this plant belongs here.",
ANNOUNCE_OTHER_WORLD_TREASURE = "Th'map don't be matchin' th'land.",
ANNOUNCE_PECKED = "Keep yer beak ta yerself!",
ANNOUNCE_QUAKE = "Th'world be belchin'.",
ANNOUNCE_RESEARCH = "Th'wheels be turnin'.",
ANNOUNCE_SHARX = "Aye, me ol'frenemies back ta take a bite outta me hide!",
ANNOUNCE_SHELTER = "Ye done right by me, tree.",
ANNOUNCE_SOAKED = "Me soaked ta th'bones!",
ANNOUNCE_THORNS = "Ye poky devils ye!",
ANNOUNCE_TOOL_SLIP = "Slipped right from me hands!",
ANNOUNCE_TORCH_OUT = "Me light went out!",
ANNOUNCE_TRAP_WENT_OFF = "Blast!",
ANNOUNCE_TRAWL_FULL = "Me net be full!",
ANNOUNCE_TREASURE = "Th'map marks th'spot o'treasure!",
ANNOUNCE_UNIMPLEMENTED = "It ain't be ready yet.",
ANNOUNCE_VOLCANO_ERUPT = "Th'fire devils be belchin'!",
ANNOUNCE_WAVE_BOOST = "We be a silver streak on th'blue now!",
ANNOUNCE_WET = "Me pirate blouse be takin' on water.",
ANNOUNCE_WETTER = "I likes me water ta stay 'neath me boat.",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "A big devil be near'abouts.",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Me lost th'devils trail...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "Like findin' a wet needle inna wet haystack.",
ANNOUNCE_WORMHOLE = "Me must be oot me mind.",
ANNOUNCE_TREASURE_DISCOVER = "Me pirate sense be tinglin'.",
BATTLECRY =
{
	GENERIC = "Ye messed wit' th'wrong pirate!",
	PIG = "Thar be ham on th'menu tonight!",
	PREY = "Meet yer death!",
	SPIDER = "I'm gunna peg leg ye ta death!",
	SPIDER_WARRIOR = "I'm gunna peg leg ye ta death!",
},
COMBAT_QUIT =
{
	GENERIC = "How'd ye like yer taste o'pirate?",
	PIG = "Ye live ta ham it up 'nother day.",
	PREY = "It be too fast fer me peg leg.",
	SPIDER = "Try me again ye leggy devil.",
	SPIDER_WARRIOR = "Try me again ye leggy devil.",
},
DESCRIBE =
{

	SEAWEED_STALK = "Fine bit o' tha sea veg.", --copied from the Wikia because I couldn't find it in the game files. -M

	--ABIGAIL = "A lady spectre!",
	ACCOMPLISHMENT_SHRINE = "Ye be knowin'th'glory of pirate Woodlegs, world!",
	ACORN = "It be rattlin' when ye shake it.",
	ACCORN_SAPLING = "Thar be a tree in its future.",
	ACORN_COOKED = "Not bad fer a landlubbin' nut.",
	ADVENTURE_PORTAL = "What new trap be this?",
	AERODYNAMICHAT = "Cuts me walkin' time in half!",
	AMULET = "A wee bit o'insurance round me neck.",
	ANCIENT_ALTAR = "A statue from ye old times.",
	ANCIENT_ALTAR_BROKEN = "It be broke.",
	ANCIENT_STATUE = "Me ain't be likin'th'vibes it be givin'.",
	ANIMAL_TRACK = "Th'beast left a trail leadin'ta its hide.",
	ANTIVENOM = "'Tis th'sea thet'll claim me, not some sickly biter.",
	ARMORDRAGONFLY = "She be hot ta th'touch o'me enemies!",
	ARMORGRASS = "Only a landlubber would think o'makin' armor from grass.",
	ARMORLIMESTONE = "This'd sink like a stone on th'sea.",
	ARMORMARBLE = "This'd sink like a stone in th'sea.",
	ARMOROBSIDIAN = "It be heavy 'n hot.",
	ARMORRUINS = "Feels like I be wearin' treasure.",
	ARMORSEASHELL = "Me mateys would laugh at me...",
	ARMORSLURPER = "How bad do I wanna protect myself?",
	ARMORSNURTLESHELL = "Don't seem right ta turtle in a fight.",
	ARMORWOOD = "At least wood floats.",
	ARMOR_LIFEJACKET = "Bah! For swabs only!",
	ARMOR_SANITY = "Feels good ta put it on.",
	ARMOR_SNAKESKIN = "Leathers ta slick th'rain away.",
	ARMOR_WINDBREAKER = "Ol'Woodlegs be an expert windbreaker!",
	BOAT_ARMOURED = "She's a tough 'un.",
	ASH =
	{
		GENERIC = "Th'fire claimed its price.",
		REMAINS_EYE_BONE = "Luckily I kept me own eye in me travels.",
		REMAINS_GLOMMERFLOWER = "Th'flower weren't made fer travellin'.",
		REMAINS_THINGIE = "I s'pose it weren't ash ta begin wit'.",
	},
	AXE = "I be axe'n th'questions 'round here!",
	BABYBEEFALO = "Yer cute fer dumb, hairy meat.",
	BABYOX = "'Tis lubbable how ye don't lub th'land.",
	BACKPACK = "I be packin' now.",
	BACONEGGS = "Th'most important meal o'th'day!",
	BALLPHIN = "These devil's really have a ball.",
	BAMBOO = "Ye'd be too big ta pick me teeth wit'. If me had teeth...",
	BAMBOOTREE =
	{
		BURNT = "Thet's th'end o'thet.",
		CHOPPED = "Thar be no bamboo fer th'moment.",
		GENERIC = "Ye sproutin' wood.",
	},
	BANDAGE = "Fer layabout swabs.",
	BASALT = "Strong it be.",
	BAT = "Back ye rat-faced, flyin' devil!",
	BATBAT = "I'd let this fly at me enemies.",
	BATWING = "Wit' a wee bit o'ranch dressin'...",
	BATWING_COOKED = "Tastes like cackler.",
	BEARDHAIR = "Chinny whiskers.",
	BEARGER = "Back ye badgerin' devil!",
	BEARGERVEST = "Toasty warm.",
	BEARGER_FUR = "Smells badgerin' me nose.",
	BEDROLL_FURRY = "Sweet, hairy dreams.",
	BEDROLL_STRAW = "Don't look fit fer a dry nights sleep.",
	BEE =
	{
		GENERIC = "A honey-makin' devil.",
		HELD = "Yield yer sweet treasure!",
	},
	BEEBOX =
	{
		BURNT = "I smell burnt honey...",
		FULLHONEY = "Thar be gold in this box!",
		GENERIC = "Thar be bees.",
		NOHONEY = "'Tis empty o'th'golden treasure.",
		SOMEHONEY = "'Tis a wee bit o'gold left.",
	},
	BEEFALO =
	{
		FOLLOWER = "Ye be knowin' who yer master be.",
		GENERIC = "Here's th'beef!",
		NAKED = "Ye should be ashamed o'yerself.",
		SLEEPING = "Its snorin' would wake th'dead.",
	},
	BEEFALOHAT = "Keeps me ears warm.",
	BEEFALOWOOL = "Carries a musk wit' it.",
	BEEHAT = "Woodlegs ain't no honey farmer!",
	BEEHIVE = "A den o'honey makers.",
	BEEMINE = "Step 'n get stung.",
	BEEMINE_MAXWELL = "Step 'n get stung.",
	BELL = "Thar be dingin' 'n 'lingin'.",
	BELL_BLUEPRINT = "Me can't make heads 'er tails o'this.",
	BERMUDATRIANGLE = "Whar they lead is anybody's guess.",
	BERRIES = "Stains me blouse.",
	BERRIES_COOKED = "Could use a crust o'bread ta spread o'er.",
	BERRYBUSH =
	{
		BARREN = "It needs a spot o'poop.",
		GENERIC = "Ripe fer th'pickin'.",
		PICKED = "Will thar be berries again?",
		WITHERED = "Th'bush can't beat th'heat.",
	},
	BIGFOOT = "Watch oot ye big trottin' devil ye!",
	BIOLUMINESCENCE = "They light up me life.",
	BIRCHNUTDRAKE = "Yer a mad nutter ain't ye?",
	BIRDCAGE =
	{
		GENERIC = "No parrot o'mine could bear a cagin'.",
		OCCUPIED = "How ye like yer cell, matey?",
		SLEEPING = "Awww, look at thet. Th'peeper's sleepin'.",
		HUNGRY = "Y'feelin' a wee bit peckish?",
		STARVING = "Woodlegs b'hungry too, y'know!",
		DEAD = "Yer soul's gon ta th'depths.",
		SKELETON = "Davey Bones.",
	},
	BIRDTRAP = "Once ye fly in, ye don't fly oot.",
	BIRD_EGG = "A cackler's egg.",
	BIRD_EGG_COOKED = "If only I had me a crust o'bread.",
	BISHOP = "Ye need a squirt o'oil mate, yer joints arrre squeakin'.",
	BISHOP_NIGHTMARE = "Back ye tin devil!",
	BLOWDART_FIRE = "I be breathin' fire.",
	BLOWDART_FLUP = "Flup you.",
	BLOWDART_PIPE = "A swab's weapon.",
	BLOWDART_POISON = "A swab's weapon.",
	BLOWDART_SLEEP = "Whisper 'em ta sleep.",
	BLUBBER = "Woodlegs'd never be caught blubberin'.",
	BLUBBERSUIT = "Ye has gotta be kiddin' me.",
	BLUEAMULET = "Chilly.",
	BLUEGEM = "It gleams true blue!",
	BLUEPRINT = "I ain't a learned man.",
	BLUE_CAP = "Me know enough not ta pop this'n me mouth wit'no questions asked.",
	BLUE_CAP_COOKED = "Smells eat-able...",
	BLUE_MUSHROOM =
	{
		GENERIC = "I got room fer mush in me belly.",
		INGROUND = "Ye only come oot at night?",
		PICKED = "Will th'shroom bloom again?",
	},
	BOARDS = "Good n' straight.",
	BOAT = "She's sturdy, if a lil smaller'n I be used ta.",
	BOATCANNON = "Ready ta fire six pounders!",
	BOATREPAIRKIT = "Never set sail wit'out'er.",
	BOAT_LANTERN = "Fer night sails.",
	BOAT_TORCH = "Fer a torch on me boat, not fer torchin' me boat.",
	BONESHARD = "Bits o'bone.",
	BONESTEW = "Good fer th'scurvy.",
	BOOMERANG = "I prefer somethin' thet don't come back at me head.",
	BOTTLELANTERN = "Thet's one use fer a bottle.",
	BUGNET = "Keeps th'buggies outta me no teeth.",
	BUNNYMAN = "Hop along ya floppy eared scallywag.",
	BUOY = "Buoy am me glad ta see ya.",
	BURIEDTREASURE = "Me favorite kind of buried thing!",
	BUSHHAT = "Fer blendin' in wit' th'landlubbers.",
	BUSH_VINE =
	{
		BURNT = "Thet's one way ta solve a knot.",
		CHOPPED = "Thet straightened ya out.",
		GENERIC = "Ya look like a tangled pile o'riggin'.",
	},
	BUTTER = "Look whut churned up!",
	BUTTERFLY =
	{
		GENERIC = "Pretty as a sunset o'er th'water.",
		HELD = "All that pretty in me pocket.",
	},
	BUTTERFLYMUFFIN = "Fibre gives ye wings.",
	BUTTERFLYWINGS = "I got me th'prettiest part.",
	BUZZARD = "Ye carrion-eatin' devil!",
	CACTUS =
	{
		GENERIC = "Ye have a sharp taste ye do.",
		PICKED = "Ye been freshly pricked. I mean picked.",
	},
	CACTUS_FLOWER = "Might put me eye out sniffin' ye.",
	CACTUS_MEAT = "Dry and prickly, but 'tis still meat.",
	CACTUS_MEAT_COOKED = "Not bad when it ain't stickin' ye.",
	CAMPFIRE =
	{
		EMBERS = "Th'fire needs ta be fed.",
		GENERIC = "Anyone know a good sea shanty 'side me?",
		HIGH = "She be a roarin'.",
		LOW = "Fire's goin'oot.",
		NORMAL = "Warm n' cozy.",
		OUT = "She be done.",
	},
	CANE = "I got me a built-in cane.",
	CAPTAINHAT = "Look smart mateys! Captain on deck!",
	BOAT_CARGO = "Fer th'hoarder at sea.",
	CARROT = "Fer me night vision in me eye.",
	CARROT_COOKED = "Nice 'n soft fer me no teeth.",
	CARROT_PLANTED = "Buried treasure of a kind.",
	CARROT_SEEDS = "Landlubbers.",
	CATCOON = "Ye look like ye got a taste fer garbage.",
	CATCOONDEN =
	{
		EMPTY = "Should I reach in an be sure?",
		GENERIC = "Whut lives in here. I'm stumped.",
	},
	CATCOONHAT = "Hope none o'me mates catch me in this gettup.",
	CAVE_BANANA = "I must be goin' banana's down here.",
	CAVE_BANANA_COOKED = "Not bad.",
	CAVE_BANANA_TREE = "Now ol'Woodlegs has seen it all.",
	CAVE_ENTRANCE =
	{
		GENERIC = "I ain't one fer climbin' in holes like a swab.",
		OPEN = "I bet thar ain't no sea down there.",
	},
	CAVE_EXIT = "Back ta open air.",
	CAVE_FERN = "How did ye grow doon here wit' no light?",
	CHARCOAL = "Burnt ta a brickette.",
	CHESSJUNK1 = "Somebody's a sore loser.",
	CHESSJUNK2 = "Somebody's a sore loser.",
	CHESSJUNK3 = "Somebody's a sore loser.",
	CHESTER = "Whut'n blazes arre ye?",
	CHESTER_EYEBONE =
	{
		GENERIC = "Ye got a nice eye.",
		WAITING = "'Tis gettin' some shut-eye.",
	},
	CHIMINEA = "Keeps th'wind off a good fire.",
	SAIL_CLOTH = "Fancy sail, thet.",
	COCONADE =
	{
		BURNING = "Surprise! 'Tis explodin' fruit!",
		GENERIC = "Packs a fruit punch!",
	},
	COCONUT = "Aye, me favorite tree fruit.",
	COCONUT_SAPLING = "Tis a fruit no more!",
	COCONUT_COOKED = "'Tis even better cooked o'er a fire.",
	COFFEE = "Arrr thet be th'real treasure.",
	COFFEEBEANS = "Just add water.",
	COFFEEBEANS_COOKED = "No hot water?",
	COFFEEBUSH =
	{
		BARREN = "It needs a spot o'poop.",
		GENERIC = "A crop after me bitter, black heart!",
		PICKED = "I hope they be comin' back.",
		WITHERED = "It needs a mug o'java ta perk up.",
	},
	COLDFIRE =
	{
		EMBERS = "Th'fire be goin'oot.",
		GENERIC = "Th'flames be lickin' th'dark.",
		HIGH = "I be glad this fire is in a pit and not on me ship.",
		LOW = "Th'fire be gettin' low.",
		NORMAL = "Good ta warm me'self by.",
		OUT = "Th'fire be out.",
	},
	COLDFIREPIT =
	{
		EMBERS = "Th'fire be goin'oot.",
		GENERIC = "Th'flames be lickin' th'dark.",
		HIGH = "I be glad this fire is in a pit and not on me ship.",
		LOW = "Th'fire be gettin' low.",
		NORMAL = "Good ta warm me'self by.",
		OUT = "Th'fire be out.",
	},

	COMPASS =
	{
		E = "Ta th'East!",
		GENERIC = "'Tis a compass.",
		N = "Ta th'North!",
		NE = "Ta th'Nor' East!",
		NW = "Ta th'Nor' West!",
		S = "Ta th'South!",
		SE = "Ta th'Sou' East!",
		SW = "Ta th'Sou' West!",
		W = "Ta th'West!",
	},
	COOKEDMANDRAKE = "Woodlegs did cook'im good.",
	COOKEDMEAT = "'Tis a fine meal.",
	COOKEDMONSTERMEAT = "Thet be bad eatin'.",
	COOKEDSMALLMEAT = "'Tis but a morsel.",
	COOKPOT =
	{
		BURNT = "Th'pot be burnt up.",
		COOKING_LONG = "'Tis a slow recipe.",
		COOKING_SHORT = "Ye'll be done soon 'nuff.",
		DONE = "'Tis ready for eatin'.",
		EMPTY = "Th'pot be empty.",
	},
	COONTAIL = "Thet coon dropped is' tail!",
	CORAL = "This'll tear up a boat right quick!",
	ROCK_CORAL = "Ye better steer clear, Woodlegs.",
	CORAL_BRAIN = "Ye can't think yer way outta me pocket.",
	CORAL_BRAIN_ROCK = "Th'brains o'th'ocean.",
	CORN = "Fresh corn! 'Tis me lucky day.",
	CORN_COOKED = "Roasted corn, me favorite.",
	CORN_SEEDS = "Ye'll be corn soon 'nuff",
	CRAB =
	{
		GENERIC = "Thar's a tasty meal!",
		HIDDEN = "Me knowin' thet crabbit be nearby.",
	},
	CRABHOLE = "Ye got a nice 'ome thar, crabbit.",
	CROW =
	{
		GENERIC = "Thet is one oily parrot!",
		HELD = "Ye prove hard ta clean, parrot.",
	},
	CUTGRASS = "Ye'll be helpin' Woodlegs later.",
	CUTLASS = "Aye, 'tis a true pirate's blade.",
	CUTLICHEN = "Sea-grass!",
	CUTREEDS = "But Woodlegs can't reed.",
	CUTSTONE = "Thet be well tooled stone.",
	DEADLYFEAST = "'Tis a dreadful meal.",
	SWORDFISH_DEAD = "Ye put up a good fight.",
	DECIDUOUSTREE =
	{
		BURNING = "Ye won't be standin' fer long.",
		BURNT = "Thet tree be worthless.",
		CHOPPED = "Ye'll make a fine vessel.",
		GENERIC = "Yer hair be pretty.",
		POISON = "Ye don't seem very nice.",
	},
	DEERCLOPS = "Arrrr ye serious?",
	DEERCLOPS_EYEBALL = "'Tis a giant eyeball.",
	DEPLETED_GRASS =
	{
		GENERIC = "Ye won't be much use ta Woodlegs.",
	},
	DEVTOOL = "Aye, 'tis a truly wondrous item.",
	DEVTOOL_NODEV = "Aye, 'tis a truly wondrous item.",
	DIRTPILE = "Thet be lookin like a pile o'treasures.",
	DIVININGROD =
	{
		COLD = "Thar is nary a whiff of treasure nearby.",
		GENERIC = "She'll help ol'Woodlegs sniff out treasures.",
		HOT = "Whar be th'treasures?!",
		WARM = "Take Woodlegs ta th'treasures!",
		WARMER = "Woodlegs be closing in!",
	},
	DIVININGRODBASE =
	{
		GENERIC = "Aye, 'tis a mystery.",
		READY = "'Tis a keyhole.",
		UNLOCKED = "Thar she goes!",
	},
	DIVININGRODSTART = "Thet rod be treasure.",
	DOUBLE_UMBRELLAHAT = "'Tis th'work of a madman.",
	DOYDOY = "'Tis a stupid lookin bird.",
	DOYDOYBABY = "'Tis a tiny dumb bird.",
	DOYDOYEGG = "'Tis a free meal!",
	DOYDOYEGG_CRACKED = "'Tis useless.",
	DOYDOYFEATHER = "'Tis a bird sail.",
	DOYDOYNEST = "'Tis a bird home.",
	DRAGONFLY = "Take Woodlegs ta yer tresures!",
	DRAGONFLYCHEST = "'Tis keepin me treasures safe n'sound.",
	DRAGONFRUIT = "'Tis full o'awe!",
	DRAGONFRUIT_COOKED = "Ye'll make a fine meal.",
	DRAGONFRUIT_SEEDS = "Ye need a home in th'ground.",
	DRAGONPIE = "'Tis treasure a pie.",
	DRAGON_SCALES = "'Tis a wondrous treasure.",
	DRAGOON = "Keep yer flames away from Woodlegs, landlubber!",
	DRAGOONDEN = "D'ya think 'tis full o'treasure?",
	DRAGOONEGG = "Me feels a storm comin'.",
	DRUMSTICK = "Meat treat for Woodlegs!",
	DRUMSTICK_COOKED = "Hot meat fer supper.",
	DUBLOON = "Me treasures!",
	DUG_BAMBOOTREE = "Thet will be needin' some ground ta be useful.",
	DUG_BERRYBUSH = "Thet will be needin' some ground ta be useful.",
	DUG_COFFEEBUSH = "Thet will be needin' some ground ta be useful.",
	DUG_ELEPHANTCACTUS = "Thet will be needin' some ground ta be useful.",
	DUG_GRASS = "Thet will be needin' some ground ta be useful.",
	DUG_MARSH_BUSH = "Thet will be needin' some ground ta be useful.",
	DUG_SAPLING = "Thet will be needin' some ground ta be useful.",
	DURIAN = "Thet does ney smell like food!",
	DURIAN_COOKED = "Cookin' it up don't make it better.",
	DURIAN_SEEDS = "Seeds, see?",
	EARMUFFSHAT = "Thet hat be makin' squeakin' sounds.",
	EARRING = "Ay! 'Tis me ol'earring!",
	EEL = "Ye scalawag!",
	EEL_COOKED = "Grilled urchin!",
	EGGPLANT = "She's a nice shade o'purple.",
	EGGPLANT_COOKED = "Look whut Woodlegs cooked.",
	EGGPLANT_SEEDS = "Seeds, see?",
	ELEPHANTCACTUS = "Woodlegs be wary.",
	ELEPHANTCACTUS_ACTIVE = "'Tis a dangerous plant!",
	ELEPHANTCACTUS_STUMP = "Th'fiendish plant is gatherin' its energy ta attack again!",		
	EVERGREEN =
	{
		BURNING = "Yer usefulness is running out.",
		BURNT = "Ye can't spread yer seeds now.",
		CHOPPED = "Yer earthly bonds run deep.",
		GENERIC = "'Tis some fine ship buildin' material.",
	},
	EVERGREEN_SPARSE =
	{
		BURNING = "Thet tree be burnin'.",
		BURNT = "Me won't be buildin' a ship from ye.",
		CHOPPED = "Yer lookin' a bit short.",
		GENERIC = "Thet tree be lookin' lumpy.",
	},
	EYEBRELLAHAT = "Ye'll keep an eye out fer ol'Woodlegs.",
	EYEPLANT = "Aye sea ya.",
	EYETURRET = "'Tis a magical cannon.",
	EYETURRET_ITEM = "'Twill need a base ta be useful.",
	FABRIC = "Fabric fer a sail!",
	FARMPLOT =
	{
		BURNT = "'Tis blackened.",
		GENERIC = "'Spose th'ground be somewhat useful.",
		GROWING = "Aye, 'tis breaking free o'its earthly bonds.",
		NEEDSFERTILIZER = "Th'ground be lookin' hungry.",
	},
	FEATHERFAN = "'Tis a sail for me face.",
	FEATHERHAT = "'Tis a hat o'birdy treasures.",
	SAIL_FEATHER = "'Tis light as a feather.",
	FEATHER_CROW = "Thet feather be mighty oily.",
	FEATHER_ROBIN = "Me feet are tickle proof.",
	FEATHER_ROBIN_WINTER = "Whar did all th'colors go?",
	FEM_PUPPET = "Ye seem ta be in quite a bind.",
	FERTILIZER = "Feed some plants wit' this.",
	FIREFLIES =
	{
		GENERIC = "Tiny constellations. No good for navigation.",
		HELD = "Wee stars in me pockets.",
	},
	FIREHOUND = "Stay beck from me legs!",
	FIREPIT =
	{
		EMBERS = "'Tis nearly burnt out.",
		GENERIC = "Need ta be careful ta not burn me legs.",
		HIGH = "'Tis a mercy thet me ship is ney nearby.",
		LOW = "'Tis goin' ta need some fuel soon.",
		NORMAL = "Better keep me distance.",
		OUT = "Th'fire has left.",
	},
	FIRESTAFF = "Woodlegs learned not ta play wit' fire.",
	FIRESUPPRESSOR =
	{
		LOWFUEL = "'Tis nearly empty.",
		OFF = "Hope no fires start 'round 'ere.",
		ON = "This area be protected from fires.",
	},
	FISH = "Fish! One o'me favorites.",
	FISHINGROD = "'Tis a useful tool.",
	FISHINHOLE = "A fishin'ole! Make a note on me map!",
	FISHSTICKS = "Woodlegs turned th'fish ta sticks.",
	FISHTACOS = "Th'crunchy shell be delicious.",
	FISH_COOKED = "Th'fish roasted up good.",
	SOLOFISH_DEAD = "'Tis a seadog n'more.",
	FISH_MED_COOKED = "'Tis a bit better.",
	FISH_MED = "Could use a bit'o'heat.",
	FISH_SMALL = "'Tis hardly a bite'o'fish.",
	FISH_SMALL_COOKED = "'Tis a bit better.",
	FLAMEGEYSER = "Woodlegs must be standin' on a sea o'fire.",
	FLINT = "Thet rock 'olds an edge.",
	FLOTSAM = "Th'remains o'a ship.",
	FLOWER = "'Tis a pretty flower.",
	FLOWERHAT = "'Tis a pretty flower 'at.",
	FLOWERSALAD = "'Tis a pretty flower meal.",
	FLOWER_CAVE = "Thet thar be a pretty flower.",
	FLOWER_CAVE_DOUBLE = "Thet thar be a pretty flower.",
	FLOWER_CAVE_TRIPLE = "Thet thar be a pretty flower.",
	FLOWER_EVIL = "'Tis an evil flower. Stay away!",
	FLUP = "Git back in th'ground!",
	FOLIAGE = "Landy stuff.",
	FOOTBALLHAT = "Keeps me melon safe.",
	FROG =
	{
		DEAD = "Ta th'locker wit' ya!",
		GENERIC = "Dun hop near Woodlegs!",
		SLEEPING = "Th'demon sleeps.",
	},
	FROGGLEBUNWICH = "Newt sandwich!",
	FROGLEGS = "Somewhere there be a frog walkin' around wit' two peglegs!",
	FROGLEGS_COOKED = "Rubber chicken, me likes it.",
	FROG_POISON = "Keep yer venom away from me, beastie!",
	GASHAT = "Smells o'freshness when me wears it.",
	GEMSOCKET =
	{
		GEMS = "'Tis full o'treasure.",
		VALID = "'Tis lackin' treasure.",
	},
	GHOST = "Ye 'ave ney business wit' me, spirit!",
	GLOMMER = "Ye'll be my first mate.",
	GLOMMERFLOWER =
	{
		DEAD = "'Tis drained.",
		GENERIC = "Somethin' magical be linked ta this.",
	},
	GLOMMERFUEL = "Leaves a mess on me deck, but Woodlegs loves 'em.",
	GLOMMERWINGS = "'E left me a lil gooey treasure.",
	GOATMILK = "Aye, fresh milk is rare at sea!",
	GOLDENAXE = "'Tis one way ta use treasure.",
	GOLDENMACHETE = "'Tis a mighty 'eavy blade.",
	GOLDENPICKAXE = "Thet pick is made o'mighty soft metal.",
	GOLDENPITCHFORK = "Th'ground be lucky ta touch me treasure.",
	GOLDENSHOVEL = "Perfect for buryin' me treasures.",
	GOLDNUGGET = "Havin' gold around soothes me soul.",
	GOOSE_FEATHER = "Thet bird must be 'uge!",
	GRASS =
	{
		BARREN = "Ye won't be much use ta Woodlegs.",
		BURNING = "Stay off me legs.",
		GENERIC = "Looks like some tufts o'grass.",
		PICKED = "'Urry up an' grow back.",
		WITHERED = "Ye' won't be much use ta Woodlegs like thet.",
	},
	GRASS_UMBRELLA = "A lil water ne'er hurt nobody.",
	GRASS_WATER = "Ye must 'ave a 'uge thirst!",
	GREENAMULET = "Wearin' this ol'amulet makes me feel so smart!",
	GREENGEM = "Emerald treasures.",
	GREENSTAFF = "I's ain't against some helpful magic.",
	GREEN_CAP = "Not me top choice o'grub.",
	GREEN_CAP_COOKED = "Th'witch doctor told Woodlegs it'd cure me crazies.",
	GREEN_MUSHROOM =
	{
		GENERIC = "Don't see many o'these at sea.",
		INGROUND = "'Tis below sea level.",
		PICKED = "'Tis out sailin'.",
	},
	GUACAMOLE = "Woodlegs'll find more chips fer dippin'!",
	GUNPOWDER = "Packs quite th'punch.",
	HAIL_ICE = "Me timbers is shiverin'!",
	HAMBAT = "Made wit' metal from th'finest meat mines.",
	HAMMER = "Ye could put quite a 'ole in a boat wit' tis.",
	HAWAIIANSHIRT = "'Tis light an stylish.",
	HEALINGSALVE = "Thet will soothe me wounds.",
	HEATROCK =
	{
		COLD = "Me chilly rock friend.",
		FROZEN = "Me rock friend be freezin'!",
		GENERIC = "Me rock friend.",
		HOT = "Me rock friend be gettin' toasty.",
		WARM = "Me cozy rock friend.",
	},
	HOME = "Captain's quarters.",
	HOMESIGN =
	{
		BURNT = "Used ta be markin' somethin'.",
		GENERIC = "Must be somethin' important 'round'ere.",
	},
	HONEY = "Sweet an' sticky.",
	HONEYCOMB = "Thar be larvae a-wrigglin' in ther.",
	HONEYHAM = "A feast fit fer piratin'!",
	HONEYNUGGETS = "Golden nuggets!",
	HORN = "Play th' song o'th'Beefalo.",
	HOTCHILI = "Makes m'grateful me tongue's wooden.",
	HOUND = "Hey thar, beastie.",
	HOUNDBONE = "Th'remains o'somethin'.",
	HOUNDMOUND = "Th'ounds be livin' thar.",
	HOUNDSTOOTH = "A few moor o'these and Woodlegs'll have a full set!",
	ICE = "Ney good fer sailin'.",
	ICEBOX = "Good fer keepin' me food.",
	ICECREAM = "Refreshin' on a hot day.",
	ICEHAT = "Keeps me 'ead cool.",
	ICEHOUND = "Packs quite a chilly bite!",
	ICEMAKER =
	{
		HIGH = "'Tis chuggin' along.",
		LOW = "'Tis sputterin'.",
		NORMAL = "'Tis runnin' fine.",
		OUT = "'Tis outta fuel.",
		VERYLOW = "'Tis chokin'!",
	},
	ICEPACK = "A mighty chill runs through this here pack.",
	ICESTAFF = "Thet staff be chillin'.",
	INSANITYROCK =
	{
		ACTIVE = "Thet rock be givin' Woodlegs a 'eadache.",
		INACTIVE = "Thet rock 'as a bad aura.",
	},
	IRONWIND = "Woodlegs prefers 'is sail.",
	JAMMYPRESERVES = "Prepared ta perfection.",
	JELLYFISH = "Shockin'ly squishy.",
	JELLYFISH_COOKED = "Shockin'ly tasty.",
	JELLYFISH_DEAD = "Shockin'ly dead.",
	JELLYFISH_PLANTED = "Shockin'ly dangerous.",
	JELLYJERKY = "Who be knowin' such a thing be possible?",
	JUNGLETREE =
	{
		BURNING = "She burns bright.",
		BURNT = "Be smellin' like a bag o'coal.",
		CHOPPED = "Nary a wiff o'treasure left.",
		GENERIC = "Thet tree be hidin' all kinds o'treasures.",
	},
	JUNGLETREESEED = "Ye might grow in ta a new leg fer me.",
	JUNGLETREESEED_SAPLING = "Meybe sev'ral legs!",
	KABOBS = "All food be piratin' food!",
	KILLERBEE =
	{
		GENERIC = "Ye don't be lookin' very friendly.",
		HELD = "Yer mine, now.",
	},
	KNIGHT = "Cavalry's'ere!",
	KNIGHTBOAT = "Th'navy is'ere!",
	KNIGHT_NIGHTMARE = "Yer not lookin' very good.",
	KOALEFANT_SUMMER = "Woodlegs be knowin' yer fur be mighty warm.",
	KOALEFANT_WINTER = "Woodlegs be knowin' yer fur be mighty warm. An 'tis so thick.",
	KRAMPUS = "What did ol'Woodlegs do?",
	KRAMPUS_SACK = "Woodlegs'll ne'er leave treasure behind again!",
	LANTERN = "'Tis a fine light.",
	LAVAPOOL = "Hope me legs don't catch.",
	LAVASPIT =
	{
		COOL = "Lookin' safer now.",
		HOT = "Lookin' pretty fiery.",
	},
	LEIF = "Glad me legs don't do that!",
	LEIF_SPARSE = "Glad me legs don't do that!",
	LICHEN = "Munch on thet!",
	LIGHTBULB = "Bright night light.",
	LIGHTNINGGOAT =
	{
		CHARGED = "Me better keep me distance.",
		GENERIC = "Them arr some mean lookin'orns.",
	},
	LIGHTNINGGOATHORN = "Looks good fer hittin' stuff.",
	LIGHTNING_ROD =
	{
		CHARGED = "Dodged thet!",
		GENERIC = "Protectin' me from th'eavens.",
	},
	LIMESTONENUGGET = "No good fer ship buildin'.",
	ROCK_LIMPET =
	{
		GENERIC = "Thet rock is covered in good eatin'.",
		PICKED = "'Tis just a rock now.",
	},
	LIMPETS = "Ye'll be in me tummy soon 'nuff.",
	LIMPETS_COOKED = "Yaaarm!",
	LITTLE_WALRUS = "He'll grow in ta a fine pirate.",
	LEIF_PALM = "Yarr, wit' those tree legs we're pract'ly kin!",
	LIVINGJUNGLETREE = "Thet tree be givin' Woodlegs th'evil eye.",
	LIVINGLOG = "It be cursed wood.",
	LIVINGTREE = "Don't be wakin'im up.",
	LOBSTER = "Don't be scurryin' from me!",
	LOBSTERHOLE = "'Tis th'shellbeast's cabin.",
	LOBSTER_DEAD = "Aye! Now Woodlegs can eat 'em.",
	LOBSTER_DEAD_COOKED = "Hot meat o'th'sea!",
	LOCKEDWES = "'E be locked up tight!",
	LOG =
	{
		BURNING = "Keep back!",
		GENERIC = "Thet's me legs' brother.",
	},
	BOAT_LOGRAFT = "She don't look too sturdy.",
	LUGGAGECHEST = "Thar might be gold inside.",
	LUREPLANT = "Plunderin' plant, best keep me wits about me.",
	LUREPLANTBULB = "Th'heart o'th'plunder plant.",
	MACHETE = "Ye be slicin'!",
	MAGIC_SEAL = "Whut th'devil is thet?",
	MAGMAROCK = "Could be something buried thar.",
	MAGMAROCK_GOLD = "Golden rocks!",
	MALE_PUPPET = "Ye be trapped!",
	MANDRAKE =
	{
		DEAD = "Twas a noisy little beast.",
		GENERIC = "A plant o'legend.",
		PICKED = "Quit yer squawkin'!",
	},
	MANDRAKESOUP = "'Tis a magic brew.",
	MANDRAKE_COOKED = "Woodlegs cooked it up!",
	MANGROVETREE = "Th'waters be shallow 'ere.",
	MANGROVETREE_BURNT = "'Tis cooked.",
	MANRABBIT_TAIL = "A bit o'luck!",
	MARBLE = "Strong and sandy smooth.",
	MARBLEPILLAR = "A marble peg leg. For a giant.",
	MARBLETREE = "Strange trees...",
	MARSH_BUSH =
	{
		BURNING = "Burnin'.",
		GENERIC = "She's got wee swords.",
		PICKED = "Ye poked me!",
	},
	MARSH_PLANT = "Green like me mermaid's eyes.",
	MARSH_PLANT_TROPICAL = "Green like me mermaid's eyes.",
	MARSH_TREE =
	{
		BURNING = "Burnin'.",
		BURNT = "Better 'em then me!",
		CHOPPED = "Thet be all thet's left.",
		GENERIC = "A tree wit' daggers.",
	},
	MAXWELL = "I'd like ta throw 'em overboard.",
	MAXWELLHEAD = "'E's got them villainous eyes.",
	MAXWELLLIGHT = "'Tis a dark flame.",
	MAXWELLLOCK = "Me don't think thet be unlockin' any treasure...",
	MAXWELLPHONOGRAPH = "A bewitched tune it plays.",
	MAXWELLTHRONE = "Not a seat me wants ta take.",
	MEAT = "Flesh o'th'beast.",
	MEATBALLS = "Me lunch!",
	MEATRACK =
	{
		BURNT = "Thet be a shame.",
		DONE = "She's ready!",
		DRYING = "Swing, swing, into me mouth!",
		DRYINGINRAIN = "Th'rain don't be helpin'.",
		GENERIC = "Hangin' spot fer me meats.",
	},
	MEAT_DRIED = "Jerky lasts me months at sea!",
	MERM = "Ye scalawag.",
	MERMFISHER = "At least'e be catchin'me fish!",
	MERMHEAD =
	{
		BURNT = "'Tis crispy.",
		GENERIC = "Beware...",
	},
	MERMHOUSE =
	{
		BURNT = "Good riddance.",
		GENERIC = "I don't trust 'em.",
	},
	MERMHOUSE_FISHER = "They smell worse than Woodlegs!",
	MESSAGEBOTTLE = "Oh ho! Be it a map?",
	MESSAGEBOTTLEEMPTY = "She's empty.",
	MINERHAT = "A light at sea keeps me calm.",
	MINOTAUR = "I've 'eard tales o'this devil...",
	MINOTAURCHEST = "How does Woodlegs get it back ta th'ship?!",
	MINOTAURHORN = "Aye, a treasure indeed!",
	MOLE =
	{
		ABOVEGROUND = "Whut's'e sniffin'?",
		HELD = "Quiet me pet.",
		UNDERGROUND = "'Tis swimmin' under th'dirt!",
	},
	MOLEHAT = "Gives eyes of a ghost in th'night!",
	MOLEHILL = "E's 'avin' a sleep in th'dirt.",
	MONKEY = "Me once saw a monkey wit' a hook claw.",
	MONKEYBARREL = "They be keepin' treasures in thar, no doubt.",
	MONSTERLASAGNA = "Not me favorite.",
	MONSTERMEAT = "Bit sour thet is.",
	MONSTERMEAT_DRIED = "Dried thet beast, I did.",
	MOOSE = "Keep'er off me boat!",
	MOOSEEGG = "Whut beast lurks wit'in!",
	MOSQUITO =
	{
		GENERIC = "'Is buzzin' makes me nervous.",
		HELD = "Better not bite me through me pocket!",
	},
	MOSQUITOSACK = "Looks like a jellyfish.",
	MOSQUITOSACK_YELLOW = "T'was a yellowbellied beast!",
	MOSQUITO_POISON = "Keep back ye maggot!",
	MOSSLING = "Ahoy big duck!",
	MOUND =
	{
		DUG = "I had ta check fer treasure!",
		GENERIC = "Not a bad place ta hide yer silver.",
	},
	MULTITOOL_AXE_PICKAXE = "'Tis multipurpose.",
	MUSHTREE_MEDIUM = "'Shroom tree, now me's seen it all.",
	MUSHTREE_SMALL = "It glows!",
	MUSHTREE_TALL = "Whut's thet 'shroom doin' way up thar?",
	MUSSEL = "Woodlegs loves a mussel!",
	MUSSEL_COOKED = "Yarrr, thet's good.",
	MUSSEL_FARM =
	{
		GENERIC = "Scoop 'em up!",
		STICKPLANTED = "Waitin' fer food don't be me strong suit...",
	},
	MUSSEL_STICK = "Fer lurin' mussels into me belly.",
	NEEDLESPEAR = "A dagger o'sorts.",
	NIGHTLIGHT = "Don't provide much comfort, do it?",
	NIGHTMAREFUEL = "I've seen thet dark magic asea...",
	NIGHTMARELIGHT = "Woodlegs don't trust this light.",
	NIGHTMARE_TIMEPIECE =
	{
		CALM = "All be calm.",
		DAWN = "It be slippin' away...",
		NOMAGIC = "Not a peep o'magic.",
		STEADY = "Th'nightmare's at its peak!",
		WANING = "Me pegs feel it be dyin'.",
		WARN = "Somethin' feels off...",
		WAXING = "It be buildin'!",
	},
	NIGHTSTICK = "'Tis a glowin' sword!",
	NIGHTSWORD = "Me cursed cutlass.",
	NITRE = "Cannon food thet be.",
	OBSIDIAN = "A powerful stone.",
	OBSIDIANAXE = "Keep thet away from me legs!",
	OBSIDIANCOCONADE = "Ka-boom!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "'Tis nearly burnt out.",
		GENERIC = "Need ta be careful ta not burn me legs.",
		HIGH = "'Tis a mercy thet me ship is ney nearby.",
		LOW = "'Tis goin' ta need some fuel soon.",
		NORMAL = "Hot by th'fire.",
		OUT = "Th'fire has left.",
	},
	OBSIDIANMACHETE = "Thet thing gets hot!",
	OBSIDIANSPEARGUN = "Shootin' fire!",
	OBSIDIAN_WORKBENCH = "Th'legends be true...",
	OCTOPUSCHEST = "Whut's in thar fer ol'Woodlegs?",
	OCTOPUSKING = "Ahoy, ye salty dog!",
	ONEMANBAND = "Whut's th'point o'this?",
	ORANGEAMULET = "Me magic chain.",
	ORANGEGEM = "Woodlegs loves all th'gems!",
	ORANGESTAFF = "Magic peg legs!",
	OX = "She could use a pirate hug.",
	PACKIM = "Thet's me mate!",
	PACKIM_FISHBONE = "Th'heart o'me bird. Inna manner o'speakin'.",
	PALMLEAF = "Whut can I make wit' this here?",
	PALMLEAF_HUT = "Needs a hammock!",
	PALMLEAF_UMBRELLA = "I's a pirate wit' an umbrella.",
	PALMTREE =
	{
		BURNING = "She burns bright.",
		BURNT = "Be smellin' like a bag o'coal.",
		CHOPPED = "Nary a wiff o'treasure left.",
		GENERIC = "A nice bit o'shade thar.",
	},
	PANDORASCHEST = "Yo-ho-ho! Treasure for me!",
	PANFLUTE = "Blankets ye inta a bewitched sleep.",
	PAPYRUS = "Aye! A fresh map!",
	PARROT = "Ye's a smart pretty bird.",
	PENGUIN = "A sure sign o'ice at sea.",
	PERD = "Whut a maniac!",
	PEROGIES = "Woodlegs could eat a chest full o'these!",
	PETALS = "Them flowers ain't comin' back ta life.",
	PETALS_EVIL = "Bewitched flowers.",
	PICKAXE = "Let's get them treasures!",
	PIGGUARD = "Don't ye be snortin' at me!",
	PIGGYBACK = "From th'flesh o'th'boar.",
	PIGHEAD =
	{
		BURNT = "Crispy.",
		GENERIC = "Sometimes them eyes be glowin'...",
	},
	PIGHOUSE =
	{
		BURNT = "Fire's done 'is work here.",
		FULL = "'Ere piggy, piggy.",
		GENERIC = "Looks like an outhouse, don't it?",
		LIGHTSOUT = "Gettin' some shut eye, 'e is.",
	},
	PIGKING = "'E's rich, this one.",
	PIGMAN =
	{
		DEAD = "Goodnight pig.",
		FOLLOWER = "Come along piggy!",
		GENERIC = "Ye think 'e speaks Latin?",
		GUARD = "Don't ye be snortin' at me!",
		WEREPIG = "Whut happened ta ye?!",
	},
	PIGSKIN = "'E lost 'is bottom.",
	PIGTORCH = "Bet thet be worth a pretty penny...",
	PIKE_SKULL = "Keep walkin'.",
	PINECONE = "Th'seed o'th'tree.",
	PINECONE_SAPLING = "Grow inta ship wood me sweet.",
	PIRATEHAT = "Yo-ho-ho!",
	PIRATEPACK = "Me thought me lost thet!",
	PIRATIHATITATOR =
	{
		BURNT = "What a shame.",
		GENERIC = "She looks great in thet hat.",
	},
	PITCHFORK = "Can I be diggin' treasures wit' this?",
	PLANTMEAT = "A suspect meat.",
	PLANTMEAT_COOKED = "Cooked it up, I did.",
	PLANT_NORMAL =
	{
		GENERIC = "Can Woodlegs eat it?",
		GROWING = "Waitin' and waitin'.",
		READY = "Arr, she's ready!",
		WITHERED = "Too hot fer her wee roots.",
	},
	POISONHOLE = "Th'worst kind o'hole.",
	POMEGRANATE = "Me mates tell me this be good fer me heart.",
	POMEGRANATE_COOKED = "Seedy.",
	POMEGRANATE_SEEDS = "Seeds thet grow more seeds.",
	POND = "Ye couldn't fit a real ship in this.",
	POND_ALGAE = "Ye couldn't fit a real ship in this.",
	POOP = "What scallywag left their poop layin' about!",
	PORTAL_SHIPWRECKED = "Looks a delightful lil ride!",
	POTTEDFERN = "Now whut use 'ave I for a house plant?",
	POWCAKE = "This really be food?",
	PRIMEAPE = "Like lookin' in a cracked, greasy mirror.",
	PRIMEAPEBARREL = "They ain't much fer housekeepin'.",
	PUMPKIN = "Would make a good cannon ball.",
	PUMPKINCOOKIE = "I have a sweet no tooth.",
	PUMPKIN_COOKED = "Me ships cook used ta add a dash o'cinnamon.",
	PUMPKIN_LANTERN = "A wee bit heavy fer a lantern.",
	PUMPKIN_SEEDS = "I ain't th'farmin' type, but I do loves me some pumpkin...",
	PURPLEAMULET = "Looks good on Woodlegs!",
	PURPLEGEM = "Shiny and valuable!",
	RABBIT =
	{
		GENERIC = "Twitchy wee thing.",
		HELD = "Stay in me pockets now.",
	},
	RABBITHOLE =
	{
		GENERIC = "Think they got treasures down thar?",
		SPRING = "Them lil' rabbits ain't comin' out.",
	},
	RABBITHOUSE =
	{
		BURNT = "Burnt to th'earth!",
		GENERIC = "Thet be one big carrot.",
	},
	BOAT_RAFT = "This vessel be an embarrassment!",
	RAINCOAT = "Keeps me blouse dry.",
	RAINHAT = "Keeps yer head dry.",
	RAINOMETER =
	{
		BURNT = "Ye couldn't predict fire could ye!",
		GENERIC = "Sailor's arre walkin' rain-thingies!",
	},
	RATATOUILLE = "Scurvy-fightin' super food!",
	RAWLING = "Reminds me o'me old parrot.",
	RAZOR = "Shavin's fer princes and lawyers.",
	BARREL_GUNPOWDER = "Skull 'n crossbones only means one thing whur I come from.",
	REDGEM = "It gleams like th'sun!",
	RED_CAP = "Hope th'color ain't a warnin'...",
	RED_CAP_COOKED = "Me favorite color o'shroom.",
	RED_MUSHROOM =
	{
		GENERIC = "It be an alarming colored 'shroom.",
		INGROUND = "It don't wanna 'shroom up yet.",
		PICKED = "It's outta 'shrooms.",
	},
	REEDS =
	{
		BURNING = "They burn up fast.",
		GENERIC = "Betcha I can whistle a tune wit' these!",
		PICKED = "It can't reed.",
	},
	REFLECTIVEVEST = "Right back at ye, sunny boy.",
	RELIC =
	{
		BROKEN = "It ain't worth even half a dubloon now.",
		GENERIC = "Me wonders if me could sell it on th'black market?",
	},
	RESEARCHLAB =
	{
		BURNT = "I guess science ain't so hot after all.",
		GENERIC = "I heard 'bout this science stuff. 'Tis up'n comin'.",
	},
	RESEARCHLAB2 =
	{
		BURNT = "It won't be doin' whatever it done before.",
		GENERIC = "It does whut?",
	},
	RESEARCHLAB3 =
	{
		BURNT = "Th'dark arts didn't save ye.",
		GENERIC = "Witchcraft wit' this'un, no two ways about'er.",
	},
	RESEARCHLAB4 =
	{
		BURNT = "Good! I didn't like saying yer name anyhow.",
		GENERIC = "Me ain't had enuff learnin' ta say a word like thet.",
	},
	RESURRECTIONSTATUE =
	{
		BURNT = "Won't be resurrectin' nuthin' anymores.",
		GENERIC = "Don't capture me likeness at all!",
	},
	RESURRECTIONSTONE = "Me nose smells witchcraft...",
	ROBIN =
	{
		GENERIC = "Ye don't talk do ye?",
		HELD = "Woodlegs'll takes good care o'ye.",
	},
	ROBIN_WINTER =
	{
		GENERIC = "She's a beaut.",
		HELD = "She's a cold birdy.",
	},
	ROBOT_PUPPET = "Locked up!",
	ROCK = "Would wreck a hull.",
	ROCKS = "They sink.",
	ROCKY = "Back ye clawed devil!",
	ROCK_CHARCOAL = "Could start quite a barby-q wit' this.",
	ROCK_ICE =
	{
		GENERIC = "Better here than 'neath me boat tearin' at her hull.",
		MELTED = "Needs ta chill out.",
	},
	ROCK_ICE_MELTED = "Need a cold snap so's it can freeze again.",
	ROCK_LIGHT =
	{
		GENERIC = "A puddle o'fire.",
		LOW = "It be goin' out.",
		NORMAL = "Not bad fer settin' by.",
		OUT = "She's out.",
	},
	ROCK_OBSIDIAN = "Fire rock from fire mountain.",
	ROOK = "She's full steam ahead!",
	ROOK_NIGHTMARE = "Thet beast's been cursed.",
	ROPE = "Fer lashin' stuff ta stuff.",
	ROTTENEGG = "Smells like crew quarters after chili night.",
	BOAT_ROW = "I ain't rowed since I was a young swab.",
	RUBBLE = "Just a pile o'rubble.",
	RUINSHAT = "A crown o'jewels.",
	RUINS_BAT = "Whut a beaut!",
	RUINS_RUBBLE = "Woodlegs can build this back up.",
	SAIL_PALMLEAF = "Fer catchin' th'blow.",
	SAIL_STICK = "Keeps th'wind at me back.",
	SAND = "Handful o'land.",
	SANDBAG = "Fer keepin' th'flood waters at bay.",
	SANDBAGSMALL = "Fer keepin' th'flood waters at bay.",
	SANDBAG_ITEM = "Fer keepin' th'flood waters at bay.",
	SANDDUNE = "Nothin' like th'feel o'sand 'neath me pegs.",
	SANDCASTLE =
	{
		GENERIC = "I be a sandcastle master builder!",
		SAND = "No pirate can make a better sandcastle than ol'Woodlegs!",
	},
	SANITYROCK =
	{
		ACTIVE = "Thar be a crazy lookin' rock.",
		INACTIVE = "Thet crazy rock be missin' pieces.",
	},

	SAPLING =
	{
		BURNING = "Th'wood burns.",
		GENERIC = "Wee wood.",
		PICKED = "Thar be no more pickin' o'this one fer a spell.",
		WITHERED = "Needs a splash o'rum.",
	},
	SEAGULL = "A rat wit'win's.",
	SEAGULL_WATER = "Ahoy, seafarer!",
	SEASACK = "Me travels moist'ly hereout.",
	SEASHELL = "Me hears th'blue.",
	SEASHELL_BEACHED = "Sea trinket.",
	SEATRAP = "Tis' a pirate's lunch fer me!",
	SEAWEED = "Get's tangled in my rigging.",
	SEAWEED_COOKED = "Cooking it don't make it food.",
	SEAWEED_DRIED = "This s'pose ta pass fer jerky?",
	SEAWEED_PLANTED = "Gets tangled in me rigging.",
	SEEDS = "Woodlegs ain't no landlubbin' farmer!",
	SEEDS_COOKED = "Plant 'em in me belly.",
	SEWING_KIT = "Get me a swab ta do me sewin'.",
	SHARKITTEN = "Don't ye look at me wit' those adorable eyes...",
	SHARKITTENSPAWNER =
	{
		GENERIC = "Th'kitties sharpen their claws here.",
		INACTIVE = "Here kitty-kitty?",
	},
	SHARK_FIN = "Ye left yer rudder, devil!",
	SHARK_GILLS = "Ye won't be breathin' through these namore!",
	SHARK_TEETHHAT = "Madness ta put th'devil's knives on me head.",
	SHARX = "Sea devils!",
	SHOVEL = "Ima' gold digger!",
	SIESTAHUT =
	{
		BURNT = "No good fer nappin' now.",
		GENERIC = "I hate sleeping on land.",
	},
	SILK = "Used in th'finest pirate shirts!",
	SKELETON = "Yer luck ran out, matey.",
	SKELETON_PLAYER = "So familiar...",
	SKULLCHEST = "Whut treasures it musta devoured.",
	SLOTMACHINE = "I've always thoughta myself a bettin' man.",
	SLURPER = "Yer an ugly, scallywag.",
	SLURPERPELT = "Tha smell!",
	SLURPER_PELT = "Tha smell!",
	SLURTLE = "Look at ye slurtle'n around.",
	SLURTLEHAT = "On me head?",
	SLURTLEHOLE = "They slurtle their way in there, d'they?",
	SLURTLESLIME = "Looks 'ike somethin' I coughed up.",
	SLURTLE_SHELLPIECES = "I ain't one fer puzzlers.",
	SMALLBIRD =
	{
		GENERIC = "Whoot sorta cackler arrr ye?",
		HUNGRY = "Yer feather-belly grumblin'?",
		STARVING = "Yer fit ta waste away.",
	},
	SMALLMEAT = "Tis' small, but tis' meat.",
	SMALLMEAT_DRIED = "Jolly jerky!",
	SNAKE = "Ya split-tongued devil!",
	SNAKEDEN =
	{
		BURNT = "Thet's one way ta solve a knot.",
		CHOPPED = "Thet straightened ya out.",
		GENERIC = "Ya look like a tangled pile o'riggin'.",
	},
	SNAKEOIL = "Me knows a good deal when me sees it.",
	SNAKESKIN = "Me leathers do need replacin'.",
	SNAKESKINHAT = "On me head? Wear thet?",
	SNAKE_POISON = "Stay away ye forked tongued devil!",
	SNURTLE = "I'd shell ye if I had me boat handy.",
	SOLOFISH = "Ye salty dog!",
	SPEAR = "I could jabber on wit' this all day.",
	SPEARGUN = "A fine gutshooter ye'll make.",
	SPEARGUN_POISON = "Whut swab would use such a thing?",
	SPEAR_OBSIDIAN = "Poke ye wit' fire!",
	SPEAR_POISON = "A coward's weapon.",
	SPIDER =
	{
		DEAD = "Good!",
		GENERIC = "Ye must really love th'land wit' all them legs.",
		SLEEPING = "Dreaming o'my boot heel.",
	},
	SPIDERDEN = "I prefur' a den o'thieves.",
	SPIDEREGGSACK = "Expectin' ol'Woodlegs play wetnurse ta creepy crawlies?",
	SPIDERGLAND = "I ate worse.",
	SPIDERHAT = "Wear a spider on me head? Bah!",
	SPIDERHOLE = "Whut lives innna hole ain't worth me time.",
	SPIDERQUEEN = "Woodlegs yields ta no queen, spider or udderwise!",
	SPIDER_DROPPER = "Yellow sneaks!",
	SPIDER_HIDER = "Infernal spiders!",
	SPIDER_SPITTER = "I reckon I can spit further than ye.",
	SPIDER_WARRIOR =
	{
		DEAD = "Warrior my eye!",
		GENERIC = "Eight legs ta lub th'land wit'.",
		SLEEPING = "Ye dreaming o'flies?",
	},
	SPOILED_FISH = "Smells like th'devil hisself made wind.",
	SPOILED_FOOD = "Bin eaten worse.",
	STAFFLIGHT = "Th'stars aren't under th'domain o'man.",
	STAFF_TORNADO = "Whut unholy nonsense be 'tis?",
	STALAGMITE = "Me likes rocks whar I can see'em.",
	STALAGMITE_FULL = "Me likes rocks whar I can see'em.",
	STALAGMITE_LOW = "Me likes rocks whar I can see'em.",
	STALAGMITE_MED = "Me likes rocks whar I can see'em.",
	STALAGMITE_TALL = "Me likes rocks whar I can see'em.",
	STALAGMITE_TALL_FULL = "Me likes rocks whar I can see'em.",
	STALAGMITE_TALL_LOW = "Me likes rocks whar I can see'em.",
	STALAGMITE_TALL_MED = "Me likes rocks whar I can see'em.",
	STATUEGLOMMER =
	{
		EMPTY = "It broke up.",
		GENERIC = "Ugly statue.",
	},
	STATUEHARP = "Yer missing ye head!",
	STATUEMAXWELL = "I'd know thet scallywag's face anywheres!",
	STINGER = "Bee dropped its bottom.",
	STRAWHAT = "Not fit fer a captain. But makes fer a cool head.",
	STUFFEDEGGPLANT = "Stuffed wit' whut?",
	STUNGRAY = "Back ye foul stink-shooters!",
	SUNKBOAT = "Some mateys luck ran out...",
	SUNKEN_BOAT =
	{
		ABANDONED = "Mate o'reboard.",
		GENERIC = "I'd throw ye a line if me had one.",
	},
	SUNKEN_BOAT_BURNT = "Sunk and burnt. Thet's a whole lotta bad luck.",
	SUNKEN_BOAT_TRINKET_1 = "A captain worth his salt don't need this.",
	SUNKEN_BOAT_TRINKET_2 = "Fer a pirate's tyke.",
	SUNKEN_BOAT_TRINKET_3 = "Candles and water don't mix.",
	SUNKEN_BOAT_TRINKET_4 = "Bah! Hokum!",
	SUNKEN_BOAT_TRINKET_5 = "I already got one good boot.",
	SUPERTELESCOPE = "Eye see clear ta th'horizon!",
	BANANAPOP = "I heard ther be gold in th'banana stand.",
	BISQUE = "A delightful snack t'pour down m'gullet!",
	CEVICHE = "Whut tasty creatures dredged up frum th'sea!",
	SEAFOODGUMBO = "Down th'hatch!",
	SURFNTURF = "'Could use wit less turf.",
	SHARKFINSOUP = "Now Woodlegs gits ta bite ya back!",
	LOBSTERDINNER = "I loves ta eat'em!",
	LOBSTERBISQUE = "Fends off th'scurvy!",
	JELLYOPOP = "Woodlegs' specialty!",
	SWEATERVEST = "Fit fer a swab.",
	SWEET_POTATO = "Me likes me potateys sweet!",
	SWEET_POTATO_COOKED = "Hot grub!",
	SWEET_POTATO_PLANTED = "A different kind o'buried treasure.",
	SWEET_POTATO_SEEDS = "Seeds be fer planting, an Woodlegs ain't no farmer.",
	SWORDFISH = "Arrr ye'd like ta bury thet nose in ol'Woodlegs eh?",
	TAFFY = "Sticks ta me no teeth.",
	TALLBIRD = "Ye'd be a might less tall if I had me sabre wit' me!",
	TALLBIRDEGG = "When will th'cackler be hatchin'.",
	TALLBIRDEGG_COOKED = "Me likes me tallbirdy yolk runny!",
	TALLBIRDEGG_CRACKED =
	{
		COLD = "Needs a warm cacklers bum settin' on it.",
		GENERIC = "Do it be hatchin'?",
		HOT = "Don't be gettin' hard boiled on me.",
		LONG = "I don't be seein' this eggy hatchin' any time soon.",
		SHORT = "Th'cacklers comin' anytime!",
	},
	TALLBIRDNEST =
	{
		GENERIC = "Thet thar's a big egg!",
		PICKED = "Th'egg basket's empty.",
	},
	TEENBIRD =
	{
		GENERIC = "Ye ain't too tall arrr ye?",
		HUNGRY = "I best find some food fer yer belly.",
		STARVING = "Don't ye be thinkin' on eatin' ol'Woodlegs!",
	},
	TELEBASE =
	{
		GEMS = "Needs more o'them purpley gemmies.",
		VALID = "She be in focus now!",
	},
	TELEPORTATO_BASE =
	{
		ACTIVE = "I don't be knowin' where it leads, but it be ready ta take me.",
		GENERIC = "Could take ol'Woodlegs ta seas-end!",
		LOCKED = "Thar be a piece a'missin'.",
		PARTIAL = "It be nigh ready.",
	},
	TELEPORTATO_BOX = "A simple pirate like me ain't be knowin' whut this be fer.",
	TELEPORTATO_CRANK = "Ta my eye it be a crank fer crankin'.",
	TELEPORTATO_POTATO = "Strange armor be this.",
	TELEPORTATO_RING = "A ring wit' no jewels, bah!",
	TELEPORTATO_SW_BASE = "What a curious piece.",
	TELEPORTATO_SW_BOX = "Thar be secrets hidden in this here box.",
	TELEPORTATO_SW_CRANK = "Aye, Woodlegs'll give it a crank.",
	TELEPORTATO_SW_POTATO = "Whut a potatey needs a helmet fer me never be knowin'.",
	TELEPORTATO_SW_RING = "I'd give it a bite, but I know it don't be gold.",
	TELESCOPE = "Aye eye!",
	TELESTAFF = "I prefer a fast ship and th'wind at me back.",
	TENT =
	{
		BURNT = "Thet's whut ye get fer trustin' yer snoozes ta land.",
		GENERIC = "I prefers a water bed.",
	},
	TENTACLE = "Like in me dreams!",
	TENTACLESPIKE = "Aha! Now th'creepin' dread be in me own hands!",
	TENTACLESPOTS = "Me memory be spotty. Whut's this fer again?",
	TENTACLE_GARDEN = "Thar be slime!",
	TENTACLE_PILLAR = "Would make fer a slippery mast.",
	TENTACLE_PILLAR_ARM = "Thar be slime!",
	THATCHPACK = "Thatch th'ticket!",
	THULECITE = "Wonder whut this be worth?",
	THULECITE_PIECES = "Tastes a might goldy.",
	TIDALPOOL = "I sees me future...",
	TIDAL_PLANT = "Leafy greens from high tide.",
	TIGERSHARK = "Come at me ye striped devil!",
	TOPHAT = "Even a dirty ol'pirate could use a dapper day.",
	TORCH = "Now I can spot treasure in th'dark!",
	TOUCAN = "Yer name wouldn't be Sam, would it?",
	TRAILMIX = "I prefer sea snacks.",
	TRANSISTOR = "Whut be this?",
	TRAP = "I prefer ta meet me foes head-on.",
	TRAP_TEETH = "I may be toothless, but this trap ain't.",
	TRAP_TEETH_MAXWELL = "I ain't fallin' fer thet.",
	TRAWLNET = "Fer trawl'n around.",
	TRAWLNETDROPPED =
	{
		GENERIC = "Yield yer haul!",
		SOON = "Yer haul be mine soon.",
		SOONISH = "Give up yer haul.",
	},
	TREASURECHEST =
	{
		BURNT = "Naaaaaaaaaaaaaay!",
		GENERIC = "Aye, th' meaning o'life inna box.",
	},
	TREASURECHEST_TRAP = "Treach-sure!",
	TREECLUMP = "Get oot o'me way!",
	TRIDENT = "Me thought this was just from th'stories!",
	TRINKET_IA_1 = "Lost marbles.",
	TRINKET_IA_10 = "My prayers arrr answered!",
	TRINKET_IA_11 = "Ye quick-tongued box o'bolts!",
	TRINKET_IA_12 = "Whut'n'th'whut?",
	TRINKET_IA_13 = "Sodey pop!",
	TRINKET_IA_14 = "Me don't tangle wit' witchcraft.",
	TRINKET_IA_15 = "Can't play a note.",
	TRINKET_IA_16 = "A strange plate b'this.",
	TRINKET_IA_17 = "Boot-y!",
	TRINKET_IA_18 = "Me don't have a taste fer delicate antiquities.",
	TRINKET_IA_19 = "Fer brain storms.",
	TRINKET_IA_2 = "If only it were real.",
	TRINKET_IA_23 = "Even if it weren't broken, me wouldn't be knowing whut ta do wit' it.",
	TRINKET_IA_3 = "Gord knows his way around a knot.",
	TRINKET_IA_4 = "Red hatted devil!",
	TRINKET_IA_5 = "This is no kind o'ship me knows.",
	TRINKET_IA_6 = "Whut swab tied this knot?",
	TRINKET_IA_7 = "Aye, th'newest gaming craze!",
	TRINKET_IA_8 = "Bung be hard.",
	TRINKET_IA_9 = "Me ain't picky 'bout matcheys.",
	TROPICALFAN = "Beat th'heat.",
	FISH_TROPICAL = "Aye, me favorite food!",
	TRUNKVEST_SUMMER = "Clothes from a nose!",
	TRUNKVEST_WINTER = "Clothes from a nose!",
	TRUNK_COOKED = "Bin eatin' nastier noses than this.",
	TRUNK_SUMMER = "There be jewels and riches in this trunk?",
	TRUNK_WINTER = "There be jewels and riches in this trunk?",
	TUMBLEWEED = "I like me weeds settin' still.",
	TUNACAN = "Fish inna can!",
	TURBINE_BLADES = "Methinks thar's a use fer this.",
	TURF_SANDY = "Me ain't no ground lubber.",
	TURF_ASH = "Me ain't no ground lubber.",
	TURF_BADLANDS = "Me ain't no ground lubber.",
	TURF_BEACH = "Me ain't no ground lubber.",
	TURF_CARPETFLOOR = "Me ain't no ground lubber.",
	TURF_CAVE = "Me ain't no ground lubber.",
	TURF_CHECKERFLOOR = "Me ain't no ground lubber.",
	TURF_DECIDUOUS = "Me ain't no ground lubber.",
	TURF_DESERTDIRT = "Me ain't no ground lubber.",
	TURF_DIRT = "Me ain't no ground lubber.",
	TURF_FOREST = "Me ain't no ground lubber.",
	TURF_FUNGUS = "Me ain't no ground lubber.",
	TURF_FUNGUS_GREEN = "Me ain't no ground lubber.",
	TURF_GRASS = "Me ain't no ground lubber.",
	TURF_JUNGLE = "Me ain't no ground lubber.",
	TURF_MARSH = "Me ain't no ground lubber.",
	TURF_MEADOW = "Me ain't no ground lubber.",
	TURF_MUD = "Me ain't no ground lubber.",
	TURF_ROAD = "Me ain't no ground lubber.",
	TURF_ROCKY = "Me ain't no ground lubber.",
	TURF_SAVANNA = "Me ain't no ground lubber.",
	TURF_SINKHOLE = "Me ain't no ground lubber.",
	TURF_SNAKESKIN = "Me ain't no ground lubber.",
	TURF_SWAMP = "Me ain't no ground lubber.",
	TURF_UNDERROCK = "Me ain't no ground lubber.",
	TURF_VOLCANO = "Th'devil's ground.",
	TURF_WOODFLOOR = "Creaks under me pegleg.",
	TURKEYDINNER = "This cackler is good eatin'!",
	TWIGS = "Too thin fer replacin' me peg leg.",
	TWISTER = "Thet wind is whippin' like th'devil's sneeze!",
	TWISTER_SEAL = "Don't ye be lookin' at me wit' them sad eyes.",
	UMBRELLA = "I do like ta keep me powder dry.",
	UNAGI = "Eat a eel? It be breakfast already?",
	UNIMPLEMENTED = "It don't be ready.",
	VENOMGLAND = "Aye, 'tis th'source o'th'venom.",
	VINE = "Them's be th'stranglin' kind.",
	VOLCANO = "Me ol'prison.",
	VOLCANOSTAFF = "Ye'll do me biddin' now, 'cano!",
	VOLCANO_ALTAR =
	{
		GENERIC = "'Tis be whar ye bribe th'cano.",
		OPEN = "Ready fer bribin'.",
	},
	VOLCANO_ALTAR_BROKEN = "There'll be no pleasin' th'cano now!",
	VOLCANO_EXIT = "'Tis nigh time me be leavin' this dread place.",
	VOLCANO_SHRUB = "Ye look burnt out.",
	WAFFLES = "Just like me mum used ta open from th'package.",
	WALLYINTRO_DEBRIS = "Th'sea swallowed me boat but spit up ol'Woodlegs.",
	WALL_HAY =
	{
		BURNT = "Th'hay wall burnt up, go figure.",
		GENERIC = "Th'only walls I tolerate arr in me cabin.",
	},
	WALL_HAY_ITEM = "Hope there arrr'nt any wild horses about.",
	WALL_LIMESTONE = "Bah! Walls!",
	WALL_LIMESTONE_ITEM = "Walls make me feel cagey.",
	WALL_RUINS = "These walls be even older than me!",
	WALL_RUINS_ITEM = "Ancient walls ta protect precious treasure.",
	WALL_STONE = "It would sink at sea.",
	WALL_STONE_ITEM = "Stone wall fer all yer land concerns.",
	WALL_WOOD =
	{
		BURNT = "Won't be wallin' anymore.",
		GENERIC = "Keeps yer land safe if thet's yer fancy.",
	},
	WALL_WOOD_ITEM = "Walls arrr fer land and land be fer lubbers.",
	WALRUS = "Whut's yer story, mate?",
	WALRUSHAT = "Not me style.",
	WALRUS_CAMP =
	{
		EMPTY = "Th'landlubbers ain't here.",
		GENERIC = "Campin's fer landlubbers.",
	},
	WALRUS_TUSK = "Ye'd make a fancy new peg leg.",
	WARG = "Yer a big dawg on th'land, but ye'd be fish food at sea.",
	WASPHIVE = "Leavin' it alone be th'best course.",
	WATERMELON = "Aye, th'fruit after Woodleg's watery heart.",
	WATERMELONHAT = "I love me water fruits but this be ridiculous.",
	WATERMELONICLE = "A cool treat from me favorite fruit!",
	WATERMELON_COOKED = "Better'n me thought it'd be.",
	WATERMELON_SEEDS = "If only I could plant these in th'water.",
	WEBBERSKULL = "Whut sorta neck did this sit atop?",
	WETGOOP = "Thet's why they never let ol'Woodlegs in th'galley.",
	WHALE_BLUE = "Arrr ye th'devil ta take Woodlegs ta th'depths?",
	WHALE_BUBBLES = "Thar be a devil'n'th'depths!",
	WHALE_CARCASS_BLUE = "Why don't ye sink and clear th'air!",
	WHALE_CARCASS_WHITE = "Thet's a whale o'a smell!",
	WHALE_WHITE = "Now ye arr a devil fit ta claim ol'Woodlegs!",
	WILBUR_CROWN = "Kinda head fits this crown?",
	WILBUR_UNLOCK = "Look at this fancy monkey!",
	WILDBORE = "Not wild about ye.",
	WILDBOREHOUSE = "Bet them bores be knowin' how ta parrrrrty.",
	WIND_CONCH = "Brings th'storm down.",
	WINTERHAT = "Keeps me noggin' from freezin'.",
	WINTEROMETER =
	{
		BURNT = "Thet don't help me now.",
		GENERIC = "Arrr brrrrrr!",
	},
	WORM =
	{
		DIRT = "Dirty dirt.",
		PLANT = "Ripe fer th'pickin'.",
		WORM = "'Tis a worm!",
	},
	WORMHOLE =
	{
		GENERIC = "Whut would possess me ta step into thet?",
		OPEN = "Whar'n Hades do thet lead?",
	},
	WORMHOLE_LIMITED = "Thet thar pit looks like it's on its last peglegs.",
	WORMLIGHT = "Set's a fire in yer belly.",
	YELLOWAMULET = "I be a walkin' lighthouse!",
	YELLOWGEM = "A gem th'color o'me teeth!",
	YELLOWSTAFF = "Th'stars aren't under th'domain o'man.",
	BOAT_WOODLEGS = "Me ship. She's me Sea Legs.",
	WOODLEGSHAT = "'Tis me lucky hat!",

	ARMORCACTUS = "Me'd like ta see them try ta hit Woodlegs now!",
	BIGFISHINGROD = "Woodlegs'seen bigger.",
	--BOOK_METEOR = "Devil magic thet summons demons from th'sky!",
	BRAINJELLYHAT = "A jelly ta rest upon me dainty head.",
	COCONUT_HALVED = "Its flesh be prone fer th'takin'.",
	COFFEEBOT = "Brew Woodlegs' coffee!",
	CRATE = "There be a crate.",
	DEPLETED_BAMBOOTREE = "'Tis no more.",
	DEPLETED_BUSH_VINE = "Th'bush needs some shuteye.",
	DEPLETED_GRASS_WATER = "Thet'll not be comin' back fer some time.",
	DOYDOYEGG_COOKED = "Yer would-be goose is cooked!",
	DRAGOONHEART = "Th'heart o'th'fearsome creature.",
	DRAGOONSPIT = "How uncouth! Woodlegs approves!",
	DUG_BUSH_VINE = "Thet be mine fer th'takin'.",
	FRESHFRUITCREPES = "Aye, thet be food.",
	FRUITMEDLEY = "'Tis a scrumptious little morsel.",
	GEARS = "Me gears be turnin'.",
	GUANO = "'Tis from th'backside o'a beast!",
	HOUNDFIRE = "It burns viciously!",
	INVENTORYGRAVE = "Who been meddlin' wit' me islands?",
	INVENTORYMOUND = "Who been meddlin' wit' me islands?",
	KRAKEN = "'Tis th'mightiest beast in th'sea!",
	KRAKENCHEST = "Aye, this be what Woodlegs lives fer!",
	KRAKEN_TENTACLE = "Have at ye!",
	MAGMAROCK_FULL = "Me treasure sense arrr at full blast!",
	MAGMAROCK_GOLD_FULL = "Me treasure sense arrr at full blast!",
	MONKEYBALL = "This be unsettlin'.",
	MONSTERTARTARE = "'Tis a vile thing.",
	MUSSELBOUILLABAISE = "'Tis a delicacy.",
	MYSTERYMEAT = "Aye, me'll be eatin' well tonight!",
	OXHAT = "'Tis a hat o'th'ox.",
	OX_FLUTE = "A flute ta play a lil diddy.",
	OX_HORN = "A terrible beastly horn.",
	PARROT_PIRATE = "Ack! Thet's me Polly!",
	PEACOCK = "Yer a fancy creature!",
	PEG_LEG = "Woodlegs had better hold on ta this fer future use.",
	PIRATEGHOST = "'Tis a pirate's life, even in death.",
	SANDBAGSMALL_ITEM = "Woodlegs'd never lug th'land with'im!",
	SHADOWSKITTISH_WATER = "Back, beast!",
	SHIPWRECKED_ENTRANCE = "Ahoy me mateys!",
	SHIPWRECKED_EXIT = "Farewell ye land lubbers!",
	SAIL_SNAKESKIN = "Thet be a sail.",
	SNAKE_FIRE = "Aye, thet's a foul creature.",
	SPEAR_LAUNCHER = "Load a spear an'let'er fly!",
	SWEETPOTATOSOUFFLE = "A tasty piece o'crumpet.",
	SWIMMINGHORROR = "Back ta th'depths with ye!",
	TIGEREYE = "Reminds me o'me ol'first mate, Wildeye Weston.",
	TRINKET_IA_20 = "Wit' this me'll traverse th'seas!",
	TRINKET_IA_21 = "'Tis a mockery o'th'mighty vessels o'th'sea!",
	TRINKET_IA_22 = "Where be th'wine?",
	TURF_FUNGUS_RED = "Me ain't no ground lubber.",
	TURF_MAGMAFIELD = "Me ain't no ground lubber.",
	TURF_TIDALMARSH = "Me ain't no ground lubber.",
	VOLCANO_ALTAR_TOWER = "Thet be th'devil's work.",
	WATERYGRAVE = "Th'only proper end fer a man o'th'sea.",
	WHALE_TRACK = "Whale, ahoy!",
	WILDBOREHEAD = "Quit yer starin'.",
	SAIL_WOODLEGS = "Thet's me sail!",
	WOODLEGS_CAGE = "'Tis a wretched thing.",
	WOODLEGS_KEY1 = "A useless thing if ever there were one.",
	WOODLEGS_KEY2 = "A useless thing if ever there were one.",
	WOODLEGS_KEY3 = "A useless thing if ever there were one.",
	SHIPWRECK = "Rest well, ye weary seafarer.",
	CALIFORNIAROLL = "Them be fancy fish treats.",


--- 5C DLC ------------------------------------------------------------------------------------------------

	BOAT_ENCRUSTED = "A vessel'o th'sea, t'be sure.",
	BABYOX = "Ye ain'tna land lubber, is ya? Nah!",
	BALLPHINHOUSE = "They be at home on th'sea, jus' like ol'Woodlegs!",
	DORSALFIN = "Th'fin o'a sea beast.",
	NUBBIN = "N'ta hair t'be seen.",
	CORALLARVE = "Not th'most intimidatin' sea monster!",
	RAINBOWJELLYFISH = "Aye, thet b'a jellyfish.",
	RAINBOWJELLYFISH_PLANTED = "Th'sea b'full'o colors!",
	RAINBOWJELLYFISH_DEAD = "'Tis gon' belly up!",
	RAINBOWJELLYFISH_COOKED = "Now Woodlegs' belly'll soon b'full'o colors!",
	RAINBOWJELLYJERKY = "Fit fer'a king!",
	WALL_ENFORCEDLIMESTONE = "Wall'o'th'sea!",
	WALL_ENFORCEDLIMESTONE_ITEM = "A wall t'be.",
	CROCODOG = "A mangy reptile!",
	POISONCROCODOG = "A mighty poison infests thet one!",
	WATERCROCODOG = "A terr'ble fido, t'be sure!",
	QUACKENBEAK = "Twas a mighty maw on thet one.",
	QUACKERINGRAM = "Tis time fer a quackerin'!",

	--- DLC ------------------------------------------------------------------------------------------------    

	CAVIAR = "Snooty landlubb'rin' eats!",
	CORMORANT = "A most foul seabird!",

	PURPLE_GROUPER = "Ye got thet look t'ya.",
	PIERROT_FISH = "Don't ye b'starin' at ol'Woodlegs!",
	NEON_QUATTRO = "Inta th'pot w'ya.",

	PURPLE_GROUPER_COOKED = "Ready fer m'gullet.",
	PIERROT_FISH_COOKED = "Down th'hatch!",
	NEON_QUATTRO_COOKED = "Th'bread'n'butter'o'th'sea!",

	FISH_FARM = 
	{
		EMPTY = "Nary a fish in sight!",
		STOCKED = "Th'fish b'growin', aye.",
		ONEFISH = "Tharr be a bite!",
		TWOFISH = "More fish fer ol'Woodlegs!",
		REDFISH = "They b'ready fer a cookin'!",
		BLUEFISH  = "Thet be a netful!",
	},
	
	ROE = "Egg'o'th'fish.",
	ROE_COOKED = "Roast egg'o'th'fish.",
	
	SEA_YARD = 
	{
		ON = "Thet'll give Sea Legs a leg up! Harr!",
		OFF = "Who'll take care'a ol'Sea Legs now?",
		LOWFUEL = "Thar be near no wind in them sails!",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "Thet needs a stokin'.",
		GENERIC = "Prote'tion frum th'waves.",
		HIGH = "Burnin' bright, aye!",
		LOW = "Tis a wee bit low.",
		NORMAL = "Th'bitter cold'll not get Woodlegs, na!",
		OUT = "It be out... Like a light!",
	}, 

	TAR = "Tis a m'ghty sticky sludge!",
	TAR_EXTRACTOR =
	{
		ON = "Tis workin'up a mighty sweat!",
		OFF = "Ain't doin' nuthin'!",
		LOWFUEL = "Thet b'lookin' mor'n a tad low.",
	},
	TAR_POOL = "There be sludgy treasure down ther'.",

	TARLAMP = "Looks like a wee boat!",
	TARSUIT = "Y'arr, cov'r me in tarr!",
	TAR_TRAP = "Ol' Woodlegs' pegs'd get stuck f'sure!",

	TROPICALBOUILLABAISSE = "Tis a'hearty fish soup!",
	
	SEA_LAB = "Thet b'fer tinkerin' on th'waves!",
	WATERCHEST = "Woodlegs' treasure, buried at sea!",
	QUACKENDRILL = "Thar b'a drill.",
	HARPOON = "T'whales cow'r in fear 'fore ol'Woodlegs!",
	MUSSEL_BED = "Ye'll b'returned t'th'sea.",	

},
DESCRIBE_GENERIC = "'Tis a... somethin'er tother.",
DESCRIBE_SMOLDERING = "'Tis like ta catch fire.",
DESCRIBE_TOODARK = "'Tis too dark ta spy wit' ye eye!",
EAT_FOOD =
{
	TALLBIRDEGG_CRACKED = "Inta' ma belly wit ya!",
},
}%%+%%strings/wormwood.lua%%-%%return {

ACTIONFAIL = {
	REPAIRBOAT =
	{
		GENERIC = "Nope. Can't fix ",
	},
	EMBARK =
	{
		INUSE = "Nope. Friends float now",
	},
	INSPECTBOAT =
	{
		INUSE = GLOBAL.STRINGS.CHARACTERS.WORMWOOD and GLOBAL.STRINGS.CHARACTERS.WORMWOOD.ACTIONFAIL.STORE.INUSE
	},
},

ANNOUNCE_MAGIC_FAIL = "Magic won't work",

ANNOUNCE_VOLCANO_ERUPT = "Woah. Earth Blood moving",
ANNOUNCE_TREASURE = "Hidden stuff nearby",
ANNOUNCE_CRAB_ESCAPE = "Run, Pinchy, run!",
ANNOUNCE_SHARX = "Swimmy Fins near!",
ANNOUNCE_MORETREASURE = "More hidden stuff near!",
ANNOUNCE_OTHER_WORLD_TREASURE = "Not from here",
ANNOUNCE_OTHER_WORLD_PLANT = "Won't grow here",
ANNOUNCE_MAPWRAP_WARN = "Oh. Can't see",
ANNOUNCE_MAPWRAP_LOSECONTROL = "Lost",
ANNOUNCE_MAPWRAP_RETURN = "Back again",

ANNOUNCE_MESSAGEBOTTLE =
{
	"Can't read",
},
ANNOUNCE_BOAT_DAMAGED = "Oh. Floater is wobbly",
ANNOUNCE_BOAT_SINKING = "Why sinking, Floater?",
ANNOUNCE_BOAT_SINKING_IMMINENT = "Sunk",
ANNOUNCE_TRAWL_FULL = "Full",
ANNOUNCE_WAVE_BOOST = "Whee!",
ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Bubbles!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "Can't see bubbles",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "Can't see bubbles",


DESCRIBE = {

	SEAWEED_STALK = "Needs sea", --copied from the Wikia because I couldn't find it in the game files. -M

	POISONBALM = "Takes away sick",

	--some stray lines I found -M
	BIGFISHINGROD = "Stick for Glub Glubs",
	TROPICALFAN = "Makes wind",
	GHOST_SAILOR = "Floaty man!",
	PALMLEAF_UMBRELLA = "Rain Taker made of friend hair",
	PALMTREE =
	{
		BURNING = "Friend needs help!",
		BURNT = "Nooo!",
		CHOPPED = "Didn't want to",
		GENERIC = "Nice hair!",
	},
	SOLOFISH_DEAD = "Hello, Glub Glub",
	FISH_MED_COOKED = "For belly",
	SUNKBOAT = "Broken",
	--the big bulk of lines -M
	AERODYNAMICHAT = "Zoomie head thing",
	ARMOR_LIFEJACKET = "Water saver",
	ARMOR_SNAKESKIN = "Poor Squirmy",
	ARMOR_WINDBREAKER = "Cozy",
	ARMORLIMESTONE = "Heavy",
	ARMOROBSIDIAN = "Fire clothes",
	ARMORSEASHELL = "Sea clothes",
	BOAT_ARMOURED = "Lots of rocks",
	BABYOX = "Cute ear branches",
	BALLPHIN = "EEE! EEE!",
	BALLPHINPOD = "EEEs!",
	BAMBOOTREE = "Green sticks",
	BERRYBUSH2_SNAKE = "Something hiding?",--I don't think these should have diff name or examine text
	BERRYBUSH_SNAKE = "Something hiding?",--I don't think these should have diff name or examine text
	BIOLUMINESCENCE = "Wet lights",
	BLOWDART_POISON = "Patoo!",
	BOAT_LANTERN = "Floaty light",
	BOTTLELANTERN = "Light home",
	BURIEDTREASURE = "Stuff!",
	CANNONSHOT = "Pa-KOW!!",
	CAPTAINHAT = "Ahoy!",
	BOAT_CARGO = "Big Floater of friends",
	CHIMINEA = "Makes water fires",
	CIRCLINGSEAGULL = "Sea Tweeter",
	SAIL_CLOTH = "Woosh!",
	COCONUT =
	{
		GENERIC = "Ball of belly stuff",
		PLANTED = "Grow up strong!",
	},
	COCONUT_COOKED = "Warm",
	COFFEE = "Wheee!!!",
	COFFEEBEANS = "Zoomberries!",
	COFFEEBEANS_COOKED = "Smells good",
	COFFEEBUSH = "Zoomberry friend",
	CORAL = "Water rocks",
	ROCK_CORAL = "Rock party",
	CUTLASS = "Swooshy Stick",
	SWORDFISH_DEAD = "(sob)",
	DEPLETED_BAMBOOTREE = "Hurt?",
	DEPLETED_BUSH_VINE = "Hurt?",
	DOYDOY = "Odd Tweeter",
	DOYDOYBABY = "Odd Tweeter baby",
	DOYDOYEGG = "Odd Tweeter inside?",
	DOYDOYEGG_COOKED = "Fired egg",
	DOYDOYEGG_CRACKED = "Hatching?",
	DOYDOYFEATHER = "Odd Tweeter clothes",
	DOYDOYNEST = "Hello sticks!",
	DUBLOON = "Belly stuff? Nope",
	DUG_BAMBOOTREE = "Needs dirt",
	DUG_BERRYBUSH2 = "Needs dirt",
	DUG_BUSH_VINE = "Needs dirt",
	DUG_COFFEEBUSH = "Needs dirt",
	EARRING = "Doesn't fit",
	FABRIC = "Soft. Made from friends",
	SAIL_FEATHER = "Wind nabber",
	FIRERAIN = "Not good! Not good!",
	FIRERAINSHADOW = "Fire coming",
	FISHINHOLE = "Hello Glub Glubs!",
	GASHAT = "Head thing full of air",
	GOLDENMACHETE = "Pretty Slicer",
	ICEMAKER = "Cold Spitter",
	IRONWIND = "Air Machine",
	JELLYFISH = "Glub Glub Blob",
	JELLYFISH_DEAD = "Poor Blob",
	JELLYFISH_COOKED = "Blob hoops",
	JELLYFISH_PLANTED = "Glub Glub Blob",
	JELLYJERKY = "Hmm... bit chewy",
	JUNGLETREESEED =
	{
		GENERIC = "Cute little guy",
		PLANTED = "Grow well",
	},
	LAVAPOOL = "Fire water. Stay back!",
	LIMESTONENUGGET = "Where pretty parts go?",
	LIMPETS = "Rock Glub Glubs",
	LIMPETS_COOKED = "Goes in belly",
	LOBSTERHOLE = "Wet nest",
	BOAT_LOGRAFT = "Friend ship",
	MOSQUITO_POISON = "Bzzt that makes sick",
	MUSSEL = "Hiding",
	MUSSEL_COOKED = "Fire made it open",
	MUSSEL_STICK = "Stick is swimming!",
	OBSIDIAN = "Fire trapped in rock",
	OBSIDIAN_WORKBENCH = "Makes hard things",
	OBSIDIANAXE = "Hard Chopper",
	OBSIDIANCOCONADE = "Big Fireboomer!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "Dying",
		GENERIC = "Not too close",
		HIGH = "Too high!",
		LOW = "Stay back",
		NORMAL = "Not too close",
		OUT = "Whew!",
	},
	OBSIDIANMACHETE = "Hard Slicer",
	SPEAR_OBSIDIAN = "Makes fire!",
	OBSIDIANSPEARGUN = "Hard Flying Stick",
	PACKIM = "Friend Tweeter",
	PACKIM_FISHBONE = "Friend Tweeter likes you!",
	PALMLEAF = "Wig from friend hair",
	PALMTREE_BURNT = "NOO!",
	PALMTREE_STUMP = "Sorry. Didn't want to",
	PARROT = "Pretty Tweeter!",
	PIRATEHAT = "Yo ho head thing",
	PIRATIHATITATOR = "Makes the Yo Ho magic",
	POISONHOLE = "Dirt is burping",
	BOAT_RAFT = "Greenstick ship",
	BOAT_ROW = "Push Pull Floater",
	SAIL_PALM = "Wind Nabber",
	SAND = "Dirt",
	SANDBAG = "Full of dirt",
	SANDBAG_ITEM = "Full of dirt",
	SANDDUNE = "Pile of dirt",
	SEAGULL = "Sea Tweeter",
	SEASACK = "Keeps belly stuff fresh",
	SEASHELL = "Head thing? Nope",
	SEASHELL_BEACHED = "No friends inside",
	SEATRAP = "Wet trap",
	SEAWEED = "Yum",
	SEAWEED_COOKED = "Ball of Sea Yum",
	SEAWEED_DRIED = "No more sea in Sea Yum",
	SEAWEED_PLANTED = "Nice day for a swim?",
	SHARX = "Fins?",
	SLOTMACHINE = "Luck Box",
	SNAKE = "Squirmy",
	SNAKE_FIRE = "Burny Squirmy",
	SNAKESKIN = "Squirmy clothes",
	SNAKESKINHAT = "Snazzy Squirmy head thing",
	SPEAR_POISON = "Sick Stick",
	SPEARGUN = "Patoo Machine",
	SPEARGUN_POISON = "Machine for Sick Patoo",
	STUNGRAY = "Smelly Glub Glub",
	SUPERTELESCOPE = "Can see home?",
	SWORDFISH = "Sharpnose Glub Glub",
	TELESCOPE = "Looky look",
	TIGERSHARK = "Mow Fin",
	TIGERSHARKSHADOW = "Hello? You hiding?",
	TOUCAN = "Big Nose Tweeter",
	TRAWLNET = "Glub Glub Snagger",
	TRAWLNETDROPPED = "Snagging...",
	TREEGUARD = "How doing, friend?",
	TRIDENT = "Three Stick Stick",
	TRINKET_IA_13 = "Psht",
	TRINKET_IA_14 = "Hello!... Hello?",
	TRINKET_IA_15 = "Plink Plink",
	TRINKET_IA_16 = "Name?",
	TRINKET_IA_17 = "(sniff, sniff) Whew-wee!",
	TRINKET_IA_18 = "Oh. Broken",
	TRINKET_IA_19 = "Hmm...",
	TURBINE_BLADES = "Wooshy",
	TURF_BEACH = "Sand",
	TURF_JUNGLE = "Dirt",
	VENOMGLAND = "For sickness",
	VINE = "String branches",
	VOLCANO = "Ka-BOOMER!",
	VOLCANO_ALTAR = "Hot water!",
	VOLCANO_ALTAR_BROKEN = "Broken",
	VOLCANO_EXIT = "Out",
	VOLCANOSTAFF = "Fire Rain Stick",
	WALL_LIMESTONE = "Big strong wall",
	WALL_LIMESTONE_ITEM = "Should put this somewhere",
	WHALE_BLUE = "Barrooooo!",
	WHALE_CARCASS_BLUE = "(sniff sniff) Smells good",
	WHALE_CARCASS_WHITE = "(sniff) Smells good",
	WHALE_WHITE = "Pale Barrooooo",
	CRABHOLE = "Anyone home?",
	CRAB =
	{
		GENERIC = "Pinchy",
		HIDDEN = "Come out and play?",
	},
	BERMUDATRIANGLE = "Zzzt Zoomer",
	BOATCANNON = "BOOM! BOOM! for Floater",
	BOATREPAIRKIT = "Fix it stuff",
	MACHETE = "Slicer. For friend haircuts",
	LUGGAGECHEST = "Stuff!",
	DRAGOON = "Hot Patuey!",
	ANTIVENOM = "Sick Fixer",
	BAMBOO = "Greenstick",
	FROG_POISON = "Sick Ribbit",
	OX = "Water Buddy",
	PEACOCK = "Lovely Tweeter",
	SEAGULL_WATER = "How's the water?",
	SNAKE_POISON = "Sick Squirmy",
	SOLOFISH = "Glub Glub Woofer",
	SPOILED_FISH = "Smells good. Mmmmm...",
	TWISTER = "Wooshy Wooshy",
	SAND_CASTLE =
	{
		GENERIC = "Made that",
		SAND = "Dirt",
	},
	SNAKEOIL = "Hmmm...",
	LOBSTER = "Snappy Glub Glub",
	MESSAGEBOTTLE = "Says something...",
	MESSAGEBOTTLEEMPTY = "Aw. Nothing inside",
	SHARK_FIN = "Water Slicer",
	VOLCANO_ALTAR =
	{
		GENERIC = "Hello?",
		OPEN = "Needs stuff for belly",
	},
	ELEPHANTCACTUS = "Pokey friend",
	ELEPHANTCACTUS_ACTIVE = "Friend? Ouch!",
	ELEPHANTCACTUS_STUMP = "Sorry!  (sob)",
	DOUBLE_UMBRELLAHAT = "Two Times Rain Taker",
	MUSSEL_FARM =
	{
		GENERIC = "Why you hiding?",
		STICKPLANTED = "Swimming stick",
	},
	WOODLEGS_CAGE = "Very locked",
	PIRATIHATITATOR =
	{
		GENERIC = "Makes magic stuff",
		BURNT = "Oh dear",
	},
	COFFEEBUSH =
	{
		BARREN = "Are you sick?",
		PICKED = "They'll grow back",
		WITHERED = "Needs ashes!",
		GENERIC = "Zoomberry friend",
	},
	DUG_ELEPHANTCACTUS = "Needs dirt",
	WHALE_BUBBLES = "Glub Glub or Barrooooo?",
	ARMORCACTUS = "Friend clothes",
	BAMBOOTREE =
	{
		BURNT = "NOOO!",
		CHOPPED = "Nice haircut!",
		GENERIC = "Greenstick friend",
	},
	BLOWDART_FLUP = "Eye patuey",
	BLUBBER = "Squishy",
	BLUBBERSUIT = "Still warm",
	BOAT = "Floater",
	BOAT_TORCH = "For dark times on floater",
	BRAINJELLYHAT = "Smart head thing",
	BUOY = "Water light",
	BUSH_VINE =
	{
		BURNT = "NOOOO!",
		CHOPPED = "Keep growing",
		GENERIC = "Hello Rope friend!",
	},
	COCONADE =
	{
		BURNING = "Burning!!!",
		GENERIC = "BOOMER!",
	},
	COCONUT_HALVED = "Stuff for belly",
	COFFEEBOT = "Zoomberry machine",
	CORAL_BRAIN = "Thinking...",
	CORAL_BRAIN_ROCK = "Thinky rock",
	CRATE = "Wood friends made a box!",
	DEPLETED_GRASS_WATER = "Sick",
	DRAGOONDEN = "Home of Fire Patuey",
	DRAGOONEGG = "Something inside...",
	DRAGOONHEART = "Still beating. Ba-dump Ba-dump",
	DRAGOONSPIT = "Patuey",
	FISH_MED = "Glub Glub",
	FISH_SMALL = "Wee Glub Glub",
	FISH_SMALL_COOKED = "Cute little belly stuff",
	FLAMEGEYSER = "Hot! Too hot!",
	FLOTSAM = "Swim, friends! Swim!",
	FLUP = "Peeper Glub Glub",
	-- FRESHFRUITCREPES = "Sweet belly stuff",
	GRASS_WATER = "How's the water?",
	HAIL_ICE = "Cold. Wet",
	HOME = "Hello? Anyone?",
	ICEMAKER =
	{
		HIGH = "Making lots of cold rocks",
		LOW = "Slow",
		NORMAL = "Cold Rock machine",
		OUT = "Needs food",
		VERYLOW = "It's getting hungry",
	},
	JUNGLETREE =
	{
		BURNING = "NOOO!!",
		BURNT = "(sob)",
		CHOPPED = "Oh. So sorry",
		GENERIC = "Sleeping friend",
	},
	KNIGHTBOAT = "Floating Neigh",
	KRAKEN = "Angry Beaker",
	KRAKENCHEST = "Stuff from the Beaker!",
	KRAKEN_TENTACLE = "Ocean arms!",
	LIMPETROCK =
	{
		GENERIC = "Rocks that grow stuff",
		PICKED = "Belly stuff already gone",
	},
	LIVINGJUNGLETREE = "Are you Friend?",
	LOBSTER_DEAD = "Oh. Belly stuff now",
	LOBSTER_DEAD_COOKED = "Why changed color?",
	MAGIC_SEAL = "Hello? Hello? Not talking",
	MAGMAROCK = "Hello, rocks!",
	MAGMAROCK_FULL = "Hello, rocks!",
	MAGMAROCK_GOLD = "Pretty rock inside",
	MAGMAROCK_GOLD_FULL = "Pretty rock inside",
	MANGROVETREE = "Hello! Friend?",
	MANGROVETREE_BURNT = "Fire kills everything",
	MARSH_PLANT_TROPICAL = "Little friend. Hello!",
	MERMFISHER = "Glub Glub Man",
	MERMHOUSE_FISHER = "Glub Glub Man home",
	MONKEYBALL = "Hee hee. Fun!",
	-- MONSTERTARTARE = "Nope",
	MOSQUITOSACK_YELLOW = "Bzzt bum",
	MUSSELBOUILLABAISE = "They look comfortable",
	MYSTERYMEAT = "Hmm...What is it?",
	NEEDLESPEAR = "Pokey friend bits",
	OCTOPUSCHEST = "Stuff from Big Arms guy!",
	OCTOPUSKING = "Big Arms guy",
	OXHAT = "Ear branches?",
	OX_FLUTE = "Toot! Toot!",
	OX_HORN = "Branches?",
	PALMLEAF_HUT = "Home made of friends",
	PARROT_PIRATE = "Arrg Tweeter",
	PEG_LEG = "Friend?",
	PIGTENT = "(sniff, sniff) Has Twirly Tail smell",
	PIKE_SKULL = "That poor stick",
	PIRATEGHOST = "Floaty man",
	PIRATEPACK = "Stuff!",
	PORTAL_SHIPWRECKED = "Oh. Broken",
	PRIMEAPE = "Big Cheeky",
	PRIMEAPEBARREL = "Cheeky home",
	RAWLING = "New fun friend!",
	REDBARREL = "BOOM Barrel",
	ROCK_CHARCOAL = "Burnt rock",
	ROCK_OBSIDIAN = "Hard",
	SAIL_STICK = "Blow Stick",
	SANDBAGSMALL = "Dirt Bag",
	SANDBAGSMALL_ITEM = "Dirt Bag",
	SHADOWSKITTISH_WATER = "Dark Creeper",
	SHARKITTEN = "Mow Glub Glub",
	SHARKITTENSPAWNER =
	{
		GENERIC = "Full",
		INACTIVE = "Mow?... Mow?",
	},
	SHARK_GILLS = "Glub Glub breather",
	SHARK_TEETHHAT = "Bitey Head Thing.",
	SHIPWRECKED_ENTRANCE = "Where to?",
	SHIPWRECKED_EXIT = "Goes where?",
	SNAKEDEN =
	{
		BURNT = "NOOOO!",
		CHOPPED = "You'll grow back soon!",
		GENERIC = "Hello Rope friend",
	},
	SAIL_SNAKESKIN = "Squirmy Wind Nabber",
	SPEAR_LAUNCHER = "Pokey Stick launcher",
	SUNKEN_BOAT =
	{
		ABANDONED = "Poor wood...",
		GENERIC = "Wood is drowning!",
	},
	SUNKEN_BOAT_BURNT = "(sob)",
	SUNKEN_BOAT_TRINKET_1 = "Pretty machine",
	SUNKEN_BOAT_TRINKET_2 = "Baby floater",
	SUNKEN_BOAT_TRINKET_3 = "Hmm...",
	SUNKEN_BOAT_TRINKET_4 = "Beep bwoop",
	SUNKEN_BOAT_TRINKET_5 = "(sniff, sniff) Whoo-wee!",
	SWEETPOTATOSOUFFLE = "Belly stuff",
	SWEET_POTATO = "Sweet belly stuff",
	SWEET_POTATO_COOKED = "Mmmm...",
	SWEET_POTATO_PLANTED = "Needs to grow",
	SWEET_POTATO_SEEDS = "Grows sweet belly stuff",
	SWIMMINGHORROR = "Yeep!",
	TELEPORTATO_SW_BASE = "Wood",
	TELEPORTATO_SW_BOX = "Box",
	TELEPORTATO_SW_CRANK = "Crank",
	TELEPORTATO_SW_POTATO = "Thing",
	TELEPORTATO_SW_RING = "Ring",
	THATCHPACK = "Keeps stuff",
	TIDALPOOL = "Home for Glub Glub",
	TIDAL_PLANT = "Looking good!",
	TIGEREYE = "(poke)",
	TRAWLNETDROPPED =
	{
		GENERIC = "Water stuff",
		SOON = "Have to wait",
		SOONISH = "Have to wait more",
	},
	TREASURECHEST_TRAP = "Hmm...",
	TRINKET_IA_20 = "Pretty machine",
	TRINKET_IA_21 = "Baby floater",
	TRINKET_IA_22 = "Hmm...",
	TRINKET_IA_23 = "Green stick glass",
	FISH_TROPICAL = "Pretty Glub Glub",
	TUNACAN = "Glub Glub inside?",
	TURF_ASH = "Burnt",
	TURF_MAGMAFIELD = "Burnt",
	TURF_MEADOW = "Dirt",
	TURF_SNAKESKIN = "Not dirt",
	TURF_TIDALMARSH = "Dirt!",
	TURF_VOLCANO = "Dirt",
	TWISTER_SEAL = "Those peepers...",
	VOLCANO_ALTAR_TOWER = "Big boomer!",
	VOLCANO_SHRUB = "Burnt (sob)",
	WALLYINTRO_DEBRIS = "Hello, wood!",
	WATERYGRAVE = "Wood drowning!",
	WHALE_TRACK = "Barrooooo?",
	WILBUR_CROWN = "Won't fit",
	WILBUR_UNLOCK = "Cheeky boss",
	WILDBORE = "Scary Twirly Tail",
	WILDBOREHEAD = "Yeep!",
	WILDBOREHOUSE = "Anyone home?",
	WIND_CONCH = "Blow rock",
	BOAT_WOODLEGS = "Arrg Floater",
	WOODLEGSHAT = "Arrg Head Thing",
	SAIL_WOODLEGS = "Arrg Wind Nabber",
	WOODLEGS_KEY1 = "Key",
	WOODLEGS_KEY2 = "Key. What for?",
	WOODLEGS_KEY3 = "Opens something",
	WRECK = "Save the wood!",
	CALIFORNIAROLL = "Belly stuff",
	-- BANANAPOP = "Frozen friend hair",
	BISQUE = "Swimmy belly stuff",
	-- CEVICHE = "Belly goop",
	SEAFOODGUMBO = "Mmm...",
	SURFNTURF = "Fills belly right up",
	SHARKFINSOUP = "Still swimming",
	LOBSTERDINNER = "Fancy belly stuff",
	LOBSTERBISQUE = "Still snappy?",
	JELLYOPOP = "Cold Glub Glub Blob",
	VOLCANO_SHRUB = "Oh, fire. Why?!",
	ROCK_OBSIDIAN = "Hard rock",
	ROCK_CHARCOAL = "Burnt rock",

	MUSSEL_BED = "Needs sea",
	SEAWEED_STALK = "Needs sea",
	HARPOON = "Throwy stick",

	BOAT_ENCRUSTED = "Heavy Floater",
	BABYOX = "Ear branches. Cute!",
	BALLPHINHOUSE = "EEE! Home",
	DORSALFIN = "EEE?... EEE?...",
	NUBBIN = "Cute baby Wet Rock",
	CORALLARVE = "Needs rock",
	RAINBOWJELLYFISH = "Pretty Glub Glub Blob",
	RAINBOWJELLYFISH_PLANTED = "Hello! Found you!",
	RAINBOWJELLYFISH_DEAD = "Not poofy anymore",
	RAINBOWJELLYFISH_COOKED = "Pretty rings",
	RAINBOWJELLYJERKY = "More chewy now",
	WALL_ENFORCEDLIMESTONE = "Wall. Strong wall",
	WALL_ENFORCEDLIMESTONE_ITEM = "Wall. Strong wall",
	CROCODOG = "GRRawr!",
	POISONCROCODOG = "Yellow GRRawr!",
	WATERCROCODOG = "Wet GRRawr!",
	QUACKENBEAK = "Beaky nose",
	QUACKERINGRAM = "Floater nose",
	CAVIAR = "Glub Glub babies trapped?",
	CORMORANT = "Floating Tweeter",
	PURPLE_GROUPER = "Purple Glub Glub",
	PIERROT_FISH = "Yellow Glub Glub",
	NEON_QUATTRO = "Big Lip Glub Glub",
	PURPLE_GROUPER_COOKED = "No more swimming",
	PIERROT_FISH_COOKED = "Glub Glub for belly",
	NEON_QUATTRO_COOKED = "Fins are yummy",
	FISH_FARM =
	{
		EMPTY = "Where glub glubs?",
		STOCKED = "Hello glub glubs!",
		ONEFISH = "Glub",
		TWOFISH = "Glub Glub",
		REDFISH = "Splishy",
		BLUEFISH  = "Splashy",
	},
	ROE = "Baby Glub Glubs",
	ROE_COOKED = "Tidy rows",
	SEA_YARD =
	{
		ON = "Fixing",
		OFF = "Not fixing",
		LOWFUEL = "Hungry?",
	},
	SEA_CHIMINEA =
	{
		EMBERS = "Dying",
		GENERIC = "Not too close",
		HIGH = "Too high!",
		LOW = "Stay back",
		NORMAL = "Not too close",
		OUT = "Whew",
	},
	TAR = "Dark Gloop",
	TAR_EXTRACTOR =
	{
		ON = "Getting Gloop",
		OFF = "Not getting Gloop",
		LOWFUEL = "Hungry?",
	},
	TAR_POOL = "Gloopy Puddle",
	TARLAMP = "Gloopy Light",
	TARSUIT = "Feelin' gloopy",
	TAR_TRAP = "Stuck",
	TROPICALBOUILLABAISSE = "Glub Glubs?",
	SEA_LAB = "Water things maker",
	WATERCHEST = "Swimming stuff!",
},

}
%%+%%strings/wortox.lua%%-%%return {

ACTIONFAIL =
{
	REPAIRBOAT = 
	{
		GENERIC = "Oh I simply couldn't.",
	},
	EMBARK =
	{
		INUSE = "To far, far away? No, I'll stay.",
	},
	INSPECTBOAT = 
	{
		INUSE = GLOBAL.STRINGS.CHARACTERS.GENERIC.ACTIONFAIL.STORE.INUSE
	},
},

ANNOUNCE_MAGIC_FAIL = "Magic? Hmm, not that simple!",

ANNOUNCE_SHARX = "I hear, I hear! Oh dear...",

ANNOUNCE_TREASURE = "The sound of gold, so I've been told!", --SWC
ANNOUNCE_MORETREASURE = "And more, more, more!",
ANNOUNCE_OTHER_WORLD_TREASURE = "Not from this world or the one below!",
ANNOUNCE_OTHER_WORLD_PLANT = "It's not from this soil, what a spoil!",

ANNOUNCE_MESSAGEBOTTLE =
{
	"The message is faded. I can't read it.",
},
ANNOUNCE_VOLCANO_ERUPT = "That can't be good.",
ANNOUNCE_MAPWRAP_WARN = "Here be monsters.",
ANNOUNCE_MAPWRAP_LOSECONTROL = "It would seem my future is foggy.",
ANNOUNCE_MAPWRAP_RETURN = "I think I felt something brush against my leg...",
ANNOUNCE_CRAB_ESCAPE = "I could've sworn it was right there...",
ANNOUNCE_TRAWL_FULL = "My net filled up!",
ANNOUNCE_BOAT_DAMAGED = "I think I sprung a leak.",
ANNOUNCE_BOAT_SINKING = "I seem to be sinking.",
ANNOUNCE_BOAT_SINKING_IMMINENT = "I need to get to land!",
ANNOUNCE_WAVE_BOOST = "Weeeee!",

ANNOUNCE_WHALE_HUNT_BEAST_NEARBY = "Follow those bubbles!",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL = "I wonder where it went...",
ANNOUNCE_WHALE_HUNT_LOST_TRAIL_SPRING = "The water is too rough!",


DESCRIBE = {
	
	--SWC
	-- PORTABLECOOKPOT_ITEM = "That mortal knows of many cooking things.",
	CHEFPACK = "Keep mortal foods chilly, chilly!",
	-- FRESHFRUITCREPES = "Mortals say it's a sweet treat to eat! Maybe I will try a little nibble!",
	-- MONSTERTARTARE = "I do not wish to eat it, even with the dress-up!",
	-- PORTABLECOOKPOT = 
	-- {
		-- COOKING_LONG = "Mortals take their time for fancy cooking.",
		-- COOKING_SHORT = "This dish must be good, as it we know it should!",
		-- DONE = "A treat is ready to eat!",
		-- EMPTY = "The mortals like it when food looks nice, they do!",
    -- },
	-- WARLY = 
    -- {
        -- GENERIC = "%s, how many tasty soul recipes do you have?",
        -- ATTACKER = "Don't cook me up, imps taste bad, hyuyu!",
        -- MURDERER = "%s, you've got a taste for souls after all!",
        -- REVIVER = "%s saved the best souls just for me! Hyuyu!",
        -- GHOST = "Mmm, the real tasty meal is you, %s!",
        -- FIRESTARTER = "Ooo, you can cook up jokes too!",
    -- },
    --
	SOLOFISH_DEAD = "Good dog.",
	FISH_MED_COOKED = "Grilled to perfection.",
	PURPLE_GROUPER = "A fish with widespread appeal.",
	PURPLE_GROUPER_COOKED = "Avoid the green ones, they're not ripe yet.",

	GHOST_SAILOR = "I wonder what he wants?",

	FLOTSAM = "If only I had some way of hooking on to it from here.",

	SUNKEN_BOAT = 
	{
		GENERIC = "That fellow looks like he wants to talk.",
		ABANDONED = "This is why I hate the water.",
	},
	SUNKEN_BOAT_BURNT = "It's even less seaworthy than before.",
	SUNKEN_BOAT_TRINKET_1 = "An instrument of some sort.", --sextant
	SUNKEN_BOAT_TRINKET_2 = "Now all I need is a miniaturization machine!", --toy boat
	SUNKEN_BOAT_TRINKET_3 = "Looks kinda soggy.", --candle
	SUNKEN_BOAT_TRINKET_4 = "Scientific!", --sea worther
	SUNKEN_BOAT_TRINKET_5 = "If only I had another!", --boot
	SUNKBOAT = "It's no use to me out there!",
	-- BANANAPOP = "No, not brain freeze! I need that for science!",
	BISQUE = "Cooking that sure kept me bisque-y!",
	-- CEVICHE = "Can I get a bigger bowl? This one looks a little shrimpy.",
	SEAFOODGUMBO = "It's a jumbo seafood gumbo.",
	SURFNTURF = "It's perf!",
	SHARKFINSOUP = "It's shark fin-ished!",
	LOBSTERDINNER = "If I eat it in the morning is it still dinner?",
	LOBSTERBISQUE = "Could use more salt, but that's none of my bisque-ness.",
	JELLYOPOP = "Jelly-O pop it right in my mouth!",

	BOAT_ENCRUSTED = "A mere shell of a ship.",
	BABYOX = "Smaller, but just as smelly.",
	BALLPHINHOUSE = "The place where the ballphins roost.",
	DORSALFIN = "Guess that house is FINished.",
	NUBBIN = "I want nubbin to do with that.",
	CORALLARVE = "That's a baby coral reef.",
	RAINBOWJELLYFISH = "That's a lot of tendrils.",
	RAINBOWJELLYFISH_PLANTED = "A colorful blob of science.",
	RAINBOWJELLYFISH_DEAD = "An electric shock will not revive it. I tried.",
	RAINBOWJELLYFISH_COOKED = "A colorful snack!",
	RAINBOWJELLYJERKY = "All the water's dried right out of it.",
	WALL_ENFORCEDLIMESTONE = "I shelled out for the good stuff.",
	WALL_ENFORCEDLIMESTONE_ITEM = "I have to build it in the water.",
	CROCODOG = "I'd rather stay away from the business end of that jerk.",
	POISONCROCODOG = "That looks like an experiment gone wrong.",
	WATERCROCODOG = "It's a dog-eat-me world out here.",
	QUACKENBEAK = "I'd say I made the pecking order around here quite clear.",
	QUACKERINGRAM = "Does my ingenuity know no bounds?!",

	CAVIAR = "I never had it before I came here.",
	CORMORANT = "I bet it eats a lot of fish.",

	PURPLE_GROUPER = "Surf and turf, hold the turf.",
	PIERROT_FISH = "This one's extra water repellent.",
	NEON_QUATTRO = "It looks like a fish, but it feels clammy.",

	PURPLE_GROUPER_COOKED = "That fish is fin-ished.",
	PIERROT_FISH_COOKED = "Gilled to perfection.",
	NEON_QUATTRO_COOKED = "Fried fry.",

	FISH_FARM = 
	{
		EMPTY = "I need to find some fish eggs for this.",
		STOCKED = "The fish babies haven't hatched yet.",
		ONEFISH = "There's a fish!",
		TWOFISH = "The fish are still multiplying.",
		REDFISH = "This has been a successful fish experiment!",
		BLUEFISH  = "I'd better start harvesting these!",
	},

	ROE = "Fish babies.",
	ROE_COOKED = "Roe, sunny side up.",
	
	SEA_YARD =
	{
		ON = "For keeping my ships in tiptop shape!",
		OFF = "It's not in shipshape right now.",
		LOWFUEL = "I'll need to refill it soon.",
	},

	SEA_CHIMINEA = 
	{
		EMBERS = "Better put something on it before it goes out.",
		GENERIC = "Science protect my fires out here.",
		HIGH = "I'm glad we're surrounded by water.",
		LOW = "It's getting low.",
		NORMAL = "As cozy as it gets.",
		OUT = "It finally went out.",
	}, 

	TAR = "Do I have to hold it with my bare hands?",
	TAR_EXTRACTOR =
	{
		ON = "It's running smoothly.",
		OFF = "I have to turn it on.",
		LOWFUEL = "I need to refuel that.",
	},
	TAR_POOL = "There must be a way to get that tar out.",

	TARLAMP = "That's a real slick lamp.",
	TARSUIT = "I'll pitch a fit if I have to wear that.",
	TAR_TRAP = "Who's cleaning that up, I wonder?",

	TROPICALBOUILLABAISSE = "I seasoned it with a dash of science.",

	SEA_LAB = "For sea science!",
	WATERCHEST = "Watertight, just like all my theories.",
	QUACKENDRILL = "I can get more tar if I used this at sea.",
	HARPOON = "I don't intend to harp on the issue.",
	MUSSEL_BED = "I should find a good spot for these.",
	ANTIVENOM = "Tastes horrible!",
	VENOMGLAND = "Only poison can cure poison.",
	BLOWDART_POISON = "The pointy end goes that way.",
	OBSIDIANMACHETE = "It's hot to the touch.",
	SPEARGUN_POISON = "Poison tipped.",
	OBSIDIANSPEARGUN = "Fire tipped.",
	LUGGAGECHEST = "It looks like a premier steamer trunk.",
	PIRATIHATITATOR =
	{
		GENERIC = "It's twisting my tongue.",
		BURNT = "Fire doesn't really solve naming issues...",
	},
	COFFEEBEANS = "They could use some roasting.",
	COFFEE = "Smells delicious and energizing!",
	COFFEEBEANS_COOKED = "Heat definitely improved them.",
	COFFEEBUSH =
	{
		BARREN = "I think it needs to be fertilized.",
		WITHERED = "Looks malnourished.",
		GENERIC = "This is a plant I could learn to love.",
		PICKED = "Maybe they'll grow back?",
	},
	COFFEEBOT = "It's a coffee maker.",
	MUSSEL = "Could use some flexing.",
	MUSSEL_FARM =
	{
		 GENERIC = "I wonder if they are from Brussels.",
		 STICKPLANTED = "I really stuck it to them."
	},

	MUSSEL_STICK = "I'm really going to stick it to those mussels.",
	LOBSTER = "What a Wascally Wobster.",
	LOBSTERHOLE = "That Wascal is sleeping.",
	SEATRAP = "For the deadliest catch.",
	SANDCASTLE =
	{
		SAND = "It's a sandcastle, in the sand!",
		GENERIC = "Look what I made!"
	},
	BOATREPAIRKIT = "This will add some float to my boat.",

	BALLPHIN = "Such a round, rubbery fellow.",
	BOATCANNON = "The only thing better than a boat is a boat with a cannon.",
	BOTTLELANTERN = "A bottle full of sunshine.",
	BURIEDTREASURE = "Ooo, what have we here?", --SWC
	BUSH_VINE =
	{
		BURNING = "Whoops.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "It's all viney!",
	},
	CAPTAINHAT = "The proper boating attire!",
	COCONADE =
	{
		BURNING = "This seems dangerous.",
		GENERIC = "I'll need to light it first.",
	},
	CORAL = "Living building material!",
	ROCK_CORAL = "The coral's formed a reef!",
	CRABHOLE = "They call a hole in the sand their home.",
	CUTLASS = "I hope this sword doesn't start to smell...",
	DUBLOON = "I'm rich!",
	FABRIC = "Soft cloth made from hard roots!",
	FISHINHOLE = "This area seems pretty fishy.",
	GOLDENMACHETE = "Hack in style!",
	JELLYFISH = "This creature is pure science!",
	JELLYFISH_DEAD = "It lived a good life. Maybe.",
	JELLYFISH_COOKED = "It's all wriggly.",
	JELLYFISH_PLANTED = "Science works in mysterious, blobby ways.",
	JELLYJERKY = "I'd be a jerk not to eat this.",

	ROCK_LIMPET =
	{
		GENERIC = "I could fill a pail with all those snails.",
		PICKED = "I can't fill a pail without snails.",
	},
	BOAT_LOGRAFT = "This looks... sort of boat-like...",
	MACHETE = "I like the cut of this blade.",
	MESSAGEBOTTLEEMPTY = "Just an empty bottle.",
	MOSQUITO_POISON = "These blasted mosquitoes carry a terrible sickness.",
	OBSIDIANCOCONADE = "It's even bombier!",
	OBSIDIANFIREPIT =
	{
		EMBERS = "I should put something on the fire before it goes out.",
		GENERIC = "This fire pit is a conductor for even more... fire.",
		HIGH = "Good thing it's contained!",
		LOW = "The fire's getting a bit low.",
		NORMAL = "This is my best invention yet.",
		OUT = "At least I can start it up again.",
	},
	OX = "These creatures seem reasonable.",
	PIRATEHAT = "Fit for a cutthroat scallywag. Or me.",
	BOAT_RAFT = "This looks adequate.",
	BOAT_ROW = "It runs on elbow grease.",
	SAIL_PALMLEAF = "This should really transform my boating experience.",
	SANDBAG_ITEM = "Sand technology, on the go.",
	SANDBAG = "Keeps the water at bay.",
	SEASACK = "I hate when food has that not-so-fresh taste.",
	SEASHELL_BEACHED = "Sea refuse.",
	SEAWEED = "A weed. Of the sea.",

	SEAWEED_PLANTED = "Is that what passes for food around here?",
	SLOTMACHINE = "I suppose I could linger for a moment or two.",
	SNAKE_POISON = "Even worse than a regular snake!",
	SNAKESKIN = "I'm intrigued AND repelled.",
	SNAKESKINHAT = "It should repel the rain from my hair.",
	SOLOFISH = "It has that wet-dog smell.",
	SPEARGUN = "Oh, the science I could get up to with this!",
	SPOILED_FISH = "I'm not terribly curious about the smell.",
	SWORDFISH = "I think this fish evolved to run me through.",
	TRIDENT = "I wonder how old this artifact is?",
	TRINKET_IA_13 = "What is this substance?",
	TRINKET_IA_14 = "This thing gives me the creeps...",
	TRINKET_IA_15 = "Incredible! This guitar has undergone shrinkification!",
	TRINKET_IA_16 = "How did this get all the way out here?",
	TRINKET_IA_17 = "Where's the other one?",
	TRINKET_IA_18 = "A relic of a bygone era!",
	TRINKET_IA_19 = "Clouding of the brain. Never heard of it...",
	TURBINE_BLADES = "Perhaps this powered that beastly storm?",
	TURF_BEACH = "Sandy ground.",
	TURF_JUNGLE = "Very gnarled ground.",
	VOLCANO_ALTAR =
	{
		GENERIC = "It appears to be closed.",
		OPEN = "The altar is open and ready to accept offerings!",
	},
	VOLCANO_ALTAR_BROKEN = "Er, that won't be a problem, will it?",
	WHALE_BLUE = "That whale has emotional issues.",
	WHALE_CARCASS_BLUE = "Gross. I think the bloating has begun.",
	WHALE_CARCASS_WHITE = "Gross. I think the bloating has begun.",

	ARMOR_SNAKESKIN = "How fashionable!",
	SAIL_CLOTH = "That wind isn't getting away now!",
	DUG_COFFEEBUSH = "This belongs in the ground!",
	LAVAPOOL = "A bit hot for my tastes.",
	BAMBOO = "Maybe I can bamboozle my enemies with this?",
	AERODYNAMICHAT = "It really cuts through the air!",
	POISONHOLE = "I think I'll stay away from that.",
	BOAT_LANTERN = "This will do wonders for my night vision!",
	SWORDFISH_DEAD = "I better not run with this.",
	LIMPETS = "Maybe starving wouldn't be so bad.",
	OBSIDIANAXE = "A winning combination!",
	COCONUT = "It requires a large nut hacker.",
	COCONUT_SAPLING = "It doesn't need my help to grow anymore.",
	COCONUT_COOKED = "Now I just need a cake.",
	BERMUDATRIANGLE = "Gives me an uneasy feeling.",
	SNAKE = "I wonder if it'll sell me some oil?",
	SNAKEOIL = "The label says \"Jay's Wondrous Snake Oil!\"",
	ARMORSEASHELL = "Arts and crafts!",
	SNAKE_FIRE = "Is that snake smoldering?",
	MUSSEL_COOKED = "I cook a mean mussel.",

	PACKIM_FISHBONE = "This seems like something I should carry around.",
	PACKIM = "I bet I could pack'im full of stuff.",

	ARMORLIMESTONE = "I'm sure this will hold up great!",
	TIGERSHARK = "Well that's terrifying.",
	WOODLEGS_KEY1 = "Something, somewhere must be locked.",
	WOODLEGS_KEY2 = "This key probably unlocks something.",
	WOODLEGS_KEY3 = "That's a key.",
	WOODLEGS_CAGE = "That seems like an excessive amount of locks.",
	OBSIDIAN_WORKBENCH = "I feel inspired.",

	NEEDLESPEAR = "I'm glad I didn't step on this.",
	LIMESTONENUGGET = "Could be a useful building material.",
	DRAGOON = "You're a quick one, aren't you?",

	ICEMAKER = 
	{
		OUT = "It needs more fuel.",
		VERYLOW = "I can hear it sputtering.",
		LOW = "It seems to be slowing down.",
		NORMAL = "It's putting along.",
		HIGH = "It's running great!",
	},

	DUG_BAMBOOTREE = "I need to plant this.",
	BAMBOOTREE =
	{
		BURNING = "Bye bye, bamboo.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "Golly, it's even floatier than wood!", --"Looks pretty sturdy.", -Mob
	},
	
	JUNGLETREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "That tree needs a hair cut.",
	},
	SHARK_GILLS = "I wish I had gills.",
	LEIF_PALM = "Someone gimme a hand with this palm!",
	OBSIDIAN = "It's a fire rock.",
	BABYOX = "It's a tiny meat beast.",
	STUNGRAY = "I think I'll keep my distance.",
	SHARK_FIN = "A sleek fin.",
	FROG_POISON = "It looks meaner than usual.",
	BOAT_ARMOURED = "That is one durable boat.",
	ARMOROBSIDIAN = "I'm a genius.",
	BIOLUMINESCENCE = "These make a soothing glow.",
	SPEAR_POISON = "Now it's extra deadly.",
	SPEAR_OBSIDIAN = "This will leave a mark.",
	SNAKEDEN =
	{
		BURNING = "Whoops.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "It's all viney!",
	},
	TOUCAN = "I tou-can't catch him.",
	MESSAGEBOTTLE = "Someone wrote me a note!",
	SAND = "A handy pile of pocket sand.",
	SANDDUNE = "You better stay out of my shoes.",
	PEACOCK = "Nothing more than a dressed up thief.",
	VINE = "Maybe I can tie stuff up with this.",
	SUPERTELESCOPE = "I can see forever!",
	SEAGULL = "Shoo! Find some other land!",
	SEAGULL_WATER = "Shoo! Find some other water!",
	PARROT = "I find myself fresh out of crackers.",
	ARMOR_LIFEJACKET = "Keeps me afloat, without my boat!",
	WHALE_BUBBLES = "Something's underwater here.",
	EARRING = "The fewer holes in my body, the better.",
	ARMOR_WINDBREAKER = "The wind doesn't stand a chance!",
	SEAWEED_COOKED = "Crispy.",
	BOAT_CARGO = "It has room for all my stuff!",
	GASHAT = "Sucks all the stink out.",
	ELEPHANTCACTUS = "Yikes! I could poke an eye out!",
	DUG_ELEPHANTCACTUS = "A portable poker plant.",
	ELEPHANTCACTUS_ACTIVE = "That cactus seems abnormally pokey.",
	ELEPHANTCACTUS_STUMP = "It'll sprout pokers again eventually.",
	SAIL_FEATHER = "It's feather-light!",
	WALL_LIMESTONE_ITEM = "These would do more good if I placed them.",
	JUNGLETREESEED = "I can hear the hissing of tiny snakes.",
	JUNGLETREESEED_SAPLING = "It will grow into a nice jungle tree.",
	VOLCANO = "My scientific know-how tells me that's a perfectly safe mountain!",
	IRONWIND = "This is how a scientist should travel.",
	SEAWEED_DRIED = "Salty!",
	TELESCOPE = "I spy with my little eye...",
	
	DOYDOY = "I feel oddly protective of this dumb bird.",
	DOYDOYBABY = "What a cute little, uh, thing.",
	DOYDOYEGG = "Maybe I should have let it hatch.",
	DOYDOYEGG_CRACKED = "Oh well. I'm sure there are lots more!",
	DOYDOYFEATHER = "Soft AND endangered!",

	PALMTREE =
	{
		BURNING = "What a waste of wood.",
		BURNT = "I feel like I could have prevented that.",
		CHOPPED = "Take that, nature!",
		GENERIC = "How tropical.",
	},
	PALMLEAF = "I'm fond of these fronds.",
	CHIMINEA = "Take that, wind!",
	DOUBLE_UMBRELLAHAT = "The second umbrella keeps the first umbrella dry.",
	CRAB = 
	{
		GENERIC = "Don't get snappy with me, mister.",
		HIDDEN = "I wonder where that crabbit went?",
	},
	TRAWLNET = "Nothing but net.",
	TRAWLNETDROPPED = 
	{
		SOON = "It is definitely sinking.",
		SOONISH = "I think it's sinking.",
		GENERIC = "It's bulging with potential!",
	},
	VOLCANO_EXIT = "There's a cool breeze blowing in from outside.",
	SHARX = "These things sure are persistent.",
	SEASHELL = "Maybe I could sell these.",
	WHALE_BUBBLES = "Something down there has bad breath.",
	MAGMAROCK = "I can dig it.",
	MAGMAROCK_GOLD = "I see a golden opportunity.",
	CORAL_BRAIN_ROCK = "I wonder what it's plotting...",
	CORAL_BRAIN = "Food for thought.",
	SHARKITTEN = "You've got to be kitten me!",
	SHARKITTENSPAWNER = 
	{
		GENERIC = "Is that sand pile purring?",
		INACTIVE = "That is a rather large pile of sand.",
	},
	LIVINGJUNGLETREE = "Just like any other tree.",
	WALLYINTRO_DEBRIS = "Part of a wrecked ship.",
	MERMFISHER = "You better not try anything fishy.",
	PRIMEAPE = "Those things are going to be the end of me.",
	PRIMEAPEBARREL = "Here be evil.",
	BARREL_GUNPOWDER = "How original.",
	PORTAL_SHIPWRECKED = "It's broken.",
	MARSH_PLANT_TROPICAL = "Planty.",
	TELEPORTATO_SW_POTATO = "Seems like it was made with a purpose in mind.",
	PIKE_SKULL = "Ouch.",
	PALMLEAF_HUT = "Shade, sweet shade.",
	FISH_SMALL_COOKED = "A small bit of cooked fish.",
	LOBSTER_DEAD = "You should cook up nicely.",
	MERMHOUSE_FISHER = "Doesn't smell very good.",
	WILDBORE = "Looks aggressive.",
	PIRATEPACK = "I can keep my booty in here.",
	TUNACAN = "Where did this can come from?",
	MOSQUITOSACK_YELLOW = "Part of a yellow mosquito.",
	SANDBAGSMALL = "This should keep the water out.",
	FLUP = "Leave me alone!",
	OCTOPUSKING = "I'm a sucker for this guy.",
	OCTOPUSCHEST = "I hope that thing is waterproof.",
	GRASS_WATER = "I hope you're thirsty, grass.",
	WILDBOREHOUSE = "What a bore-ing house.",
	FISH_SMALL = "A small bit of fish.",
	TURF_SWAMP = "Swampy turf.",
	FLAMEGEYSER = "Maybe I should stand back.",
	KNIGHTBOAT = "Get off the waterway, you maniac!",
	MANGROVETREE_BURNT = "I wonder how that happened.",
	TIDAL_PLANT = "Look. A plant.",
	WALL_LIMESTONE = "Sturdy.",
	FISH_MED = "A chunk of fish meat.",
	LOBSTER_DEAD_COOKED = "I can't wait to eat you.",
	BLUBBERSUIT = "Well, it's something.",
	BLOWDART_FLUP = "Eye see.",
	TURF_MEADOW = "Meadow-y turf.",
	TURF_VOLCANO = "Volcano-y turf.",
	SWEET_POTATO = "Looks yammy!",
	SWEET_POTATO_COOKED = "Looks even yammier!",
	SWEET_POTATO_PLANTED = "That's an odd looking carrot.",
	SWEET_POTATO_SEEDS = "My very own plant eggs.",
	BLUBBER = "Squishy.",
	TELEPORTATO_SW_RING = "Looks like I could use this.",
	TELEPORTATO_SW_BOX = "It looks like a part for something.",
	TELEPORTATO_SW_CRANK = "I wonder what this is used for.",
	TELEPORTATO_SW_BASE = "I think it's missing some parts.",
	VOLCANOSTAFF = "The label says \"Keep out of reach of children.\"",
	THATCHPACK = "I call it a thatchel.",
	SHARK_TEETHHAT = "What a dangerous looking hat.",
	TURF_ASH = "Ashy turf.",
	BOAT_TORCH = "This'll keep my hands free.",
	MANGROVETREE = "I wonder if it's getting enough water?",
	HAIL_ICE = "Chilling.",
	FISH_TROPICAL = "What a tropical looking fish.",
	TIDALPOOL = "A pool, left by the tides.",
	WHALE_WHITE = "Looks like a fighter.",
	VOLCANO_SHRUB = "You look ashen.",
	ROCK_OBSIDIAN = "Blast it! It won't be mined!",
	ROCK_CHARCOAL = "Would need an awfully big stocking for that.",
	DRAGOONDEN = "Even goons gotta sleep.",
	WILBUR_UNLOCK = "He looks kind of regal.",
	WILBUR_CROWN = "It's oddly monkey-sized.",
	TWISTER = "I thought it was strangely windy around here.",
	TWISTER_SEAL = "D'awww.",
	MAGIC_SEAL = "This is a powerful artifact.",
	SAIL_STICK = "There must be a scientific explanation for this.",
	WIND_CONCH = "I can hear the wind trapped within.",
	DRAGOONEGG = "Do I hear cracking?",
	BUOY = "Awww yaaaaa buoy!", 
	TURF_SNAKESKIN = "Sssstylish ssssstatement.",
	DOYDOYNEST = "It's for doydoy eggs, dummy.",
	ARMORCACTUS = "The best defense is a good offense.",
	BIGFISHINGROD = "To catch a big fish, you need a big rod.",
	BRAINJELLYHAT = "Two brains means double the ideas!",
	COCONUT_HALVED = "When I click them together, they make horsey sounds.",
	CRATE = "There must be a way to open it.",
	DEPLETED_BAMBOOTREE = "Will it grow again?",
	DEPLETED_BUSH_VINE = "One day it may return.",
	DEPLETED_GRASS_WATER = "Farewell, sweet plant.",
	DOYDOYEGG_COOKED = "A controlled chemical reaction has made this egg matter more nutritious.",
	DRAGOONHEART = "Where the dragoon once stored its feelings.",
	DRAGOONSPIT = "It's SPITacularly disgusting!",
	DUG_BUSH_VINE = "I suppose I should pick it up.",
	-- FRESHFRUITCREPES = "Sugary fruit! Part of a balanced breakfast.",
	KRAKEN = "Now's not the time for me to be Quacken wise!",
	KRAKENCHEST = "To the victor, the spoils.",
	KRAKEN_TENTACLE = "A beast that never sleeps.",
	MAGMAROCK_FULL = "I can dig it.",
	MAGMAROCK_GOLD_FULL = "I see a golden opportunity.",
	MONKEYBALL = "I have a strange desire to name it after myself.",
	-- MONSTERTARTARE = "There's got to be something else to eat around here.",
	MUSSELBOUILLABAISE = "Imagine the experiments I could run on it!",
	MYSTERYMEAT = "I'm not dissecting that.",
	OXHAT = "Nice and dry. This helmet will protect me from the elements.",
	OX_FLUTE = "Is it dripping...?",
	OX_HORN = "I grabbed the ox by the horn.",
	PARROT_PIRATE = "I try not to eat anything with a name.",
	PEG_LEG = "I can perform amputations if anyone'd like to wear it for real.",
	PIRATEGHOST = "He met a terrible end. I will too if I don't get out of here.",
	SANDBAGSMALL_ITEM = "A bag full of sand. Does science know no bounds?",
	SHADOWSKITTISH_WATER = "Yikes!",
	SHIPWRECKED_ENTRANCE = "Ahoy!",
	SHIPWRECKED_EXIT = "And so, I sail away into the horizon!",
	SAIL_SNAKESKIN = "Scale it and sail it!",
	SPEAR_LAUNCHER = "Science takes care of me.",
	SWEETPOTATOSOUFFLE = "Sweet potato souffles are a rising trend.",
	SWIMMINGHORROR = "Yikes! Get me back to land!",
	TIGEREYE = "More eyes means better sight... right?",
	TRINKET_IA_20 = "I'm not sure what it is, but it makes me feel smarter!",
	TRINKET_IA_21 = "I ought to measure it to ensure it's to scale.",
	TRINKET_IA_22 = "I'm sure someone would like this.",
	TURF_MAGMAFIELD = "Lava-y floor.",
	TURF_TIDALMARSH = "Marsh-y floor.",
	VOLCANO_ALTAR_TOWER = "How scary!",
	WATERYGRAVE = "Sure, I could fish it out of there. But should I?",
	WHALE_TRACK = "Whale, ho!",
	WILDBOREHEAD = "It smells as bad as it looks.",
	BOAT_WOODLEGS = "A vessel fit for a scallywag.",
	WOODLEGSHAT = "Oh, to be a pirate without the irate!", --SWC
	SAIL_WOODLEGS = "The quintessential pirate sail.",
	SHIPWRECK = "Poor little boat.",
	INVENTORYGRAVE = "There was someone here before me!",
	INVENTORYMOUND = "There was someone here before me!",
	LIMPETS_COOKED = "Escargotcha!",
	RAWLING = "It's my buddy!",
	CALIFORNIAROLL = "But I don't have chopsticks.",
},
}
